/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  ClosedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  AuthTypeOptions,
  AuthTypeOptions$inboundSchema,
  AuthTypeOptions$outboundSchema,
} from "./authtypeoptions.js";
import {
  ConnectionsType,
  ConnectionsType$inboundSchema,
  ConnectionsType$Outbound,
  ConnectionsType$outboundSchema,
} from "./connectionstype.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  LogLevelOptions,
  LogLevelOptions$inboundSchema,
  LogLevelOptions$outboundSchema,
} from "./logleveloptions.js";
import {
  Metadata1Type,
  Metadata1Type$inboundSchema,
  Metadata1Type$Outbound,
  Metadata1Type$outboundSchema,
} from "./metadata1type.js";
import {
  PqType,
  PqType$inboundSchema,
  PqType$Outbound,
  PqType$outboundSchema,
} from "./pqtype.js";
import {
  RetryRulesType,
  RetryRulesType$inboundSchema,
  RetryRulesType$Outbound,
  RetryRulesType$outboundSchema,
} from "./retryrulestype.js";

export const InputSplunkSearchType10 = {
  SplunkSearch: "splunk_search",
} as const;
export type InputSplunkSearchType10 = ClosedEnum<
  typeof InputSplunkSearchType10
>;

/**
 * Format of the returned output
 */
export const OutputMode10 = {
  Csv: "csv",
  Json: "json",
} as const;
/**
 * Format of the returned output
 */
export type OutputMode10 = OpenEnum<typeof OutputMode10>;

export type InputSplunkSearchSplunkSearch10 = {
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputSplunkSearchType10;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead?: string | undefined;
  /**
   * Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * A cron schedule on which to run this job
   */
  cronSchedule?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint?: string | undefined;
  /**
   * Format of the returned output
   */
  outputMode?: OutputMode10 | undefined;
  /**
   * Optional request parameters to send to the endpoint
   */
  endpointParams?: Array<Metadata1Type> | undefined;
  /**
   * Optional request headers to send to the endpoint
   */
  endpointHeaders?: Array<Metadata1Type> | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel?: LogLevelOptions | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  requestTimeout?: number | undefined;
  /**
   * When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  retryRules?: RetryRulesType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl: string;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName: string;
  /**
   * Secret parameter value to pass in request body
   */
  secret: string;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName: string;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams: Array<Metadata1Type>;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders: Array<Metadata1Type>;
};

export const InputSplunkSearchType9 = {
  SplunkSearch: "splunk_search",
} as const;
export type InputSplunkSearchType9 = ClosedEnum<typeof InputSplunkSearchType9>;

/**
 * Format of the returned output
 */
export const OutputMode9 = {
  Csv: "csv",
  Json: "json",
} as const;
/**
 * Format of the returned output
 */
export type OutputMode9 = OpenEnum<typeof OutputMode9>;

export type InputSplunkSearchSplunkSearch9 = {
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputSplunkSearchType9;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead?: string | undefined;
  /**
   * Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * A cron schedule on which to run this job
   */
  cronSchedule?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint?: string | undefined;
  /**
   * Format of the returned output
   */
  outputMode?: OutputMode9 | undefined;
  /**
   * Optional request parameters to send to the endpoint
   */
  endpointParams?: Array<Metadata1Type> | undefined;
  /**
   * Optional request headers to send to the endpoint
   */
  endpointHeaders?: Array<Metadata1Type> | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel?: LogLevelOptions | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  requestTimeout?: number | undefined;
  /**
   * When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  retryRules?: RetryRulesType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret: string;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
};

export const InputSplunkSearchType8 = {
  SplunkSearch: "splunk_search",
} as const;
export type InputSplunkSearchType8 = ClosedEnum<typeof InputSplunkSearchType8>;

/**
 * Format of the returned output
 */
export const OutputMode8 = {
  Csv: "csv",
  Json: "json",
} as const;
/**
 * Format of the returned output
 */
export type OutputMode8 = OpenEnum<typeof OutputMode8>;

export type InputSplunkSearchSplunkSearch8 = {
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputSplunkSearchType8;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead?: string | undefined;
  /**
   * Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * A cron schedule on which to run this job
   */
  cronSchedule?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint?: string | undefined;
  /**
   * Format of the returned output
   */
  outputMode?: OutputMode8 | undefined;
  /**
   * Optional request parameters to send to the endpoint
   */
  endpointParams?: Array<Metadata1Type> | undefined;
  /**
   * Optional request headers to send to the endpoint
   */
  endpointHeaders?: Array<Metadata1Type> | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel?: LogLevelOptions | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  requestTimeout?: number | undefined;
  /**
   * When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  retryRules?: RetryRulesType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret: string;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
};

export const InputSplunkSearchType7 = {
  SplunkSearch: "splunk_search",
} as const;
export type InputSplunkSearchType7 = ClosedEnum<typeof InputSplunkSearchType7>;

/**
 * Format of the returned output
 */
export const OutputMode7 = {
  Csv: "csv",
  Json: "json",
} as const;
/**
 * Format of the returned output
 */
export type OutputMode7 = OpenEnum<typeof OutputMode7>;

export type InputSplunkSearchSplunkSearch7 = {
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputSplunkSearchType7;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead?: string | undefined;
  /**
   * Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * A cron schedule on which to run this job
   */
  cronSchedule?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint?: string | undefined;
  /**
   * Format of the returned output
   */
  outputMode?: OutputMode7 | undefined;
  /**
   * Optional request parameters to send to the endpoint
   */
  endpointParams?: Array<Metadata1Type> | undefined;
  /**
   * Optional request headers to send to the endpoint
   */
  endpointHeaders?: Array<Metadata1Type> | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel?: LogLevelOptions | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  requestTimeout?: number | undefined;
  /**
   * When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  retryRules?: RetryRulesType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token: string;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
};

export const InputSplunkSearchType6 = {
  SplunkSearch: "splunk_search",
} as const;
export type InputSplunkSearchType6 = ClosedEnum<typeof InputSplunkSearchType6>;

/**
 * Format of the returned output
 */
export const OutputMode6 = {
  Csv: "csv",
  Json: "json",
} as const;
/**
 * Format of the returned output
 */
export type OutputMode6 = OpenEnum<typeof OutputMode6>;

export type InputSplunkSearchSplunkSearch6 = {
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputSplunkSearchType6;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead?: string | undefined;
  /**
   * Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * A cron schedule on which to run this job
   */
  cronSchedule?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint?: string | undefined;
  /**
   * Format of the returned output
   */
  outputMode?: OutputMode6 | undefined;
  /**
   * Optional request parameters to send to the endpoint
   */
  endpointParams?: Array<Metadata1Type> | undefined;
  /**
   * Optional request headers to send to the endpoint
   */
  endpointHeaders?: Array<Metadata1Type> | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel?: LogLevelOptions | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  requestTimeout?: number | undefined;
  /**
   * When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  retryRules?: RetryRulesType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  description?: string | undefined;
  username: string;
  password: string;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
};

export const InputSplunkSearchType5 = {
  SplunkSearch: "splunk_search",
} as const;
export type InputSplunkSearchType5 = ClosedEnum<typeof InputSplunkSearchType5>;

/**
 * Format of the returned output
 */
export const OutputMode5 = {
  Csv: "csv",
  Json: "json",
} as const;
/**
 * Format of the returned output
 */
export type OutputMode5 = OpenEnum<typeof OutputMode5>;

export type InputSplunkSearchSplunkSearch5 = {
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputSplunkSearchType5;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead?: string | undefined;
  /**
   * Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * A cron schedule on which to run this job
   */
  cronSchedule?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint?: string | undefined;
  /**
   * Format of the returned output
   */
  outputMode?: OutputMode5 | undefined;
  /**
   * Optional request parameters to send to the endpoint
   */
  endpointParams?: Array<Metadata1Type> | undefined;
  /**
   * Optional request headers to send to the endpoint
   */
  endpointHeaders?: Array<Metadata1Type> | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel?: LogLevelOptions | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  requestTimeout?: number | undefined;
  /**
   * When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  retryRules?: RetryRulesType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
};

export const InputSplunkSearchType4 = {
  SplunkSearch: "splunk_search",
} as const;
export type InputSplunkSearchType4 = ClosedEnum<typeof InputSplunkSearchType4>;

/**
 * Format of the returned output
 */
export const OutputMode4 = {
  Csv: "csv",
  Json: "json",
} as const;
/**
 * Format of the returned output
 */
export type OutputMode4 = OpenEnum<typeof OutputMode4>;

export type InputSplunkSearchSplunkSearch4 = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputSplunkSearchType4;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq: PqType;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead?: string | undefined;
  /**
   * Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * A cron schedule on which to run this job
   */
  cronSchedule?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint?: string | undefined;
  /**
   * Format of the returned output
   */
  outputMode?: OutputMode4 | undefined;
  /**
   * Optional request parameters to send to the endpoint
   */
  endpointParams?: Array<Metadata1Type> | undefined;
  /**
   * Optional request headers to send to the endpoint
   */
  endpointHeaders?: Array<Metadata1Type> | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel?: LogLevelOptions | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  requestTimeout?: number | undefined;
  /**
   * When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  retryRules?: RetryRulesType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
};

export const InputSplunkSearchType3 = {
  SplunkSearch: "splunk_search",
} as const;
export type InputSplunkSearchType3 = ClosedEnum<typeof InputSplunkSearchType3>;

/**
 * Format of the returned output
 */
export const OutputMode3 = {
  Csv: "csv",
  Json: "json",
} as const;
/**
 * Format of the returned output
 */
export type OutputMode3 = OpenEnum<typeof OutputMode3>;

export type InputSplunkSearchSplunkSearch3 = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputSplunkSearchType3;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead?: string | undefined;
  /**
   * Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * A cron schedule on which to run this job
   */
  cronSchedule?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint?: string | undefined;
  /**
   * Format of the returned output
   */
  outputMode?: OutputMode3 | undefined;
  /**
   * Optional request parameters to send to the endpoint
   */
  endpointParams?: Array<Metadata1Type> | undefined;
  /**
   * Optional request headers to send to the endpoint
   */
  endpointHeaders?: Array<Metadata1Type> | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel?: LogLevelOptions | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  requestTimeout?: number | undefined;
  /**
   * When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  retryRules?: RetryRulesType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
};

export const InputSplunkSearchType2 = {
  SplunkSearch: "splunk_search",
} as const;
export type InputSplunkSearchType2 = ClosedEnum<typeof InputSplunkSearchType2>;

/**
 * Format of the returned output
 */
export const OutputMode2 = {
  Csv: "csv",
  Json: "json",
} as const;
/**
 * Format of the returned output
 */
export type OutputMode2 = OpenEnum<typeof OutputMode2>;

export type InputSplunkSearchSplunkSearch2 = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputSplunkSearchType2;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections: Array<ConnectionsType>;
  pq?: PqType | undefined;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead?: string | undefined;
  /**
   * Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * A cron schedule on which to run this job
   */
  cronSchedule?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint?: string | undefined;
  /**
   * Format of the returned output
   */
  outputMode?: OutputMode2 | undefined;
  /**
   * Optional request parameters to send to the endpoint
   */
  endpointParams?: Array<Metadata1Type> | undefined;
  /**
   * Optional request headers to send to the endpoint
   */
  endpointHeaders?: Array<Metadata1Type> | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel?: LogLevelOptions | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  requestTimeout?: number | undefined;
  /**
   * When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  retryRules?: RetryRulesType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
};

export const InputSplunkSearchType1 = {
  SplunkSearch: "splunk_search",
} as const;
export type InputSplunkSearchType1 = ClosedEnum<typeof InputSplunkSearchType1>;

/**
 * Format of the returned output
 */
export const OutputMode1 = {
  Csv: "csv",
  Json: "json",
} as const;
/**
 * Format of the returned output
 */
export type OutputMode1 = OpenEnum<typeof OutputMode1>;

export type InputSplunkSearchSplunkSearch1 = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputSplunkSearchType1;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead?: string | undefined;
  /**
   * Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * A cron schedule on which to run this job
   */
  cronSchedule?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint?: string | undefined;
  /**
   * Format of the returned output
   */
  outputMode?: OutputMode1 | undefined;
  /**
   * Optional request parameters to send to the endpoint
   */
  endpointParams?: Array<Metadata1Type> | undefined;
  /**
   * Optional request headers to send to the endpoint
   */
  endpointHeaders?: Array<Metadata1Type> | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel?: LogLevelOptions | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  requestTimeout?: number | undefined;
  /**
   * When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  retryRules?: RetryRulesType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
};

export type InputSplunkSearch =
  | InputSplunkSearchSplunkSearch10
  | InputSplunkSearchSplunkSearch6
  | InputSplunkSearchSplunkSearch2
  | InputSplunkSearchSplunkSearch4
  | InputSplunkSearchSplunkSearch7
  | InputSplunkSearchSplunkSearch8
  | InputSplunkSearchSplunkSearch9
  | InputSplunkSearchSplunkSearch1
  | InputSplunkSearchSplunkSearch3
  | InputSplunkSearchSplunkSearch5;

/** @internal */
export const InputSplunkSearchType10$inboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType10
> = z.nativeEnum(InputSplunkSearchType10);
/** @internal */
export const InputSplunkSearchType10$outboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType10
> = InputSplunkSearchType10$inboundSchema;

/** @internal */
export const OutputMode10$inboundSchema: z.ZodType<
  OutputMode10,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMode10),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputMode10$outboundSchema: z.ZodType<
  OutputMode10,
  z.ZodTypeDef,
  OutputMode10
> = z.union([
  z.nativeEnum(OutputMode10),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputSplunkSearchSplunkSearch10$inboundSchema: z.ZodType<
  InputSplunkSearchSplunkSearch10,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  id: z.string().optional(),
  type: InputSplunkSearchType10$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode10$inboundSchema.default("json"),
  endpointParams: z.array(Metadata1Type$inboundSchema).optional(),
  endpointHeaders: z.array(Metadata1Type$inboundSchema).optional(),
  logLevel: LogLevelOptions$inboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  retryRules: RetryRulesType$inboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string(),
  secretParamName: z.string(),
  secret: z.string(),
  tokenAttributeName: z.string(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema),
  oauthHeaders: z.array(Metadata1Type$inboundSchema),
});
/** @internal */
export type InputSplunkSearchSplunkSearch10$Outbound = {
  authType: string;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  searchHead: string;
  search: string;
  earliest: string;
  latest: string;
  cronSchedule: string;
  endpoint: string;
  outputMode: string;
  endpointParams?: Array<Metadata1Type$Outbound> | undefined;
  endpointHeaders?: Array<Metadata1Type$Outbound> | undefined;
  logLevel?: string | undefined;
  requestTimeout: number;
  useRoundRobinDns: boolean;
  rejectUnauthorized: boolean;
  encoding?: string | undefined;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  retryRules?: RetryRulesType$Outbound | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl: string;
  secretParamName: string;
  secret: string;
  tokenAttributeName: string;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams: Array<Metadata1Type$Outbound>;
  oauthHeaders: Array<Metadata1Type$Outbound>;
};

/** @internal */
export const InputSplunkSearchSplunkSearch10$outboundSchema: z.ZodType<
  InputSplunkSearchSplunkSearch10$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchSplunkSearch10
> = z.object({
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  id: z.string().optional(),
  type: InputSplunkSearchType10$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode10$outboundSchema.default("json"),
  endpointParams: z.array(Metadata1Type$outboundSchema).optional(),
  endpointHeaders: z.array(Metadata1Type$outboundSchema).optional(),
  logLevel: LogLevelOptions$outboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  retryRules: RetryRulesType$outboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string(),
  secretParamName: z.string(),
  secret: z.string(),
  tokenAttributeName: z.string(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema),
  oauthHeaders: z.array(Metadata1Type$outboundSchema),
});

export function inputSplunkSearchSplunkSearch10ToJSON(
  inputSplunkSearchSplunkSearch10: InputSplunkSearchSplunkSearch10,
): string {
  return JSON.stringify(
    InputSplunkSearchSplunkSearch10$outboundSchema.parse(
      inputSplunkSearchSplunkSearch10,
    ),
  );
}
export function inputSplunkSearchSplunkSearch10FromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchSplunkSearch10, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchSplunkSearch10$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchSplunkSearch10' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchType9$inboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType9
> = z.nativeEnum(InputSplunkSearchType9);
/** @internal */
export const InputSplunkSearchType9$outboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType9
> = InputSplunkSearchType9$inboundSchema;

/** @internal */
export const OutputMode9$inboundSchema: z.ZodType<
  OutputMode9,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMode9),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputMode9$outboundSchema: z.ZodType<
  OutputMode9,
  z.ZodTypeDef,
  OutputMode9
> = z.union([
  z.nativeEnum(OutputMode9),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputSplunkSearchSplunkSearch9$inboundSchema: z.ZodType<
  InputSplunkSearchSplunkSearch9,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  id: z.string().optional(),
  type: InputSplunkSearchType9$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode9$inboundSchema.default("json"),
  endpointParams: z.array(Metadata1Type$inboundSchema).optional(),
  endpointHeaders: z.array(Metadata1Type$inboundSchema).optional(),
  logLevel: LogLevelOptions$inboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  retryRules: RetryRulesType$inboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
});
/** @internal */
export type InputSplunkSearchSplunkSearch9$Outbound = {
  authType: string;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  searchHead: string;
  search: string;
  earliest: string;
  latest: string;
  cronSchedule: string;
  endpoint: string;
  outputMode: string;
  endpointParams?: Array<Metadata1Type$Outbound> | undefined;
  endpointHeaders?: Array<Metadata1Type$Outbound> | undefined;
  logLevel?: string | undefined;
  requestTimeout: number;
  useRoundRobinDns: boolean;
  rejectUnauthorized: boolean;
  encoding?: string | undefined;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  retryRules?: RetryRulesType$Outbound | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret: string;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
};

/** @internal */
export const InputSplunkSearchSplunkSearch9$outboundSchema: z.ZodType<
  InputSplunkSearchSplunkSearch9$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchSplunkSearch9
> = z.object({
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  id: z.string().optional(),
  type: InputSplunkSearchType9$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode9$outboundSchema.default("json"),
  endpointParams: z.array(Metadata1Type$outboundSchema).optional(),
  endpointHeaders: z.array(Metadata1Type$outboundSchema).optional(),
  logLevel: LogLevelOptions$outboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  retryRules: RetryRulesType$outboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
});

export function inputSplunkSearchSplunkSearch9ToJSON(
  inputSplunkSearchSplunkSearch9: InputSplunkSearchSplunkSearch9,
): string {
  return JSON.stringify(
    InputSplunkSearchSplunkSearch9$outboundSchema.parse(
      inputSplunkSearchSplunkSearch9,
    ),
  );
}
export function inputSplunkSearchSplunkSearch9FromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchSplunkSearch9, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchSplunkSearch9$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchSplunkSearch9' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchType8$inboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType8
> = z.nativeEnum(InputSplunkSearchType8);
/** @internal */
export const InputSplunkSearchType8$outboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType8
> = InputSplunkSearchType8$inboundSchema;

/** @internal */
export const OutputMode8$inboundSchema: z.ZodType<
  OutputMode8,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMode8),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputMode8$outboundSchema: z.ZodType<
  OutputMode8,
  z.ZodTypeDef,
  OutputMode8
> = z.union([
  z.nativeEnum(OutputMode8),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputSplunkSearchSplunkSearch8$inboundSchema: z.ZodType<
  InputSplunkSearchSplunkSearch8,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  id: z.string().optional(),
  type: InputSplunkSearchType8$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode8$inboundSchema.default("json"),
  endpointParams: z.array(Metadata1Type$inboundSchema).optional(),
  endpointHeaders: z.array(Metadata1Type$inboundSchema).optional(),
  logLevel: LogLevelOptions$inboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  retryRules: RetryRulesType$inboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
});
/** @internal */
export type InputSplunkSearchSplunkSearch8$Outbound = {
  authType: string;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  searchHead: string;
  search: string;
  earliest: string;
  latest: string;
  cronSchedule: string;
  endpoint: string;
  outputMode: string;
  endpointParams?: Array<Metadata1Type$Outbound> | undefined;
  endpointHeaders?: Array<Metadata1Type$Outbound> | undefined;
  logLevel?: string | undefined;
  requestTimeout: number;
  useRoundRobinDns: boolean;
  rejectUnauthorized: boolean;
  encoding?: string | undefined;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  retryRules?: RetryRulesType$Outbound | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret: string;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
};

/** @internal */
export const InputSplunkSearchSplunkSearch8$outboundSchema: z.ZodType<
  InputSplunkSearchSplunkSearch8$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchSplunkSearch8
> = z.object({
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  id: z.string().optional(),
  type: InputSplunkSearchType8$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode8$outboundSchema.default("json"),
  endpointParams: z.array(Metadata1Type$outboundSchema).optional(),
  endpointHeaders: z.array(Metadata1Type$outboundSchema).optional(),
  logLevel: LogLevelOptions$outboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  retryRules: RetryRulesType$outboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
});

export function inputSplunkSearchSplunkSearch8ToJSON(
  inputSplunkSearchSplunkSearch8: InputSplunkSearchSplunkSearch8,
): string {
  return JSON.stringify(
    InputSplunkSearchSplunkSearch8$outboundSchema.parse(
      inputSplunkSearchSplunkSearch8,
    ),
  );
}
export function inputSplunkSearchSplunkSearch8FromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchSplunkSearch8, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchSplunkSearch8$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchSplunkSearch8' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchType7$inboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType7
> = z.nativeEnum(InputSplunkSearchType7);
/** @internal */
export const InputSplunkSearchType7$outboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType7
> = InputSplunkSearchType7$inboundSchema;

/** @internal */
export const OutputMode7$inboundSchema: z.ZodType<
  OutputMode7,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMode7),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputMode7$outboundSchema: z.ZodType<
  OutputMode7,
  z.ZodTypeDef,
  OutputMode7
> = z.union([
  z.nativeEnum(OutputMode7),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputSplunkSearchSplunkSearch7$inboundSchema: z.ZodType<
  InputSplunkSearchSplunkSearch7,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  id: z.string().optional(),
  type: InputSplunkSearchType7$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode7$inboundSchema.default("json"),
  endpointParams: z.array(Metadata1Type$inboundSchema).optional(),
  endpointHeaders: z.array(Metadata1Type$inboundSchema).optional(),
  logLevel: LogLevelOptions$inboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  retryRules: RetryRulesType$inboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
});
/** @internal */
export type InputSplunkSearchSplunkSearch7$Outbound = {
  authType: string;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  searchHead: string;
  search: string;
  earliest: string;
  latest: string;
  cronSchedule: string;
  endpoint: string;
  outputMode: string;
  endpointParams?: Array<Metadata1Type$Outbound> | undefined;
  endpointHeaders?: Array<Metadata1Type$Outbound> | undefined;
  logLevel?: string | undefined;
  requestTimeout: number;
  useRoundRobinDns: boolean;
  rejectUnauthorized: boolean;
  encoding?: string | undefined;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  retryRules?: RetryRulesType$Outbound | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token: string;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
};

/** @internal */
export const InputSplunkSearchSplunkSearch7$outboundSchema: z.ZodType<
  InputSplunkSearchSplunkSearch7$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchSplunkSearch7
> = z.object({
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  id: z.string().optional(),
  type: InputSplunkSearchType7$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode7$outboundSchema.default("json"),
  endpointParams: z.array(Metadata1Type$outboundSchema).optional(),
  endpointHeaders: z.array(Metadata1Type$outboundSchema).optional(),
  logLevel: LogLevelOptions$outboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  retryRules: RetryRulesType$outboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
});

export function inputSplunkSearchSplunkSearch7ToJSON(
  inputSplunkSearchSplunkSearch7: InputSplunkSearchSplunkSearch7,
): string {
  return JSON.stringify(
    InputSplunkSearchSplunkSearch7$outboundSchema.parse(
      inputSplunkSearchSplunkSearch7,
    ),
  );
}
export function inputSplunkSearchSplunkSearch7FromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchSplunkSearch7, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchSplunkSearch7$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchSplunkSearch7' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchType6$inboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType6
> = z.nativeEnum(InputSplunkSearchType6);
/** @internal */
export const InputSplunkSearchType6$outboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType6
> = InputSplunkSearchType6$inboundSchema;

/** @internal */
export const OutputMode6$inboundSchema: z.ZodType<
  OutputMode6,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMode6),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputMode6$outboundSchema: z.ZodType<
  OutputMode6,
  z.ZodTypeDef,
  OutputMode6
> = z.union([
  z.nativeEnum(OutputMode6),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputSplunkSearchSplunkSearch6$inboundSchema: z.ZodType<
  InputSplunkSearchSplunkSearch6,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  id: z.string().optional(),
  type: InputSplunkSearchType6$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode6$inboundSchema.default("json"),
  endpointParams: z.array(Metadata1Type$inboundSchema).optional(),
  endpointHeaders: z.array(Metadata1Type$inboundSchema).optional(),
  logLevel: LogLevelOptions$inboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  retryRules: RetryRulesType$inboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  description: z.string().optional(),
  username: z.string(),
  password: z.string(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
});
/** @internal */
export type InputSplunkSearchSplunkSearch6$Outbound = {
  authType: string;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  searchHead: string;
  search: string;
  earliest: string;
  latest: string;
  cronSchedule: string;
  endpoint: string;
  outputMode: string;
  endpointParams?: Array<Metadata1Type$Outbound> | undefined;
  endpointHeaders?: Array<Metadata1Type$Outbound> | undefined;
  logLevel?: string | undefined;
  requestTimeout: number;
  useRoundRobinDns: boolean;
  rejectUnauthorized: boolean;
  encoding?: string | undefined;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  retryRules?: RetryRulesType$Outbound | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  description?: string | undefined;
  username: string;
  password: string;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
};

/** @internal */
export const InputSplunkSearchSplunkSearch6$outboundSchema: z.ZodType<
  InputSplunkSearchSplunkSearch6$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchSplunkSearch6
> = z.object({
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  id: z.string().optional(),
  type: InputSplunkSearchType6$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode6$outboundSchema.default("json"),
  endpointParams: z.array(Metadata1Type$outboundSchema).optional(),
  endpointHeaders: z.array(Metadata1Type$outboundSchema).optional(),
  logLevel: LogLevelOptions$outboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  retryRules: RetryRulesType$outboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  description: z.string().optional(),
  username: z.string(),
  password: z.string(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
});

export function inputSplunkSearchSplunkSearch6ToJSON(
  inputSplunkSearchSplunkSearch6: InputSplunkSearchSplunkSearch6,
): string {
  return JSON.stringify(
    InputSplunkSearchSplunkSearch6$outboundSchema.parse(
      inputSplunkSearchSplunkSearch6,
    ),
  );
}
export function inputSplunkSearchSplunkSearch6FromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchSplunkSearch6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchSplunkSearch6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchSplunkSearch6' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchType5$inboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType5
> = z.nativeEnum(InputSplunkSearchType5);
/** @internal */
export const InputSplunkSearchType5$outboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType5
> = InputSplunkSearchType5$inboundSchema;

/** @internal */
export const OutputMode5$inboundSchema: z.ZodType<
  OutputMode5,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMode5),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputMode5$outboundSchema: z.ZodType<
  OutputMode5,
  z.ZodTypeDef,
  OutputMode5
> = z.union([
  z.nativeEnum(OutputMode5),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputSplunkSearchSplunkSearch5$inboundSchema: z.ZodType<
  InputSplunkSearchSplunkSearch5,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  id: z.string().optional(),
  type: InputSplunkSearchType5$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode5$inboundSchema.default("json"),
  endpointParams: z.array(Metadata1Type$inboundSchema).optional(),
  endpointHeaders: z.array(Metadata1Type$inboundSchema).optional(),
  logLevel: LogLevelOptions$inboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  retryRules: RetryRulesType$inboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
});
/** @internal */
export type InputSplunkSearchSplunkSearch5$Outbound = {
  authType: string;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  searchHead: string;
  search: string;
  earliest: string;
  latest: string;
  cronSchedule: string;
  endpoint: string;
  outputMode: string;
  endpointParams?: Array<Metadata1Type$Outbound> | undefined;
  endpointHeaders?: Array<Metadata1Type$Outbound> | undefined;
  logLevel?: string | undefined;
  requestTimeout: number;
  useRoundRobinDns: boolean;
  rejectUnauthorized: boolean;
  encoding?: string | undefined;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  retryRules?: RetryRulesType$Outbound | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
};

/** @internal */
export const InputSplunkSearchSplunkSearch5$outboundSchema: z.ZodType<
  InputSplunkSearchSplunkSearch5$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchSplunkSearch5
> = z.object({
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  id: z.string().optional(),
  type: InputSplunkSearchType5$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode5$outboundSchema.default("json"),
  endpointParams: z.array(Metadata1Type$outboundSchema).optional(),
  endpointHeaders: z.array(Metadata1Type$outboundSchema).optional(),
  logLevel: LogLevelOptions$outboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  retryRules: RetryRulesType$outboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
});

export function inputSplunkSearchSplunkSearch5ToJSON(
  inputSplunkSearchSplunkSearch5: InputSplunkSearchSplunkSearch5,
): string {
  return JSON.stringify(
    InputSplunkSearchSplunkSearch5$outboundSchema.parse(
      inputSplunkSearchSplunkSearch5,
    ),
  );
}
export function inputSplunkSearchSplunkSearch5FromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchSplunkSearch5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchSplunkSearch5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchSplunkSearch5' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchType4$inboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType4
> = z.nativeEnum(InputSplunkSearchType4);
/** @internal */
export const InputSplunkSearchType4$outboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType4
> = InputSplunkSearchType4$inboundSchema;

/** @internal */
export const OutputMode4$inboundSchema: z.ZodType<
  OutputMode4,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMode4),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputMode4$outboundSchema: z.ZodType<
  OutputMode4,
  z.ZodTypeDef,
  OutputMode4
> = z.union([
  z.nativeEnum(OutputMode4),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputSplunkSearchSplunkSearch4$inboundSchema: z.ZodType<
  InputSplunkSearchSplunkSearch4,
  z.ZodTypeDef,
  unknown
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputSplunkSearchType4$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema,
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode4$inboundSchema.default("json"),
  endpointParams: z.array(Metadata1Type$inboundSchema).optional(),
  endpointHeaders: z.array(Metadata1Type$inboundSchema).optional(),
  logLevel: LogLevelOptions$inboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  retryRules: RetryRulesType$inboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
});
/** @internal */
export type InputSplunkSearchSplunkSearch4$Outbound = {
  pqEnabled: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq: PqType$Outbound;
  searchHead: string;
  search: string;
  earliest: string;
  latest: string;
  cronSchedule: string;
  endpoint: string;
  outputMode: string;
  endpointParams?: Array<Metadata1Type$Outbound> | undefined;
  endpointHeaders?: Array<Metadata1Type$Outbound> | undefined;
  logLevel?: string | undefined;
  requestTimeout: number;
  useRoundRobinDns: boolean;
  rejectUnauthorized: boolean;
  encoding?: string | undefined;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  retryRules?: RetryRulesType$Outbound | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  authType: string;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
};

/** @internal */
export const InputSplunkSearchSplunkSearch4$outboundSchema: z.ZodType<
  InputSplunkSearchSplunkSearch4$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchSplunkSearch4
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputSplunkSearchType4$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema,
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode4$outboundSchema.default("json"),
  endpointParams: z.array(Metadata1Type$outboundSchema).optional(),
  endpointHeaders: z.array(Metadata1Type$outboundSchema).optional(),
  logLevel: LogLevelOptions$outboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  retryRules: RetryRulesType$outboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
});

export function inputSplunkSearchSplunkSearch4ToJSON(
  inputSplunkSearchSplunkSearch4: InputSplunkSearchSplunkSearch4,
): string {
  return JSON.stringify(
    InputSplunkSearchSplunkSearch4$outboundSchema.parse(
      inputSplunkSearchSplunkSearch4,
    ),
  );
}
export function inputSplunkSearchSplunkSearch4FromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchSplunkSearch4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchSplunkSearch4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchSplunkSearch4' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchType3$inboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType3
> = z.nativeEnum(InputSplunkSearchType3);
/** @internal */
export const InputSplunkSearchType3$outboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType3
> = InputSplunkSearchType3$inboundSchema;

/** @internal */
export const OutputMode3$inboundSchema: z.ZodType<
  OutputMode3,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMode3),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputMode3$outboundSchema: z.ZodType<
  OutputMode3,
  z.ZodTypeDef,
  OutputMode3
> = z.union([
  z.nativeEnum(OutputMode3),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputSplunkSearchSplunkSearch3$inboundSchema: z.ZodType<
  InputSplunkSearchSplunkSearch3,
  z.ZodTypeDef,
  unknown
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputSplunkSearchType3$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode3$inboundSchema.default("json"),
  endpointParams: z.array(Metadata1Type$inboundSchema).optional(),
  endpointHeaders: z.array(Metadata1Type$inboundSchema).optional(),
  logLevel: LogLevelOptions$inboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  retryRules: RetryRulesType$inboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
});
/** @internal */
export type InputSplunkSearchSplunkSearch3$Outbound = {
  pqEnabled: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  searchHead: string;
  search: string;
  earliest: string;
  latest: string;
  cronSchedule: string;
  endpoint: string;
  outputMode: string;
  endpointParams?: Array<Metadata1Type$Outbound> | undefined;
  endpointHeaders?: Array<Metadata1Type$Outbound> | undefined;
  logLevel?: string | undefined;
  requestTimeout: number;
  useRoundRobinDns: boolean;
  rejectUnauthorized: boolean;
  encoding?: string | undefined;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  retryRules?: RetryRulesType$Outbound | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  authType: string;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
};

/** @internal */
export const InputSplunkSearchSplunkSearch3$outboundSchema: z.ZodType<
  InputSplunkSearchSplunkSearch3$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchSplunkSearch3
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputSplunkSearchType3$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode3$outboundSchema.default("json"),
  endpointParams: z.array(Metadata1Type$outboundSchema).optional(),
  endpointHeaders: z.array(Metadata1Type$outboundSchema).optional(),
  logLevel: LogLevelOptions$outboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  retryRules: RetryRulesType$outboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
});

export function inputSplunkSearchSplunkSearch3ToJSON(
  inputSplunkSearchSplunkSearch3: InputSplunkSearchSplunkSearch3,
): string {
  return JSON.stringify(
    InputSplunkSearchSplunkSearch3$outboundSchema.parse(
      inputSplunkSearchSplunkSearch3,
    ),
  );
}
export function inputSplunkSearchSplunkSearch3FromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchSplunkSearch3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchSplunkSearch3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchSplunkSearch3' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchType2$inboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType2
> = z.nativeEnum(InputSplunkSearchType2);
/** @internal */
export const InputSplunkSearchType2$outboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType2
> = InputSplunkSearchType2$inboundSchema;

/** @internal */
export const OutputMode2$inboundSchema: z.ZodType<
  OutputMode2,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMode2),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputMode2$outboundSchema: z.ZodType<
  OutputMode2,
  z.ZodTypeDef,
  OutputMode2
> = z.union([
  z.nativeEnum(OutputMode2),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputSplunkSearchSplunkSearch2$inboundSchema: z.ZodType<
  InputSplunkSearchSplunkSearch2,
  z.ZodTypeDef,
  unknown
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputSplunkSearchType2$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema),
  pq: PqType$inboundSchema.optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode2$inboundSchema.default("json"),
  endpointParams: z.array(Metadata1Type$inboundSchema).optional(),
  endpointHeaders: z.array(Metadata1Type$inboundSchema).optional(),
  logLevel: LogLevelOptions$inboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  retryRules: RetryRulesType$inboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
});
/** @internal */
export type InputSplunkSearchSplunkSearch2$Outbound = {
  sendToRoutes: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections: Array<ConnectionsType$Outbound>;
  pq?: PqType$Outbound | undefined;
  searchHead: string;
  search: string;
  earliest: string;
  latest: string;
  cronSchedule: string;
  endpoint: string;
  outputMode: string;
  endpointParams?: Array<Metadata1Type$Outbound> | undefined;
  endpointHeaders?: Array<Metadata1Type$Outbound> | undefined;
  logLevel?: string | undefined;
  requestTimeout: number;
  useRoundRobinDns: boolean;
  rejectUnauthorized: boolean;
  encoding?: string | undefined;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  retryRules?: RetryRulesType$Outbound | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  authType: string;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
};

/** @internal */
export const InputSplunkSearchSplunkSearch2$outboundSchema: z.ZodType<
  InputSplunkSearchSplunkSearch2$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchSplunkSearch2
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputSplunkSearchType2$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema),
  pq: PqType$outboundSchema.optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode2$outboundSchema.default("json"),
  endpointParams: z.array(Metadata1Type$outboundSchema).optional(),
  endpointHeaders: z.array(Metadata1Type$outboundSchema).optional(),
  logLevel: LogLevelOptions$outboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  retryRules: RetryRulesType$outboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
});

export function inputSplunkSearchSplunkSearch2ToJSON(
  inputSplunkSearchSplunkSearch2: InputSplunkSearchSplunkSearch2,
): string {
  return JSON.stringify(
    InputSplunkSearchSplunkSearch2$outboundSchema.parse(
      inputSplunkSearchSplunkSearch2,
    ),
  );
}
export function inputSplunkSearchSplunkSearch2FromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchSplunkSearch2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchSplunkSearch2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchSplunkSearch2' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchType1$inboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType1
> = z.nativeEnum(InputSplunkSearchType1);
/** @internal */
export const InputSplunkSearchType1$outboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType1
> = InputSplunkSearchType1$inboundSchema;

/** @internal */
export const OutputMode1$inboundSchema: z.ZodType<
  OutputMode1,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMode1),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputMode1$outboundSchema: z.ZodType<
  OutputMode1,
  z.ZodTypeDef,
  OutputMode1
> = z.union([
  z.nativeEnum(OutputMode1),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputSplunkSearchSplunkSearch1$inboundSchema: z.ZodType<
  InputSplunkSearchSplunkSearch1,
  z.ZodTypeDef,
  unknown
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputSplunkSearchType1$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode1$inboundSchema.default("json"),
  endpointParams: z.array(Metadata1Type$inboundSchema).optional(),
  endpointHeaders: z.array(Metadata1Type$inboundSchema).optional(),
  logLevel: LogLevelOptions$inboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  retryRules: RetryRulesType$inboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
});
/** @internal */
export type InputSplunkSearchSplunkSearch1$Outbound = {
  sendToRoutes: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  searchHead: string;
  search: string;
  earliest: string;
  latest: string;
  cronSchedule: string;
  endpoint: string;
  outputMode: string;
  endpointParams?: Array<Metadata1Type$Outbound> | undefined;
  endpointHeaders?: Array<Metadata1Type$Outbound> | undefined;
  logLevel?: string | undefined;
  requestTimeout: number;
  useRoundRobinDns: boolean;
  rejectUnauthorized: boolean;
  encoding?: string | undefined;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  retryRules?: RetryRulesType$Outbound | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  authType: string;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
};

/** @internal */
export const InputSplunkSearchSplunkSearch1$outboundSchema: z.ZodType<
  InputSplunkSearchSplunkSearch1$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchSplunkSearch1
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputSplunkSearchType1$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode1$outboundSchema.default("json"),
  endpointParams: z.array(Metadata1Type$outboundSchema).optional(),
  endpointHeaders: z.array(Metadata1Type$outboundSchema).optional(),
  logLevel: LogLevelOptions$outboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  retryRules: RetryRulesType$outboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
});

export function inputSplunkSearchSplunkSearch1ToJSON(
  inputSplunkSearchSplunkSearch1: InputSplunkSearchSplunkSearch1,
): string {
  return JSON.stringify(
    InputSplunkSearchSplunkSearch1$outboundSchema.parse(
      inputSplunkSearchSplunkSearch1,
    ),
  );
}
export function inputSplunkSearchSplunkSearch1FromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchSplunkSearch1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchSplunkSearch1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchSplunkSearch1' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearch$inboundSchema: z.ZodType<
  InputSplunkSearch,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => InputSplunkSearchSplunkSearch10$inboundSchema),
  z.lazy(() => InputSplunkSearchSplunkSearch6$inboundSchema),
  z.lazy(() => InputSplunkSearchSplunkSearch2$inboundSchema),
  z.lazy(() => InputSplunkSearchSplunkSearch4$inboundSchema),
  z.lazy(() => InputSplunkSearchSplunkSearch7$inboundSchema),
  z.lazy(() => InputSplunkSearchSplunkSearch8$inboundSchema),
  z.lazy(() => InputSplunkSearchSplunkSearch9$inboundSchema),
  z.lazy(() => InputSplunkSearchSplunkSearch1$inboundSchema),
  z.lazy(() => InputSplunkSearchSplunkSearch3$inboundSchema),
  z.lazy(() => InputSplunkSearchSplunkSearch5$inboundSchema),
]);
/** @internal */
export type InputSplunkSearch$Outbound =
  | InputSplunkSearchSplunkSearch10$Outbound
  | InputSplunkSearchSplunkSearch6$Outbound
  | InputSplunkSearchSplunkSearch2$Outbound
  | InputSplunkSearchSplunkSearch4$Outbound
  | InputSplunkSearchSplunkSearch7$Outbound
  | InputSplunkSearchSplunkSearch8$Outbound
  | InputSplunkSearchSplunkSearch9$Outbound
  | InputSplunkSearchSplunkSearch1$Outbound
  | InputSplunkSearchSplunkSearch3$Outbound
  | InputSplunkSearchSplunkSearch5$Outbound;

/** @internal */
export const InputSplunkSearch$outboundSchema: z.ZodType<
  InputSplunkSearch$Outbound,
  z.ZodTypeDef,
  InputSplunkSearch
> = z.union([
  z.lazy(() => InputSplunkSearchSplunkSearch10$outboundSchema),
  z.lazy(() => InputSplunkSearchSplunkSearch6$outboundSchema),
  z.lazy(() => InputSplunkSearchSplunkSearch2$outboundSchema),
  z.lazy(() => InputSplunkSearchSplunkSearch4$outboundSchema),
  z.lazy(() => InputSplunkSearchSplunkSearch7$outboundSchema),
  z.lazy(() => InputSplunkSearchSplunkSearch8$outboundSchema),
  z.lazy(() => InputSplunkSearchSplunkSearch9$outboundSchema),
  z.lazy(() => InputSplunkSearchSplunkSearch1$outboundSchema),
  z.lazy(() => InputSplunkSearchSplunkSearch3$outboundSchema),
  z.lazy(() => InputSplunkSearchSplunkSearch5$outboundSchema),
]);

export function inputSplunkSearchToJSON(
  inputSplunkSearch: InputSplunkSearch,
): string {
  return JSON.stringify(
    InputSplunkSearch$outboundSchema.parse(inputSplunkSearch),
  );
}
export function inputSplunkSearchFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearch, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearch$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearch' from JSON`,
  );
}
