/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  ClosedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const InputSplunkSearchType = {
  SplunkSearch: "splunk_search",
} as const;
export type InputSplunkSearchType = ClosedEnum<typeof InputSplunkSearchType>;

export type InputSplunkSearchConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputSplunkSearchMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputSplunkSearchMode = OpenEnum<typeof InputSplunkSearchMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputSplunkSearchCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputSplunkSearchCompression = OpenEnum<
  typeof InputSplunkSearchCompression
>;

export type InputSplunkSearchPqControls = {};

export type InputSplunkSearchPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputSplunkSearchMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputSplunkSearchCompression | undefined;
  pqControls?: InputSplunkSearchPqControls | undefined;
};

/**
 * Format of the returned output
 */
export const OutputMode = {
  Csv: "csv",
  Json: "json",
} as const;
/**
 * Format of the returned output
 */
export type OutputMode = OpenEnum<typeof OutputMode>;

export type EndpointParam = {
  name: string;
  /**
   * JavaScript expression to compute the parameter's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings.
   */
  value: string;
};

export type EndpointHeader = {
  name: string;
  /**
   * JavaScript expression to compute the header's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings.
   */
  value: string;
};

/**
 * Collector runtime log level (verbosity)
 */
export const InputSplunkSearchLogLevel = {
  Error: "error",
  Warn: "warn",
  Info: "info",
  Debug: "debug",
} as const;
/**
 * Collector runtime log level (verbosity)
 */
export type InputSplunkSearchLogLevel = OpenEnum<
  typeof InputSplunkSearchLogLevel
>;

export type InputSplunkSearchMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * The algorithm to use when performing HTTP retries
 */
export const InputSplunkSearchRetryType = {
  None: "none",
  Backoff: "backoff",
  Static: "static",
} as const;
/**
 * The algorithm to use when performing HTTP retries
 */
export type InputSplunkSearchRetryType = OpenEnum<
  typeof InputSplunkSearchRetryType
>;

export type InputSplunkSearchRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: InputSplunkSearchRetryType | undefined;
  /**
   * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * The maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
   */
  multiplier?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

/**
 * Splunk Search authentication type
 */
export const InputSplunkSearchAuthenticationType = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * Splunk Search authentication type
 */
export type InputSplunkSearchAuthenticationType = OpenEnum<
  typeof InputSplunkSearchAuthenticationType
>;

export type InputSplunkSearchOauthParam = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type InputSplunkSearchOauthHeader = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type InputSplunkSearch = {
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputSplunkSearchType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputSplunkSearchConnection> | undefined;
  pq?: InputSplunkSearchPq | undefined;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead?: string | undefined;
  /**
   * Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * A cron schedule on which to run this job
   */
  cronSchedule?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint?: string | undefined;
  /**
   * Format of the returned output
   */
  outputMode?: OutputMode | undefined;
  /**
   * Optional request parameters to send to the endpoint
   */
  endpointParams?: Array<EndpointParam> | undefined;
  /**
   * Optional request headers to send to the endpoint
   */
  endpointHeaders?: Array<EndpointHeader> | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel?: InputSplunkSearchLogLevel | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  requestTimeout?: number | undefined;
  /**
   * When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputSplunkSearchMetadatum> | undefined;
  retryRules?: InputSplunkSearchRetryRules | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: InputSplunkSearchAuthenticationType | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<InputSplunkSearchOauthParam> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<InputSplunkSearchOauthHeader> | undefined;
};

/** @internal */
export const InputSplunkSearchType$inboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType
> = z.nativeEnum(InputSplunkSearchType);

/** @internal */
export const InputSplunkSearchType$outboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType
> = InputSplunkSearchType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchType$ {
  /** @deprecated use `InputSplunkSearchType$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearchType$inboundSchema;
  /** @deprecated use `InputSplunkSearchType$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearchType$outboundSchema;
}

/** @internal */
export const InputSplunkSearchConnection$inboundSchema: z.ZodType<
  InputSplunkSearchConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputSplunkSearchConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputSplunkSearchConnection$outboundSchema: z.ZodType<
  InputSplunkSearchConnection$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchConnection$ {
  /** @deprecated use `InputSplunkSearchConnection$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearchConnection$inboundSchema;
  /** @deprecated use `InputSplunkSearchConnection$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearchConnection$outboundSchema;
  /** @deprecated use `InputSplunkSearchConnection$Outbound` instead. */
  export type Outbound = InputSplunkSearchConnection$Outbound;
}

export function inputSplunkSearchConnectionToJSON(
  inputSplunkSearchConnection: InputSplunkSearchConnection,
): string {
  return JSON.stringify(
    InputSplunkSearchConnection$outboundSchema.parse(
      inputSplunkSearchConnection,
    ),
  );
}

export function inputSplunkSearchConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchConnection' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchMode$inboundSchema: z.ZodType<
  InputSplunkSearchMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkSearchMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSplunkSearchMode$outboundSchema: z.ZodType<
  InputSplunkSearchMode,
  z.ZodTypeDef,
  InputSplunkSearchMode
> = z.union([
  z.nativeEnum(InputSplunkSearchMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchMode$ {
  /** @deprecated use `InputSplunkSearchMode$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearchMode$inboundSchema;
  /** @deprecated use `InputSplunkSearchMode$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearchMode$outboundSchema;
}

/** @internal */
export const InputSplunkSearchCompression$inboundSchema: z.ZodType<
  InputSplunkSearchCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkSearchCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSplunkSearchCompression$outboundSchema: z.ZodType<
  InputSplunkSearchCompression,
  z.ZodTypeDef,
  InputSplunkSearchCompression
> = z.union([
  z.nativeEnum(InputSplunkSearchCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchCompression$ {
  /** @deprecated use `InputSplunkSearchCompression$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearchCompression$inboundSchema;
  /** @deprecated use `InputSplunkSearchCompression$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearchCompression$outboundSchema;
}

/** @internal */
export const InputSplunkSearchPqControls$inboundSchema: z.ZodType<
  InputSplunkSearchPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type InputSplunkSearchPqControls$Outbound = {};

/** @internal */
export const InputSplunkSearchPqControls$outboundSchema: z.ZodType<
  InputSplunkSearchPqControls$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchPqControls$ {
  /** @deprecated use `InputSplunkSearchPqControls$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearchPqControls$inboundSchema;
  /** @deprecated use `InputSplunkSearchPqControls$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearchPqControls$outboundSchema;
  /** @deprecated use `InputSplunkSearchPqControls$Outbound` instead. */
  export type Outbound = InputSplunkSearchPqControls$Outbound;
}

export function inputSplunkSearchPqControlsToJSON(
  inputSplunkSearchPqControls: InputSplunkSearchPqControls,
): string {
  return JSON.stringify(
    InputSplunkSearchPqControls$outboundSchema.parse(
      inputSplunkSearchPqControls,
    ),
  );
}

export function inputSplunkSearchPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchPqControls' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchPq$inboundSchema: z.ZodType<
  InputSplunkSearchPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputSplunkSearchMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSplunkSearchCompression$inboundSchema.default("none"),
  pqControls: z.lazy(() => InputSplunkSearchPqControls$inboundSchema)
    .optional(),
});

/** @internal */
export type InputSplunkSearchPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
  pqControls?: InputSplunkSearchPqControls$Outbound | undefined;
};

/** @internal */
export const InputSplunkSearchPq$outboundSchema: z.ZodType<
  InputSplunkSearchPq$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchPq
> = z.object({
  mode: InputSplunkSearchMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSplunkSearchCompression$outboundSchema.default("none"),
  pqControls: z.lazy(() => InputSplunkSearchPqControls$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchPq$ {
  /** @deprecated use `InputSplunkSearchPq$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearchPq$inboundSchema;
  /** @deprecated use `InputSplunkSearchPq$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearchPq$outboundSchema;
  /** @deprecated use `InputSplunkSearchPq$Outbound` instead. */
  export type Outbound = InputSplunkSearchPq$Outbound;
}

export function inputSplunkSearchPqToJSON(
  inputSplunkSearchPq: InputSplunkSearchPq,
): string {
  return JSON.stringify(
    InputSplunkSearchPq$outboundSchema.parse(inputSplunkSearchPq),
  );
}

export function inputSplunkSearchPqFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchPq' from JSON`,
  );
}

/** @internal */
export const OutputMode$inboundSchema: z.ZodType<
  OutputMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMode$outboundSchema: z.ZodType<
  OutputMode,
  z.ZodTypeDef,
  OutputMode
> = z.union([
  z.nativeEnum(OutputMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMode$ {
  /** @deprecated use `OutputMode$inboundSchema` instead. */
  export const inboundSchema = OutputMode$inboundSchema;
  /** @deprecated use `OutputMode$outboundSchema` instead. */
  export const outboundSchema = OutputMode$outboundSchema;
}

/** @internal */
export const EndpointParam$inboundSchema: z.ZodType<
  EndpointParam,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type EndpointParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const EndpointParam$outboundSchema: z.ZodType<
  EndpointParam$Outbound,
  z.ZodTypeDef,
  EndpointParam
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EndpointParam$ {
  /** @deprecated use `EndpointParam$inboundSchema` instead. */
  export const inboundSchema = EndpointParam$inboundSchema;
  /** @deprecated use `EndpointParam$outboundSchema` instead. */
  export const outboundSchema = EndpointParam$outboundSchema;
  /** @deprecated use `EndpointParam$Outbound` instead. */
  export type Outbound = EndpointParam$Outbound;
}

export function endpointParamToJSON(endpointParam: EndpointParam): string {
  return JSON.stringify(EndpointParam$outboundSchema.parse(endpointParam));
}

export function endpointParamFromJSON(
  jsonString: string,
): SafeParseResult<EndpointParam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EndpointParam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EndpointParam' from JSON`,
  );
}

/** @internal */
export const EndpointHeader$inboundSchema: z.ZodType<
  EndpointHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type EndpointHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const EndpointHeader$outboundSchema: z.ZodType<
  EndpointHeader$Outbound,
  z.ZodTypeDef,
  EndpointHeader
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EndpointHeader$ {
  /** @deprecated use `EndpointHeader$inboundSchema` instead. */
  export const inboundSchema = EndpointHeader$inboundSchema;
  /** @deprecated use `EndpointHeader$outboundSchema` instead. */
  export const outboundSchema = EndpointHeader$outboundSchema;
  /** @deprecated use `EndpointHeader$Outbound` instead. */
  export type Outbound = EndpointHeader$Outbound;
}

export function endpointHeaderToJSON(endpointHeader: EndpointHeader): string {
  return JSON.stringify(EndpointHeader$outboundSchema.parse(endpointHeader));
}

export function endpointHeaderFromJSON(
  jsonString: string,
): SafeParseResult<EndpointHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EndpointHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EndpointHeader' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchLogLevel$inboundSchema: z.ZodType<
  InputSplunkSearchLogLevel,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkSearchLogLevel),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSplunkSearchLogLevel$outboundSchema: z.ZodType<
  InputSplunkSearchLogLevel,
  z.ZodTypeDef,
  InputSplunkSearchLogLevel
> = z.union([
  z.nativeEnum(InputSplunkSearchLogLevel),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchLogLevel$ {
  /** @deprecated use `InputSplunkSearchLogLevel$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearchLogLevel$inboundSchema;
  /** @deprecated use `InputSplunkSearchLogLevel$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearchLogLevel$outboundSchema;
}

/** @internal */
export const InputSplunkSearchMetadatum$inboundSchema: z.ZodType<
  InputSplunkSearchMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputSplunkSearchMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputSplunkSearchMetadatum$outboundSchema: z.ZodType<
  InputSplunkSearchMetadatum$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchMetadatum$ {
  /** @deprecated use `InputSplunkSearchMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearchMetadatum$inboundSchema;
  /** @deprecated use `InputSplunkSearchMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearchMetadatum$outboundSchema;
  /** @deprecated use `InputSplunkSearchMetadatum$Outbound` instead. */
  export type Outbound = InputSplunkSearchMetadatum$Outbound;
}

export function inputSplunkSearchMetadatumToJSON(
  inputSplunkSearchMetadatum: InputSplunkSearchMetadatum,
): string {
  return JSON.stringify(
    InputSplunkSearchMetadatum$outboundSchema.parse(inputSplunkSearchMetadatum),
  );
}

export function inputSplunkSearchMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchMetadatum' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchRetryType$inboundSchema: z.ZodType<
  InputSplunkSearchRetryType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkSearchRetryType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSplunkSearchRetryType$outboundSchema: z.ZodType<
  InputSplunkSearchRetryType,
  z.ZodTypeDef,
  InputSplunkSearchRetryType
> = z.union([
  z.nativeEnum(InputSplunkSearchRetryType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchRetryType$ {
  /** @deprecated use `InputSplunkSearchRetryType$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearchRetryType$inboundSchema;
  /** @deprecated use `InputSplunkSearchRetryType$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearchRetryType$outboundSchema;
}

/** @internal */
export const InputSplunkSearchRetryRules$inboundSchema: z.ZodType<
  InputSplunkSearchRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: InputSplunkSearchRetryType$inboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/** @internal */
export type InputSplunkSearchRetryRules$Outbound = {
  type: string;
  interval: number;
  limit: number;
  multiplier: number;
  codes?: Array<number> | undefined;
  enableHeader: boolean;
  retryConnectTimeout: boolean;
  retryConnectReset: boolean;
};

/** @internal */
export const InputSplunkSearchRetryRules$outboundSchema: z.ZodType<
  InputSplunkSearchRetryRules$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchRetryRules
> = z.object({
  type: InputSplunkSearchRetryType$outboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchRetryRules$ {
  /** @deprecated use `InputSplunkSearchRetryRules$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearchRetryRules$inboundSchema;
  /** @deprecated use `InputSplunkSearchRetryRules$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearchRetryRules$outboundSchema;
  /** @deprecated use `InputSplunkSearchRetryRules$Outbound` instead. */
  export type Outbound = InputSplunkSearchRetryRules$Outbound;
}

export function inputSplunkSearchRetryRulesToJSON(
  inputSplunkSearchRetryRules: InputSplunkSearchRetryRules,
): string {
  return JSON.stringify(
    InputSplunkSearchRetryRules$outboundSchema.parse(
      inputSplunkSearchRetryRules,
    ),
  );
}

export function inputSplunkSearchRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchRetryRules' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchAuthenticationType$inboundSchema: z.ZodType<
  InputSplunkSearchAuthenticationType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkSearchAuthenticationType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSplunkSearchAuthenticationType$outboundSchema: z.ZodType<
  InputSplunkSearchAuthenticationType,
  z.ZodTypeDef,
  InputSplunkSearchAuthenticationType
> = z.union([
  z.nativeEnum(InputSplunkSearchAuthenticationType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchAuthenticationType$ {
  /** @deprecated use `InputSplunkSearchAuthenticationType$inboundSchema` instead. */
  export const inboundSchema =
    InputSplunkSearchAuthenticationType$inboundSchema;
  /** @deprecated use `InputSplunkSearchAuthenticationType$outboundSchema` instead. */
  export const outboundSchema =
    InputSplunkSearchAuthenticationType$outboundSchema;
}

/** @internal */
export const InputSplunkSearchOauthParam$inboundSchema: z.ZodType<
  InputSplunkSearchOauthParam,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputSplunkSearchOauthParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputSplunkSearchOauthParam$outboundSchema: z.ZodType<
  InputSplunkSearchOauthParam$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchOauthParam
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchOauthParam$ {
  /** @deprecated use `InputSplunkSearchOauthParam$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearchOauthParam$inboundSchema;
  /** @deprecated use `InputSplunkSearchOauthParam$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearchOauthParam$outboundSchema;
  /** @deprecated use `InputSplunkSearchOauthParam$Outbound` instead. */
  export type Outbound = InputSplunkSearchOauthParam$Outbound;
}

export function inputSplunkSearchOauthParamToJSON(
  inputSplunkSearchOauthParam: InputSplunkSearchOauthParam,
): string {
  return JSON.stringify(
    InputSplunkSearchOauthParam$outboundSchema.parse(
      inputSplunkSearchOauthParam,
    ),
  );
}

export function inputSplunkSearchOauthParamFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchOauthParam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchOauthParam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchOauthParam' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchOauthHeader$inboundSchema: z.ZodType<
  InputSplunkSearchOauthHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputSplunkSearchOauthHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputSplunkSearchOauthHeader$outboundSchema: z.ZodType<
  InputSplunkSearchOauthHeader$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchOauthHeader
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchOauthHeader$ {
  /** @deprecated use `InputSplunkSearchOauthHeader$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearchOauthHeader$inboundSchema;
  /** @deprecated use `InputSplunkSearchOauthHeader$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearchOauthHeader$outboundSchema;
  /** @deprecated use `InputSplunkSearchOauthHeader$Outbound` instead. */
  export type Outbound = InputSplunkSearchOauthHeader$Outbound;
}

export function inputSplunkSearchOauthHeaderToJSON(
  inputSplunkSearchOauthHeader: InputSplunkSearchOauthHeader,
): string {
  return JSON.stringify(
    InputSplunkSearchOauthHeader$outboundSchema.parse(
      inputSplunkSearchOauthHeader,
    ),
  );
}

export function inputSplunkSearchOauthHeaderFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchOauthHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchOauthHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchOauthHeader' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearch$inboundSchema: z.ZodType<
  InputSplunkSearch,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  type: InputSplunkSearchType$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSplunkSearchConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputSplunkSearchPq$inboundSchema).optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode$inboundSchema.default("json"),
  endpointParams: z.array(z.lazy(() => EndpointParam$inboundSchema)).optional(),
  endpointHeaders: z.array(z.lazy(() => EndpointHeader$inboundSchema))
    .optional(),
  logLevel: InputSplunkSearchLogLevel$inboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputSplunkSearchMetadatum$inboundSchema))
    .optional(),
  retryRules: z.lazy(() => InputSplunkSearchRetryRules$inboundSchema)
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  authType: InputSplunkSearchAuthenticationType$inboundSchema.default("basic"),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => InputSplunkSearchOauthParam$inboundSchema))
    .optional(),
  oauthHeaders: z.array(
    z.lazy(() => InputSplunkSearchOauthHeader$inboundSchema),
  ).optional(),
});

/** @internal */
export type InputSplunkSearch$Outbound = {
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputSplunkSearchConnection$Outbound> | undefined;
  pq?: InputSplunkSearchPq$Outbound | undefined;
  searchHead: string;
  search: string;
  earliest: string;
  latest: string;
  cronSchedule: string;
  endpoint: string;
  outputMode: string;
  endpointParams?: Array<EndpointParam$Outbound> | undefined;
  endpointHeaders?: Array<EndpointHeader$Outbound> | undefined;
  logLevel?: string | undefined;
  requestTimeout: number;
  useRoundRobinDns: boolean;
  rejectUnauthorized: boolean;
  encoding?: string | undefined;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<InputSplunkSearchMetadatum$Outbound> | undefined;
  retryRules?: InputSplunkSearchRetryRules$Outbound | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  authType: string;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<InputSplunkSearchOauthParam$Outbound> | undefined;
  oauthHeaders?: Array<InputSplunkSearchOauthHeader$Outbound> | undefined;
};

/** @internal */
export const InputSplunkSearch$outboundSchema: z.ZodType<
  InputSplunkSearch$Outbound,
  z.ZodTypeDef,
  InputSplunkSearch
> = z.object({
  id: z.string().optional(),
  type: InputSplunkSearchType$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSplunkSearchConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputSplunkSearchPq$outboundSchema).optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode$outboundSchema.default("json"),
  endpointParams: z.array(z.lazy(() => EndpointParam$outboundSchema))
    .optional(),
  endpointHeaders: z.array(z.lazy(() => EndpointHeader$outboundSchema))
    .optional(),
  logLevel: InputSplunkSearchLogLevel$outboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputSplunkSearchMetadatum$outboundSchema))
    .optional(),
  retryRules: z.lazy(() => InputSplunkSearchRetryRules$outboundSchema)
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  authType: InputSplunkSearchAuthenticationType$outboundSchema.default("basic"),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => InputSplunkSearchOauthParam$outboundSchema))
    .optional(),
  oauthHeaders: z.array(
    z.lazy(() => InputSplunkSearchOauthHeader$outboundSchema),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearch$ {
  /** @deprecated use `InputSplunkSearch$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearch$inboundSchema;
  /** @deprecated use `InputSplunkSearch$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearch$outboundSchema;
  /** @deprecated use `InputSplunkSearch$Outbound` instead. */
  export type Outbound = InputSplunkSearch$Outbound;
}

export function inputSplunkSearchToJSON(
  inputSplunkSearch: InputSplunkSearch,
): string {
  return JSON.stringify(
    InputSplunkSearch$outboundSchema.parse(inputSplunkSearch),
  );
}

export function inputSplunkSearchFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearch, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearch$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearch' from JSON`,
  );
}
