/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  ClosedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const InputSplunkSearchType = {
  SplunkSearch: "splunk_search",
} as const;
export type InputSplunkSearchType = ClosedEnum<typeof InputSplunkSearchType>;

export type InputSplunkSearchConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputSplunkSearchMode = {
  /**
   * Smart
   */
  Smart: "smart",
  /**
   * Always On
   */
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputSplunkSearchMode = OpenEnum<typeof InputSplunkSearchMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputSplunkSearchCompression = {
  /**
   * None
   */
  None: "none",
  /**
   * Gzip
   */
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputSplunkSearchCompression = OpenEnum<
  typeof InputSplunkSearchCompression
>;

export type InputSplunkSearchPqControls = {};

export type InputSplunkSearchPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputSplunkSearchMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputSplunkSearchCompression | undefined;
  pqControls?: InputSplunkSearchPqControls | undefined;
};

/**
 * Format of the returned output
 */
export const OutputMode = {
  Csv: "csv",
  Json: "json",
} as const;
/**
 * Format of the returned output
 */
export type OutputMode = OpenEnum<typeof OutputMode>;

export type EndpointParam = {
  name: string;
  /**
   * JavaScript expression to compute the parameter's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings.
   */
  value: string;
};

export type EndpointHeader = {
  name: string;
  /**
   * JavaScript expression to compute the header's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings.
   */
  value: string;
};

/**
 * Collector runtime log level (verbosity)
 */
export const InputSplunkSearchLogLevel = {
  Error: "error",
  Warn: "warn",
  Info: "info",
  Debug: "debug",
} as const;
/**
 * Collector runtime log level (verbosity)
 */
export type InputSplunkSearchLogLevel = OpenEnum<
  typeof InputSplunkSearchLogLevel
>;

export type InputSplunkSearchMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * The algorithm to use when performing HTTP retries
 */
export const InputSplunkSearchRetryType = {
  /**
   * Disabled
   */
  None: "none",
  /**
   * Backoff
   */
  Backoff: "backoff",
  /**
   * Static
   */
  Static: "static",
} as const;
/**
 * The algorithm to use when performing HTTP retries
 */
export type InputSplunkSearchRetryType = OpenEnum<
  typeof InputSplunkSearchRetryType
>;

export type InputSplunkSearchRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: InputSplunkSearchRetryType | undefined;
  /**
   * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * The maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
   */
  multiplier?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

/**
 * Splunk Search authentication type
 */
export const InputSplunkSearchAuthenticationType = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * Splunk Search authentication type
 */
export type InputSplunkSearchAuthenticationType = OpenEnum<
  typeof InputSplunkSearchAuthenticationType
>;

export type InputSplunkSearchOauthParam = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type InputSplunkSearchOauthHeader = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type InputSplunkSearch = {
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputSplunkSearchType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputSplunkSearchConnection> | undefined;
  pq?: InputSplunkSearchPq | undefined;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead?: string | undefined;
  /**
   * Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * A cron schedule on which to run this job
   */
  cronSchedule?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint?: string | undefined;
  /**
   * Format of the returned output
   */
  outputMode?: OutputMode | undefined;
  /**
   * Optional request parameters to send to the endpoint
   */
  endpointParams?: Array<EndpointParam> | undefined;
  /**
   * Optional request headers to send to the endpoint
   */
  endpointHeaders?: Array<EndpointHeader> | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel?: InputSplunkSearchLogLevel | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  requestTimeout?: number | undefined;
  /**
   * When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputSplunkSearchMetadatum> | undefined;
  retryRules?: InputSplunkSearchRetryRules | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: InputSplunkSearchAuthenticationType | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<InputSplunkSearchOauthParam> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<InputSplunkSearchOauthHeader> | undefined;
};

/** @internal */
export const InputSplunkSearchType$inboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType
> = z.nativeEnum(InputSplunkSearchType);
/** @internal */
export const InputSplunkSearchType$outboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType
> = InputSplunkSearchType$inboundSchema;

/** @internal */
export const InputSplunkSearchConnection$inboundSchema: z.ZodType<
  InputSplunkSearchConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});
/** @internal */
export type InputSplunkSearchConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputSplunkSearchConnection$outboundSchema: z.ZodType<
  InputSplunkSearchConnection$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

export function inputSplunkSearchConnectionToJSON(
  inputSplunkSearchConnection: InputSplunkSearchConnection,
): string {
  return JSON.stringify(
    InputSplunkSearchConnection$outboundSchema.parse(
      inputSplunkSearchConnection,
    ),
  );
}
export function inputSplunkSearchConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchConnection' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchMode$inboundSchema: z.ZodType<
  InputSplunkSearchMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkSearchMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const InputSplunkSearchMode$outboundSchema: z.ZodType<
  InputSplunkSearchMode,
  z.ZodTypeDef,
  InputSplunkSearchMode
> = z.union([
  z.nativeEnum(InputSplunkSearchMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputSplunkSearchCompression$inboundSchema: z.ZodType<
  InputSplunkSearchCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkSearchCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const InputSplunkSearchCompression$outboundSchema: z.ZodType<
  InputSplunkSearchCompression,
  z.ZodTypeDef,
  InputSplunkSearchCompression
> = z.union([
  z.nativeEnum(InputSplunkSearchCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputSplunkSearchPqControls$inboundSchema: z.ZodType<
  InputSplunkSearchPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});
/** @internal */
export type InputSplunkSearchPqControls$Outbound = {};

/** @internal */
export const InputSplunkSearchPqControls$outboundSchema: z.ZodType<
  InputSplunkSearchPqControls$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchPqControls
> = z.object({});

export function inputSplunkSearchPqControlsToJSON(
  inputSplunkSearchPqControls: InputSplunkSearchPqControls,
): string {
  return JSON.stringify(
    InputSplunkSearchPqControls$outboundSchema.parse(
      inputSplunkSearchPqControls,
    ),
  );
}
export function inputSplunkSearchPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchPqControls' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchPq$inboundSchema: z.ZodType<
  InputSplunkSearchPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputSplunkSearchMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSplunkSearchCompression$inboundSchema.default("none"),
  pqControls: z.lazy(() => InputSplunkSearchPqControls$inboundSchema)
    .optional(),
});
/** @internal */
export type InputSplunkSearchPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
  pqControls?: InputSplunkSearchPqControls$Outbound | undefined;
};

/** @internal */
export const InputSplunkSearchPq$outboundSchema: z.ZodType<
  InputSplunkSearchPq$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchPq
> = z.object({
  mode: InputSplunkSearchMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSplunkSearchCompression$outboundSchema.default("none"),
  pqControls: z.lazy(() => InputSplunkSearchPqControls$outboundSchema)
    .optional(),
});

export function inputSplunkSearchPqToJSON(
  inputSplunkSearchPq: InputSplunkSearchPq,
): string {
  return JSON.stringify(
    InputSplunkSearchPq$outboundSchema.parse(inputSplunkSearchPq),
  );
}
export function inputSplunkSearchPqFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchPq' from JSON`,
  );
}

/** @internal */
export const OutputMode$inboundSchema: z.ZodType<
  OutputMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputMode$outboundSchema: z.ZodType<
  OutputMode,
  z.ZodTypeDef,
  OutputMode
> = z.union([
  z.nativeEnum(OutputMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const EndpointParam$inboundSchema: z.ZodType<
  EndpointParam,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type EndpointParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const EndpointParam$outboundSchema: z.ZodType<
  EndpointParam$Outbound,
  z.ZodTypeDef,
  EndpointParam
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function endpointParamToJSON(endpointParam: EndpointParam): string {
  return JSON.stringify(EndpointParam$outboundSchema.parse(endpointParam));
}
export function endpointParamFromJSON(
  jsonString: string,
): SafeParseResult<EndpointParam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EndpointParam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EndpointParam' from JSON`,
  );
}

/** @internal */
export const EndpointHeader$inboundSchema: z.ZodType<
  EndpointHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type EndpointHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const EndpointHeader$outboundSchema: z.ZodType<
  EndpointHeader$Outbound,
  z.ZodTypeDef,
  EndpointHeader
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function endpointHeaderToJSON(endpointHeader: EndpointHeader): string {
  return JSON.stringify(EndpointHeader$outboundSchema.parse(endpointHeader));
}
export function endpointHeaderFromJSON(
  jsonString: string,
): SafeParseResult<EndpointHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EndpointHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EndpointHeader' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchLogLevel$inboundSchema: z.ZodType<
  InputSplunkSearchLogLevel,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkSearchLogLevel),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const InputSplunkSearchLogLevel$outboundSchema: z.ZodType<
  InputSplunkSearchLogLevel,
  z.ZodTypeDef,
  InputSplunkSearchLogLevel
> = z.union([
  z.nativeEnum(InputSplunkSearchLogLevel),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputSplunkSearchMetadatum$inboundSchema: z.ZodType<
  InputSplunkSearchMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type InputSplunkSearchMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputSplunkSearchMetadatum$outboundSchema: z.ZodType<
  InputSplunkSearchMetadatum$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function inputSplunkSearchMetadatumToJSON(
  inputSplunkSearchMetadatum: InputSplunkSearchMetadatum,
): string {
  return JSON.stringify(
    InputSplunkSearchMetadatum$outboundSchema.parse(inputSplunkSearchMetadatum),
  );
}
export function inputSplunkSearchMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchMetadatum' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchRetryType$inboundSchema: z.ZodType<
  InputSplunkSearchRetryType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkSearchRetryType),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const InputSplunkSearchRetryType$outboundSchema: z.ZodType<
  InputSplunkSearchRetryType,
  z.ZodTypeDef,
  InputSplunkSearchRetryType
> = z.union([
  z.nativeEnum(InputSplunkSearchRetryType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputSplunkSearchRetryRules$inboundSchema: z.ZodType<
  InputSplunkSearchRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: InputSplunkSearchRetryType$inboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});
/** @internal */
export type InputSplunkSearchRetryRules$Outbound = {
  type: string;
  interval: number;
  limit: number;
  multiplier: number;
  codes?: Array<number> | undefined;
  enableHeader: boolean;
  retryConnectTimeout: boolean;
  retryConnectReset: boolean;
};

/** @internal */
export const InputSplunkSearchRetryRules$outboundSchema: z.ZodType<
  InputSplunkSearchRetryRules$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchRetryRules
> = z.object({
  type: InputSplunkSearchRetryType$outboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

export function inputSplunkSearchRetryRulesToJSON(
  inputSplunkSearchRetryRules: InputSplunkSearchRetryRules,
): string {
  return JSON.stringify(
    InputSplunkSearchRetryRules$outboundSchema.parse(
      inputSplunkSearchRetryRules,
    ),
  );
}
export function inputSplunkSearchRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchRetryRules' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchAuthenticationType$inboundSchema: z.ZodType<
  InputSplunkSearchAuthenticationType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkSearchAuthenticationType),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const InputSplunkSearchAuthenticationType$outboundSchema: z.ZodType<
  InputSplunkSearchAuthenticationType,
  z.ZodTypeDef,
  InputSplunkSearchAuthenticationType
> = z.union([
  z.nativeEnum(InputSplunkSearchAuthenticationType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputSplunkSearchOauthParam$inboundSchema: z.ZodType<
  InputSplunkSearchOauthParam,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type InputSplunkSearchOauthParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputSplunkSearchOauthParam$outboundSchema: z.ZodType<
  InputSplunkSearchOauthParam$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchOauthParam
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function inputSplunkSearchOauthParamToJSON(
  inputSplunkSearchOauthParam: InputSplunkSearchOauthParam,
): string {
  return JSON.stringify(
    InputSplunkSearchOauthParam$outboundSchema.parse(
      inputSplunkSearchOauthParam,
    ),
  );
}
export function inputSplunkSearchOauthParamFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchOauthParam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchOauthParam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchOauthParam' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchOauthHeader$inboundSchema: z.ZodType<
  InputSplunkSearchOauthHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type InputSplunkSearchOauthHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputSplunkSearchOauthHeader$outboundSchema: z.ZodType<
  InputSplunkSearchOauthHeader$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchOauthHeader
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function inputSplunkSearchOauthHeaderToJSON(
  inputSplunkSearchOauthHeader: InputSplunkSearchOauthHeader,
): string {
  return JSON.stringify(
    InputSplunkSearchOauthHeader$outboundSchema.parse(
      inputSplunkSearchOauthHeader,
    ),
  );
}
export function inputSplunkSearchOauthHeaderFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchOauthHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchOauthHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchOauthHeader' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearch$inboundSchema: z.ZodType<
  InputSplunkSearch,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  type: InputSplunkSearchType$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSplunkSearchConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputSplunkSearchPq$inboundSchema).optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode$inboundSchema.default("json"),
  endpointParams: z.array(z.lazy(() => EndpointParam$inboundSchema)).optional(),
  endpointHeaders: z.array(z.lazy(() => EndpointHeader$inboundSchema))
    .optional(),
  logLevel: InputSplunkSearchLogLevel$inboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputSplunkSearchMetadatum$inboundSchema))
    .optional(),
  retryRules: z.lazy(() => InputSplunkSearchRetryRules$inboundSchema)
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  authType: InputSplunkSearchAuthenticationType$inboundSchema.default("basic"),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => InputSplunkSearchOauthParam$inboundSchema))
    .optional(),
  oauthHeaders: z.array(
    z.lazy(() => InputSplunkSearchOauthHeader$inboundSchema),
  ).optional(),
});
/** @internal */
export type InputSplunkSearch$Outbound = {
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputSplunkSearchConnection$Outbound> | undefined;
  pq?: InputSplunkSearchPq$Outbound | undefined;
  searchHead: string;
  search: string;
  earliest: string;
  latest: string;
  cronSchedule: string;
  endpoint: string;
  outputMode: string;
  endpointParams?: Array<EndpointParam$Outbound> | undefined;
  endpointHeaders?: Array<EndpointHeader$Outbound> | undefined;
  logLevel?: string | undefined;
  requestTimeout: number;
  useRoundRobinDns: boolean;
  rejectUnauthorized: boolean;
  encoding?: string | undefined;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<InputSplunkSearchMetadatum$Outbound> | undefined;
  retryRules?: InputSplunkSearchRetryRules$Outbound | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  authType: string;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<InputSplunkSearchOauthParam$Outbound> | undefined;
  oauthHeaders?: Array<InputSplunkSearchOauthHeader$Outbound> | undefined;
};

/** @internal */
export const InputSplunkSearch$outboundSchema: z.ZodType<
  InputSplunkSearch$Outbound,
  z.ZodTypeDef,
  InputSplunkSearch
> = z.object({
  id: z.string().optional(),
  type: InputSplunkSearchType$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSplunkSearchConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputSplunkSearchPq$outboundSchema).optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode$outboundSchema.default("json"),
  endpointParams: z.array(z.lazy(() => EndpointParam$outboundSchema))
    .optional(),
  endpointHeaders: z.array(z.lazy(() => EndpointHeader$outboundSchema))
    .optional(),
  logLevel: InputSplunkSearchLogLevel$outboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputSplunkSearchMetadatum$outboundSchema))
    .optional(),
  retryRules: z.lazy(() => InputSplunkSearchRetryRules$outboundSchema)
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  authType: InputSplunkSearchAuthenticationType$outboundSchema.default("basic"),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => InputSplunkSearchOauthParam$outboundSchema))
    .optional(),
  oauthHeaders: z.array(
    z.lazy(() => InputSplunkSearchOauthHeader$outboundSchema),
  ).optional(),
});

export function inputSplunkSearchToJSON(
  inputSplunkSearch: InputSplunkSearch,
): string {
  return JSON.stringify(
    InputSplunkSearch$outboundSchema.parse(inputSplunkSearch),
  );
}
export function inputSplunkSearchFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearch, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearch$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearch' from JSON`,
  );
}
