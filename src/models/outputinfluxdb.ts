/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  ClosedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  AuthTypeOptions,
  AuthTypeOptions$inboundSchema,
  AuthTypeOptions$outboundSchema,
} from "./authtypeoptions.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ExtraHttpHeadersType,
  ExtraHttpHeadersType$inboundSchema,
  ExtraHttpHeadersType$Outbound,
  ExtraHttpHeadersType$outboundSchema,
} from "./extrahttpheaderstype.js";
import {
  FailedRequestLoggingModeOptions,
  FailedRequestLoggingModeOptions$inboundSchema,
  FailedRequestLoggingModeOptions$outboundSchema,
} from "./failedrequestloggingmodeoptions.js";
import {
  Metadata1Type,
  Metadata1Type$inboundSchema,
  Metadata1Type$Outbound,
  Metadata1Type$outboundSchema,
} from "./metadata1type.js";
import {
  MetadataType,
  MetadataType$inboundSchema,
  MetadataType$Outbound,
  MetadataType$outboundSchema,
} from "./metadatatype.js";
import {
  OnBackpressureOptions,
  OnBackpressureOptions$inboundSchema,
  OnBackpressureOptions$outboundSchema,
} from "./onbackpressureoptions.js";
import {
  PqCompressOptions,
  PqCompressOptions$inboundSchema,
  PqCompressOptions$outboundSchema,
} from "./pqcompressoptions.js";
import {
  PqModeOptions,
  PqModeOptions$inboundSchema,
  PqModeOptions$outboundSchema,
} from "./pqmodeoptions.js";
import {
  PqOnBackpressureOptions,
  PqOnBackpressureOptions$inboundSchema,
  PqOnBackpressureOptions$outboundSchema,
} from "./pqonbackpressureoptions.js";
import {
  ResponseRetrySettingsType,
  ResponseRetrySettingsType$inboundSchema,
  ResponseRetrySettingsType$Outbound,
  ResponseRetrySettingsType$outboundSchema,
} from "./responseretrysettingstype.js";
import {
  TimeoutRetrySettingsType,
  TimeoutRetrySettingsType$inboundSchema,
  TimeoutRetrySettingsType$Outbound,
  TimeoutRetrySettingsType$outboundSchema,
} from "./timeoutretrysettingstype.js";

export const OutputInfluxdbType10 = {
  Influxdb: "influxdb",
} as const;
export type OutputInfluxdbType10 = ClosedEnum<typeof OutputInfluxdbType10>;

/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export const TimestampPrecision10 = {
  /**
   * Nanoseconds
   */
  Ns: "ns",
  /**
   * Microseconds
   */
  U: "u",
  /**
   * Milliseconds
   */
  Ms: "ms",
  /**
   * Seconds
   */
  S: "s",
  /**
   * Minutes
   */
  M: "m",
  /**
   * Hours
   */
  H: "h",
} as const;
/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export type TimestampPrecision10 = OpenEnum<typeof TimestampPrecision10>;

export type OutputInfluxdbInfluxdb10 = {
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputInfluxdbType10;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * URL of an InfluxDB cluster to send events to, e.g., http://localhost:8086/write
   */
  url: string;
  /**
   * The v2 API can be enabled with InfluxDB versions 1.8 and later.
   */
  useV2API?: boolean | undefined;
  /**
   * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
   */
  timestampPrecision?: TimestampPrecision10 | undefined;
  /**
   * Enabling this will pull the value field from the metric name. E,g, 'db.query.user' will use 'db.query' as the measurement and 'user' as the value field.
   */
  dynamicValueFieldName?: boolean | undefined;
  /**
   * Name of the field in which to store the metric when sending to InfluxDB. If dynamic generation is enabled and fails, this will be used as a fallback.
   */
  valueFieldName?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  description?: string | undefined;
  /**
   * Database to write to.
   */
  database?: string | undefined;
  /**
   * Bucket to write to.
   */
  bucket?: string | undefined;
  /**
   * Organization ID for this bucket.
   */
  org?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls?: MetadataType | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl: string;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName: string;
  /**
   * Secret parameter value to pass in request body
   */
  secret: string;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName: string;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams: Array<Metadata1Type>;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders: Array<Metadata1Type>;
};

export const OutputInfluxdbType9 = {
  Influxdb: "influxdb",
} as const;
export type OutputInfluxdbType9 = ClosedEnum<typeof OutputInfluxdbType9>;

/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export const TimestampPrecision9 = {
  /**
   * Nanoseconds
   */
  Ns: "ns",
  /**
   * Microseconds
   */
  U: "u",
  /**
   * Milliseconds
   */
  Ms: "ms",
  /**
   * Seconds
   */
  S: "s",
  /**
   * Minutes
   */
  M: "m",
  /**
   * Hours
   */
  H: "h",
} as const;
/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export type TimestampPrecision9 = OpenEnum<typeof TimestampPrecision9>;

export type OutputInfluxdbInfluxdb9 = {
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputInfluxdbType9;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * URL of an InfluxDB cluster to send events to, e.g., http://localhost:8086/write
   */
  url: string;
  /**
   * The v2 API can be enabled with InfluxDB versions 1.8 and later.
   */
  useV2API?: boolean | undefined;
  /**
   * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
   */
  timestampPrecision?: TimestampPrecision9 | undefined;
  /**
   * Enabling this will pull the value field from the metric name. E,g, 'db.query.user' will use 'db.query' as the measurement and 'user' as the value field.
   */
  dynamicValueFieldName?: boolean | undefined;
  /**
   * Name of the field in which to store the metric when sending to InfluxDB. If dynamic generation is enabled and fails, this will be used as a fallback.
   */
  valueFieldName?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  description?: string | undefined;
  /**
   * Database to write to.
   */
  database?: string | undefined;
  /**
   * Bucket to write to.
   */
  bucket?: string | undefined;
  /**
   * Organization ID for this bucket.
   */
  org?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls?: MetadataType | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret: string;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
};

export const OutputInfluxdbType8 = {
  Influxdb: "influxdb",
} as const;
export type OutputInfluxdbType8 = ClosedEnum<typeof OutputInfluxdbType8>;

/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export const TimestampPrecision8 = {
  /**
   * Nanoseconds
   */
  Ns: "ns",
  /**
   * Microseconds
   */
  U: "u",
  /**
   * Milliseconds
   */
  Ms: "ms",
  /**
   * Seconds
   */
  S: "s",
  /**
   * Minutes
   */
  M: "m",
  /**
   * Hours
   */
  H: "h",
} as const;
/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export type TimestampPrecision8 = OpenEnum<typeof TimestampPrecision8>;

export type OutputInfluxdbInfluxdb8 = {
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputInfluxdbType8;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * URL of an InfluxDB cluster to send events to, e.g., http://localhost:8086/write
   */
  url: string;
  /**
   * The v2 API can be enabled with InfluxDB versions 1.8 and later.
   */
  useV2API?: boolean | undefined;
  /**
   * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
   */
  timestampPrecision?: TimestampPrecision8 | undefined;
  /**
   * Enabling this will pull the value field from the metric name. E,g, 'db.query.user' will use 'db.query' as the measurement and 'user' as the value field.
   */
  dynamicValueFieldName?: boolean | undefined;
  /**
   * Name of the field in which to store the metric when sending to InfluxDB. If dynamic generation is enabled and fails, this will be used as a fallback.
   */
  valueFieldName?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  description?: string | undefined;
  /**
   * Database to write to.
   */
  database?: string | undefined;
  /**
   * Bucket to write to.
   */
  bucket?: string | undefined;
  /**
   * Organization ID for this bucket.
   */
  org?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls?: MetadataType | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret: string;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
};

export const OutputInfluxdbType7 = {
  Influxdb: "influxdb",
} as const;
export type OutputInfluxdbType7 = ClosedEnum<typeof OutputInfluxdbType7>;

/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export const TimestampPrecision7 = {
  /**
   * Nanoseconds
   */
  Ns: "ns",
  /**
   * Microseconds
   */
  U: "u",
  /**
   * Milliseconds
   */
  Ms: "ms",
  /**
   * Seconds
   */
  S: "s",
  /**
   * Minutes
   */
  M: "m",
  /**
   * Hours
   */
  H: "h",
} as const;
/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export type TimestampPrecision7 = OpenEnum<typeof TimestampPrecision7>;

export type OutputInfluxdbInfluxdb7 = {
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputInfluxdbType7;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * URL of an InfluxDB cluster to send events to, e.g., http://localhost:8086/write
   */
  url: string;
  /**
   * The v2 API can be enabled with InfluxDB versions 1.8 and later.
   */
  useV2API?: boolean | undefined;
  /**
   * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
   */
  timestampPrecision?: TimestampPrecision7 | undefined;
  /**
   * Enabling this will pull the value field from the metric name. E,g, 'db.query.user' will use 'db.query' as the measurement and 'user' as the value field.
   */
  dynamicValueFieldName?: boolean | undefined;
  /**
   * Name of the field in which to store the metric when sending to InfluxDB. If dynamic generation is enabled and fails, this will be used as a fallback.
   */
  valueFieldName?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  description?: string | undefined;
  /**
   * Database to write to.
   */
  database?: string | undefined;
  /**
   * Bucket to write to.
   */
  bucket?: string | undefined;
  /**
   * Organization ID for this bucket.
   */
  org?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls?: MetadataType | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token: string;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
};

export const OutputInfluxdbType6 = {
  Influxdb: "influxdb",
} as const;
export type OutputInfluxdbType6 = ClosedEnum<typeof OutputInfluxdbType6>;

/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export const TimestampPrecision6 = {
  /**
   * Nanoseconds
   */
  Ns: "ns",
  /**
   * Microseconds
   */
  U: "u",
  /**
   * Milliseconds
   */
  Ms: "ms",
  /**
   * Seconds
   */
  S: "s",
  /**
   * Minutes
   */
  M: "m",
  /**
   * Hours
   */
  H: "h",
} as const;
/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export type TimestampPrecision6 = OpenEnum<typeof TimestampPrecision6>;

export type OutputInfluxdbInfluxdb6 = {
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputInfluxdbType6;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * URL of an InfluxDB cluster to send events to, e.g., http://localhost:8086/write
   */
  url: string;
  /**
   * The v2 API can be enabled with InfluxDB versions 1.8 and later.
   */
  useV2API?: boolean | undefined;
  /**
   * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
   */
  timestampPrecision?: TimestampPrecision6 | undefined;
  /**
   * Enabling this will pull the value field from the metric name. E,g, 'db.query.user' will use 'db.query' as the measurement and 'user' as the value field.
   */
  dynamicValueFieldName?: boolean | undefined;
  /**
   * Name of the field in which to store the metric when sending to InfluxDB. If dynamic generation is enabled and fails, this will be used as a fallback.
   */
  valueFieldName?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  description?: string | undefined;
  /**
   * Database to write to.
   */
  database?: string | undefined;
  /**
   * Bucket to write to.
   */
  bucket?: string | undefined;
  /**
   * Organization ID for this bucket.
   */
  org?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls?: MetadataType | undefined;
  username: string;
  password: string;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
};

export const OutputInfluxdbType5 = {
  Influxdb: "influxdb",
} as const;
export type OutputInfluxdbType5 = ClosedEnum<typeof OutputInfluxdbType5>;

/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export const TimestampPrecision5 = {
  /**
   * Nanoseconds
   */
  Ns: "ns",
  /**
   * Microseconds
   */
  U: "u",
  /**
   * Milliseconds
   */
  Ms: "ms",
  /**
   * Seconds
   */
  S: "s",
  /**
   * Minutes
   */
  M: "m",
  /**
   * Hours
   */
  H: "h",
} as const;
/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export type TimestampPrecision5 = OpenEnum<typeof TimestampPrecision5>;

export type OutputInfluxdbInfluxdb5 = {
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputInfluxdbType5;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * URL of an InfluxDB cluster to send events to, e.g., http://localhost:8086/write
   */
  url: string;
  /**
   * The v2 API can be enabled with InfluxDB versions 1.8 and later.
   */
  useV2API?: boolean | undefined;
  /**
   * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
   */
  timestampPrecision?: TimestampPrecision5 | undefined;
  /**
   * Enabling this will pull the value field from the metric name. E,g, 'db.query.user' will use 'db.query' as the measurement and 'user' as the value field.
   */
  dynamicValueFieldName?: boolean | undefined;
  /**
   * Name of the field in which to store the metric when sending to InfluxDB. If dynamic generation is enabled and fails, this will be used as a fallback.
   */
  valueFieldName?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  description?: string | undefined;
  /**
   * Database to write to.
   */
  database?: string | undefined;
  /**
   * Bucket to write to.
   */
  bucket?: string | undefined;
  /**
   * Organization ID for this bucket.
   */
  org?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls?: MetadataType | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
};

export const OutputInfluxdbType4 = {
  Influxdb: "influxdb",
} as const;
export type OutputInfluxdbType4 = ClosedEnum<typeof OutputInfluxdbType4>;

/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export const TimestampPrecision4 = {
  /**
   * Nanoseconds
   */
  Ns: "ns",
  /**
   * Microseconds
   */
  U: "u",
  /**
   * Milliseconds
   */
  Ms: "ms",
  /**
   * Seconds
   */
  S: "s",
  /**
   * Minutes
   */
  M: "m",
  /**
   * Hours
   */
  H: "h",
} as const;
/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export type TimestampPrecision4 = OpenEnum<typeof TimestampPrecision4>;

export type OutputInfluxdbInfluxdb4 = {
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputInfluxdbType4;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * URL of an InfluxDB cluster to send events to, e.g., http://localhost:8086/write
   */
  url: string;
  /**
   * The v2 API can be enabled with InfluxDB versions 1.8 and later.
   */
  useV2API?: boolean | undefined;
  /**
   * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
   */
  timestampPrecision?: TimestampPrecision4 | undefined;
  /**
   * Enabling this will pull the value field from the metric name. E,g, 'db.query.user' will use 'db.query' as the measurement and 'user' as the value field.
   */
  dynamicValueFieldName?: boolean | undefined;
  /**
   * Name of the field in which to store the metric when sending to InfluxDB. If dynamic generation is enabled and fails, this will be used as a fallback.
   */
  valueFieldName?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  description?: string | undefined;
  /**
   * Database to write to.
   */
  database?: string | undefined;
  /**
   * Bucket to write to.
   */
  bucket?: string | undefined;
  /**
   * Organization ID for this bucket.
   */
  org?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls: MetadataType;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
};

export const OutputInfluxdbType3 = {
  Influxdb: "influxdb",
} as const;
export type OutputInfluxdbType3 = ClosedEnum<typeof OutputInfluxdbType3>;

/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export const TimestampPrecision3 = {
  /**
   * Nanoseconds
   */
  Ns: "ns",
  /**
   * Microseconds
   */
  U: "u",
  /**
   * Milliseconds
   */
  Ms: "ms",
  /**
   * Seconds
   */
  S: "s",
  /**
   * Minutes
   */
  M: "m",
  /**
   * Hours
   */
  H: "h",
} as const;
/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export type TimestampPrecision3 = OpenEnum<typeof TimestampPrecision3>;

export type OutputInfluxdbInfluxdb3 = {
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputInfluxdbType3;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * URL of an InfluxDB cluster to send events to, e.g., http://localhost:8086/write
   */
  url: string;
  /**
   * The v2 API can be enabled with InfluxDB versions 1.8 and later.
   */
  useV2API?: boolean | undefined;
  /**
   * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
   */
  timestampPrecision?: TimestampPrecision3 | undefined;
  /**
   * Enabling this will pull the value field from the metric name. E,g, 'db.query.user' will use 'db.query' as the measurement and 'user' as the value field.
   */
  dynamicValueFieldName?: boolean | undefined;
  /**
   * Name of the field in which to store the metric when sending to InfluxDB. If dynamic generation is enabled and fails, this will be used as a fallback.
   */
  valueFieldName?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  description?: string | undefined;
  /**
   * Database to write to.
   */
  database?: string | undefined;
  /**
   * Bucket to write to.
   */
  bucket?: string | undefined;
  /**
   * Organization ID for this bucket.
   */
  org?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls?: MetadataType | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
};

export const OutputInfluxdbType2 = {
  Influxdb: "influxdb",
} as const;
export type OutputInfluxdbType2 = ClosedEnum<typeof OutputInfluxdbType2>;

/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export const TimestampPrecision2 = {
  /**
   * Nanoseconds
   */
  Ns: "ns",
  /**
   * Microseconds
   */
  U: "u",
  /**
   * Milliseconds
   */
  Ms: "ms",
  /**
   * Seconds
   */
  S: "s",
  /**
   * Minutes
   */
  M: "m",
  /**
   * Hours
   */
  H: "h",
} as const;
/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export type TimestampPrecision2 = OpenEnum<typeof TimestampPrecision2>;

export type OutputInfluxdbInfluxdb2 = {
  /**
   * The v2 API can be enabled with InfluxDB versions 1.8 and later.
   */
  useV2API?: boolean | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputInfluxdbType2;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * URL of an InfluxDB cluster to send events to, e.g., http://localhost:8086/write
   */
  url: string;
  /**
   * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
   */
  timestampPrecision?: TimestampPrecision2 | undefined;
  /**
   * Enabling this will pull the value field from the metric name. E,g, 'db.query.user' will use 'db.query' as the measurement and 'user' as the value field.
   */
  dynamicValueFieldName?: boolean | undefined;
  /**
   * Name of the field in which to store the metric when sending to InfluxDB. If dynamic generation is enabled and fails, this will be used as a fallback.
   */
  valueFieldName?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  description?: string | undefined;
  /**
   * Database to write to.
   */
  database?: string | undefined;
  /**
   * Bucket to write to.
   */
  bucket: string;
  /**
   * Organization ID for this bucket.
   */
  org: string;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls?: MetadataType | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
};

export const OutputInfluxdbType1 = {
  Influxdb: "influxdb",
} as const;
export type OutputInfluxdbType1 = ClosedEnum<typeof OutputInfluxdbType1>;

/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export const TimestampPrecision1 = {
  /**
   * Nanoseconds
   */
  Ns: "ns",
  /**
   * Microseconds
   */
  U: "u",
  /**
   * Milliseconds
   */
  Ms: "ms",
  /**
   * Seconds
   */
  S: "s",
  /**
   * Minutes
   */
  M: "m",
  /**
   * Hours
   */
  H: "h",
} as const;
/**
 * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
 */
export type TimestampPrecision1 = OpenEnum<typeof TimestampPrecision1>;

export type OutputInfluxdbInfluxdb1 = {
  /**
   * The v2 API can be enabled with InfluxDB versions 1.8 and later.
   */
  useV2API?: boolean | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputInfluxdbType1;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * URL of an InfluxDB cluster to send events to, e.g., http://localhost:8086/write
   */
  url: string;
  /**
   * Sets the precision for the supplied Unix time values. Defaults to milliseconds.
   */
  timestampPrecision?: TimestampPrecision1 | undefined;
  /**
   * Enabling this will pull the value field from the metric name. E,g, 'db.query.user' will use 'db.query' as the measurement and 'user' as the value field.
   */
  dynamicValueFieldName?: boolean | undefined;
  /**
   * Name of the field in which to store the metric when sending to InfluxDB. If dynamic generation is enabled and fails, this will be used as a fallback.
   */
  valueFieldName?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  description?: string | undefined;
  /**
   * Database to write to.
   */
  database: string;
  /**
   * Bucket to write to.
   */
  bucket?: string | undefined;
  /**
   * Organization ID for this bucket.
   */
  org?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls?: MetadataType | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
};

export type OutputInfluxdb =
  | OutputInfluxdbInfluxdb10
  | OutputInfluxdbInfluxdb2
  | OutputInfluxdbInfluxdb6
  | OutputInfluxdbInfluxdb1
  | OutputInfluxdbInfluxdb4
  | OutputInfluxdbInfluxdb7
  | OutputInfluxdbInfluxdb8
  | OutputInfluxdbInfluxdb9
  | OutputInfluxdbInfluxdb3
  | OutputInfluxdbInfluxdb5;

/** @internal */
export const OutputInfluxdbType10$inboundSchema: z.ZodNativeEnum<
  typeof OutputInfluxdbType10
> = z.nativeEnum(OutputInfluxdbType10);
/** @internal */
export const OutputInfluxdbType10$outboundSchema: z.ZodNativeEnum<
  typeof OutputInfluxdbType10
> = OutputInfluxdbType10$inboundSchema;

/** @internal */
export const TimestampPrecision10$inboundSchema: z.ZodType<
  TimestampPrecision10,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(TimestampPrecision10),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const TimestampPrecision10$outboundSchema: z.ZodType<
  TimestampPrecision10,
  z.ZodTypeDef,
  TimestampPrecision10
> = z.union([
  z.nativeEnum(TimestampPrecision10),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputInfluxdbInfluxdb10$inboundSchema: z.ZodType<
  OutputInfluxdbInfluxdb10,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputInfluxdbType10$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  useV2API: z.boolean().default(false),
  timestampPrecision: TimestampPrecision10$inboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(true),
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  description: z.string().optional(),
  database: z.string().optional(),
  bucket: z.string().optional(),
  org: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string(),
  secretParamName: z.string(),
  secret: z.string(),
  tokenAttributeName: z.string(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema),
  oauthHeaders: z.array(Metadata1Type$inboundSchema),
});
/** @internal */
export type OutputInfluxdbInfluxdb10$Outbound = {
  authType: string;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  useV2API: boolean;
  timestampPrecision: string;
  dynamicValueFieldName: boolean;
  valueFieldName: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  description?: string | undefined;
  database?: string | undefined;
  bucket?: string | undefined;
  org?: string | undefined;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls?: MetadataType$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl: string;
  secretParamName: string;
  secret: string;
  tokenAttributeName: string;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams: Array<Metadata1Type$Outbound>;
  oauthHeaders: Array<Metadata1Type$Outbound>;
};

/** @internal */
export const OutputInfluxdbInfluxdb10$outboundSchema: z.ZodType<
  OutputInfluxdbInfluxdb10$Outbound,
  z.ZodTypeDef,
  OutputInfluxdbInfluxdb10
> = z.object({
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputInfluxdbType10$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  useV2API: z.boolean().default(false),
  timestampPrecision: TimestampPrecision10$outboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(true),
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  description: z.string().optional(),
  database: z.string().optional(),
  bucket: z.string().optional(),
  org: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string(),
  secretParamName: z.string(),
  secret: z.string(),
  tokenAttributeName: z.string(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema),
  oauthHeaders: z.array(Metadata1Type$outboundSchema),
});

export function outputInfluxdbInfluxdb10ToJSON(
  outputInfluxdbInfluxdb10: OutputInfluxdbInfluxdb10,
): string {
  return JSON.stringify(
    OutputInfluxdbInfluxdb10$outboundSchema.parse(outputInfluxdbInfluxdb10),
  );
}
export function outputInfluxdbInfluxdb10FromJSON(
  jsonString: string,
): SafeParseResult<OutputInfluxdbInfluxdb10, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputInfluxdbInfluxdb10$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputInfluxdbInfluxdb10' from JSON`,
  );
}

/** @internal */
export const OutputInfluxdbType9$inboundSchema: z.ZodNativeEnum<
  typeof OutputInfluxdbType9
> = z.nativeEnum(OutputInfluxdbType9);
/** @internal */
export const OutputInfluxdbType9$outboundSchema: z.ZodNativeEnum<
  typeof OutputInfluxdbType9
> = OutputInfluxdbType9$inboundSchema;

/** @internal */
export const TimestampPrecision9$inboundSchema: z.ZodType<
  TimestampPrecision9,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(TimestampPrecision9),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const TimestampPrecision9$outboundSchema: z.ZodType<
  TimestampPrecision9,
  z.ZodTypeDef,
  TimestampPrecision9
> = z.union([
  z.nativeEnum(TimestampPrecision9),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputInfluxdbInfluxdb9$inboundSchema: z.ZodType<
  OutputInfluxdbInfluxdb9,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputInfluxdbType9$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  useV2API: z.boolean().default(false),
  timestampPrecision: TimestampPrecision9$inboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(true),
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  description: z.string().optional(),
  database: z.string().optional(),
  bucket: z.string().optional(),
  org: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
});
/** @internal */
export type OutputInfluxdbInfluxdb9$Outbound = {
  authType: string;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  useV2API: boolean;
  timestampPrecision: string;
  dynamicValueFieldName: boolean;
  valueFieldName: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  description?: string | undefined;
  database?: string | undefined;
  bucket?: string | undefined;
  org?: string | undefined;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls?: MetadataType$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret: string;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
};

/** @internal */
export const OutputInfluxdbInfluxdb9$outboundSchema: z.ZodType<
  OutputInfluxdbInfluxdb9$Outbound,
  z.ZodTypeDef,
  OutputInfluxdbInfluxdb9
> = z.object({
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputInfluxdbType9$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  useV2API: z.boolean().default(false),
  timestampPrecision: TimestampPrecision9$outboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(true),
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  description: z.string().optional(),
  database: z.string().optional(),
  bucket: z.string().optional(),
  org: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
});

export function outputInfluxdbInfluxdb9ToJSON(
  outputInfluxdbInfluxdb9: OutputInfluxdbInfluxdb9,
): string {
  return JSON.stringify(
    OutputInfluxdbInfluxdb9$outboundSchema.parse(outputInfluxdbInfluxdb9),
  );
}
export function outputInfluxdbInfluxdb9FromJSON(
  jsonString: string,
): SafeParseResult<OutputInfluxdbInfluxdb9, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputInfluxdbInfluxdb9$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputInfluxdbInfluxdb9' from JSON`,
  );
}

/** @internal */
export const OutputInfluxdbType8$inboundSchema: z.ZodNativeEnum<
  typeof OutputInfluxdbType8
> = z.nativeEnum(OutputInfluxdbType8);
/** @internal */
export const OutputInfluxdbType8$outboundSchema: z.ZodNativeEnum<
  typeof OutputInfluxdbType8
> = OutputInfluxdbType8$inboundSchema;

/** @internal */
export const TimestampPrecision8$inboundSchema: z.ZodType<
  TimestampPrecision8,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(TimestampPrecision8),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const TimestampPrecision8$outboundSchema: z.ZodType<
  TimestampPrecision8,
  z.ZodTypeDef,
  TimestampPrecision8
> = z.union([
  z.nativeEnum(TimestampPrecision8),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputInfluxdbInfluxdb8$inboundSchema: z.ZodType<
  OutputInfluxdbInfluxdb8,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputInfluxdbType8$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  useV2API: z.boolean().default(false),
  timestampPrecision: TimestampPrecision8$inboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(true),
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  description: z.string().optional(),
  database: z.string().optional(),
  bucket: z.string().optional(),
  org: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
});
/** @internal */
export type OutputInfluxdbInfluxdb8$Outbound = {
  authType: string;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  useV2API: boolean;
  timestampPrecision: string;
  dynamicValueFieldName: boolean;
  valueFieldName: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  description?: string | undefined;
  database?: string | undefined;
  bucket?: string | undefined;
  org?: string | undefined;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls?: MetadataType$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret: string;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
};

/** @internal */
export const OutputInfluxdbInfluxdb8$outboundSchema: z.ZodType<
  OutputInfluxdbInfluxdb8$Outbound,
  z.ZodTypeDef,
  OutputInfluxdbInfluxdb8
> = z.object({
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputInfluxdbType8$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  useV2API: z.boolean().default(false),
  timestampPrecision: TimestampPrecision8$outboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(true),
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  description: z.string().optional(),
  database: z.string().optional(),
  bucket: z.string().optional(),
  org: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
});

export function outputInfluxdbInfluxdb8ToJSON(
  outputInfluxdbInfluxdb8: OutputInfluxdbInfluxdb8,
): string {
  return JSON.stringify(
    OutputInfluxdbInfluxdb8$outboundSchema.parse(outputInfluxdbInfluxdb8),
  );
}
export function outputInfluxdbInfluxdb8FromJSON(
  jsonString: string,
): SafeParseResult<OutputInfluxdbInfluxdb8, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputInfluxdbInfluxdb8$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputInfluxdbInfluxdb8' from JSON`,
  );
}

/** @internal */
export const OutputInfluxdbType7$inboundSchema: z.ZodNativeEnum<
  typeof OutputInfluxdbType7
> = z.nativeEnum(OutputInfluxdbType7);
/** @internal */
export const OutputInfluxdbType7$outboundSchema: z.ZodNativeEnum<
  typeof OutputInfluxdbType7
> = OutputInfluxdbType7$inboundSchema;

/** @internal */
export const TimestampPrecision7$inboundSchema: z.ZodType<
  TimestampPrecision7,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(TimestampPrecision7),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const TimestampPrecision7$outboundSchema: z.ZodType<
  TimestampPrecision7,
  z.ZodTypeDef,
  TimestampPrecision7
> = z.union([
  z.nativeEnum(TimestampPrecision7),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputInfluxdbInfluxdb7$inboundSchema: z.ZodType<
  OutputInfluxdbInfluxdb7,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputInfluxdbType7$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  useV2API: z.boolean().default(false),
  timestampPrecision: TimestampPrecision7$inboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(true),
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  description: z.string().optional(),
  database: z.string().optional(),
  bucket: z.string().optional(),
  org: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
});
/** @internal */
export type OutputInfluxdbInfluxdb7$Outbound = {
  authType: string;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  useV2API: boolean;
  timestampPrecision: string;
  dynamicValueFieldName: boolean;
  valueFieldName: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  description?: string | undefined;
  database?: string | undefined;
  bucket?: string | undefined;
  org?: string | undefined;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls?: MetadataType$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token: string;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
};

/** @internal */
export const OutputInfluxdbInfluxdb7$outboundSchema: z.ZodType<
  OutputInfluxdbInfluxdb7$Outbound,
  z.ZodTypeDef,
  OutputInfluxdbInfluxdb7
> = z.object({
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputInfluxdbType7$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  useV2API: z.boolean().default(false),
  timestampPrecision: TimestampPrecision7$outboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(true),
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  description: z.string().optional(),
  database: z.string().optional(),
  bucket: z.string().optional(),
  org: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
});

export function outputInfluxdbInfluxdb7ToJSON(
  outputInfluxdbInfluxdb7: OutputInfluxdbInfluxdb7,
): string {
  return JSON.stringify(
    OutputInfluxdbInfluxdb7$outboundSchema.parse(outputInfluxdbInfluxdb7),
  );
}
export function outputInfluxdbInfluxdb7FromJSON(
  jsonString: string,
): SafeParseResult<OutputInfluxdbInfluxdb7, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputInfluxdbInfluxdb7$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputInfluxdbInfluxdb7' from JSON`,
  );
}

/** @internal */
export const OutputInfluxdbType6$inboundSchema: z.ZodNativeEnum<
  typeof OutputInfluxdbType6
> = z.nativeEnum(OutputInfluxdbType6);
/** @internal */
export const OutputInfluxdbType6$outboundSchema: z.ZodNativeEnum<
  typeof OutputInfluxdbType6
> = OutputInfluxdbType6$inboundSchema;

/** @internal */
export const TimestampPrecision6$inboundSchema: z.ZodType<
  TimestampPrecision6,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(TimestampPrecision6),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const TimestampPrecision6$outboundSchema: z.ZodType<
  TimestampPrecision6,
  z.ZodTypeDef,
  TimestampPrecision6
> = z.union([
  z.nativeEnum(TimestampPrecision6),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputInfluxdbInfluxdb6$inboundSchema: z.ZodType<
  OutputInfluxdbInfluxdb6,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputInfluxdbType6$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  useV2API: z.boolean().default(false),
  timestampPrecision: TimestampPrecision6$inboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(true),
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  description: z.string().optional(),
  database: z.string().optional(),
  bucket: z.string().optional(),
  org: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema.optional(),
  username: z.string(),
  password: z.string(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
});
/** @internal */
export type OutputInfluxdbInfluxdb6$Outbound = {
  authType: string;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  useV2API: boolean;
  timestampPrecision: string;
  dynamicValueFieldName: boolean;
  valueFieldName: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  description?: string | undefined;
  database?: string | undefined;
  bucket?: string | undefined;
  org?: string | undefined;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls?: MetadataType$Outbound | undefined;
  username: string;
  password: string;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
};

/** @internal */
export const OutputInfluxdbInfluxdb6$outboundSchema: z.ZodType<
  OutputInfluxdbInfluxdb6$Outbound,
  z.ZodTypeDef,
  OutputInfluxdbInfluxdb6
> = z.object({
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputInfluxdbType6$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  useV2API: z.boolean().default(false),
  timestampPrecision: TimestampPrecision6$outboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(true),
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  description: z.string().optional(),
  database: z.string().optional(),
  bucket: z.string().optional(),
  org: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema.optional(),
  username: z.string(),
  password: z.string(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
});

export function outputInfluxdbInfluxdb6ToJSON(
  outputInfluxdbInfluxdb6: OutputInfluxdbInfluxdb6,
): string {
  return JSON.stringify(
    OutputInfluxdbInfluxdb6$outboundSchema.parse(outputInfluxdbInfluxdb6),
  );
}
export function outputInfluxdbInfluxdb6FromJSON(
  jsonString: string,
): SafeParseResult<OutputInfluxdbInfluxdb6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputInfluxdbInfluxdb6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputInfluxdbInfluxdb6' from JSON`,
  );
}

/** @internal */
export const OutputInfluxdbType5$inboundSchema: z.ZodNativeEnum<
  typeof OutputInfluxdbType5
> = z.nativeEnum(OutputInfluxdbType5);
/** @internal */
export const OutputInfluxdbType5$outboundSchema: z.ZodNativeEnum<
  typeof OutputInfluxdbType5
> = OutputInfluxdbType5$inboundSchema;

/** @internal */
export const TimestampPrecision5$inboundSchema: z.ZodType<
  TimestampPrecision5,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(TimestampPrecision5),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const TimestampPrecision5$outboundSchema: z.ZodType<
  TimestampPrecision5,
  z.ZodTypeDef,
  TimestampPrecision5
> = z.union([
  z.nativeEnum(TimestampPrecision5),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputInfluxdbInfluxdb5$inboundSchema: z.ZodType<
  OutputInfluxdbInfluxdb5,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputInfluxdbType5$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  useV2API: z.boolean().default(false),
  timestampPrecision: TimestampPrecision5$inboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(true),
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  description: z.string().optional(),
  database: z.string().optional(),
  bucket: z.string().optional(),
  org: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
});
/** @internal */
export type OutputInfluxdbInfluxdb5$Outbound = {
  authType: string;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  useV2API: boolean;
  timestampPrecision: string;
  dynamicValueFieldName: boolean;
  valueFieldName: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  description?: string | undefined;
  database?: string | undefined;
  bucket?: string | undefined;
  org?: string | undefined;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls?: MetadataType$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
};

/** @internal */
export const OutputInfluxdbInfluxdb5$outboundSchema: z.ZodType<
  OutputInfluxdbInfluxdb5$Outbound,
  z.ZodTypeDef,
  OutputInfluxdbInfluxdb5
> = z.object({
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputInfluxdbType5$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  useV2API: z.boolean().default(false),
  timestampPrecision: TimestampPrecision5$outboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(true),
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  description: z.string().optional(),
  database: z.string().optional(),
  bucket: z.string().optional(),
  org: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
});

export function outputInfluxdbInfluxdb5ToJSON(
  outputInfluxdbInfluxdb5: OutputInfluxdbInfluxdb5,
): string {
  return JSON.stringify(
    OutputInfluxdbInfluxdb5$outboundSchema.parse(outputInfluxdbInfluxdb5),
  );
}
export function outputInfluxdbInfluxdb5FromJSON(
  jsonString: string,
): SafeParseResult<OutputInfluxdbInfluxdb5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputInfluxdbInfluxdb5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputInfluxdbInfluxdb5' from JSON`,
  );
}

/** @internal */
export const OutputInfluxdbType4$inboundSchema: z.ZodNativeEnum<
  typeof OutputInfluxdbType4
> = z.nativeEnum(OutputInfluxdbType4);
/** @internal */
export const OutputInfluxdbType4$outboundSchema: z.ZodNativeEnum<
  typeof OutputInfluxdbType4
> = OutputInfluxdbType4$inboundSchema;

/** @internal */
export const TimestampPrecision4$inboundSchema: z.ZodType<
  TimestampPrecision4,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(TimestampPrecision4),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const TimestampPrecision4$outboundSchema: z.ZodType<
  TimestampPrecision4,
  z.ZodTypeDef,
  TimestampPrecision4
> = z.union([
  z.nativeEnum(TimestampPrecision4),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputInfluxdbInfluxdb4$inboundSchema: z.ZodType<
  OutputInfluxdbInfluxdb4,
  z.ZodTypeDef,
  unknown
> = z.object({
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  id: z.string().optional(),
  type: OutputInfluxdbType4$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  useV2API: z.boolean().default(false),
  timestampPrecision: TimestampPrecision4$inboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(true),
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  description: z.string().optional(),
  database: z.string().optional(),
  bucket: z.string().optional(),
  org: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema,
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
});
/** @internal */
export type OutputInfluxdbInfluxdb4$Outbound = {
  onBackpressure: string;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  useV2API: boolean;
  timestampPrecision: string;
  dynamicValueFieldName: boolean;
  valueFieldName: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  authType: string;
  description?: string | undefined;
  database?: string | undefined;
  bucket?: string | undefined;
  org?: string | undefined;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls: MetadataType$Outbound;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
};

/** @internal */
export const OutputInfluxdbInfluxdb4$outboundSchema: z.ZodType<
  OutputInfluxdbInfluxdb4$Outbound,
  z.ZodTypeDef,
  OutputInfluxdbInfluxdb4
> = z.object({
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  id: z.string().optional(),
  type: OutputInfluxdbType4$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  useV2API: z.boolean().default(false),
  timestampPrecision: TimestampPrecision4$outboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(true),
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  description: z.string().optional(),
  database: z.string().optional(),
  bucket: z.string().optional(),
  org: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema,
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
});

export function outputInfluxdbInfluxdb4ToJSON(
  outputInfluxdbInfluxdb4: OutputInfluxdbInfluxdb4,
): string {
  return JSON.stringify(
    OutputInfluxdbInfluxdb4$outboundSchema.parse(outputInfluxdbInfluxdb4),
  );
}
export function outputInfluxdbInfluxdb4FromJSON(
  jsonString: string,
): SafeParseResult<OutputInfluxdbInfluxdb4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputInfluxdbInfluxdb4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputInfluxdbInfluxdb4' from JSON`,
  );
}

/** @internal */
export const OutputInfluxdbType3$inboundSchema: z.ZodNativeEnum<
  typeof OutputInfluxdbType3
> = z.nativeEnum(OutputInfluxdbType3);
/** @internal */
export const OutputInfluxdbType3$outboundSchema: z.ZodNativeEnum<
  typeof OutputInfluxdbType3
> = OutputInfluxdbType3$inboundSchema;

/** @internal */
export const TimestampPrecision3$inboundSchema: z.ZodType<
  TimestampPrecision3,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(TimestampPrecision3),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const TimestampPrecision3$outboundSchema: z.ZodType<
  TimestampPrecision3,
  z.ZodTypeDef,
  TimestampPrecision3
> = z.union([
  z.nativeEnum(TimestampPrecision3),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputInfluxdbInfluxdb3$inboundSchema: z.ZodType<
  OutputInfluxdbInfluxdb3,
  z.ZodTypeDef,
  unknown
> = z.object({
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  id: z.string().optional(),
  type: OutputInfluxdbType3$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  useV2API: z.boolean().default(false),
  timestampPrecision: TimestampPrecision3$inboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(true),
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  description: z.string().optional(),
  database: z.string().optional(),
  bucket: z.string().optional(),
  org: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
});
/** @internal */
export type OutputInfluxdbInfluxdb3$Outbound = {
  onBackpressure: string;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  useV2API: boolean;
  timestampPrecision: string;
  dynamicValueFieldName: boolean;
  valueFieldName: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  authType: string;
  description?: string | undefined;
  database?: string | undefined;
  bucket?: string | undefined;
  org?: string | undefined;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls?: MetadataType$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
};

/** @internal */
export const OutputInfluxdbInfluxdb3$outboundSchema: z.ZodType<
  OutputInfluxdbInfluxdb3$Outbound,
  z.ZodTypeDef,
  OutputInfluxdbInfluxdb3
> = z.object({
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  id: z.string().optional(),
  type: OutputInfluxdbType3$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  useV2API: z.boolean().default(false),
  timestampPrecision: TimestampPrecision3$outboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(true),
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  description: z.string().optional(),
  database: z.string().optional(),
  bucket: z.string().optional(),
  org: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
});

export function outputInfluxdbInfluxdb3ToJSON(
  outputInfluxdbInfluxdb3: OutputInfluxdbInfluxdb3,
): string {
  return JSON.stringify(
    OutputInfluxdbInfluxdb3$outboundSchema.parse(outputInfluxdbInfluxdb3),
  );
}
export function outputInfluxdbInfluxdb3FromJSON(
  jsonString: string,
): SafeParseResult<OutputInfluxdbInfluxdb3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputInfluxdbInfluxdb3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputInfluxdbInfluxdb3' from JSON`,
  );
}

/** @internal */
export const OutputInfluxdbType2$inboundSchema: z.ZodNativeEnum<
  typeof OutputInfluxdbType2
> = z.nativeEnum(OutputInfluxdbType2);
/** @internal */
export const OutputInfluxdbType2$outboundSchema: z.ZodNativeEnum<
  typeof OutputInfluxdbType2
> = OutputInfluxdbType2$inboundSchema;

/** @internal */
export const TimestampPrecision2$inboundSchema: z.ZodType<
  TimestampPrecision2,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(TimestampPrecision2),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const TimestampPrecision2$outboundSchema: z.ZodType<
  TimestampPrecision2,
  z.ZodTypeDef,
  TimestampPrecision2
> = z.union([
  z.nativeEnum(TimestampPrecision2),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputInfluxdbInfluxdb2$inboundSchema: z.ZodType<
  OutputInfluxdbInfluxdb2,
  z.ZodTypeDef,
  unknown
> = z.object({
  useV2API: z.boolean().default(false),
  id: z.string().optional(),
  type: OutputInfluxdbType2$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  timestampPrecision: TimestampPrecision2$inboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(true),
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  description: z.string().optional(),
  database: z.string().optional(),
  bucket: z.string(),
  org: z.string(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
});
/** @internal */
export type OutputInfluxdbInfluxdb2$Outbound = {
  useV2API: boolean;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  timestampPrecision: string;
  dynamicValueFieldName: boolean;
  valueFieldName: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  authType: string;
  description?: string | undefined;
  database?: string | undefined;
  bucket: string;
  org: string;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls?: MetadataType$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
};

/** @internal */
export const OutputInfluxdbInfluxdb2$outboundSchema: z.ZodType<
  OutputInfluxdbInfluxdb2$Outbound,
  z.ZodTypeDef,
  OutputInfluxdbInfluxdb2
> = z.object({
  useV2API: z.boolean().default(false),
  id: z.string().optional(),
  type: OutputInfluxdbType2$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  timestampPrecision: TimestampPrecision2$outboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(true),
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  description: z.string().optional(),
  database: z.string().optional(),
  bucket: z.string(),
  org: z.string(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
});

export function outputInfluxdbInfluxdb2ToJSON(
  outputInfluxdbInfluxdb2: OutputInfluxdbInfluxdb2,
): string {
  return JSON.stringify(
    OutputInfluxdbInfluxdb2$outboundSchema.parse(outputInfluxdbInfluxdb2),
  );
}
export function outputInfluxdbInfluxdb2FromJSON(
  jsonString: string,
): SafeParseResult<OutputInfluxdbInfluxdb2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputInfluxdbInfluxdb2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputInfluxdbInfluxdb2' from JSON`,
  );
}

/** @internal */
export const OutputInfluxdbType1$inboundSchema: z.ZodNativeEnum<
  typeof OutputInfluxdbType1
> = z.nativeEnum(OutputInfluxdbType1);
/** @internal */
export const OutputInfluxdbType1$outboundSchema: z.ZodNativeEnum<
  typeof OutputInfluxdbType1
> = OutputInfluxdbType1$inboundSchema;

/** @internal */
export const TimestampPrecision1$inboundSchema: z.ZodType<
  TimestampPrecision1,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(TimestampPrecision1),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const TimestampPrecision1$outboundSchema: z.ZodType<
  TimestampPrecision1,
  z.ZodTypeDef,
  TimestampPrecision1
> = z.union([
  z.nativeEnum(TimestampPrecision1),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputInfluxdbInfluxdb1$inboundSchema: z.ZodType<
  OutputInfluxdbInfluxdb1,
  z.ZodTypeDef,
  unknown
> = z.object({
  useV2API: z.boolean().default(false),
  id: z.string().optional(),
  type: OutputInfluxdbType1$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  timestampPrecision: TimestampPrecision1$inboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(true),
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  description: z.string().optional(),
  database: z.string(),
  bucket: z.string().optional(),
  org: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
});
/** @internal */
export type OutputInfluxdbInfluxdb1$Outbound = {
  useV2API: boolean;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  url: string;
  timestampPrecision: string;
  dynamicValueFieldName: boolean;
  valueFieldName: string;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  authType: string;
  description?: string | undefined;
  database: string;
  bucket?: string | undefined;
  org?: string | undefined;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls?: MetadataType$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
};

/** @internal */
export const OutputInfluxdbInfluxdb1$outboundSchema: z.ZodType<
  OutputInfluxdbInfluxdb1$Outbound,
  z.ZodTypeDef,
  OutputInfluxdbInfluxdb1
> = z.object({
  useV2API: z.boolean().default(false),
  id: z.string().optional(),
  type: OutputInfluxdbType1$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  url: z.string(),
  timestampPrecision: TimestampPrecision1$outboundSchema.default("ms"),
  dynamicValueFieldName: z.boolean().default(true),
  valueFieldName: z.string().default("value"),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(true),
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  description: z.string().optional(),
  database: z.string(),
  bucket: z.string().optional(),
  org: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
});

export function outputInfluxdbInfluxdb1ToJSON(
  outputInfluxdbInfluxdb1: OutputInfluxdbInfluxdb1,
): string {
  return JSON.stringify(
    OutputInfluxdbInfluxdb1$outboundSchema.parse(outputInfluxdbInfluxdb1),
  );
}
export function outputInfluxdbInfluxdb1FromJSON(
  jsonString: string,
): SafeParseResult<OutputInfluxdbInfluxdb1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputInfluxdbInfluxdb1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputInfluxdbInfluxdb1' from JSON`,
  );
}

/** @internal */
export const OutputInfluxdb$inboundSchema: z.ZodType<
  OutputInfluxdb,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => OutputInfluxdbInfluxdb10$inboundSchema),
  z.lazy(() => OutputInfluxdbInfluxdb2$inboundSchema),
  z.lazy(() => OutputInfluxdbInfluxdb6$inboundSchema),
  z.lazy(() => OutputInfluxdbInfluxdb1$inboundSchema),
  z.lazy(() => OutputInfluxdbInfluxdb4$inboundSchema),
  z.lazy(() => OutputInfluxdbInfluxdb7$inboundSchema),
  z.lazy(() => OutputInfluxdbInfluxdb8$inboundSchema),
  z.lazy(() => OutputInfluxdbInfluxdb9$inboundSchema),
  z.lazy(() => OutputInfluxdbInfluxdb3$inboundSchema),
  z.lazy(() => OutputInfluxdbInfluxdb5$inboundSchema),
]);
/** @internal */
export type OutputInfluxdb$Outbound =
  | OutputInfluxdbInfluxdb10$Outbound
  | OutputInfluxdbInfluxdb2$Outbound
  | OutputInfluxdbInfluxdb6$Outbound
  | OutputInfluxdbInfluxdb1$Outbound
  | OutputInfluxdbInfluxdb4$Outbound
  | OutputInfluxdbInfluxdb7$Outbound
  | OutputInfluxdbInfluxdb8$Outbound
  | OutputInfluxdbInfluxdb9$Outbound
  | OutputInfluxdbInfluxdb3$Outbound
  | OutputInfluxdbInfluxdb5$Outbound;

/** @internal */
export const OutputInfluxdb$outboundSchema: z.ZodType<
  OutputInfluxdb$Outbound,
  z.ZodTypeDef,
  OutputInfluxdb
> = z.union([
  z.lazy(() => OutputInfluxdbInfluxdb10$outboundSchema),
  z.lazy(() => OutputInfluxdbInfluxdb2$outboundSchema),
  z.lazy(() => OutputInfluxdbInfluxdb6$outboundSchema),
  z.lazy(() => OutputInfluxdbInfluxdb1$outboundSchema),
  z.lazy(() => OutputInfluxdbInfluxdb4$outboundSchema),
  z.lazy(() => OutputInfluxdbInfluxdb7$outboundSchema),
  z.lazy(() => OutputInfluxdbInfluxdb8$outboundSchema),
  z.lazy(() => OutputInfluxdbInfluxdb9$outboundSchema),
  z.lazy(() => OutputInfluxdbInfluxdb3$outboundSchema),
  z.lazy(() => OutputInfluxdbInfluxdb5$outboundSchema),
]);

export function outputInfluxdbToJSON(outputInfluxdb: OutputInfluxdb): string {
  return JSON.stringify(OutputInfluxdb$outboundSchema.parse(outputInfluxdb));
}
export function outputInfluxdbFromJSON(
  jsonString: string,
): SafeParseResult<OutputInfluxdb, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputInfluxdb$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputInfluxdb' from JSON`,
  );
}
