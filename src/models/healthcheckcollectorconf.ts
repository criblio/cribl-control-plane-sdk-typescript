/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  HiddenDefaultBreakersOptionsDatabaseCollectorConf,
  HiddenDefaultBreakersOptionsDatabaseCollectorConf$inboundSchema,
  HiddenDefaultBreakersOptionsDatabaseCollectorConf$outboundSchema,
} from "./hiddendefaultbreakersoptionsdatabasecollectorconf.js";
import {
  ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders,
  ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders$inboundSchema,
  ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders$Outbound,
  ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders$outboundSchema,
} from "./itemstypehealthcheckauthenticationloginauthrequestheaders.js";
import {
  ItemsTypeHealthCheckAuthenticationOauthAuthRequestHeaders,
  ItemsTypeHealthCheckAuthenticationOauthAuthRequestHeaders$inboundSchema,
  ItemsTypeHealthCheckAuthenticationOauthAuthRequestHeaders$Outbound,
  ItemsTypeHealthCheckAuthenticationOauthAuthRequestHeaders$outboundSchema,
} from "./itemstypehealthcheckauthenticationoauthauthrequestheaders.js";
import {
  ItemsTypeHealthCheckAuthenticationOauthAuthRequestParams,
  ItemsTypeHealthCheckAuthenticationOauthAuthRequestParams$inboundSchema,
  ItemsTypeHealthCheckAuthenticationOauthAuthRequestParams$Outbound,
  ItemsTypeHealthCheckAuthenticationOauthAuthRequestParams$outboundSchema,
} from "./itemstypehealthcheckauthenticationoauthauthrequestparams.js";
import {
  RetryTypeOptionsHealthCheckCollectorConfRetryRules,
  RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
} from "./retrytypeoptionshealthcheckcollectorconfretryrules.js";

/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export const HealthCheckAuthenticationOauthSecretDiscoverType = {
  /**
   * HTTP Request
   */
  Http: "http",
  /**
   * JSON Response
   */
  Json: "json",
  /**
   * Item List
   */
  List: "list",
  /**
   * None
   */
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export type HealthCheckAuthenticationOauthSecretDiscoverType = OpenEnum<
  typeof HealthCheckAuthenticationOauthSecretDiscoverType
>;

export type HealthCheckAuthenticationOauthSecretDiscovery = {
  /**
   * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
   */
  discoverType: HealthCheckAuthenticationOauthSecretDiscoverType;
};

/**
 * Health check HTTP method.
 */
export const HealthCheckAuthenticationOauthSecretHealthCheckMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
} as const;
/**
 * Health check HTTP method.
 */
export type HealthCheckAuthenticationOauthSecretHealthCheckMethod = OpenEnum<
  typeof HealthCheckAuthenticationOauthSecretHealthCheckMethod
>;

export type HealthCheckAuthenticationOauthSecretCollectRequestHeader = {
  /**
   * Header Name
   */
  name: string;
  /**
   * JavaScript expression to compute the header value (can be a constant).
   */
  value: string;
};

export type HealthCheckAuthenticationOauthSecretRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

export type HealthCheckAuthenticationOauthSecret = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "oauthSecret";
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl: string;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  /**
   * Parameter name that contains client secret. Defaults to 'client_secret', and is automatically added to request parameters.
   */
  clientSecretParamName: string;
  /**
   * Select or create a text secret that contains the client secret's value.
   */
  textSecret: string;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?:
    | Array<ItemsTypeHealthCheckAuthenticationOauthAuthRequestParams>
    | undefined;
  /**
   * Optional authentication request headers.
   */
  authRequestHeaders?:
    | Array<ItemsTypeHealthCheckAuthenticationOauthAuthRequestHeaders>
    | undefined;
  discovery?: HealthCheckAuthenticationOauthSecretDiscovery | undefined;
  /**
   * Expression to derive URL to use for the health check operation (can be a constant).
   */
  collectUrl: string;
  /**
   * Health check HTTP method.
   */
  collectMethod: HealthCheckAuthenticationOauthSecretHealthCheckMethod;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  /**
   * Optional health check request headers.
   */
  collectRequestHeaders?:
    | Array<HealthCheckAuthenticationOauthSecretCollectRequestHeader>
    | undefined;
  /**
   * Enable to make auth health check call.
   */
  authenticateCollect?: boolean | undefined;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
   */
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?:
    | HiddenDefaultBreakersOptionsDatabaseCollectorConf
    | undefined;
  /**
   * List of headers that are safe to log in plain text.
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: HealthCheckAuthenticationOauthSecretRetryRules | undefined;
};

/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export const HealthCheckAuthenticationOauthDiscoverType = {
  /**
   * HTTP Request
   */
  Http: "http",
  /**
   * JSON Response
   */
  Json: "json",
  /**
   * Item List
   */
  List: "list",
  /**
   * None
   */
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export type HealthCheckAuthenticationOauthDiscoverType = OpenEnum<
  typeof HealthCheckAuthenticationOauthDiscoverType
>;

export type HealthCheckAuthenticationOauthDiscovery = {
  /**
   * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
   */
  discoverType: HealthCheckAuthenticationOauthDiscoverType;
};

/**
 * Health check HTTP method.
 */
export const HealthCheckAuthenticationOauthHealthCheckMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
} as const;
/**
 * Health check HTTP method.
 */
export type HealthCheckAuthenticationOauthHealthCheckMethod = OpenEnum<
  typeof HealthCheckAuthenticationOauthHealthCheckMethod
>;

export type HealthCheckAuthenticationOauthCollectRequestHeader = {
  /**
   * Header Name
   */
  name: string;
  /**
   * JavaScript expression to compute the header value (can be a constant).
   */
  value: string;
};

export type HealthCheckAuthenticationOauthRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

export type HealthCheckAuthenticationOauth = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "oauth";
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl: string;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  /**
   * Parameter name that contains client secret. Defaults to 'client_secret', and is automatically added to request parameters.
   */
  clientSecretParamName: string;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Stored on disk encrypted, and is automatically added to request parameters
   */
  clientSecretParamValue: string;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?:
    | Array<ItemsTypeHealthCheckAuthenticationOauthAuthRequestParams>
    | undefined;
  /**
   * Optional authentication request headers.
   */
  authRequestHeaders?:
    | Array<ItemsTypeHealthCheckAuthenticationOauthAuthRequestHeaders>
    | undefined;
  discovery?: HealthCheckAuthenticationOauthDiscovery | undefined;
  /**
   * Expression to derive URL to use for the health check operation (can be a constant).
   */
  collectUrl: string;
  /**
   * Health check HTTP method.
   */
  collectMethod: HealthCheckAuthenticationOauthHealthCheckMethod;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  /**
   * Optional health check request headers.
   */
  collectRequestHeaders?:
    | Array<HealthCheckAuthenticationOauthCollectRequestHeader>
    | undefined;
  /**
   * Enable to make auth health check call.
   */
  authenticateCollect?: boolean | undefined;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
   */
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?:
    | HiddenDefaultBreakersOptionsDatabaseCollectorConf
    | undefined;
  /**
   * List of headers that are safe to log in plain text.
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: HealthCheckAuthenticationOauthRetryRules | undefined;
};

/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export const HealthCheckAuthenticationLoginSecretDiscoverType = {
  /**
   * HTTP Request
   */
  Http: "http",
  /**
   * JSON Response
   */
  Json: "json",
  /**
   * Item List
   */
  List: "list",
  /**
   * None
   */
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export type HealthCheckAuthenticationLoginSecretDiscoverType = OpenEnum<
  typeof HealthCheckAuthenticationLoginSecretDiscoverType
>;

export type HealthCheckAuthenticationLoginSecretDiscovery = {
  /**
   * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
   */
  discoverType: HealthCheckAuthenticationLoginSecretDiscoverType;
};

/**
 * Health check HTTP method.
 */
export const HealthCheckAuthenticationLoginSecretHealthCheckMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
} as const;
/**
 * Health check HTTP method.
 */
export type HealthCheckAuthenticationLoginSecretHealthCheckMethod = OpenEnum<
  typeof HealthCheckAuthenticationLoginSecretHealthCheckMethod
>;

export type HealthCheckAuthenticationLoginSecretCollectRequestHeader = {
  /**
   * Header Name
   */
  name: string;
  /**
   * JavaScript expression to compute the header value (can be a constant).
   */
  value: string;
};

export type HealthCheckAuthenticationLoginSecretRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

export type HealthCheckAuthenticationLoginSecret = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "loginSecret";
  /**
   * URL to use for login API call, this call is expected to be a POST.
   */
  loginUrl: string;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret: string;
  /**
   * Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message
   */
  loginBody: string;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. If left blank, the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  /**
   * Optional authentication request headers.
   */
  authRequestHeaders?:
    | Array<ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders>
    | undefined;
  discovery?: HealthCheckAuthenticationLoginSecretDiscovery | undefined;
  /**
   * Expression to derive URL to use for the health check operation (can be a constant).
   */
  collectUrl: string;
  /**
   * Health check HTTP method.
   */
  collectMethod: HealthCheckAuthenticationLoginSecretHealthCheckMethod;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  /**
   * Optional health check request headers.
   */
  collectRequestHeaders?:
    | Array<HealthCheckAuthenticationLoginSecretCollectRequestHeader>
    | undefined;
  /**
   * Enable to make auth health check call.
   */
  authenticateCollect?: boolean | undefined;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
   */
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?:
    | HiddenDefaultBreakersOptionsDatabaseCollectorConf
    | undefined;
  /**
   * List of headers that are safe to log in plain text.
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: HealthCheckAuthenticationLoginSecretRetryRules | undefined;
};

/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export const HealthCheckAuthenticationLoginDiscoverType = {
  /**
   * HTTP Request
   */
  Http: "http",
  /**
   * JSON Response
   */
  Json: "json",
  /**
   * Item List
   */
  List: "list",
  /**
   * None
   */
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export type HealthCheckAuthenticationLoginDiscoverType = OpenEnum<
  typeof HealthCheckAuthenticationLoginDiscoverType
>;

export type HealthCheckAuthenticationLoginDiscovery = {
  /**
   * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
   */
  discoverType: HealthCheckAuthenticationLoginDiscoverType;
};

/**
 * Health check HTTP method.
 */
export const HealthCheckAuthenticationLoginHealthCheckMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
} as const;
/**
 * Health check HTTP method.
 */
export type HealthCheckAuthenticationLoginHealthCheckMethod = OpenEnum<
  typeof HealthCheckAuthenticationLoginHealthCheckMethod
>;

export type HealthCheckAuthenticationLoginCollectRequestHeader = {
  /**
   * Header Name
   */
  name: string;
  /**
   * JavaScript expression to compute the header value (can be a constant).
   */
  value: string;
};

export type HealthCheckAuthenticationLoginRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

export type HealthCheckAuthenticationLogin = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "login";
  /**
   * URL to use for login API call. This call is expected to be a POST.
   */
  loginUrl: string;
  /**
   * Login username
   */
  username: string;
  /**
   * Login password
   */
  password: string;
  /**
   * Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message
   */
  loginBody: string;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  /**
   * Optional authentication request headers.
   */
  authRequestHeaders?:
    | Array<ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders>
    | undefined;
  discovery?: HealthCheckAuthenticationLoginDiscovery | undefined;
  /**
   * Expression to derive URL to use for the health check operation (can be a constant).
   */
  collectUrl: string;
  /**
   * Health check HTTP method.
   */
  collectMethod: HealthCheckAuthenticationLoginHealthCheckMethod;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  /**
   * Optional health check request headers.
   */
  collectRequestHeaders?:
    | Array<HealthCheckAuthenticationLoginCollectRequestHeader>
    | undefined;
  /**
   * Enable to make auth health check call.
   */
  authenticateCollect?: boolean | undefined;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
   */
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?:
    | HiddenDefaultBreakersOptionsDatabaseCollectorConf
    | undefined;
  /**
   * List of headers that are safe to log in plain text.
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: HealthCheckAuthenticationLoginRetryRules | undefined;
};

/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export const HealthCheckAuthenticationBasicSecretDiscoverType = {
  /**
   * HTTP Request
   */
  Http: "http",
  /**
   * JSON Response
   */
  Json: "json",
  /**
   * Item List
   */
  List: "list",
  /**
   * None
   */
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export type HealthCheckAuthenticationBasicSecretDiscoverType = OpenEnum<
  typeof HealthCheckAuthenticationBasicSecretDiscoverType
>;

export type HealthCheckAuthenticationBasicSecretDiscovery = {
  /**
   * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
   */
  discoverType: HealthCheckAuthenticationBasicSecretDiscoverType;
};

/**
 * Health check HTTP method.
 */
export const HealthCheckAuthenticationBasicSecretHealthCheckMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
} as const;
/**
 * Health check HTTP method.
 */
export type HealthCheckAuthenticationBasicSecretHealthCheckMethod = OpenEnum<
  typeof HealthCheckAuthenticationBasicSecretHealthCheckMethod
>;

export type HealthCheckAuthenticationBasicSecretCollectRequestHeader = {
  /**
   * Header Name
   */
  name: string;
  /**
   * JavaScript expression to compute the header value (can be a constant).
   */
  value: string;
};

export type HealthCheckAuthenticationBasicSecretRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

export type HealthCheckAuthenticationBasicSecret = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "basicSecret";
  /**
   * Select or create a stored secret that references your credentials
   */
  credentialsSecret: string;
  discovery?: HealthCheckAuthenticationBasicSecretDiscovery | undefined;
  /**
   * Expression to derive URL to use for the health check operation (can be a constant).
   */
  collectUrl: string;
  /**
   * Health check HTTP method.
   */
  collectMethod: HealthCheckAuthenticationBasicSecretHealthCheckMethod;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  /**
   * Optional health check request headers.
   */
  collectRequestHeaders?:
    | Array<HealthCheckAuthenticationBasicSecretCollectRequestHeader>
    | undefined;
  /**
   * Enable to make auth health check call.
   */
  authenticateCollect?: boolean | undefined;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
   */
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?:
    | HiddenDefaultBreakersOptionsDatabaseCollectorConf
    | undefined;
  /**
   * List of headers that are safe to log in plain text.
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: HealthCheckAuthenticationBasicSecretRetryRules | undefined;
};

/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export const HealthCheckAuthenticationBasicDiscoverType = {
  /**
   * HTTP Request
   */
  Http: "http",
  /**
   * JSON Response
   */
  Json: "json",
  /**
   * Item List
   */
  List: "list",
  /**
   * None
   */
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export type HealthCheckAuthenticationBasicDiscoverType = OpenEnum<
  typeof HealthCheckAuthenticationBasicDiscoverType
>;

export type HealthCheckAuthenticationBasicDiscovery = {
  /**
   * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
   */
  discoverType: HealthCheckAuthenticationBasicDiscoverType;
};

/**
 * Health check HTTP method.
 */
export const HealthCheckAuthenticationBasicHealthCheckMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
} as const;
/**
 * Health check HTTP method.
 */
export type HealthCheckAuthenticationBasicHealthCheckMethod = OpenEnum<
  typeof HealthCheckAuthenticationBasicHealthCheckMethod
>;

export type HealthCheckAuthenticationBasicCollectRequestHeader = {
  /**
   * Header Name
   */
  name: string;
  /**
   * JavaScript expression to compute the header value (can be a constant).
   */
  value: string;
};

export type HealthCheckAuthenticationBasicRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

export type HealthCheckAuthenticationBasic = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "basic";
  /**
   * Basic authentication username
   */
  username: string;
  /**
   * Basic authentication password
   */
  password: string;
  discovery?: HealthCheckAuthenticationBasicDiscovery | undefined;
  /**
   * Expression to derive URL to use for the health check operation (can be a constant).
   */
  collectUrl: string;
  /**
   * Health check HTTP method.
   */
  collectMethod: HealthCheckAuthenticationBasicHealthCheckMethod;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  /**
   * Optional health check request headers.
   */
  collectRequestHeaders?:
    | Array<HealthCheckAuthenticationBasicCollectRequestHeader>
    | undefined;
  /**
   * Enable to make auth health check call.
   */
  authenticateCollect?: boolean | undefined;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
   */
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?:
    | HiddenDefaultBreakersOptionsDatabaseCollectorConf
    | undefined;
  /**
   * List of headers that are safe to log in plain text.
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: HealthCheckAuthenticationBasicRetryRules | undefined;
};

/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export const HealthCheckAuthenticationNoneDiscoverType = {
  /**
   * HTTP Request
   */
  Http: "http",
  /**
   * JSON Response
   */
  Json: "json",
  /**
   * Item List
   */
  List: "list",
  /**
   * None
   */
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export type HealthCheckAuthenticationNoneDiscoverType = OpenEnum<
  typeof HealthCheckAuthenticationNoneDiscoverType
>;

export type HealthCheckAuthenticationNoneDiscovery = {
  /**
   * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
   */
  discoverType: HealthCheckAuthenticationNoneDiscoverType;
};

/**
 * Health check HTTP method.
 */
export const HealthCheckAuthenticationNoneHealthCheckMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
} as const;
/**
 * Health check HTTP method.
 */
export type HealthCheckAuthenticationNoneHealthCheckMethod = OpenEnum<
  typeof HealthCheckAuthenticationNoneHealthCheckMethod
>;

export type HealthCheckAuthenticationNoneCollectRequestHeader = {
  /**
   * Header Name
   */
  name: string;
  /**
   * JavaScript expression to compute the header value (can be a constant).
   */
  value: string;
};

export type HealthCheckAuthenticationNoneRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

export type HealthCheckAuthenticationNone = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "none";
  discovery?: HealthCheckAuthenticationNoneDiscovery | undefined;
  /**
   * Expression to derive URL to use for the health check operation (can be a constant).
   */
  collectUrl: string;
  /**
   * Health check HTTP method.
   */
  collectMethod: HealthCheckAuthenticationNoneHealthCheckMethod;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  /**
   * Optional health check request headers.
   */
  collectRequestHeaders?:
    | Array<HealthCheckAuthenticationNoneCollectRequestHeader>
    | undefined;
  /**
   * Enable to make auth health check call.
   */
  authenticateCollect?: boolean | undefined;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
   */
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?:
    | HiddenDefaultBreakersOptionsDatabaseCollectorConf
    | undefined;
  /**
   * List of headers that are safe to log in plain text.
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: HealthCheckAuthenticationNoneRetryRules | undefined;
};

/**
 * Health check HTTP method.
 */
export const HealthCheckCollectMethodPostWithBodyHealthCheckMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
} as const;
/**
 * Health check HTTP method.
 */
export type HealthCheckCollectMethodPostWithBodyHealthCheckMethod = OpenEnum<
  typeof HealthCheckCollectMethodPostWithBodyHealthCheckMethod
>;

/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export const HealthCheckCollectMethodPostWithBodyDiscoverType = {
  /**
   * HTTP Request
   */
  Http: "http",
  /**
   * JSON Response
   */
  Json: "json",
  /**
   * Item List
   */
  List: "list",
  /**
   * None
   */
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export type HealthCheckCollectMethodPostWithBodyDiscoverType = OpenEnum<
  typeof HealthCheckCollectMethodPostWithBodyDiscoverType
>;

export type HealthCheckCollectMethodPostWithBodyDiscovery = {
  /**
   * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
   */
  discoverType: HealthCheckCollectMethodPostWithBodyDiscoverType;
};

export type HealthCheckCollectMethodPostWithBodyCollectRequestHeader = {
  /**
   * Header Name
   */
  name: string;
  /**
   * JavaScript expression to compute the header value (can be a constant).
   */
  value: string;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
 */
export const HealthCheckCollectMethodPostWithBodyAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
 */
export type HealthCheckCollectMethodPostWithBodyAuthentication = OpenEnum<
  typeof HealthCheckCollectMethodPostWithBodyAuthentication
>;

export type HealthCheckCollectMethodPostWithBodyRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

export type HealthCheckCollectMethodPostWithBody = {
  /**
   * Health check HTTP method.
   */
  collectMethod: HealthCheckCollectMethodPostWithBodyHealthCheckMethod;
  collectBody?: any | undefined;
  discovery?: HealthCheckCollectMethodPostWithBodyDiscovery | undefined;
  /**
   * Expression to derive URL to use for the health check operation (can be a constant).
   */
  collectUrl: string;
  collectRequestParams?: any | undefined;
  /**
   * Optional health check request headers.
   */
  collectRequestHeaders?:
    | Array<HealthCheckCollectMethodPostWithBodyCollectRequestHeader>
    | undefined;
  /**
   * Enable to make auth health check call.
   */
  authenticateCollect?: boolean | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
   */
  authentication: HealthCheckCollectMethodPostWithBodyAuthentication;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
   */
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?:
    | HiddenDefaultBreakersOptionsDatabaseCollectorConf
    | undefined;
  /**
   * List of headers that are safe to log in plain text.
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: HealthCheckCollectMethodPostWithBodyRetryRules | undefined;
};

/**
 * Health check HTTP method.
 */
export const HealthCheckCollectMethodPostHealthCheckMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
} as const;
/**
 * Health check HTTP method.
 */
export type HealthCheckCollectMethodPostHealthCheckMethod = OpenEnum<
  typeof HealthCheckCollectMethodPostHealthCheckMethod
>;

/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export const HealthCheckCollectMethodPostDiscoverType = {
  /**
   * HTTP Request
   */
  Http: "http",
  /**
   * JSON Response
   */
  Json: "json",
  /**
   * Item List
   */
  List: "list",
  /**
   * None
   */
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export type HealthCheckCollectMethodPostDiscoverType = OpenEnum<
  typeof HealthCheckCollectMethodPostDiscoverType
>;

export type HealthCheckCollectMethodPostDiscovery = {
  /**
   * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
   */
  discoverType: HealthCheckCollectMethodPostDiscoverType;
};

export type HealthCheckCollectMethodPostCollectRequestHeader = {
  /**
   * Header Name
   */
  name: string;
  /**
   * JavaScript expression to compute the header value (can be a constant).
   */
  value: string;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
 */
export const HealthCheckCollectMethodPostAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
 */
export type HealthCheckCollectMethodPostAuthentication = OpenEnum<
  typeof HealthCheckCollectMethodPostAuthentication
>;

export type HealthCheckCollectMethodPostRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

export type HealthCheckCollectMethodPost = {
  /**
   * Health check HTTP method.
   */
  collectMethod: HealthCheckCollectMethodPostHealthCheckMethod;
  collectRequestParams?: any | undefined;
  discovery?: HealthCheckCollectMethodPostDiscovery | undefined;
  /**
   * Expression to derive URL to use for the health check operation (can be a constant).
   */
  collectUrl: string;
  collectBody?: any | undefined;
  /**
   * Optional health check request headers.
   */
  collectRequestHeaders?:
    | Array<HealthCheckCollectMethodPostCollectRequestHeader>
    | undefined;
  /**
   * Enable to make auth health check call.
   */
  authenticateCollect?: boolean | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
   */
  authentication: HealthCheckCollectMethodPostAuthentication;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
   */
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?:
    | HiddenDefaultBreakersOptionsDatabaseCollectorConf
    | undefined;
  /**
   * List of headers that are safe to log in plain text.
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: HealthCheckCollectMethodPostRetryRules | undefined;
};

/**
 * Health check HTTP method.
 */
export const HealthCheckCollectMethodGetHealthCheckMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
} as const;
/**
 * Health check HTTP method.
 */
export type HealthCheckCollectMethodGetHealthCheckMethod = OpenEnum<
  typeof HealthCheckCollectMethodGetHealthCheckMethod
>;

/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export const HealthCheckCollectMethodGetDiscoverType = {
  /**
   * HTTP Request
   */
  Http: "http",
  /**
   * JSON Response
   */
  Json: "json",
  /**
   * Item List
   */
  List: "list",
  /**
   * None
   */
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export type HealthCheckCollectMethodGetDiscoverType = OpenEnum<
  typeof HealthCheckCollectMethodGetDiscoverType
>;

export type HealthCheckCollectMethodGetDiscovery = {
  /**
   * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
   */
  discoverType: HealthCheckCollectMethodGetDiscoverType;
};

export type HealthCheckCollectMethodGetCollectRequestHeader = {
  /**
   * Header Name
   */
  name: string;
  /**
   * JavaScript expression to compute the header value (can be a constant).
   */
  value: string;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
 */
export const HealthCheckCollectMethodGetAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
 */
export type HealthCheckCollectMethodGetAuthentication = OpenEnum<
  typeof HealthCheckCollectMethodGetAuthentication
>;

export type HealthCheckCollectMethodGetRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

export type HealthCheckCollectMethodGet = {
  /**
   * Health check HTTP method.
   */
  collectMethod: HealthCheckCollectMethodGetHealthCheckMethod;
  collectRequestParams?: any | undefined;
  discovery?: HealthCheckCollectMethodGetDiscovery | undefined;
  /**
   * Expression to derive URL to use for the health check operation (can be a constant).
   */
  collectUrl: string;
  collectBody?: any | undefined;
  /**
   * Optional health check request headers.
   */
  collectRequestHeaders?:
    | Array<HealthCheckCollectMethodGetCollectRequestHeader>
    | undefined;
  /**
   * Enable to make auth health check call.
   */
  authenticateCollect?: boolean | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
   */
  authentication: HealthCheckCollectMethodGetAuthentication;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
   */
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?:
    | HiddenDefaultBreakersOptionsDatabaseCollectorConf
    | undefined;
  /**
   * List of headers that are safe to log in plain text.
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: HealthCheckCollectMethodGetRetryRules | undefined;
};

export type HealthCheckCollectorConf =
  | HealthCheckAuthenticationNone
  | HealthCheckAuthenticationBasic
  | HealthCheckAuthenticationBasicSecret
  | HealthCheckAuthenticationLogin
  | HealthCheckAuthenticationLoginSecret
  | HealthCheckAuthenticationOauth
  | HealthCheckAuthenticationOauthSecret;

/** @internal */
export const HealthCheckAuthenticationOauthSecretDiscoverType$inboundSchema:
  z.ZodType<
    HealthCheckAuthenticationOauthSecretDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(HealthCheckAuthenticationOauthSecretDiscoverType);
/** @internal */
export const HealthCheckAuthenticationOauthSecretDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    HealthCheckAuthenticationOauthSecretDiscoverType
  > = openEnums.outboundSchema(
    HealthCheckAuthenticationOauthSecretDiscoverType,
  );

/** @internal */
export const HealthCheckAuthenticationOauthSecretDiscovery$inboundSchema:
  z.ZodType<
    HealthCheckAuthenticationOauthSecretDiscovery,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType:
      HealthCheckAuthenticationOauthSecretDiscoverType$inboundSchema,
  });
/** @internal */
export type HealthCheckAuthenticationOauthSecretDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const HealthCheckAuthenticationOauthSecretDiscovery$outboundSchema:
  z.ZodType<
    HealthCheckAuthenticationOauthSecretDiscovery$Outbound,
    z.ZodTypeDef,
    HealthCheckAuthenticationOauthSecretDiscovery
  > = z.object({
    discoverType:
      HealthCheckAuthenticationOauthSecretDiscoverType$outboundSchema,
  });

export function healthCheckAuthenticationOauthSecretDiscoveryToJSON(
  healthCheckAuthenticationOauthSecretDiscovery:
    HealthCheckAuthenticationOauthSecretDiscovery,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationOauthSecretDiscovery$outboundSchema.parse(
      healthCheckAuthenticationOauthSecretDiscovery,
    ),
  );
}
export function healthCheckAuthenticationOauthSecretDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckAuthenticationOauthSecretDiscovery,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationOauthSecretDiscovery$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'HealthCheckAuthenticationOauthSecretDiscovery' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationOauthSecretHealthCheckMethod$inboundSchema:
  z.ZodType<
    HealthCheckAuthenticationOauthSecretHealthCheckMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    HealthCheckAuthenticationOauthSecretHealthCheckMethod,
  );
/** @internal */
export const HealthCheckAuthenticationOauthSecretHealthCheckMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    HealthCheckAuthenticationOauthSecretHealthCheckMethod
  > = openEnums.outboundSchema(
    HealthCheckAuthenticationOauthSecretHealthCheckMethod,
  );

/** @internal */
export const HealthCheckAuthenticationOauthSecretCollectRequestHeader$inboundSchema:
  z.ZodType<
    HealthCheckAuthenticationOauthSecretCollectRequestHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
    value: z.string(),
  });
/** @internal */
export type HealthCheckAuthenticationOauthSecretCollectRequestHeader$Outbound =
  {
    name: string;
    value: string;
  };

/** @internal */
export const HealthCheckAuthenticationOauthSecretCollectRequestHeader$outboundSchema:
  z.ZodType<
    HealthCheckAuthenticationOauthSecretCollectRequestHeader$Outbound,
    z.ZodTypeDef,
    HealthCheckAuthenticationOauthSecretCollectRequestHeader
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function healthCheckAuthenticationOauthSecretCollectRequestHeaderToJSON(
  healthCheckAuthenticationOauthSecretCollectRequestHeader:
    HealthCheckAuthenticationOauthSecretCollectRequestHeader,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationOauthSecretCollectRequestHeader$outboundSchema
      .parse(healthCheckAuthenticationOauthSecretCollectRequestHeader),
  );
}
export function healthCheckAuthenticationOauthSecretCollectRequestHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckAuthenticationOauthSecretCollectRequestHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationOauthSecretCollectRequestHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'HealthCheckAuthenticationOauthSecretCollectRequestHeader' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationOauthSecretRetryRules$inboundSchema:
  z.ZodType<
    HealthCheckAuthenticationOauthSecretRetryRules,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
  });
/** @internal */
export type HealthCheckAuthenticationOauthSecretRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/** @internal */
export const HealthCheckAuthenticationOauthSecretRetryRules$outboundSchema:
  z.ZodType<
    HealthCheckAuthenticationOauthSecretRetryRules$Outbound,
    z.ZodTypeDef,
    HealthCheckAuthenticationOauthSecretRetryRules
  > = z.object({
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
  });

export function healthCheckAuthenticationOauthSecretRetryRulesToJSON(
  healthCheckAuthenticationOauthSecretRetryRules:
    HealthCheckAuthenticationOauthSecretRetryRules,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationOauthSecretRetryRules$outboundSchema.parse(
      healthCheckAuthenticationOauthSecretRetryRules,
    ),
  );
}
export function healthCheckAuthenticationOauthSecretRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckAuthenticationOauthSecretRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationOauthSecretRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'HealthCheckAuthenticationOauthSecretRetryRules' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationOauthSecret$inboundSchema: z.ZodType<
  HealthCheckAuthenticationOauthSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("oauthSecret"),
  loginUrl: z.string(),
  tokenRespAttribute: z.string().optional(),
  authHeaderExpr: z.string(),
  clientSecretParamName: z.string(),
  textSecret: z.string(),
  authRequestParams: z.array(
    ItemsTypeHealthCheckAuthenticationOauthAuthRequestParams$inboundSchema,
  ).optional(),
  authRequestHeaders: z.array(
    ItemsTypeHealthCheckAuthenticationOauthAuthRequestHeaders$inboundSchema,
  ).optional(),
  discovery: z.lazy(() =>
    HealthCheckAuthenticationOauthSecretDiscovery$inboundSchema
  ).optional(),
  collectUrl: z.string(),
  collectMethod:
    HealthCheckAuthenticationOauthSecretHealthCheckMethod$inboundSchema,
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() =>
      HealthCheckAuthenticationOauthSecretCollectRequestHeader$inboundSchema
    ),
  ).optional(),
  authenticateCollect: z.boolean().optional(),
  timeout: z.number().optional(),
  rejectUnauthorized: z.boolean().optional(),
  defaultBreakers:
    HiddenDefaultBreakersOptionsDatabaseCollectorConf$inboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    HealthCheckAuthenticationOauthSecretRetryRules$inboundSchema
  ).optional(),
});
/** @internal */
export type HealthCheckAuthenticationOauthSecret$Outbound = {
  authentication: "oauthSecret";
  loginUrl: string;
  tokenRespAttribute?: string | undefined;
  authHeaderExpr: string;
  clientSecretParamName: string;
  textSecret: string;
  authRequestParams?:
    | Array<ItemsTypeHealthCheckAuthenticationOauthAuthRequestParams$Outbound>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeHealthCheckAuthenticationOauthAuthRequestHeaders$Outbound>
    | undefined;
  discovery?:
    | HealthCheckAuthenticationOauthSecretDiscovery$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<HealthCheckAuthenticationOauthSecretCollectRequestHeader$Outbound>
    | undefined;
  authenticateCollect?: boolean | undefined;
  timeout?: number | undefined;
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | HealthCheckAuthenticationOauthSecretRetryRules$Outbound
    | undefined;
};

/** @internal */
export const HealthCheckAuthenticationOauthSecret$outboundSchema: z.ZodType<
  HealthCheckAuthenticationOauthSecret$Outbound,
  z.ZodTypeDef,
  HealthCheckAuthenticationOauthSecret
> = z.object({
  authentication: z.literal("oauthSecret"),
  loginUrl: z.string(),
  tokenRespAttribute: z.string().optional(),
  authHeaderExpr: z.string(),
  clientSecretParamName: z.string(),
  textSecret: z.string(),
  authRequestParams: z.array(
    ItemsTypeHealthCheckAuthenticationOauthAuthRequestParams$outboundSchema,
  ).optional(),
  authRequestHeaders: z.array(
    ItemsTypeHealthCheckAuthenticationOauthAuthRequestHeaders$outboundSchema,
  ).optional(),
  discovery: z.lazy(() =>
    HealthCheckAuthenticationOauthSecretDiscovery$outboundSchema
  ).optional(),
  collectUrl: z.string(),
  collectMethod:
    HealthCheckAuthenticationOauthSecretHealthCheckMethod$outboundSchema,
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() =>
      HealthCheckAuthenticationOauthSecretCollectRequestHeader$outboundSchema
    ),
  ).optional(),
  authenticateCollect: z.boolean().optional(),
  timeout: z.number().optional(),
  rejectUnauthorized: z.boolean().optional(),
  defaultBreakers:
    HiddenDefaultBreakersOptionsDatabaseCollectorConf$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    HealthCheckAuthenticationOauthSecretRetryRules$outboundSchema
  ).optional(),
});

export function healthCheckAuthenticationOauthSecretToJSON(
  healthCheckAuthenticationOauthSecret: HealthCheckAuthenticationOauthSecret,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationOauthSecret$outboundSchema.parse(
      healthCheckAuthenticationOauthSecret,
    ),
  );
}
export function healthCheckAuthenticationOauthSecretFromJSON(
  jsonString: string,
): SafeParseResult<HealthCheckAuthenticationOauthSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationOauthSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HealthCheckAuthenticationOauthSecret' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationOauthDiscoverType$inboundSchema:
  z.ZodType<HealthCheckAuthenticationOauthDiscoverType, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(HealthCheckAuthenticationOauthDiscoverType);
/** @internal */
export const HealthCheckAuthenticationOauthDiscoverType$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, HealthCheckAuthenticationOauthDiscoverType> =
    openEnums.outboundSchema(HealthCheckAuthenticationOauthDiscoverType);

/** @internal */
export const HealthCheckAuthenticationOauthDiscovery$inboundSchema: z.ZodType<
  HealthCheckAuthenticationOauthDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: HealthCheckAuthenticationOauthDiscoverType$inboundSchema,
});
/** @internal */
export type HealthCheckAuthenticationOauthDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const HealthCheckAuthenticationOauthDiscovery$outboundSchema: z.ZodType<
  HealthCheckAuthenticationOauthDiscovery$Outbound,
  z.ZodTypeDef,
  HealthCheckAuthenticationOauthDiscovery
> = z.object({
  discoverType: HealthCheckAuthenticationOauthDiscoverType$outboundSchema,
});

export function healthCheckAuthenticationOauthDiscoveryToJSON(
  healthCheckAuthenticationOauthDiscovery:
    HealthCheckAuthenticationOauthDiscovery,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationOauthDiscovery$outboundSchema.parse(
      healthCheckAuthenticationOauthDiscovery,
    ),
  );
}
export function healthCheckAuthenticationOauthDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckAuthenticationOauthDiscovery,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationOauthDiscovery$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'HealthCheckAuthenticationOauthDiscovery' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationOauthHealthCheckMethod$inboundSchema:
  z.ZodType<
    HealthCheckAuthenticationOauthHealthCheckMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(HealthCheckAuthenticationOauthHealthCheckMethod);
/** @internal */
export const HealthCheckAuthenticationOauthHealthCheckMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    HealthCheckAuthenticationOauthHealthCheckMethod
  > = openEnums.outboundSchema(HealthCheckAuthenticationOauthHealthCheckMethod);

/** @internal */
export const HealthCheckAuthenticationOauthCollectRequestHeader$inboundSchema:
  z.ZodType<
    HealthCheckAuthenticationOauthCollectRequestHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
    value: z.string(),
  });
/** @internal */
export type HealthCheckAuthenticationOauthCollectRequestHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const HealthCheckAuthenticationOauthCollectRequestHeader$outboundSchema:
  z.ZodType<
    HealthCheckAuthenticationOauthCollectRequestHeader$Outbound,
    z.ZodTypeDef,
    HealthCheckAuthenticationOauthCollectRequestHeader
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function healthCheckAuthenticationOauthCollectRequestHeaderToJSON(
  healthCheckAuthenticationOauthCollectRequestHeader:
    HealthCheckAuthenticationOauthCollectRequestHeader,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationOauthCollectRequestHeader$outboundSchema.parse(
      healthCheckAuthenticationOauthCollectRequestHeader,
    ),
  );
}
export function healthCheckAuthenticationOauthCollectRequestHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckAuthenticationOauthCollectRequestHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationOauthCollectRequestHeader$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'HealthCheckAuthenticationOauthCollectRequestHeader' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationOauthRetryRules$inboundSchema: z.ZodType<
  HealthCheckAuthenticationOauthRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});
/** @internal */
export type HealthCheckAuthenticationOauthRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/** @internal */
export const HealthCheckAuthenticationOauthRetryRules$outboundSchema: z.ZodType<
  HealthCheckAuthenticationOauthRetryRules$Outbound,
  z.ZodTypeDef,
  HealthCheckAuthenticationOauthRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});

export function healthCheckAuthenticationOauthRetryRulesToJSON(
  healthCheckAuthenticationOauthRetryRules:
    HealthCheckAuthenticationOauthRetryRules,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationOauthRetryRules$outboundSchema.parse(
      healthCheckAuthenticationOauthRetryRules,
    ),
  );
}
export function healthCheckAuthenticationOauthRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckAuthenticationOauthRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationOauthRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'HealthCheckAuthenticationOauthRetryRules' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationOauth$inboundSchema: z.ZodType<
  HealthCheckAuthenticationOauth,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("oauth"),
  loginUrl: z.string(),
  tokenRespAttribute: z.string().optional(),
  authHeaderExpr: z.string(),
  clientSecretParamName: z.string(),
  clientSecretParamValue: z.string(),
  authRequestParams: z.array(
    ItemsTypeHealthCheckAuthenticationOauthAuthRequestParams$inboundSchema,
  ).optional(),
  authRequestHeaders: z.array(
    ItemsTypeHealthCheckAuthenticationOauthAuthRequestHeaders$inboundSchema,
  ).optional(),
  discovery: z.lazy(() => HealthCheckAuthenticationOauthDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: HealthCheckAuthenticationOauthHealthCheckMethod$inboundSchema,
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() =>
      HealthCheckAuthenticationOauthCollectRequestHeader$inboundSchema
    ),
  ).optional(),
  authenticateCollect: z.boolean().optional(),
  timeout: z.number().optional(),
  rejectUnauthorized: z.boolean().optional(),
  defaultBreakers:
    HiddenDefaultBreakersOptionsDatabaseCollectorConf$inboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    HealthCheckAuthenticationOauthRetryRules$inboundSchema
  ).optional(),
});
/** @internal */
export type HealthCheckAuthenticationOauth$Outbound = {
  authentication: "oauth";
  loginUrl: string;
  tokenRespAttribute?: string | undefined;
  authHeaderExpr: string;
  clientSecretParamName: string;
  clientSecretParamValue: string;
  authRequestParams?:
    | Array<ItemsTypeHealthCheckAuthenticationOauthAuthRequestParams$Outbound>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeHealthCheckAuthenticationOauthAuthRequestHeaders$Outbound>
    | undefined;
  discovery?: HealthCheckAuthenticationOauthDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<HealthCheckAuthenticationOauthCollectRequestHeader$Outbound>
    | undefined;
  authenticateCollect?: boolean | undefined;
  timeout?: number | undefined;
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: HealthCheckAuthenticationOauthRetryRules$Outbound | undefined;
};

/** @internal */
export const HealthCheckAuthenticationOauth$outboundSchema: z.ZodType<
  HealthCheckAuthenticationOauth$Outbound,
  z.ZodTypeDef,
  HealthCheckAuthenticationOauth
> = z.object({
  authentication: z.literal("oauth"),
  loginUrl: z.string(),
  tokenRespAttribute: z.string().optional(),
  authHeaderExpr: z.string(),
  clientSecretParamName: z.string(),
  clientSecretParamValue: z.string(),
  authRequestParams: z.array(
    ItemsTypeHealthCheckAuthenticationOauthAuthRequestParams$outboundSchema,
  ).optional(),
  authRequestHeaders: z.array(
    ItemsTypeHealthCheckAuthenticationOauthAuthRequestHeaders$outboundSchema,
  ).optional(),
  discovery: z.lazy(() =>
    HealthCheckAuthenticationOauthDiscovery$outboundSchema
  ).optional(),
  collectUrl: z.string(),
  collectMethod: HealthCheckAuthenticationOauthHealthCheckMethod$outboundSchema,
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() =>
      HealthCheckAuthenticationOauthCollectRequestHeader$outboundSchema
    ),
  ).optional(),
  authenticateCollect: z.boolean().optional(),
  timeout: z.number().optional(),
  rejectUnauthorized: z.boolean().optional(),
  defaultBreakers:
    HiddenDefaultBreakersOptionsDatabaseCollectorConf$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    HealthCheckAuthenticationOauthRetryRules$outboundSchema
  ).optional(),
});

export function healthCheckAuthenticationOauthToJSON(
  healthCheckAuthenticationOauth: HealthCheckAuthenticationOauth,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationOauth$outboundSchema.parse(
      healthCheckAuthenticationOauth,
    ),
  );
}
export function healthCheckAuthenticationOauthFromJSON(
  jsonString: string,
): SafeParseResult<HealthCheckAuthenticationOauth, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HealthCheckAuthenticationOauth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HealthCheckAuthenticationOauth' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationLoginSecretDiscoverType$inboundSchema:
  z.ZodType<
    HealthCheckAuthenticationLoginSecretDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(HealthCheckAuthenticationLoginSecretDiscoverType);
/** @internal */
export const HealthCheckAuthenticationLoginSecretDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    HealthCheckAuthenticationLoginSecretDiscoverType
  > = openEnums.outboundSchema(
    HealthCheckAuthenticationLoginSecretDiscoverType,
  );

/** @internal */
export const HealthCheckAuthenticationLoginSecretDiscovery$inboundSchema:
  z.ZodType<
    HealthCheckAuthenticationLoginSecretDiscovery,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType:
      HealthCheckAuthenticationLoginSecretDiscoverType$inboundSchema,
  });
/** @internal */
export type HealthCheckAuthenticationLoginSecretDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const HealthCheckAuthenticationLoginSecretDiscovery$outboundSchema:
  z.ZodType<
    HealthCheckAuthenticationLoginSecretDiscovery$Outbound,
    z.ZodTypeDef,
    HealthCheckAuthenticationLoginSecretDiscovery
  > = z.object({
    discoverType:
      HealthCheckAuthenticationLoginSecretDiscoverType$outboundSchema,
  });

export function healthCheckAuthenticationLoginSecretDiscoveryToJSON(
  healthCheckAuthenticationLoginSecretDiscovery:
    HealthCheckAuthenticationLoginSecretDiscovery,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationLoginSecretDiscovery$outboundSchema.parse(
      healthCheckAuthenticationLoginSecretDiscovery,
    ),
  );
}
export function healthCheckAuthenticationLoginSecretDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckAuthenticationLoginSecretDiscovery,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationLoginSecretDiscovery$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'HealthCheckAuthenticationLoginSecretDiscovery' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationLoginSecretHealthCheckMethod$inboundSchema:
  z.ZodType<
    HealthCheckAuthenticationLoginSecretHealthCheckMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    HealthCheckAuthenticationLoginSecretHealthCheckMethod,
  );
/** @internal */
export const HealthCheckAuthenticationLoginSecretHealthCheckMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    HealthCheckAuthenticationLoginSecretHealthCheckMethod
  > = openEnums.outboundSchema(
    HealthCheckAuthenticationLoginSecretHealthCheckMethod,
  );

/** @internal */
export const HealthCheckAuthenticationLoginSecretCollectRequestHeader$inboundSchema:
  z.ZodType<
    HealthCheckAuthenticationLoginSecretCollectRequestHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
    value: z.string(),
  });
/** @internal */
export type HealthCheckAuthenticationLoginSecretCollectRequestHeader$Outbound =
  {
    name: string;
    value: string;
  };

/** @internal */
export const HealthCheckAuthenticationLoginSecretCollectRequestHeader$outboundSchema:
  z.ZodType<
    HealthCheckAuthenticationLoginSecretCollectRequestHeader$Outbound,
    z.ZodTypeDef,
    HealthCheckAuthenticationLoginSecretCollectRequestHeader
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function healthCheckAuthenticationLoginSecretCollectRequestHeaderToJSON(
  healthCheckAuthenticationLoginSecretCollectRequestHeader:
    HealthCheckAuthenticationLoginSecretCollectRequestHeader,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationLoginSecretCollectRequestHeader$outboundSchema
      .parse(healthCheckAuthenticationLoginSecretCollectRequestHeader),
  );
}
export function healthCheckAuthenticationLoginSecretCollectRequestHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckAuthenticationLoginSecretCollectRequestHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationLoginSecretCollectRequestHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'HealthCheckAuthenticationLoginSecretCollectRequestHeader' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationLoginSecretRetryRules$inboundSchema:
  z.ZodType<
    HealthCheckAuthenticationLoginSecretRetryRules,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
  });
/** @internal */
export type HealthCheckAuthenticationLoginSecretRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/** @internal */
export const HealthCheckAuthenticationLoginSecretRetryRules$outboundSchema:
  z.ZodType<
    HealthCheckAuthenticationLoginSecretRetryRules$Outbound,
    z.ZodTypeDef,
    HealthCheckAuthenticationLoginSecretRetryRules
  > = z.object({
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
  });

export function healthCheckAuthenticationLoginSecretRetryRulesToJSON(
  healthCheckAuthenticationLoginSecretRetryRules:
    HealthCheckAuthenticationLoginSecretRetryRules,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationLoginSecretRetryRules$outboundSchema.parse(
      healthCheckAuthenticationLoginSecretRetryRules,
    ),
  );
}
export function healthCheckAuthenticationLoginSecretRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckAuthenticationLoginSecretRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationLoginSecretRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'HealthCheckAuthenticationLoginSecretRetryRules' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationLoginSecret$inboundSchema: z.ZodType<
  HealthCheckAuthenticationLoginSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("loginSecret"),
  loginUrl: z.string(),
  credentialsSecret: z.string(),
  loginBody: z.string(),
  tokenRespAttribute: z.string().optional(),
  authHeaderExpr: z.string(),
  authRequestHeaders: z.array(
    ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders$inboundSchema,
  ).optional(),
  discovery: z.lazy(() =>
    HealthCheckAuthenticationLoginSecretDiscovery$inboundSchema
  ).optional(),
  collectUrl: z.string(),
  collectMethod:
    HealthCheckAuthenticationLoginSecretHealthCheckMethod$inboundSchema,
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() =>
      HealthCheckAuthenticationLoginSecretCollectRequestHeader$inboundSchema
    ),
  ).optional(),
  authenticateCollect: z.boolean().optional(),
  timeout: z.number().optional(),
  rejectUnauthorized: z.boolean().optional(),
  defaultBreakers:
    HiddenDefaultBreakersOptionsDatabaseCollectorConf$inboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    HealthCheckAuthenticationLoginSecretRetryRules$inboundSchema
  ).optional(),
});
/** @internal */
export type HealthCheckAuthenticationLoginSecret$Outbound = {
  authentication: "loginSecret";
  loginUrl: string;
  credentialsSecret: string;
  loginBody: string;
  tokenRespAttribute?: string | undefined;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders$Outbound>
    | undefined;
  discovery?:
    | HealthCheckAuthenticationLoginSecretDiscovery$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<HealthCheckAuthenticationLoginSecretCollectRequestHeader$Outbound>
    | undefined;
  authenticateCollect?: boolean | undefined;
  timeout?: number | undefined;
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | HealthCheckAuthenticationLoginSecretRetryRules$Outbound
    | undefined;
};

/** @internal */
export const HealthCheckAuthenticationLoginSecret$outboundSchema: z.ZodType<
  HealthCheckAuthenticationLoginSecret$Outbound,
  z.ZodTypeDef,
  HealthCheckAuthenticationLoginSecret
> = z.object({
  authentication: z.literal("loginSecret"),
  loginUrl: z.string(),
  credentialsSecret: z.string(),
  loginBody: z.string(),
  tokenRespAttribute: z.string().optional(),
  authHeaderExpr: z.string(),
  authRequestHeaders: z.array(
    ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders$outboundSchema,
  ).optional(),
  discovery: z.lazy(() =>
    HealthCheckAuthenticationLoginSecretDiscovery$outboundSchema
  ).optional(),
  collectUrl: z.string(),
  collectMethod:
    HealthCheckAuthenticationLoginSecretHealthCheckMethod$outboundSchema,
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() =>
      HealthCheckAuthenticationLoginSecretCollectRequestHeader$outboundSchema
    ),
  ).optional(),
  authenticateCollect: z.boolean().optional(),
  timeout: z.number().optional(),
  rejectUnauthorized: z.boolean().optional(),
  defaultBreakers:
    HiddenDefaultBreakersOptionsDatabaseCollectorConf$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    HealthCheckAuthenticationLoginSecretRetryRules$outboundSchema
  ).optional(),
});

export function healthCheckAuthenticationLoginSecretToJSON(
  healthCheckAuthenticationLoginSecret: HealthCheckAuthenticationLoginSecret,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationLoginSecret$outboundSchema.parse(
      healthCheckAuthenticationLoginSecret,
    ),
  );
}
export function healthCheckAuthenticationLoginSecretFromJSON(
  jsonString: string,
): SafeParseResult<HealthCheckAuthenticationLoginSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationLoginSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HealthCheckAuthenticationLoginSecret' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationLoginDiscoverType$inboundSchema:
  z.ZodType<HealthCheckAuthenticationLoginDiscoverType, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(HealthCheckAuthenticationLoginDiscoverType);
/** @internal */
export const HealthCheckAuthenticationLoginDiscoverType$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, HealthCheckAuthenticationLoginDiscoverType> =
    openEnums.outboundSchema(HealthCheckAuthenticationLoginDiscoverType);

/** @internal */
export const HealthCheckAuthenticationLoginDiscovery$inboundSchema: z.ZodType<
  HealthCheckAuthenticationLoginDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: HealthCheckAuthenticationLoginDiscoverType$inboundSchema,
});
/** @internal */
export type HealthCheckAuthenticationLoginDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const HealthCheckAuthenticationLoginDiscovery$outboundSchema: z.ZodType<
  HealthCheckAuthenticationLoginDiscovery$Outbound,
  z.ZodTypeDef,
  HealthCheckAuthenticationLoginDiscovery
> = z.object({
  discoverType: HealthCheckAuthenticationLoginDiscoverType$outboundSchema,
});

export function healthCheckAuthenticationLoginDiscoveryToJSON(
  healthCheckAuthenticationLoginDiscovery:
    HealthCheckAuthenticationLoginDiscovery,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationLoginDiscovery$outboundSchema.parse(
      healthCheckAuthenticationLoginDiscovery,
    ),
  );
}
export function healthCheckAuthenticationLoginDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckAuthenticationLoginDiscovery,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationLoginDiscovery$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'HealthCheckAuthenticationLoginDiscovery' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationLoginHealthCheckMethod$inboundSchema:
  z.ZodType<
    HealthCheckAuthenticationLoginHealthCheckMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(HealthCheckAuthenticationLoginHealthCheckMethod);
/** @internal */
export const HealthCheckAuthenticationLoginHealthCheckMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    HealthCheckAuthenticationLoginHealthCheckMethod
  > = openEnums.outboundSchema(HealthCheckAuthenticationLoginHealthCheckMethod);

/** @internal */
export const HealthCheckAuthenticationLoginCollectRequestHeader$inboundSchema:
  z.ZodType<
    HealthCheckAuthenticationLoginCollectRequestHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
    value: z.string(),
  });
/** @internal */
export type HealthCheckAuthenticationLoginCollectRequestHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const HealthCheckAuthenticationLoginCollectRequestHeader$outboundSchema:
  z.ZodType<
    HealthCheckAuthenticationLoginCollectRequestHeader$Outbound,
    z.ZodTypeDef,
    HealthCheckAuthenticationLoginCollectRequestHeader
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function healthCheckAuthenticationLoginCollectRequestHeaderToJSON(
  healthCheckAuthenticationLoginCollectRequestHeader:
    HealthCheckAuthenticationLoginCollectRequestHeader,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationLoginCollectRequestHeader$outboundSchema.parse(
      healthCheckAuthenticationLoginCollectRequestHeader,
    ),
  );
}
export function healthCheckAuthenticationLoginCollectRequestHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckAuthenticationLoginCollectRequestHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationLoginCollectRequestHeader$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'HealthCheckAuthenticationLoginCollectRequestHeader' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationLoginRetryRules$inboundSchema: z.ZodType<
  HealthCheckAuthenticationLoginRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});
/** @internal */
export type HealthCheckAuthenticationLoginRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/** @internal */
export const HealthCheckAuthenticationLoginRetryRules$outboundSchema: z.ZodType<
  HealthCheckAuthenticationLoginRetryRules$Outbound,
  z.ZodTypeDef,
  HealthCheckAuthenticationLoginRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});

export function healthCheckAuthenticationLoginRetryRulesToJSON(
  healthCheckAuthenticationLoginRetryRules:
    HealthCheckAuthenticationLoginRetryRules,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationLoginRetryRules$outboundSchema.parse(
      healthCheckAuthenticationLoginRetryRules,
    ),
  );
}
export function healthCheckAuthenticationLoginRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckAuthenticationLoginRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationLoginRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'HealthCheckAuthenticationLoginRetryRules' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationLogin$inboundSchema: z.ZodType<
  HealthCheckAuthenticationLogin,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("login"),
  loginUrl: z.string(),
  username: z.string(),
  password: z.string(),
  loginBody: z.string(),
  tokenRespAttribute: z.string().optional(),
  authHeaderExpr: z.string(),
  authRequestHeaders: z.array(
    ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders$inboundSchema,
  ).optional(),
  discovery: z.lazy(() => HealthCheckAuthenticationLoginDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: HealthCheckAuthenticationLoginHealthCheckMethod$inboundSchema,
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() =>
      HealthCheckAuthenticationLoginCollectRequestHeader$inboundSchema
    ),
  ).optional(),
  authenticateCollect: z.boolean().optional(),
  timeout: z.number().optional(),
  rejectUnauthorized: z.boolean().optional(),
  defaultBreakers:
    HiddenDefaultBreakersOptionsDatabaseCollectorConf$inboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    HealthCheckAuthenticationLoginRetryRules$inboundSchema
  ).optional(),
});
/** @internal */
export type HealthCheckAuthenticationLogin$Outbound = {
  authentication: "login";
  loginUrl: string;
  username: string;
  password: string;
  loginBody: string;
  tokenRespAttribute?: string | undefined;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders$Outbound>
    | undefined;
  discovery?: HealthCheckAuthenticationLoginDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<HealthCheckAuthenticationLoginCollectRequestHeader$Outbound>
    | undefined;
  authenticateCollect?: boolean | undefined;
  timeout?: number | undefined;
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: HealthCheckAuthenticationLoginRetryRules$Outbound | undefined;
};

/** @internal */
export const HealthCheckAuthenticationLogin$outboundSchema: z.ZodType<
  HealthCheckAuthenticationLogin$Outbound,
  z.ZodTypeDef,
  HealthCheckAuthenticationLogin
> = z.object({
  authentication: z.literal("login"),
  loginUrl: z.string(),
  username: z.string(),
  password: z.string(),
  loginBody: z.string(),
  tokenRespAttribute: z.string().optional(),
  authHeaderExpr: z.string(),
  authRequestHeaders: z.array(
    ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders$outboundSchema,
  ).optional(),
  discovery: z.lazy(() =>
    HealthCheckAuthenticationLoginDiscovery$outboundSchema
  ).optional(),
  collectUrl: z.string(),
  collectMethod: HealthCheckAuthenticationLoginHealthCheckMethod$outboundSchema,
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() =>
      HealthCheckAuthenticationLoginCollectRequestHeader$outboundSchema
    ),
  ).optional(),
  authenticateCollect: z.boolean().optional(),
  timeout: z.number().optional(),
  rejectUnauthorized: z.boolean().optional(),
  defaultBreakers:
    HiddenDefaultBreakersOptionsDatabaseCollectorConf$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    HealthCheckAuthenticationLoginRetryRules$outboundSchema
  ).optional(),
});

export function healthCheckAuthenticationLoginToJSON(
  healthCheckAuthenticationLogin: HealthCheckAuthenticationLogin,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationLogin$outboundSchema.parse(
      healthCheckAuthenticationLogin,
    ),
  );
}
export function healthCheckAuthenticationLoginFromJSON(
  jsonString: string,
): SafeParseResult<HealthCheckAuthenticationLogin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HealthCheckAuthenticationLogin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HealthCheckAuthenticationLogin' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationBasicSecretDiscoverType$inboundSchema:
  z.ZodType<
    HealthCheckAuthenticationBasicSecretDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(HealthCheckAuthenticationBasicSecretDiscoverType);
/** @internal */
export const HealthCheckAuthenticationBasicSecretDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    HealthCheckAuthenticationBasicSecretDiscoverType
  > = openEnums.outboundSchema(
    HealthCheckAuthenticationBasicSecretDiscoverType,
  );

/** @internal */
export const HealthCheckAuthenticationBasicSecretDiscovery$inboundSchema:
  z.ZodType<
    HealthCheckAuthenticationBasicSecretDiscovery,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType:
      HealthCheckAuthenticationBasicSecretDiscoverType$inboundSchema,
  });
/** @internal */
export type HealthCheckAuthenticationBasicSecretDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const HealthCheckAuthenticationBasicSecretDiscovery$outboundSchema:
  z.ZodType<
    HealthCheckAuthenticationBasicSecretDiscovery$Outbound,
    z.ZodTypeDef,
    HealthCheckAuthenticationBasicSecretDiscovery
  > = z.object({
    discoverType:
      HealthCheckAuthenticationBasicSecretDiscoverType$outboundSchema,
  });

export function healthCheckAuthenticationBasicSecretDiscoveryToJSON(
  healthCheckAuthenticationBasicSecretDiscovery:
    HealthCheckAuthenticationBasicSecretDiscovery,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationBasicSecretDiscovery$outboundSchema.parse(
      healthCheckAuthenticationBasicSecretDiscovery,
    ),
  );
}
export function healthCheckAuthenticationBasicSecretDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckAuthenticationBasicSecretDiscovery,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationBasicSecretDiscovery$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'HealthCheckAuthenticationBasicSecretDiscovery' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationBasicSecretHealthCheckMethod$inboundSchema:
  z.ZodType<
    HealthCheckAuthenticationBasicSecretHealthCheckMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    HealthCheckAuthenticationBasicSecretHealthCheckMethod,
  );
/** @internal */
export const HealthCheckAuthenticationBasicSecretHealthCheckMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    HealthCheckAuthenticationBasicSecretHealthCheckMethod
  > = openEnums.outboundSchema(
    HealthCheckAuthenticationBasicSecretHealthCheckMethod,
  );

/** @internal */
export const HealthCheckAuthenticationBasicSecretCollectRequestHeader$inboundSchema:
  z.ZodType<
    HealthCheckAuthenticationBasicSecretCollectRequestHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
    value: z.string(),
  });
/** @internal */
export type HealthCheckAuthenticationBasicSecretCollectRequestHeader$Outbound =
  {
    name: string;
    value: string;
  };

/** @internal */
export const HealthCheckAuthenticationBasicSecretCollectRequestHeader$outboundSchema:
  z.ZodType<
    HealthCheckAuthenticationBasicSecretCollectRequestHeader$Outbound,
    z.ZodTypeDef,
    HealthCheckAuthenticationBasicSecretCollectRequestHeader
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function healthCheckAuthenticationBasicSecretCollectRequestHeaderToJSON(
  healthCheckAuthenticationBasicSecretCollectRequestHeader:
    HealthCheckAuthenticationBasicSecretCollectRequestHeader,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationBasicSecretCollectRequestHeader$outboundSchema
      .parse(healthCheckAuthenticationBasicSecretCollectRequestHeader),
  );
}
export function healthCheckAuthenticationBasicSecretCollectRequestHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckAuthenticationBasicSecretCollectRequestHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationBasicSecretCollectRequestHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'HealthCheckAuthenticationBasicSecretCollectRequestHeader' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationBasicSecretRetryRules$inboundSchema:
  z.ZodType<
    HealthCheckAuthenticationBasicSecretRetryRules,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
  });
/** @internal */
export type HealthCheckAuthenticationBasicSecretRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/** @internal */
export const HealthCheckAuthenticationBasicSecretRetryRules$outboundSchema:
  z.ZodType<
    HealthCheckAuthenticationBasicSecretRetryRules$Outbound,
    z.ZodTypeDef,
    HealthCheckAuthenticationBasicSecretRetryRules
  > = z.object({
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
  });

export function healthCheckAuthenticationBasicSecretRetryRulesToJSON(
  healthCheckAuthenticationBasicSecretRetryRules:
    HealthCheckAuthenticationBasicSecretRetryRules,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationBasicSecretRetryRules$outboundSchema.parse(
      healthCheckAuthenticationBasicSecretRetryRules,
    ),
  );
}
export function healthCheckAuthenticationBasicSecretRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckAuthenticationBasicSecretRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationBasicSecretRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'HealthCheckAuthenticationBasicSecretRetryRules' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationBasicSecret$inboundSchema: z.ZodType<
  HealthCheckAuthenticationBasicSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("basicSecret"),
  credentialsSecret: z.string(),
  discovery: z.lazy(() =>
    HealthCheckAuthenticationBasicSecretDiscovery$inboundSchema
  ).optional(),
  collectUrl: z.string(),
  collectMethod:
    HealthCheckAuthenticationBasicSecretHealthCheckMethod$inboundSchema,
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() =>
      HealthCheckAuthenticationBasicSecretCollectRequestHeader$inboundSchema
    ),
  ).optional(),
  authenticateCollect: z.boolean().optional(),
  timeout: z.number().optional(),
  rejectUnauthorized: z.boolean().optional(),
  defaultBreakers:
    HiddenDefaultBreakersOptionsDatabaseCollectorConf$inboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    HealthCheckAuthenticationBasicSecretRetryRules$inboundSchema
  ).optional(),
});
/** @internal */
export type HealthCheckAuthenticationBasicSecret$Outbound = {
  authentication: "basicSecret";
  credentialsSecret: string;
  discovery?:
    | HealthCheckAuthenticationBasicSecretDiscovery$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<HealthCheckAuthenticationBasicSecretCollectRequestHeader$Outbound>
    | undefined;
  authenticateCollect?: boolean | undefined;
  timeout?: number | undefined;
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | HealthCheckAuthenticationBasicSecretRetryRules$Outbound
    | undefined;
};

/** @internal */
export const HealthCheckAuthenticationBasicSecret$outboundSchema: z.ZodType<
  HealthCheckAuthenticationBasicSecret$Outbound,
  z.ZodTypeDef,
  HealthCheckAuthenticationBasicSecret
> = z.object({
  authentication: z.literal("basicSecret"),
  credentialsSecret: z.string(),
  discovery: z.lazy(() =>
    HealthCheckAuthenticationBasicSecretDiscovery$outboundSchema
  ).optional(),
  collectUrl: z.string(),
  collectMethod:
    HealthCheckAuthenticationBasicSecretHealthCheckMethod$outboundSchema,
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() =>
      HealthCheckAuthenticationBasicSecretCollectRequestHeader$outboundSchema
    ),
  ).optional(),
  authenticateCollect: z.boolean().optional(),
  timeout: z.number().optional(),
  rejectUnauthorized: z.boolean().optional(),
  defaultBreakers:
    HiddenDefaultBreakersOptionsDatabaseCollectorConf$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    HealthCheckAuthenticationBasicSecretRetryRules$outboundSchema
  ).optional(),
});

export function healthCheckAuthenticationBasicSecretToJSON(
  healthCheckAuthenticationBasicSecret: HealthCheckAuthenticationBasicSecret,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationBasicSecret$outboundSchema.parse(
      healthCheckAuthenticationBasicSecret,
    ),
  );
}
export function healthCheckAuthenticationBasicSecretFromJSON(
  jsonString: string,
): SafeParseResult<HealthCheckAuthenticationBasicSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationBasicSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HealthCheckAuthenticationBasicSecret' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationBasicDiscoverType$inboundSchema:
  z.ZodType<HealthCheckAuthenticationBasicDiscoverType, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(HealthCheckAuthenticationBasicDiscoverType);
/** @internal */
export const HealthCheckAuthenticationBasicDiscoverType$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, HealthCheckAuthenticationBasicDiscoverType> =
    openEnums.outboundSchema(HealthCheckAuthenticationBasicDiscoverType);

/** @internal */
export const HealthCheckAuthenticationBasicDiscovery$inboundSchema: z.ZodType<
  HealthCheckAuthenticationBasicDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: HealthCheckAuthenticationBasicDiscoverType$inboundSchema,
});
/** @internal */
export type HealthCheckAuthenticationBasicDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const HealthCheckAuthenticationBasicDiscovery$outboundSchema: z.ZodType<
  HealthCheckAuthenticationBasicDiscovery$Outbound,
  z.ZodTypeDef,
  HealthCheckAuthenticationBasicDiscovery
> = z.object({
  discoverType: HealthCheckAuthenticationBasicDiscoverType$outboundSchema,
});

export function healthCheckAuthenticationBasicDiscoveryToJSON(
  healthCheckAuthenticationBasicDiscovery:
    HealthCheckAuthenticationBasicDiscovery,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationBasicDiscovery$outboundSchema.parse(
      healthCheckAuthenticationBasicDiscovery,
    ),
  );
}
export function healthCheckAuthenticationBasicDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckAuthenticationBasicDiscovery,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationBasicDiscovery$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'HealthCheckAuthenticationBasicDiscovery' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationBasicHealthCheckMethod$inboundSchema:
  z.ZodType<
    HealthCheckAuthenticationBasicHealthCheckMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(HealthCheckAuthenticationBasicHealthCheckMethod);
/** @internal */
export const HealthCheckAuthenticationBasicHealthCheckMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    HealthCheckAuthenticationBasicHealthCheckMethod
  > = openEnums.outboundSchema(HealthCheckAuthenticationBasicHealthCheckMethod);

/** @internal */
export const HealthCheckAuthenticationBasicCollectRequestHeader$inboundSchema:
  z.ZodType<
    HealthCheckAuthenticationBasicCollectRequestHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
    value: z.string(),
  });
/** @internal */
export type HealthCheckAuthenticationBasicCollectRequestHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const HealthCheckAuthenticationBasicCollectRequestHeader$outboundSchema:
  z.ZodType<
    HealthCheckAuthenticationBasicCollectRequestHeader$Outbound,
    z.ZodTypeDef,
    HealthCheckAuthenticationBasicCollectRequestHeader
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function healthCheckAuthenticationBasicCollectRequestHeaderToJSON(
  healthCheckAuthenticationBasicCollectRequestHeader:
    HealthCheckAuthenticationBasicCollectRequestHeader,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationBasicCollectRequestHeader$outboundSchema.parse(
      healthCheckAuthenticationBasicCollectRequestHeader,
    ),
  );
}
export function healthCheckAuthenticationBasicCollectRequestHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckAuthenticationBasicCollectRequestHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationBasicCollectRequestHeader$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'HealthCheckAuthenticationBasicCollectRequestHeader' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationBasicRetryRules$inboundSchema: z.ZodType<
  HealthCheckAuthenticationBasicRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});
/** @internal */
export type HealthCheckAuthenticationBasicRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/** @internal */
export const HealthCheckAuthenticationBasicRetryRules$outboundSchema: z.ZodType<
  HealthCheckAuthenticationBasicRetryRules$Outbound,
  z.ZodTypeDef,
  HealthCheckAuthenticationBasicRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});

export function healthCheckAuthenticationBasicRetryRulesToJSON(
  healthCheckAuthenticationBasicRetryRules:
    HealthCheckAuthenticationBasicRetryRules,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationBasicRetryRules$outboundSchema.parse(
      healthCheckAuthenticationBasicRetryRules,
    ),
  );
}
export function healthCheckAuthenticationBasicRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckAuthenticationBasicRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationBasicRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'HealthCheckAuthenticationBasicRetryRules' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationBasic$inboundSchema: z.ZodType<
  HealthCheckAuthenticationBasic,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("basic"),
  username: z.string(),
  password: z.string(),
  discovery: z.lazy(() => HealthCheckAuthenticationBasicDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: HealthCheckAuthenticationBasicHealthCheckMethod$inboundSchema,
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() =>
      HealthCheckAuthenticationBasicCollectRequestHeader$inboundSchema
    ),
  ).optional(),
  authenticateCollect: z.boolean().optional(),
  timeout: z.number().optional(),
  rejectUnauthorized: z.boolean().optional(),
  defaultBreakers:
    HiddenDefaultBreakersOptionsDatabaseCollectorConf$inboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    HealthCheckAuthenticationBasicRetryRules$inboundSchema
  ).optional(),
});
/** @internal */
export type HealthCheckAuthenticationBasic$Outbound = {
  authentication: "basic";
  username: string;
  password: string;
  discovery?: HealthCheckAuthenticationBasicDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<HealthCheckAuthenticationBasicCollectRequestHeader$Outbound>
    | undefined;
  authenticateCollect?: boolean | undefined;
  timeout?: number | undefined;
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: HealthCheckAuthenticationBasicRetryRules$Outbound | undefined;
};

/** @internal */
export const HealthCheckAuthenticationBasic$outboundSchema: z.ZodType<
  HealthCheckAuthenticationBasic$Outbound,
  z.ZodTypeDef,
  HealthCheckAuthenticationBasic
> = z.object({
  authentication: z.literal("basic"),
  username: z.string(),
  password: z.string(),
  discovery: z.lazy(() =>
    HealthCheckAuthenticationBasicDiscovery$outboundSchema
  ).optional(),
  collectUrl: z.string(),
  collectMethod: HealthCheckAuthenticationBasicHealthCheckMethod$outboundSchema,
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() =>
      HealthCheckAuthenticationBasicCollectRequestHeader$outboundSchema
    ),
  ).optional(),
  authenticateCollect: z.boolean().optional(),
  timeout: z.number().optional(),
  rejectUnauthorized: z.boolean().optional(),
  defaultBreakers:
    HiddenDefaultBreakersOptionsDatabaseCollectorConf$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    HealthCheckAuthenticationBasicRetryRules$outboundSchema
  ).optional(),
});

export function healthCheckAuthenticationBasicToJSON(
  healthCheckAuthenticationBasic: HealthCheckAuthenticationBasic,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationBasic$outboundSchema.parse(
      healthCheckAuthenticationBasic,
    ),
  );
}
export function healthCheckAuthenticationBasicFromJSON(
  jsonString: string,
): SafeParseResult<HealthCheckAuthenticationBasic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HealthCheckAuthenticationBasic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HealthCheckAuthenticationBasic' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationNoneDiscoverType$inboundSchema: z.ZodType<
  HealthCheckAuthenticationNoneDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(HealthCheckAuthenticationNoneDiscoverType);
/** @internal */
export const HealthCheckAuthenticationNoneDiscoverType$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, HealthCheckAuthenticationNoneDiscoverType> =
    openEnums.outboundSchema(HealthCheckAuthenticationNoneDiscoverType);

/** @internal */
export const HealthCheckAuthenticationNoneDiscovery$inboundSchema: z.ZodType<
  HealthCheckAuthenticationNoneDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: HealthCheckAuthenticationNoneDiscoverType$inboundSchema,
});
/** @internal */
export type HealthCheckAuthenticationNoneDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const HealthCheckAuthenticationNoneDiscovery$outboundSchema: z.ZodType<
  HealthCheckAuthenticationNoneDiscovery$Outbound,
  z.ZodTypeDef,
  HealthCheckAuthenticationNoneDiscovery
> = z.object({
  discoverType: HealthCheckAuthenticationNoneDiscoverType$outboundSchema,
});

export function healthCheckAuthenticationNoneDiscoveryToJSON(
  healthCheckAuthenticationNoneDiscovery:
    HealthCheckAuthenticationNoneDiscovery,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationNoneDiscovery$outboundSchema.parse(
      healthCheckAuthenticationNoneDiscovery,
    ),
  );
}
export function healthCheckAuthenticationNoneDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<HealthCheckAuthenticationNoneDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationNoneDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HealthCheckAuthenticationNoneDiscovery' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationNoneHealthCheckMethod$inboundSchema:
  z.ZodType<
    HealthCheckAuthenticationNoneHealthCheckMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(HealthCheckAuthenticationNoneHealthCheckMethod);
/** @internal */
export const HealthCheckAuthenticationNoneHealthCheckMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    HealthCheckAuthenticationNoneHealthCheckMethod
  > = openEnums.outboundSchema(HealthCheckAuthenticationNoneHealthCheckMethod);

/** @internal */
export const HealthCheckAuthenticationNoneCollectRequestHeader$inboundSchema:
  z.ZodType<
    HealthCheckAuthenticationNoneCollectRequestHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
    value: z.string(),
  });
/** @internal */
export type HealthCheckAuthenticationNoneCollectRequestHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const HealthCheckAuthenticationNoneCollectRequestHeader$outboundSchema:
  z.ZodType<
    HealthCheckAuthenticationNoneCollectRequestHeader$Outbound,
    z.ZodTypeDef,
    HealthCheckAuthenticationNoneCollectRequestHeader
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function healthCheckAuthenticationNoneCollectRequestHeaderToJSON(
  healthCheckAuthenticationNoneCollectRequestHeader:
    HealthCheckAuthenticationNoneCollectRequestHeader,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationNoneCollectRequestHeader$outboundSchema.parse(
      healthCheckAuthenticationNoneCollectRequestHeader,
    ),
  );
}
export function healthCheckAuthenticationNoneCollectRequestHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckAuthenticationNoneCollectRequestHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationNoneCollectRequestHeader$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'HealthCheckAuthenticationNoneCollectRequestHeader' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationNoneRetryRules$inboundSchema: z.ZodType<
  HealthCheckAuthenticationNoneRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});
/** @internal */
export type HealthCheckAuthenticationNoneRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/** @internal */
export const HealthCheckAuthenticationNoneRetryRules$outboundSchema: z.ZodType<
  HealthCheckAuthenticationNoneRetryRules$Outbound,
  z.ZodTypeDef,
  HealthCheckAuthenticationNoneRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});

export function healthCheckAuthenticationNoneRetryRulesToJSON(
  healthCheckAuthenticationNoneRetryRules:
    HealthCheckAuthenticationNoneRetryRules,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationNoneRetryRules$outboundSchema.parse(
      healthCheckAuthenticationNoneRetryRules,
    ),
  );
}
export function healthCheckAuthenticationNoneRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckAuthenticationNoneRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckAuthenticationNoneRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'HealthCheckAuthenticationNoneRetryRules' from JSON`,
  );
}

/** @internal */
export const HealthCheckAuthenticationNone$inboundSchema: z.ZodType<
  HealthCheckAuthenticationNone,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("none"),
  discovery: z.lazy(() => HealthCheckAuthenticationNoneDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: HealthCheckAuthenticationNoneHealthCheckMethod$inboundSchema,
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() =>
      HealthCheckAuthenticationNoneCollectRequestHeader$inboundSchema
    ),
  ).optional(),
  authenticateCollect: z.boolean().optional(),
  timeout: z.number().optional(),
  rejectUnauthorized: z.boolean().optional(),
  defaultBreakers:
    HiddenDefaultBreakersOptionsDatabaseCollectorConf$inboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    HealthCheckAuthenticationNoneRetryRules$inboundSchema
  ).optional(),
});
/** @internal */
export type HealthCheckAuthenticationNone$Outbound = {
  authentication: "none";
  discovery?: HealthCheckAuthenticationNoneDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<HealthCheckAuthenticationNoneCollectRequestHeader$Outbound>
    | undefined;
  authenticateCollect?: boolean | undefined;
  timeout?: number | undefined;
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: HealthCheckAuthenticationNoneRetryRules$Outbound | undefined;
};

/** @internal */
export const HealthCheckAuthenticationNone$outboundSchema: z.ZodType<
  HealthCheckAuthenticationNone$Outbound,
  z.ZodTypeDef,
  HealthCheckAuthenticationNone
> = z.object({
  authentication: z.literal("none"),
  discovery: z.lazy(() => HealthCheckAuthenticationNoneDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: HealthCheckAuthenticationNoneHealthCheckMethod$outboundSchema,
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() =>
      HealthCheckAuthenticationNoneCollectRequestHeader$outboundSchema
    ),
  ).optional(),
  authenticateCollect: z.boolean().optional(),
  timeout: z.number().optional(),
  rejectUnauthorized: z.boolean().optional(),
  defaultBreakers:
    HiddenDefaultBreakersOptionsDatabaseCollectorConf$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    HealthCheckAuthenticationNoneRetryRules$outboundSchema
  ).optional(),
});

export function healthCheckAuthenticationNoneToJSON(
  healthCheckAuthenticationNone: HealthCheckAuthenticationNone,
): string {
  return JSON.stringify(
    HealthCheckAuthenticationNone$outboundSchema.parse(
      healthCheckAuthenticationNone,
    ),
  );
}
export function healthCheckAuthenticationNoneFromJSON(
  jsonString: string,
): SafeParseResult<HealthCheckAuthenticationNone, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HealthCheckAuthenticationNone$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HealthCheckAuthenticationNone' from JSON`,
  );
}

/** @internal */
export const HealthCheckCollectMethodPostWithBodyHealthCheckMethod$inboundSchema:
  z.ZodType<
    HealthCheckCollectMethodPostWithBodyHealthCheckMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    HealthCheckCollectMethodPostWithBodyHealthCheckMethod,
  );
/** @internal */
export const HealthCheckCollectMethodPostWithBodyHealthCheckMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    HealthCheckCollectMethodPostWithBodyHealthCheckMethod
  > = openEnums.outboundSchema(
    HealthCheckCollectMethodPostWithBodyHealthCheckMethod,
  );

/** @internal */
export const HealthCheckCollectMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    HealthCheckCollectMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(HealthCheckCollectMethodPostWithBodyDiscoverType);
/** @internal */
export const HealthCheckCollectMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    HealthCheckCollectMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    HealthCheckCollectMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const HealthCheckCollectMethodPostWithBodyDiscovery$inboundSchema:
  z.ZodType<
    HealthCheckCollectMethodPostWithBodyDiscovery,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType:
      HealthCheckCollectMethodPostWithBodyDiscoverType$inboundSchema,
  });
/** @internal */
export type HealthCheckCollectMethodPostWithBodyDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const HealthCheckCollectMethodPostWithBodyDiscovery$outboundSchema:
  z.ZodType<
    HealthCheckCollectMethodPostWithBodyDiscovery$Outbound,
    z.ZodTypeDef,
    HealthCheckCollectMethodPostWithBodyDiscovery
  > = z.object({
    discoverType:
      HealthCheckCollectMethodPostWithBodyDiscoverType$outboundSchema,
  });

export function healthCheckCollectMethodPostWithBodyDiscoveryToJSON(
  healthCheckCollectMethodPostWithBodyDiscovery:
    HealthCheckCollectMethodPostWithBodyDiscovery,
): string {
  return JSON.stringify(
    HealthCheckCollectMethodPostWithBodyDiscovery$outboundSchema.parse(
      healthCheckCollectMethodPostWithBodyDiscovery,
    ),
  );
}
export function healthCheckCollectMethodPostWithBodyDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckCollectMethodPostWithBodyDiscovery,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckCollectMethodPostWithBodyDiscovery$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'HealthCheckCollectMethodPostWithBodyDiscovery' from JSON`,
  );
}

/** @internal */
export const HealthCheckCollectMethodPostWithBodyCollectRequestHeader$inboundSchema:
  z.ZodType<
    HealthCheckCollectMethodPostWithBodyCollectRequestHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
    value: z.string(),
  });
/** @internal */
export type HealthCheckCollectMethodPostWithBodyCollectRequestHeader$Outbound =
  {
    name: string;
    value: string;
  };

/** @internal */
export const HealthCheckCollectMethodPostWithBodyCollectRequestHeader$outboundSchema:
  z.ZodType<
    HealthCheckCollectMethodPostWithBodyCollectRequestHeader$Outbound,
    z.ZodTypeDef,
    HealthCheckCollectMethodPostWithBodyCollectRequestHeader
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function healthCheckCollectMethodPostWithBodyCollectRequestHeaderToJSON(
  healthCheckCollectMethodPostWithBodyCollectRequestHeader:
    HealthCheckCollectMethodPostWithBodyCollectRequestHeader,
): string {
  return JSON.stringify(
    HealthCheckCollectMethodPostWithBodyCollectRequestHeader$outboundSchema
      .parse(healthCheckCollectMethodPostWithBodyCollectRequestHeader),
  );
}
export function healthCheckCollectMethodPostWithBodyCollectRequestHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckCollectMethodPostWithBodyCollectRequestHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckCollectMethodPostWithBodyCollectRequestHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'HealthCheckCollectMethodPostWithBodyCollectRequestHeader' from JSON`,
  );
}

/** @internal */
export const HealthCheckCollectMethodPostWithBodyAuthentication$inboundSchema:
  z.ZodType<
    HealthCheckCollectMethodPostWithBodyAuthentication,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    HealthCheckCollectMethodPostWithBodyAuthentication,
  );
/** @internal */
export const HealthCheckCollectMethodPostWithBodyAuthentication$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    HealthCheckCollectMethodPostWithBodyAuthentication
  > = openEnums.outboundSchema(
    HealthCheckCollectMethodPostWithBodyAuthentication,
  );

/** @internal */
export const HealthCheckCollectMethodPostWithBodyRetryRules$inboundSchema:
  z.ZodType<
    HealthCheckCollectMethodPostWithBodyRetryRules,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
  });
/** @internal */
export type HealthCheckCollectMethodPostWithBodyRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/** @internal */
export const HealthCheckCollectMethodPostWithBodyRetryRules$outboundSchema:
  z.ZodType<
    HealthCheckCollectMethodPostWithBodyRetryRules$Outbound,
    z.ZodTypeDef,
    HealthCheckCollectMethodPostWithBodyRetryRules
  > = z.object({
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
  });

export function healthCheckCollectMethodPostWithBodyRetryRulesToJSON(
  healthCheckCollectMethodPostWithBodyRetryRules:
    HealthCheckCollectMethodPostWithBodyRetryRules,
): string {
  return JSON.stringify(
    HealthCheckCollectMethodPostWithBodyRetryRules$outboundSchema.parse(
      healthCheckCollectMethodPostWithBodyRetryRules,
    ),
  );
}
export function healthCheckCollectMethodPostWithBodyRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckCollectMethodPostWithBodyRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckCollectMethodPostWithBodyRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'HealthCheckCollectMethodPostWithBodyRetryRules' from JSON`,
  );
}

/** @internal */
export const HealthCheckCollectMethodPostWithBody$inboundSchema: z.ZodType<
  HealthCheckCollectMethodPostWithBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod:
    HealthCheckCollectMethodPostWithBodyHealthCheckMethod$inboundSchema,
  collectBody: z.any().optional(),
  discovery: z.lazy(() =>
    HealthCheckCollectMethodPostWithBodyDiscovery$inboundSchema
  ).optional(),
  collectUrl: z.string(),
  collectRequestParams: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() =>
      HealthCheckCollectMethodPostWithBodyCollectRequestHeader$inboundSchema
    ),
  ).optional(),
  authenticateCollect: z.boolean().optional(),
  authentication:
    HealthCheckCollectMethodPostWithBodyAuthentication$inboundSchema,
  timeout: z.number().optional(),
  rejectUnauthorized: z.boolean().optional(),
  defaultBreakers:
    HiddenDefaultBreakersOptionsDatabaseCollectorConf$inboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    HealthCheckCollectMethodPostWithBodyRetryRules$inboundSchema
  ).optional(),
});
/** @internal */
export type HealthCheckCollectMethodPostWithBody$Outbound = {
  collectMethod: string;
  collectBody?: any | undefined;
  discovery?:
    | HealthCheckCollectMethodPostWithBodyDiscovery$Outbound
    | undefined;
  collectUrl: string;
  collectRequestParams?: any | undefined;
  collectRequestHeaders?:
    | Array<HealthCheckCollectMethodPostWithBodyCollectRequestHeader$Outbound>
    | undefined;
  authenticateCollect?: boolean | undefined;
  authentication: string;
  timeout?: number | undefined;
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | HealthCheckCollectMethodPostWithBodyRetryRules$Outbound
    | undefined;
};

/** @internal */
export const HealthCheckCollectMethodPostWithBody$outboundSchema: z.ZodType<
  HealthCheckCollectMethodPostWithBody$Outbound,
  z.ZodTypeDef,
  HealthCheckCollectMethodPostWithBody
> = z.object({
  collectMethod:
    HealthCheckCollectMethodPostWithBodyHealthCheckMethod$outboundSchema,
  collectBody: z.any().optional(),
  discovery: z.lazy(() =>
    HealthCheckCollectMethodPostWithBodyDiscovery$outboundSchema
  ).optional(),
  collectUrl: z.string(),
  collectRequestParams: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() =>
      HealthCheckCollectMethodPostWithBodyCollectRequestHeader$outboundSchema
    ),
  ).optional(),
  authenticateCollect: z.boolean().optional(),
  authentication:
    HealthCheckCollectMethodPostWithBodyAuthentication$outboundSchema,
  timeout: z.number().optional(),
  rejectUnauthorized: z.boolean().optional(),
  defaultBreakers:
    HiddenDefaultBreakersOptionsDatabaseCollectorConf$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    HealthCheckCollectMethodPostWithBodyRetryRules$outboundSchema
  ).optional(),
});

export function healthCheckCollectMethodPostWithBodyToJSON(
  healthCheckCollectMethodPostWithBody: HealthCheckCollectMethodPostWithBody,
): string {
  return JSON.stringify(
    HealthCheckCollectMethodPostWithBody$outboundSchema.parse(
      healthCheckCollectMethodPostWithBody,
    ),
  );
}
export function healthCheckCollectMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<HealthCheckCollectMethodPostWithBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckCollectMethodPostWithBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HealthCheckCollectMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const HealthCheckCollectMethodPostHealthCheckMethod$inboundSchema:
  z.ZodType<
    HealthCheckCollectMethodPostHealthCheckMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(HealthCheckCollectMethodPostHealthCheckMethod);
/** @internal */
export const HealthCheckCollectMethodPostHealthCheckMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    HealthCheckCollectMethodPostHealthCheckMethod
  > = openEnums.outboundSchema(HealthCheckCollectMethodPostHealthCheckMethod);

/** @internal */
export const HealthCheckCollectMethodPostDiscoverType$inboundSchema: z.ZodType<
  HealthCheckCollectMethodPostDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(HealthCheckCollectMethodPostDiscoverType);
/** @internal */
export const HealthCheckCollectMethodPostDiscoverType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  HealthCheckCollectMethodPostDiscoverType
> = openEnums.outboundSchema(HealthCheckCollectMethodPostDiscoverType);

/** @internal */
export const HealthCheckCollectMethodPostDiscovery$inboundSchema: z.ZodType<
  HealthCheckCollectMethodPostDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: HealthCheckCollectMethodPostDiscoverType$inboundSchema,
});
/** @internal */
export type HealthCheckCollectMethodPostDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const HealthCheckCollectMethodPostDiscovery$outboundSchema: z.ZodType<
  HealthCheckCollectMethodPostDiscovery$Outbound,
  z.ZodTypeDef,
  HealthCheckCollectMethodPostDiscovery
> = z.object({
  discoverType: HealthCheckCollectMethodPostDiscoverType$outboundSchema,
});

export function healthCheckCollectMethodPostDiscoveryToJSON(
  healthCheckCollectMethodPostDiscovery: HealthCheckCollectMethodPostDiscovery,
): string {
  return JSON.stringify(
    HealthCheckCollectMethodPostDiscovery$outboundSchema.parse(
      healthCheckCollectMethodPostDiscovery,
    ),
  );
}
export function healthCheckCollectMethodPostDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<HealthCheckCollectMethodPostDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckCollectMethodPostDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HealthCheckCollectMethodPostDiscovery' from JSON`,
  );
}

/** @internal */
export const HealthCheckCollectMethodPostCollectRequestHeader$inboundSchema:
  z.ZodType<
    HealthCheckCollectMethodPostCollectRequestHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
    value: z.string(),
  });
/** @internal */
export type HealthCheckCollectMethodPostCollectRequestHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const HealthCheckCollectMethodPostCollectRequestHeader$outboundSchema:
  z.ZodType<
    HealthCheckCollectMethodPostCollectRequestHeader$Outbound,
    z.ZodTypeDef,
    HealthCheckCollectMethodPostCollectRequestHeader
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function healthCheckCollectMethodPostCollectRequestHeaderToJSON(
  healthCheckCollectMethodPostCollectRequestHeader:
    HealthCheckCollectMethodPostCollectRequestHeader,
): string {
  return JSON.stringify(
    HealthCheckCollectMethodPostCollectRequestHeader$outboundSchema.parse(
      healthCheckCollectMethodPostCollectRequestHeader,
    ),
  );
}
export function healthCheckCollectMethodPostCollectRequestHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckCollectMethodPostCollectRequestHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckCollectMethodPostCollectRequestHeader$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'HealthCheckCollectMethodPostCollectRequestHeader' from JSON`,
  );
}

/** @internal */
export const HealthCheckCollectMethodPostAuthentication$inboundSchema:
  z.ZodType<HealthCheckCollectMethodPostAuthentication, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(HealthCheckCollectMethodPostAuthentication);
/** @internal */
export const HealthCheckCollectMethodPostAuthentication$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, HealthCheckCollectMethodPostAuthentication> =
    openEnums.outboundSchema(HealthCheckCollectMethodPostAuthentication);

/** @internal */
export const HealthCheckCollectMethodPostRetryRules$inboundSchema: z.ZodType<
  HealthCheckCollectMethodPostRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});
/** @internal */
export type HealthCheckCollectMethodPostRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/** @internal */
export const HealthCheckCollectMethodPostRetryRules$outboundSchema: z.ZodType<
  HealthCheckCollectMethodPostRetryRules$Outbound,
  z.ZodTypeDef,
  HealthCheckCollectMethodPostRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});

export function healthCheckCollectMethodPostRetryRulesToJSON(
  healthCheckCollectMethodPostRetryRules:
    HealthCheckCollectMethodPostRetryRules,
): string {
  return JSON.stringify(
    HealthCheckCollectMethodPostRetryRules$outboundSchema.parse(
      healthCheckCollectMethodPostRetryRules,
    ),
  );
}
export function healthCheckCollectMethodPostRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<HealthCheckCollectMethodPostRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckCollectMethodPostRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HealthCheckCollectMethodPostRetryRules' from JSON`,
  );
}

/** @internal */
export const HealthCheckCollectMethodPost$inboundSchema: z.ZodType<
  HealthCheckCollectMethodPost,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: HealthCheckCollectMethodPostHealthCheckMethod$inboundSchema,
  collectRequestParams: z.any().optional(),
  discovery: z.lazy(() => HealthCheckCollectMethodPostDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() =>
      HealthCheckCollectMethodPostCollectRequestHeader$inboundSchema
    ),
  ).optional(),
  authenticateCollect: z.boolean().optional(),
  authentication: HealthCheckCollectMethodPostAuthentication$inboundSchema,
  timeout: z.number().optional(),
  rejectUnauthorized: z.boolean().optional(),
  defaultBreakers:
    HiddenDefaultBreakersOptionsDatabaseCollectorConf$inboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => HealthCheckCollectMethodPostRetryRules$inboundSchema)
    .optional(),
});
/** @internal */
export type HealthCheckCollectMethodPost$Outbound = {
  collectMethod: string;
  collectRequestParams?: any | undefined;
  discovery?: HealthCheckCollectMethodPostDiscovery$Outbound | undefined;
  collectUrl: string;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<HealthCheckCollectMethodPostCollectRequestHeader$Outbound>
    | undefined;
  authenticateCollect?: boolean | undefined;
  authentication: string;
  timeout?: number | undefined;
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: HealthCheckCollectMethodPostRetryRules$Outbound | undefined;
};

/** @internal */
export const HealthCheckCollectMethodPost$outboundSchema: z.ZodType<
  HealthCheckCollectMethodPost$Outbound,
  z.ZodTypeDef,
  HealthCheckCollectMethodPost
> = z.object({
  collectMethod: HealthCheckCollectMethodPostHealthCheckMethod$outboundSchema,
  collectRequestParams: z.any().optional(),
  discovery: z.lazy(() => HealthCheckCollectMethodPostDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() =>
      HealthCheckCollectMethodPostCollectRequestHeader$outboundSchema
    ),
  ).optional(),
  authenticateCollect: z.boolean().optional(),
  authentication: HealthCheckCollectMethodPostAuthentication$outboundSchema,
  timeout: z.number().optional(),
  rejectUnauthorized: z.boolean().optional(),
  defaultBreakers:
    HiddenDefaultBreakersOptionsDatabaseCollectorConf$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    HealthCheckCollectMethodPostRetryRules$outboundSchema
  ).optional(),
});

export function healthCheckCollectMethodPostToJSON(
  healthCheckCollectMethodPost: HealthCheckCollectMethodPost,
): string {
  return JSON.stringify(
    HealthCheckCollectMethodPost$outboundSchema.parse(
      healthCheckCollectMethodPost,
    ),
  );
}
export function healthCheckCollectMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<HealthCheckCollectMethodPost, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HealthCheckCollectMethodPost$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HealthCheckCollectMethodPost' from JSON`,
  );
}

/** @internal */
export const HealthCheckCollectMethodGetHealthCheckMethod$inboundSchema:
  z.ZodType<
    HealthCheckCollectMethodGetHealthCheckMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(HealthCheckCollectMethodGetHealthCheckMethod);
/** @internal */
export const HealthCheckCollectMethodGetHealthCheckMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    HealthCheckCollectMethodGetHealthCheckMethod
  > = openEnums.outboundSchema(HealthCheckCollectMethodGetHealthCheckMethod);

/** @internal */
export const HealthCheckCollectMethodGetDiscoverType$inboundSchema: z.ZodType<
  HealthCheckCollectMethodGetDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(HealthCheckCollectMethodGetDiscoverType);
/** @internal */
export const HealthCheckCollectMethodGetDiscoverType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  HealthCheckCollectMethodGetDiscoverType
> = openEnums.outboundSchema(HealthCheckCollectMethodGetDiscoverType);

/** @internal */
export const HealthCheckCollectMethodGetDiscovery$inboundSchema: z.ZodType<
  HealthCheckCollectMethodGetDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: HealthCheckCollectMethodGetDiscoverType$inboundSchema,
});
/** @internal */
export type HealthCheckCollectMethodGetDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const HealthCheckCollectMethodGetDiscovery$outboundSchema: z.ZodType<
  HealthCheckCollectMethodGetDiscovery$Outbound,
  z.ZodTypeDef,
  HealthCheckCollectMethodGetDiscovery
> = z.object({
  discoverType: HealthCheckCollectMethodGetDiscoverType$outboundSchema,
});

export function healthCheckCollectMethodGetDiscoveryToJSON(
  healthCheckCollectMethodGetDiscovery: HealthCheckCollectMethodGetDiscovery,
): string {
  return JSON.stringify(
    HealthCheckCollectMethodGetDiscovery$outboundSchema.parse(
      healthCheckCollectMethodGetDiscovery,
    ),
  );
}
export function healthCheckCollectMethodGetDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<HealthCheckCollectMethodGetDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckCollectMethodGetDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HealthCheckCollectMethodGetDiscovery' from JSON`,
  );
}

/** @internal */
export const HealthCheckCollectMethodGetCollectRequestHeader$inboundSchema:
  z.ZodType<
    HealthCheckCollectMethodGetCollectRequestHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
    value: z.string(),
  });
/** @internal */
export type HealthCheckCollectMethodGetCollectRequestHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const HealthCheckCollectMethodGetCollectRequestHeader$outboundSchema:
  z.ZodType<
    HealthCheckCollectMethodGetCollectRequestHeader$Outbound,
    z.ZodTypeDef,
    HealthCheckCollectMethodGetCollectRequestHeader
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function healthCheckCollectMethodGetCollectRequestHeaderToJSON(
  healthCheckCollectMethodGetCollectRequestHeader:
    HealthCheckCollectMethodGetCollectRequestHeader,
): string {
  return JSON.stringify(
    HealthCheckCollectMethodGetCollectRequestHeader$outboundSchema.parse(
      healthCheckCollectMethodGetCollectRequestHeader,
    ),
  );
}
export function healthCheckCollectMethodGetCollectRequestHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  HealthCheckCollectMethodGetCollectRequestHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckCollectMethodGetCollectRequestHeader$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'HealthCheckCollectMethodGetCollectRequestHeader' from JSON`,
  );
}

/** @internal */
export const HealthCheckCollectMethodGetAuthentication$inboundSchema: z.ZodType<
  HealthCheckCollectMethodGetAuthentication,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(HealthCheckCollectMethodGetAuthentication);
/** @internal */
export const HealthCheckCollectMethodGetAuthentication$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, HealthCheckCollectMethodGetAuthentication> =
    openEnums.outboundSchema(HealthCheckCollectMethodGetAuthentication);

/** @internal */
export const HealthCheckCollectMethodGetRetryRules$inboundSchema: z.ZodType<
  HealthCheckCollectMethodGetRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});
/** @internal */
export type HealthCheckCollectMethodGetRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/** @internal */
export const HealthCheckCollectMethodGetRetryRules$outboundSchema: z.ZodType<
  HealthCheckCollectMethodGetRetryRules$Outbound,
  z.ZodTypeDef,
  HealthCheckCollectMethodGetRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});

export function healthCheckCollectMethodGetRetryRulesToJSON(
  healthCheckCollectMethodGetRetryRules: HealthCheckCollectMethodGetRetryRules,
): string {
  return JSON.stringify(
    HealthCheckCollectMethodGetRetryRules$outboundSchema.parse(
      healthCheckCollectMethodGetRetryRules,
    ),
  );
}
export function healthCheckCollectMethodGetRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<HealthCheckCollectMethodGetRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      HealthCheckCollectMethodGetRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HealthCheckCollectMethodGetRetryRules' from JSON`,
  );
}

/** @internal */
export const HealthCheckCollectMethodGet$inboundSchema: z.ZodType<
  HealthCheckCollectMethodGet,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: HealthCheckCollectMethodGetHealthCheckMethod$inboundSchema,
  collectRequestParams: z.any().optional(),
  discovery: z.lazy(() => HealthCheckCollectMethodGetDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() => HealthCheckCollectMethodGetCollectRequestHeader$inboundSchema),
  ).optional(),
  authenticateCollect: z.boolean().optional(),
  authentication: HealthCheckCollectMethodGetAuthentication$inboundSchema,
  timeout: z.number().optional(),
  rejectUnauthorized: z.boolean().optional(),
  defaultBreakers:
    HiddenDefaultBreakersOptionsDatabaseCollectorConf$inboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => HealthCheckCollectMethodGetRetryRules$inboundSchema)
    .optional(),
});
/** @internal */
export type HealthCheckCollectMethodGet$Outbound = {
  collectMethod: string;
  collectRequestParams?: any | undefined;
  discovery?: HealthCheckCollectMethodGetDiscovery$Outbound | undefined;
  collectUrl: string;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<HealthCheckCollectMethodGetCollectRequestHeader$Outbound>
    | undefined;
  authenticateCollect?: boolean | undefined;
  authentication: string;
  timeout?: number | undefined;
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: HealthCheckCollectMethodGetRetryRules$Outbound | undefined;
};

/** @internal */
export const HealthCheckCollectMethodGet$outboundSchema: z.ZodType<
  HealthCheckCollectMethodGet$Outbound,
  z.ZodTypeDef,
  HealthCheckCollectMethodGet
> = z.object({
  collectMethod: HealthCheckCollectMethodGetHealthCheckMethod$outboundSchema,
  collectRequestParams: z.any().optional(),
  discovery: z.lazy(() => HealthCheckCollectMethodGetDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() =>
      HealthCheckCollectMethodGetCollectRequestHeader$outboundSchema
    ),
  ).optional(),
  authenticateCollect: z.boolean().optional(),
  authentication: HealthCheckCollectMethodGetAuthentication$outboundSchema,
  timeout: z.number().optional(),
  rejectUnauthorized: z.boolean().optional(),
  defaultBreakers:
    HiddenDefaultBreakersOptionsDatabaseCollectorConf$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => HealthCheckCollectMethodGetRetryRules$outboundSchema)
    .optional(),
});

export function healthCheckCollectMethodGetToJSON(
  healthCheckCollectMethodGet: HealthCheckCollectMethodGet,
): string {
  return JSON.stringify(
    HealthCheckCollectMethodGet$outboundSchema.parse(
      healthCheckCollectMethodGet,
    ),
  );
}
export function healthCheckCollectMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<HealthCheckCollectMethodGet, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HealthCheckCollectMethodGet$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HealthCheckCollectMethodGet' from JSON`,
  );
}

/** @internal */
export const HealthCheckCollectorConf$inboundSchema: z.ZodType<
  HealthCheckCollectorConf,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => HealthCheckAuthenticationNone$inboundSchema),
  z.lazy(() => HealthCheckAuthenticationBasic$inboundSchema),
  z.lazy(() => HealthCheckAuthenticationBasicSecret$inboundSchema),
  z.lazy(() => HealthCheckAuthenticationLogin$inboundSchema),
  z.lazy(() => HealthCheckAuthenticationLoginSecret$inboundSchema),
  z.lazy(() => HealthCheckAuthenticationOauth$inboundSchema),
  z.lazy(() => HealthCheckAuthenticationOauthSecret$inboundSchema),
]);
/** @internal */
export type HealthCheckCollectorConf$Outbound =
  | HealthCheckAuthenticationNone$Outbound
  | HealthCheckAuthenticationBasic$Outbound
  | HealthCheckAuthenticationBasicSecret$Outbound
  | HealthCheckAuthenticationLogin$Outbound
  | HealthCheckAuthenticationLoginSecret$Outbound
  | HealthCheckAuthenticationOauth$Outbound
  | HealthCheckAuthenticationOauthSecret$Outbound;

/** @internal */
export const HealthCheckCollectorConf$outboundSchema: z.ZodType<
  HealthCheckCollectorConf$Outbound,
  z.ZodTypeDef,
  HealthCheckCollectorConf
> = z.union([
  z.lazy(() => HealthCheckAuthenticationNone$outboundSchema),
  z.lazy(() => HealthCheckAuthenticationBasic$outboundSchema),
  z.lazy(() => HealthCheckAuthenticationBasicSecret$outboundSchema),
  z.lazy(() => HealthCheckAuthenticationLogin$outboundSchema),
  z.lazy(() => HealthCheckAuthenticationLoginSecret$outboundSchema),
  z.lazy(() => HealthCheckAuthenticationOauth$outboundSchema),
  z.lazy(() => HealthCheckAuthenticationOauthSecret$outboundSchema),
]);

export function healthCheckCollectorConfToJSON(
  healthCheckCollectorConf: HealthCheckCollectorConf,
): string {
  return JSON.stringify(
    HealthCheckCollectorConf$outboundSchema.parse(healthCheckCollectorConf),
  );
}
export function healthCheckCollectorConfFromJSON(
  jsonString: string,
): SafeParseResult<HealthCheckCollectorConf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HealthCheckCollectorConf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HealthCheckCollectorConf' from JSON`,
  );
}
