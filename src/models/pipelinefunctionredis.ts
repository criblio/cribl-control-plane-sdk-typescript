/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as discriminatedUnionTypes from "../types/discriminatedUnion.js";
import { discriminatedUnion } from "../types/discriminatedUnion.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  MaximumTlsVersionOptionsRedisDeploymentTypeStandaloneTlsOptions,
  MaximumTlsVersionOptionsRedisDeploymentTypeStandaloneTlsOptions$inboundSchema,
  MaximumTlsVersionOptionsRedisDeploymentTypeStandaloneTlsOptions$outboundSchema,
} from "./maximumtlsversionoptionsredisdeploymenttypestandalonetlsoptions.js";
import {
  MinimumTlsVersionOptionsRedisDeploymentTypeStandaloneTlsOptions,
  MinimumTlsVersionOptionsRedisDeploymentTypeStandaloneTlsOptions$inboundSchema,
  MinimumTlsVersionOptionsRedisDeploymentTypeStandaloneTlsOptions$outboundSchema,
} from "./minimumtlsversionoptionsredisdeploymenttypestandalonetlsoptions.js";
import {
  TlsOptionsTypeRedisDeploymentTypeClusterTlsTrue,
  TlsOptionsTypeRedisDeploymentTypeClusterTlsTrue$inboundSchema,
  TlsOptionsTypeRedisDeploymentTypeClusterTlsTrue$Outbound,
  TlsOptionsTypeRedisDeploymentTypeClusterTlsTrue$outboundSchema,
} from "./tlsoptionstyperedisdeploymenttypeclustertlstrue.js";

export type RedisAuthTypeTextSecretCommand = {
  /**
   * Name of the field in which to store the returned value. Leave blank to discard returned value.
   */
  outField?: string | undefined;
  /**
   * Redis command to perform. For a complete list visit: https://redis.io/commands
   */
  command: string;
  /**
   * A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'.
   */
  keyExpr: string;
  /**
   * A JavaScript expression to compute arguments to the operation. Can return an array.
   */
  argsExpr?: string | undefined;
};

/**
 * How the Redis server is configured. Defaults to Standalone
 */
export const RedisAuthTypeTextSecretDeploymentType = {
  /**
   * Standalone
   */
  Standalone: "standalone",
  /**
   * Cluster
   */
  Cluster: "cluster",
  /**
   * Sentinel
   */
  Sentinel: "sentinel",
} as const;
/**
 * How the Redis server is configured. Defaults to Standalone
 */
export type RedisAuthTypeTextSecretDeploymentType = OpenEnum<
  typeof RedisAuthTypeTextSecretDeploymentType
>;

export type RedisAuthTypeTextSecret = {
  authType: "textSecret";
  /**
   * Secret that references Redis admin password
   */
  textSecret: string;
  commands: Array<RedisAuthTypeTextSecretCommand>;
  /**
   * How the Redis server is configured. Defaults to Standalone
   */
  deploymentType?: RedisAuthTypeTextSecretDeploymentType | undefined;
  /**
   * Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable.
   */
  maxBlockSecs?: number | undefined;
  /**
   * Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache.
   */
  enableClientSideCaching?: boolean | undefined;
};

export type RedisAuthTypeCredentialsSecretCommand = {
  /**
   * Name of the field in which to store the returned value. Leave blank to discard returned value.
   */
  outField?: string | undefined;
  /**
   * Redis command to perform. For a complete list visit: https://redis.io/commands
   */
  command: string;
  /**
   * A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'.
   */
  keyExpr: string;
  /**
   * A JavaScript expression to compute arguments to the operation. Can return an array.
   */
  argsExpr?: string | undefined;
};

/**
 * How the Redis server is configured. Defaults to Standalone
 */
export const RedisAuthTypeCredentialsSecretDeploymentType = {
  /**
   * Standalone
   */
  Standalone: "standalone",
  /**
   * Cluster
   */
  Cluster: "cluster",
  /**
   * Sentinel
   */
  Sentinel: "sentinel",
} as const;
/**
 * How the Redis server is configured. Defaults to Standalone
 */
export type RedisAuthTypeCredentialsSecretDeploymentType = OpenEnum<
  typeof RedisAuthTypeCredentialsSecretDeploymentType
>;

export type RedisAuthTypeCredentialsSecret = {
  authType: "credentialsSecret";
  /**
   * Secret that references Redis username and password
   */
  credentialsSecret: string;
  commands: Array<RedisAuthTypeCredentialsSecretCommand>;
  /**
   * How the Redis server is configured. Defaults to Standalone
   */
  deploymentType?: RedisAuthTypeCredentialsSecretDeploymentType | undefined;
  /**
   * Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable.
   */
  maxBlockSecs?: number | undefined;
  /**
   * Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache.
   */
  enableClientSideCaching?: boolean | undefined;
};

export type RedisAuthTypeManualCommand = {
  /**
   * Name of the field in which to store the returned value. Leave blank to discard returned value.
   */
  outField?: string | undefined;
  /**
   * Redis command to perform. For a complete list visit: https://redis.io/commands
   */
  command: string;
  /**
   * A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'.
   */
  keyExpr: string;
  /**
   * A JavaScript expression to compute arguments to the operation. Can return an array.
   */
  argsExpr?: string | undefined;
};

/**
 * How the Redis server is configured. Defaults to Standalone
 */
export const RedisAuthTypeManualDeploymentType = {
  /**
   * Standalone
   */
  Standalone: "standalone",
  /**
   * Cluster
   */
  Cluster: "cluster",
  /**
   * Sentinel
   */
  Sentinel: "sentinel",
} as const;
/**
 * How the Redis server is configured. Defaults to Standalone
 */
export type RedisAuthTypeManualDeploymentType = OpenEnum<
  typeof RedisAuthTypeManualDeploymentType
>;

export type RedisAuthTypeManual = {
  authType: "manual";
  username?: string | undefined;
  password: string;
  commands: Array<RedisAuthTypeManualCommand>;
  /**
   * How the Redis server is configured. Defaults to Standalone
   */
  deploymentType?: RedisAuthTypeManualDeploymentType | undefined;
  /**
   * Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable.
   */
  maxBlockSecs?: number | undefined;
  /**
   * Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache.
   */
  enableClientSideCaching?: boolean | undefined;
};

export type RedisAuthTypeNoneCommand = {
  /**
   * Name of the field in which to store the returned value. Leave blank to discard returned value.
   */
  outField?: string | undefined;
  /**
   * Redis command to perform. For a complete list visit: https://redis.io/commands
   */
  command: string;
  /**
   * A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'.
   */
  keyExpr: string;
  /**
   * A JavaScript expression to compute arguments to the operation. Can return an array.
   */
  argsExpr?: string | undefined;
};

/**
 * How the Redis server is configured. Defaults to Standalone
 */
export const RedisAuthTypeNoneDeploymentType = {
  /**
   * Standalone
   */
  Standalone: "standalone",
  /**
   * Cluster
   */
  Cluster: "cluster",
  /**
   * Sentinel
   */
  Sentinel: "sentinel",
} as const;
/**
 * How the Redis server is configured. Defaults to Standalone
 */
export type RedisAuthTypeNoneDeploymentType = OpenEnum<
  typeof RedisAuthTypeNoneDeploymentType
>;

export type RedisAuthTypeNone = {
  authType: "none";
  commands: Array<RedisAuthTypeNoneCommand>;
  /**
   * How the Redis server is configured. Defaults to Standalone
   */
  deploymentType?: RedisAuthTypeNoneDeploymentType | undefined;
  /**
   * Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable.
   */
  maxBlockSecs?: number | undefined;
  /**
   * Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache.
   */
  enableClientSideCaching?: boolean | undefined;
};

/**
 * How the Redis server is configured. Defaults to Standalone
 */
export const RedisDeploymentTypeSentinelTlsFalseDeploymentType = {
  /**
   * Standalone
   */
  Standalone: "standalone",
  /**
   * Cluster
   */
  Cluster: "cluster",
  /**
   * Sentinel
   */
  Sentinel: "sentinel",
} as const;
/**
 * How the Redis server is configured. Defaults to Standalone
 */
export type RedisDeploymentTypeSentinelTlsFalseDeploymentType = OpenEnum<
  typeof RedisDeploymentTypeSentinelTlsFalseDeploymentType
>;

export type RedisDeploymentTypeSentinelTlsFalseRootNode = {
  /**
   * Hostname of sentinel node. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`.
   */
  host: string;
  /**
   * Port of sentinel node
   */
  port: number;
};

export type RedisDeploymentTypeSentinelTlsFalseCommand = {
  /**
   * Name of the field in which to store the returned value. Leave blank to discard returned value.
   */
  outField?: string | undefined;
  /**
   * Redis command to perform. For a complete list visit: https://redis.io/commands
   */
  command: string;
  /**
   * A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'.
   */
  keyExpr: string;
  /**
   * A JavaScript expression to compute arguments to the operation. Can return an array.
   */
  argsExpr?: string | undefined;
};

export const RedisDeploymentTypeSentinelTlsFalseAuthenticationMethod = {
  /**
   * None
   */
  None: "none",
  /**
   * Manual
   */
  Manual: "manual",
  /**
   * User Secret
   */
  CredentialsSecret: "credentialsSecret",
  /**
   * Admin Secret
   */
  TextSecret: "textSecret",
} as const;
export type RedisDeploymentTypeSentinelTlsFalseAuthenticationMethod = OpenEnum<
  typeof RedisDeploymentTypeSentinelTlsFalseAuthenticationMethod
>;

export type RedisDeploymentTypeSentinelTlsFalse = {
  /**
   * Use TLS for connections to this cluster
   */
  tls?: boolean | undefined;
  /**
   * How the Redis server is configured. Defaults to Standalone
   */
  deploymentType?:
    | RedisDeploymentTypeSentinelTlsFalseDeploymentType
    | undefined;
  masterName: string;
  /**
   * List of sentinels to be used
   */
  rootNodes?: Array<RedisDeploymentTypeSentinelTlsFalseRootNode> | undefined;
  commands: Array<RedisDeploymentTypeSentinelTlsFalseCommand>;
  authType?:
    | RedisDeploymentTypeSentinelTlsFalseAuthenticationMethod
    | undefined;
  /**
   * Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable.
   */
  maxBlockSecs?: number | undefined;
  /**
   * Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache.
   */
  enableClientSideCaching?: boolean | undefined;
};

/**
 * How the Redis server is configured. Defaults to Standalone
 */
export const RedisDeploymentTypeSentinelTlsTrueDeploymentType = {
  /**
   * Standalone
   */
  Standalone: "standalone",
  /**
   * Cluster
   */
  Cluster: "cluster",
  /**
   * Sentinel
   */
  Sentinel: "sentinel",
} as const;
/**
 * How the Redis server is configured. Defaults to Standalone
 */
export type RedisDeploymentTypeSentinelTlsTrueDeploymentType = OpenEnum<
  typeof RedisDeploymentTypeSentinelTlsTrueDeploymentType
>;

export type RedisDeploymentTypeSentinelTlsTrueRootNode = {
  /**
   * Hostname of sentinel node. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`.
   */
  host: string;
  /**
   * Port of sentinel node
   */
  port: number;
};

export type RedisDeploymentTypeSentinelTlsTrueCommand = {
  /**
   * Name of the field in which to store the returned value. Leave blank to discard returned value.
   */
  outField?: string | undefined;
  /**
   * Redis command to perform. For a complete list visit: https://redis.io/commands
   */
  command: string;
  /**
   * A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'.
   */
  keyExpr: string;
  /**
   * A JavaScript expression to compute arguments to the operation. Can return an array.
   */
  argsExpr?: string | undefined;
};

export const RedisDeploymentTypeSentinelTlsTrueAuthenticationMethod = {
  /**
   * None
   */
  None: "none",
  /**
   * Manual
   */
  Manual: "manual",
  /**
   * User Secret
   */
  CredentialsSecret: "credentialsSecret",
  /**
   * Admin Secret
   */
  TextSecret: "textSecret",
} as const;
export type RedisDeploymentTypeSentinelTlsTrueAuthenticationMethod = OpenEnum<
  typeof RedisDeploymentTypeSentinelTlsTrueAuthenticationMethod
>;

export type RedisDeploymentTypeSentinelTlsTrue = {
  /**
   * Use TLS for connections to this cluster
   */
  tls?: boolean | undefined;
  tlsOptions?: TlsOptionsTypeRedisDeploymentTypeClusterTlsTrue | undefined;
  /**
   * How the Redis server is configured. Defaults to Standalone
   */
  deploymentType?: RedisDeploymentTypeSentinelTlsTrueDeploymentType | undefined;
  masterName: string;
  /**
   * List of sentinels to be used
   */
  rootNodes?: Array<RedisDeploymentTypeSentinelTlsTrueRootNode> | undefined;
  commands: Array<RedisDeploymentTypeSentinelTlsTrueCommand>;
  authType?: RedisDeploymentTypeSentinelTlsTrueAuthenticationMethod | undefined;
  /**
   * Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable.
   */
  maxBlockSecs?: number | undefined;
  /**
   * Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache.
   */
  enableClientSideCaching?: boolean | undefined;
};

export type RedisDeploymentTypeSentinel =
  | RedisDeploymentTypeSentinelTlsTrue
  | RedisDeploymentTypeSentinelTlsFalse;

/**
 * How the Redis server is configured. Defaults to Standalone
 */
export const RedisDeploymentTypeClusterTlsFalseDeploymentType = {
  /**
   * Standalone
   */
  Standalone: "standalone",
  /**
   * Cluster
   */
  Cluster: "cluster",
  /**
   * Sentinel
   */
  Sentinel: "sentinel",
} as const;
/**
 * How the Redis server is configured. Defaults to Standalone
 */
export type RedisDeploymentTypeClusterTlsFalseDeploymentType = OpenEnum<
  typeof RedisDeploymentTypeClusterTlsFalseDeploymentType
>;

export type RedisDeploymentTypeClusterTlsFalseRootNode = {
  /**
   * Hostname of cluster node. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`.
   */
  host: string;
  /**
   * Port of cluster node
   */
  port: number;
};

/**
 * Which nodes read commands should be sent to
 */
export const RedisDeploymentTypeClusterTlsFalseScaleReads = {
  /**
   * Masters
   */
  Master: "master",
  /**
   * Replicas
   */
  Replica: "replica",
  /**
   * Masters and Replicas
   */
  All: "all",
} as const;
/**
 * Which nodes read commands should be sent to
 */
export type RedisDeploymentTypeClusterTlsFalseScaleReads = OpenEnum<
  typeof RedisDeploymentTypeClusterTlsFalseScaleReads
>;

export type RedisDeploymentTypeClusterTlsFalseCommand = {
  /**
   * Name of the field in which to store the returned value. Leave blank to discard returned value.
   */
  outField?: string | undefined;
  /**
   * Redis command to perform. For a complete list visit: https://redis.io/commands
   */
  command: string;
  /**
   * A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'.
   */
  keyExpr: string;
  /**
   * A JavaScript expression to compute arguments to the operation. Can return an array.
   */
  argsExpr?: string | undefined;
};

export const RedisDeploymentTypeClusterTlsFalseAuthenticationMethod = {
  /**
   * None
   */
  None: "none",
  /**
   * Manual
   */
  Manual: "manual",
  /**
   * User Secret
   */
  CredentialsSecret: "credentialsSecret",
  /**
   * Admin Secret
   */
  TextSecret: "textSecret",
} as const;
export type RedisDeploymentTypeClusterTlsFalseAuthenticationMethod = OpenEnum<
  typeof RedisDeploymentTypeClusterTlsFalseAuthenticationMethod
>;

export type RedisDeploymentTypeClusterTlsFalse = {
  /**
   * Use TLS for connections to this cluster
   */
  tls?: boolean | undefined;
  /**
   * How the Redis server is configured. Defaults to Standalone
   */
  deploymentType?: RedisDeploymentTypeClusterTlsFalseDeploymentType | undefined;
  /**
   * Root nodes to which the cluster connection should be initiated
   */
  rootNodes?: Array<RedisDeploymentTypeClusterTlsFalseRootNode> | undefined;
  /**
   * Which nodes read commands should be sent to
   */
  scaleReads?: RedisDeploymentTypeClusterTlsFalseScaleReads | undefined;
  commands: Array<RedisDeploymentTypeClusterTlsFalseCommand>;
  authType?: RedisDeploymentTypeClusterTlsFalseAuthenticationMethod | undefined;
  /**
   * Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable.
   */
  maxBlockSecs?: number | undefined;
  /**
   * Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache.
   */
  enableClientSideCaching?: boolean | undefined;
};

/**
 * How the Redis server is configured. Defaults to Standalone
 */
export const RedisDeploymentTypeClusterTlsTrueDeploymentType = {
  /**
   * Standalone
   */
  Standalone: "standalone",
  /**
   * Cluster
   */
  Cluster: "cluster",
  /**
   * Sentinel
   */
  Sentinel: "sentinel",
} as const;
/**
 * How the Redis server is configured. Defaults to Standalone
 */
export type RedisDeploymentTypeClusterTlsTrueDeploymentType = OpenEnum<
  typeof RedisDeploymentTypeClusterTlsTrueDeploymentType
>;

export type RedisDeploymentTypeClusterTlsTrueRootNode = {
  /**
   * Hostname of cluster node. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`.
   */
  host: string;
  /**
   * Port of cluster node
   */
  port: number;
};

/**
 * Which nodes read commands should be sent to
 */
export const RedisDeploymentTypeClusterTlsTrueScaleReads = {
  /**
   * Masters
   */
  Master: "master",
  /**
   * Replicas
   */
  Replica: "replica",
  /**
   * Masters and Replicas
   */
  All: "all",
} as const;
/**
 * Which nodes read commands should be sent to
 */
export type RedisDeploymentTypeClusterTlsTrueScaleReads = OpenEnum<
  typeof RedisDeploymentTypeClusterTlsTrueScaleReads
>;

export type RedisDeploymentTypeClusterTlsTrueCommand = {
  /**
   * Name of the field in which to store the returned value. Leave blank to discard returned value.
   */
  outField?: string | undefined;
  /**
   * Redis command to perform. For a complete list visit: https://redis.io/commands
   */
  command: string;
  /**
   * A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'.
   */
  keyExpr: string;
  /**
   * A JavaScript expression to compute arguments to the operation. Can return an array.
   */
  argsExpr?: string | undefined;
};

export const RedisDeploymentTypeClusterTlsTrueAuthenticationMethod = {
  /**
   * None
   */
  None: "none",
  /**
   * Manual
   */
  Manual: "manual",
  /**
   * User Secret
   */
  CredentialsSecret: "credentialsSecret",
  /**
   * Admin Secret
   */
  TextSecret: "textSecret",
} as const;
export type RedisDeploymentTypeClusterTlsTrueAuthenticationMethod = OpenEnum<
  typeof RedisDeploymentTypeClusterTlsTrueAuthenticationMethod
>;

export type RedisDeploymentTypeClusterTlsTrue = {
  /**
   * Use TLS for connections to this cluster
   */
  tls?: boolean | undefined;
  tlsOptions?: TlsOptionsTypeRedisDeploymentTypeClusterTlsTrue | undefined;
  /**
   * How the Redis server is configured. Defaults to Standalone
   */
  deploymentType?: RedisDeploymentTypeClusterTlsTrueDeploymentType | undefined;
  /**
   * Root nodes to which the cluster connection should be initiated
   */
  rootNodes?: Array<RedisDeploymentTypeClusterTlsTrueRootNode> | undefined;
  /**
   * Which nodes read commands should be sent to
   */
  scaleReads?: RedisDeploymentTypeClusterTlsTrueScaleReads | undefined;
  commands: Array<RedisDeploymentTypeClusterTlsTrueCommand>;
  authType?: RedisDeploymentTypeClusterTlsTrueAuthenticationMethod | undefined;
  /**
   * Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable.
   */
  maxBlockSecs?: number | undefined;
  /**
   * Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache.
   */
  enableClientSideCaching?: boolean | undefined;
};

export type RedisDeploymentTypeCluster =
  | RedisDeploymentTypeClusterTlsTrue
  | RedisDeploymentTypeClusterTlsFalse;

/**
 * How the Redis server is configured. Defaults to Standalone
 */
export const RedisDeploymentTypeStandaloneDeploymentType = {
  /**
   * Standalone
   */
  Standalone: "standalone",
  /**
   * Cluster
   */
  Cluster: "cluster",
  /**
   * Sentinel
   */
  Sentinel: "sentinel",
} as const;
/**
 * How the Redis server is configured. Defaults to Standalone
 */
export type RedisDeploymentTypeStandaloneDeploymentType = OpenEnum<
  typeof RedisDeploymentTypeStandaloneDeploymentType
>;

export type TlsOptions = {
  /**
   * Reject certificates that are not authorized by a CA in the 'CA certificate path', or by another trusted CA (such as the system's CA)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. Must be a host name, not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's certificate. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Minimum TLS version to use when connecting
   */
  minVersion?:
    | MinimumTlsVersionOptionsRedisDeploymentTypeStandaloneTlsOptions
    | undefined;
  /**
   * Maximum TLS version to use when connecting
   */
  maxVersion?:
    | MaximumTlsVersionOptionsRedisDeploymentTypeStandaloneTlsOptions
    | undefined;
};

export type RedisDeploymentTypeStandaloneCommand = {
  /**
   * Name of the field in which to store the returned value. Leave blank to discard returned value.
   */
  outField?: string | undefined;
  /**
   * Redis command to perform. For a complete list visit: https://redis.io/commands
   */
  command: string;
  /**
   * A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'.
   */
  keyExpr: string;
  /**
   * A JavaScript expression to compute arguments to the operation. Can return an array.
   */
  argsExpr?: string | undefined;
};

export const RedisDeploymentTypeStandaloneAuthenticationMethod = {
  /**
   * None
   */
  None: "none",
  /**
   * Manual
   */
  Manual: "manual",
  /**
   * User Secret
   */
  CredentialsSecret: "credentialsSecret",
  /**
   * Admin Secret
   */
  TextSecret: "textSecret",
} as const;
export type RedisDeploymentTypeStandaloneAuthenticationMethod = OpenEnum<
  typeof RedisDeploymentTypeStandaloneAuthenticationMethod
>;

export type RedisDeploymentTypeStandalone = {
  /**
   * How the Redis server is configured. Defaults to Standalone
   */
  deploymentType?: RedisDeploymentTypeStandaloneDeploymentType | undefined;
  /**
   * Redis URL to connect to. Format: redis[s]://[[user][:password@]][host][:port][/db-number][?db=db-number[&password=bar[&option=value]]]. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`
   */
  url: string;
  tlsOptions?: TlsOptions | undefined;
  commands: Array<RedisDeploymentTypeStandaloneCommand>;
  authType?: RedisDeploymentTypeStandaloneAuthenticationMethod | undefined;
  /**
   * Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable.
   */
  maxBlockSecs?: number | undefined;
  /**
   * Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache.
   */
  enableClientSideCaching?: boolean | undefined;
};

export type PipelineFunctionRedisConf =
  | RedisAuthTypeNone
  | RedisAuthTypeManual
  | RedisAuthTypeCredentialsSecret
  | RedisAuthTypeTextSecret
  | discriminatedUnionTypes.Unknown<"authType">;

export type PipelineFunctionRedis = {
  /**
   * Filter that selects data to be fed through this Function
   */
  filter?: string | undefined;
  /**
   * Function ID
   */
  id: "redis";
  /**
   * Simple description of this step
   */
  description?: string | undefined;
  /**
   * If true, data will not be pushed through this function
   */
  disabled?: boolean | undefined;
  /**
   * If enabled, stops the results of this Function from being passed to the downstream Functions
   */
  final?: boolean | undefined;
  conf:
    | RedisAuthTypeNone
    | RedisAuthTypeManual
    | RedisAuthTypeCredentialsSecret
    | RedisAuthTypeTextSecret
    | discriminatedUnionTypes.Unknown<"authType">;
  /**
   * Group ID
   */
  groupId?: string | undefined;
};

/** @internal */
export const RedisAuthTypeTextSecretCommand$inboundSchema: z.ZodType<
  RedisAuthTypeTextSecretCommand,
  z.ZodTypeDef,
  unknown
> = z.object({
  outField: types.optional(types.string()),
  command: types.string(),
  keyExpr: types.string(),
  argsExpr: types.optional(types.string()),
});
/** @internal */
export type RedisAuthTypeTextSecretCommand$Outbound = {
  outField?: string | undefined;
  command: string;
  keyExpr: string;
  argsExpr?: string | undefined;
};

/** @internal */
export const RedisAuthTypeTextSecretCommand$outboundSchema: z.ZodType<
  RedisAuthTypeTextSecretCommand$Outbound,
  z.ZodTypeDef,
  RedisAuthTypeTextSecretCommand
> = z.object({
  outField: z.string().optional(),
  command: z.string(),
  keyExpr: z.string(),
  argsExpr: z.string().optional(),
});

export function redisAuthTypeTextSecretCommandToJSON(
  redisAuthTypeTextSecretCommand: RedisAuthTypeTextSecretCommand,
): string {
  return JSON.stringify(
    RedisAuthTypeTextSecretCommand$outboundSchema.parse(
      redisAuthTypeTextSecretCommand,
    ),
  );
}
export function redisAuthTypeTextSecretCommandFromJSON(
  jsonString: string,
): SafeParseResult<RedisAuthTypeTextSecretCommand, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RedisAuthTypeTextSecretCommand$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RedisAuthTypeTextSecretCommand' from JSON`,
  );
}

/** @internal */
export const RedisAuthTypeTextSecretDeploymentType$inboundSchema: z.ZodType<
  RedisAuthTypeTextSecretDeploymentType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RedisAuthTypeTextSecretDeploymentType);
/** @internal */
export const RedisAuthTypeTextSecretDeploymentType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RedisAuthTypeTextSecretDeploymentType
> = openEnums.outboundSchema(RedisAuthTypeTextSecretDeploymentType);

/** @internal */
export const RedisAuthTypeTextSecret$inboundSchema: z.ZodType<
  RedisAuthTypeTextSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: types.literal("textSecret"),
  textSecret: types.string(),
  commands: z.array(z.lazy(() => RedisAuthTypeTextSecretCommand$inboundSchema)),
  deploymentType: types.optional(
    RedisAuthTypeTextSecretDeploymentType$inboundSchema,
  ),
  maxBlockSecs: types.optional(types.number()),
  enableClientSideCaching: types.optional(types.boolean()),
});
/** @internal */
export type RedisAuthTypeTextSecret$Outbound = {
  authType: "textSecret";
  textSecret: string;
  commands: Array<RedisAuthTypeTextSecretCommand$Outbound>;
  deploymentType?: string | undefined;
  maxBlockSecs?: number | undefined;
  enableClientSideCaching?: boolean | undefined;
};

/** @internal */
export const RedisAuthTypeTextSecret$outboundSchema: z.ZodType<
  RedisAuthTypeTextSecret$Outbound,
  z.ZodTypeDef,
  RedisAuthTypeTextSecret
> = z.object({
  authType: z.literal("textSecret"),
  textSecret: z.string(),
  commands: z.array(
    z.lazy(() => RedisAuthTypeTextSecretCommand$outboundSchema),
  ),
  deploymentType: RedisAuthTypeTextSecretDeploymentType$outboundSchema
    .optional(),
  maxBlockSecs: z.number().optional(),
  enableClientSideCaching: z.boolean().optional(),
});

export function redisAuthTypeTextSecretToJSON(
  redisAuthTypeTextSecret: RedisAuthTypeTextSecret,
): string {
  return JSON.stringify(
    RedisAuthTypeTextSecret$outboundSchema.parse(redisAuthTypeTextSecret),
  );
}
export function redisAuthTypeTextSecretFromJSON(
  jsonString: string,
): SafeParseResult<RedisAuthTypeTextSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RedisAuthTypeTextSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RedisAuthTypeTextSecret' from JSON`,
  );
}

/** @internal */
export const RedisAuthTypeCredentialsSecretCommand$inboundSchema: z.ZodType<
  RedisAuthTypeCredentialsSecretCommand,
  z.ZodTypeDef,
  unknown
> = z.object({
  outField: types.optional(types.string()),
  command: types.string(),
  keyExpr: types.string(),
  argsExpr: types.optional(types.string()),
});
/** @internal */
export type RedisAuthTypeCredentialsSecretCommand$Outbound = {
  outField?: string | undefined;
  command: string;
  keyExpr: string;
  argsExpr?: string | undefined;
};

/** @internal */
export const RedisAuthTypeCredentialsSecretCommand$outboundSchema: z.ZodType<
  RedisAuthTypeCredentialsSecretCommand$Outbound,
  z.ZodTypeDef,
  RedisAuthTypeCredentialsSecretCommand
> = z.object({
  outField: z.string().optional(),
  command: z.string(),
  keyExpr: z.string(),
  argsExpr: z.string().optional(),
});

export function redisAuthTypeCredentialsSecretCommandToJSON(
  redisAuthTypeCredentialsSecretCommand: RedisAuthTypeCredentialsSecretCommand,
): string {
  return JSON.stringify(
    RedisAuthTypeCredentialsSecretCommand$outboundSchema.parse(
      redisAuthTypeCredentialsSecretCommand,
    ),
  );
}
export function redisAuthTypeCredentialsSecretCommandFromJSON(
  jsonString: string,
): SafeParseResult<RedisAuthTypeCredentialsSecretCommand, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RedisAuthTypeCredentialsSecretCommand$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RedisAuthTypeCredentialsSecretCommand' from JSON`,
  );
}

/** @internal */
export const RedisAuthTypeCredentialsSecretDeploymentType$inboundSchema:
  z.ZodType<
    RedisAuthTypeCredentialsSecretDeploymentType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RedisAuthTypeCredentialsSecretDeploymentType);
/** @internal */
export const RedisAuthTypeCredentialsSecretDeploymentType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RedisAuthTypeCredentialsSecretDeploymentType
  > = openEnums.outboundSchema(RedisAuthTypeCredentialsSecretDeploymentType);

/** @internal */
export const RedisAuthTypeCredentialsSecret$inboundSchema: z.ZodType<
  RedisAuthTypeCredentialsSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: types.literal("credentialsSecret"),
  credentialsSecret: types.string(),
  commands: z.array(
    z.lazy(() => RedisAuthTypeCredentialsSecretCommand$inboundSchema),
  ),
  deploymentType: types.optional(
    RedisAuthTypeCredentialsSecretDeploymentType$inboundSchema,
  ),
  maxBlockSecs: types.optional(types.number()),
  enableClientSideCaching: types.optional(types.boolean()),
});
/** @internal */
export type RedisAuthTypeCredentialsSecret$Outbound = {
  authType: "credentialsSecret";
  credentialsSecret: string;
  commands: Array<RedisAuthTypeCredentialsSecretCommand$Outbound>;
  deploymentType?: string | undefined;
  maxBlockSecs?: number | undefined;
  enableClientSideCaching?: boolean | undefined;
};

/** @internal */
export const RedisAuthTypeCredentialsSecret$outboundSchema: z.ZodType<
  RedisAuthTypeCredentialsSecret$Outbound,
  z.ZodTypeDef,
  RedisAuthTypeCredentialsSecret
> = z.object({
  authType: z.literal("credentialsSecret"),
  credentialsSecret: z.string(),
  commands: z.array(
    z.lazy(() => RedisAuthTypeCredentialsSecretCommand$outboundSchema),
  ),
  deploymentType: RedisAuthTypeCredentialsSecretDeploymentType$outboundSchema
    .optional(),
  maxBlockSecs: z.number().optional(),
  enableClientSideCaching: z.boolean().optional(),
});

export function redisAuthTypeCredentialsSecretToJSON(
  redisAuthTypeCredentialsSecret: RedisAuthTypeCredentialsSecret,
): string {
  return JSON.stringify(
    RedisAuthTypeCredentialsSecret$outboundSchema.parse(
      redisAuthTypeCredentialsSecret,
    ),
  );
}
export function redisAuthTypeCredentialsSecretFromJSON(
  jsonString: string,
): SafeParseResult<RedisAuthTypeCredentialsSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RedisAuthTypeCredentialsSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RedisAuthTypeCredentialsSecret' from JSON`,
  );
}

/** @internal */
export const RedisAuthTypeManualCommand$inboundSchema: z.ZodType<
  RedisAuthTypeManualCommand,
  z.ZodTypeDef,
  unknown
> = z.object({
  outField: types.optional(types.string()),
  command: types.string(),
  keyExpr: types.string(),
  argsExpr: types.optional(types.string()),
});
/** @internal */
export type RedisAuthTypeManualCommand$Outbound = {
  outField?: string | undefined;
  command: string;
  keyExpr: string;
  argsExpr?: string | undefined;
};

/** @internal */
export const RedisAuthTypeManualCommand$outboundSchema: z.ZodType<
  RedisAuthTypeManualCommand$Outbound,
  z.ZodTypeDef,
  RedisAuthTypeManualCommand
> = z.object({
  outField: z.string().optional(),
  command: z.string(),
  keyExpr: z.string(),
  argsExpr: z.string().optional(),
});

export function redisAuthTypeManualCommandToJSON(
  redisAuthTypeManualCommand: RedisAuthTypeManualCommand,
): string {
  return JSON.stringify(
    RedisAuthTypeManualCommand$outboundSchema.parse(redisAuthTypeManualCommand),
  );
}
export function redisAuthTypeManualCommandFromJSON(
  jsonString: string,
): SafeParseResult<RedisAuthTypeManualCommand, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RedisAuthTypeManualCommand$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RedisAuthTypeManualCommand' from JSON`,
  );
}

/** @internal */
export const RedisAuthTypeManualDeploymentType$inboundSchema: z.ZodType<
  RedisAuthTypeManualDeploymentType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RedisAuthTypeManualDeploymentType);
/** @internal */
export const RedisAuthTypeManualDeploymentType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RedisAuthTypeManualDeploymentType
> = openEnums.outboundSchema(RedisAuthTypeManualDeploymentType);

/** @internal */
export const RedisAuthTypeManual$inboundSchema: z.ZodType<
  RedisAuthTypeManual,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: types.literal("manual"),
  username: types.optional(types.string()),
  password: types.string(),
  commands: z.array(z.lazy(() => RedisAuthTypeManualCommand$inboundSchema)),
  deploymentType: types.optional(
    RedisAuthTypeManualDeploymentType$inboundSchema,
  ),
  maxBlockSecs: types.optional(types.number()),
  enableClientSideCaching: types.optional(types.boolean()),
});
/** @internal */
export type RedisAuthTypeManual$Outbound = {
  authType: "manual";
  username?: string | undefined;
  password: string;
  commands: Array<RedisAuthTypeManualCommand$Outbound>;
  deploymentType?: string | undefined;
  maxBlockSecs?: number | undefined;
  enableClientSideCaching?: boolean | undefined;
};

/** @internal */
export const RedisAuthTypeManual$outboundSchema: z.ZodType<
  RedisAuthTypeManual$Outbound,
  z.ZodTypeDef,
  RedisAuthTypeManual
> = z.object({
  authType: z.literal("manual"),
  username: z.string().optional(),
  password: z.string(),
  commands: z.array(z.lazy(() => RedisAuthTypeManualCommand$outboundSchema)),
  deploymentType: RedisAuthTypeManualDeploymentType$outboundSchema.optional(),
  maxBlockSecs: z.number().optional(),
  enableClientSideCaching: z.boolean().optional(),
});

export function redisAuthTypeManualToJSON(
  redisAuthTypeManual: RedisAuthTypeManual,
): string {
  return JSON.stringify(
    RedisAuthTypeManual$outboundSchema.parse(redisAuthTypeManual),
  );
}
export function redisAuthTypeManualFromJSON(
  jsonString: string,
): SafeParseResult<RedisAuthTypeManual, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RedisAuthTypeManual$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RedisAuthTypeManual' from JSON`,
  );
}

/** @internal */
export const RedisAuthTypeNoneCommand$inboundSchema: z.ZodType<
  RedisAuthTypeNoneCommand,
  z.ZodTypeDef,
  unknown
> = z.object({
  outField: types.optional(types.string()),
  command: types.string(),
  keyExpr: types.string(),
  argsExpr: types.optional(types.string()),
});
/** @internal */
export type RedisAuthTypeNoneCommand$Outbound = {
  outField?: string | undefined;
  command: string;
  keyExpr: string;
  argsExpr?: string | undefined;
};

/** @internal */
export const RedisAuthTypeNoneCommand$outboundSchema: z.ZodType<
  RedisAuthTypeNoneCommand$Outbound,
  z.ZodTypeDef,
  RedisAuthTypeNoneCommand
> = z.object({
  outField: z.string().optional(),
  command: z.string(),
  keyExpr: z.string(),
  argsExpr: z.string().optional(),
});

export function redisAuthTypeNoneCommandToJSON(
  redisAuthTypeNoneCommand: RedisAuthTypeNoneCommand,
): string {
  return JSON.stringify(
    RedisAuthTypeNoneCommand$outboundSchema.parse(redisAuthTypeNoneCommand),
  );
}
export function redisAuthTypeNoneCommandFromJSON(
  jsonString: string,
): SafeParseResult<RedisAuthTypeNoneCommand, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RedisAuthTypeNoneCommand$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RedisAuthTypeNoneCommand' from JSON`,
  );
}

/** @internal */
export const RedisAuthTypeNoneDeploymentType$inboundSchema: z.ZodType<
  RedisAuthTypeNoneDeploymentType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RedisAuthTypeNoneDeploymentType);
/** @internal */
export const RedisAuthTypeNoneDeploymentType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RedisAuthTypeNoneDeploymentType
> = openEnums.outboundSchema(RedisAuthTypeNoneDeploymentType);

/** @internal */
export const RedisAuthTypeNone$inboundSchema: z.ZodType<
  RedisAuthTypeNone,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: types.literal("none"),
  commands: z.array(z.lazy(() => RedisAuthTypeNoneCommand$inboundSchema)),
  deploymentType: types.optional(RedisAuthTypeNoneDeploymentType$inboundSchema),
  maxBlockSecs: types.optional(types.number()),
  enableClientSideCaching: types.optional(types.boolean()),
});
/** @internal */
export type RedisAuthTypeNone$Outbound = {
  authType: "none";
  commands: Array<RedisAuthTypeNoneCommand$Outbound>;
  deploymentType?: string | undefined;
  maxBlockSecs?: number | undefined;
  enableClientSideCaching?: boolean | undefined;
};

/** @internal */
export const RedisAuthTypeNone$outboundSchema: z.ZodType<
  RedisAuthTypeNone$Outbound,
  z.ZodTypeDef,
  RedisAuthTypeNone
> = z.object({
  authType: z.literal("none"),
  commands: z.array(z.lazy(() => RedisAuthTypeNoneCommand$outboundSchema)),
  deploymentType: RedisAuthTypeNoneDeploymentType$outboundSchema.optional(),
  maxBlockSecs: z.number().optional(),
  enableClientSideCaching: z.boolean().optional(),
});

export function redisAuthTypeNoneToJSON(
  redisAuthTypeNone: RedisAuthTypeNone,
): string {
  return JSON.stringify(
    RedisAuthTypeNone$outboundSchema.parse(redisAuthTypeNone),
  );
}
export function redisAuthTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<RedisAuthTypeNone, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RedisAuthTypeNone$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RedisAuthTypeNone' from JSON`,
  );
}

/** @internal */
export const RedisDeploymentTypeSentinelTlsFalseDeploymentType$inboundSchema:
  z.ZodType<
    RedisDeploymentTypeSentinelTlsFalseDeploymentType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RedisDeploymentTypeSentinelTlsFalseDeploymentType,
  );
/** @internal */
export const RedisDeploymentTypeSentinelTlsFalseDeploymentType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RedisDeploymentTypeSentinelTlsFalseDeploymentType
  > = openEnums.outboundSchema(
    RedisDeploymentTypeSentinelTlsFalseDeploymentType,
  );

/** @internal */
export const RedisDeploymentTypeSentinelTlsFalseRootNode$inboundSchema:
  z.ZodType<
    RedisDeploymentTypeSentinelTlsFalseRootNode,
    z.ZodTypeDef,
    unknown
  > = z.object({
    host: types.string(),
    port: types.number(),
  });
/** @internal */
export type RedisDeploymentTypeSentinelTlsFalseRootNode$Outbound = {
  host: string;
  port: number;
};

/** @internal */
export const RedisDeploymentTypeSentinelTlsFalseRootNode$outboundSchema:
  z.ZodType<
    RedisDeploymentTypeSentinelTlsFalseRootNode$Outbound,
    z.ZodTypeDef,
    RedisDeploymentTypeSentinelTlsFalseRootNode
  > = z.object({
    host: z.string(),
    port: z.number(),
  });

export function redisDeploymentTypeSentinelTlsFalseRootNodeToJSON(
  redisDeploymentTypeSentinelTlsFalseRootNode:
    RedisDeploymentTypeSentinelTlsFalseRootNode,
): string {
  return JSON.stringify(
    RedisDeploymentTypeSentinelTlsFalseRootNode$outboundSchema.parse(
      redisDeploymentTypeSentinelTlsFalseRootNode,
    ),
  );
}
export function redisDeploymentTypeSentinelTlsFalseRootNodeFromJSON(
  jsonString: string,
): SafeParseResult<
  RedisDeploymentTypeSentinelTlsFalseRootNode,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RedisDeploymentTypeSentinelTlsFalseRootNode$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RedisDeploymentTypeSentinelTlsFalseRootNode' from JSON`,
  );
}

/** @internal */
export const RedisDeploymentTypeSentinelTlsFalseCommand$inboundSchema:
  z.ZodType<RedisDeploymentTypeSentinelTlsFalseCommand, z.ZodTypeDef, unknown> =
    z.object({
      outField: types.optional(types.string()),
      command: types.string(),
      keyExpr: types.string(),
      argsExpr: types.optional(types.string()),
    });
/** @internal */
export type RedisDeploymentTypeSentinelTlsFalseCommand$Outbound = {
  outField?: string | undefined;
  command: string;
  keyExpr: string;
  argsExpr?: string | undefined;
};

/** @internal */
export const RedisDeploymentTypeSentinelTlsFalseCommand$outboundSchema:
  z.ZodType<
    RedisDeploymentTypeSentinelTlsFalseCommand$Outbound,
    z.ZodTypeDef,
    RedisDeploymentTypeSentinelTlsFalseCommand
  > = z.object({
    outField: z.string().optional(),
    command: z.string(),
    keyExpr: z.string(),
    argsExpr: z.string().optional(),
  });

export function redisDeploymentTypeSentinelTlsFalseCommandToJSON(
  redisDeploymentTypeSentinelTlsFalseCommand:
    RedisDeploymentTypeSentinelTlsFalseCommand,
): string {
  return JSON.stringify(
    RedisDeploymentTypeSentinelTlsFalseCommand$outboundSchema.parse(
      redisDeploymentTypeSentinelTlsFalseCommand,
    ),
  );
}
export function redisDeploymentTypeSentinelTlsFalseCommandFromJSON(
  jsonString: string,
): SafeParseResult<
  RedisDeploymentTypeSentinelTlsFalseCommand,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RedisDeploymentTypeSentinelTlsFalseCommand$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RedisDeploymentTypeSentinelTlsFalseCommand' from JSON`,
  );
}

/** @internal */
export const RedisDeploymentTypeSentinelTlsFalseAuthenticationMethod$inboundSchema:
  z.ZodType<
    RedisDeploymentTypeSentinelTlsFalseAuthenticationMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RedisDeploymentTypeSentinelTlsFalseAuthenticationMethod,
  );
/** @internal */
export const RedisDeploymentTypeSentinelTlsFalseAuthenticationMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RedisDeploymentTypeSentinelTlsFalseAuthenticationMethod
  > = openEnums.outboundSchema(
    RedisDeploymentTypeSentinelTlsFalseAuthenticationMethod,
  );

/** @internal */
export const RedisDeploymentTypeSentinelTlsFalse$inboundSchema: z.ZodType<
  RedisDeploymentTypeSentinelTlsFalse,
  z.ZodTypeDef,
  unknown
> = z.object({
  tls: types.optional(types.boolean()),
  deploymentType: types.optional(
    RedisDeploymentTypeSentinelTlsFalseDeploymentType$inboundSchema,
  ),
  masterName: types.string(),
  rootNodes: types.optional(
    z.array(z.lazy(() =>
      RedisDeploymentTypeSentinelTlsFalseRootNode$inboundSchema
    )),
  ),
  commands: z.array(
    z.lazy(() => RedisDeploymentTypeSentinelTlsFalseCommand$inboundSchema),
  ),
  authType: types.optional(
    RedisDeploymentTypeSentinelTlsFalseAuthenticationMethod$inboundSchema,
  ),
  maxBlockSecs: types.optional(types.number()),
  enableClientSideCaching: types.optional(types.boolean()),
});
/** @internal */
export type RedisDeploymentTypeSentinelTlsFalse$Outbound = {
  tls?: boolean | undefined;
  deploymentType?: string | undefined;
  masterName: string;
  rootNodes?:
    | Array<RedisDeploymentTypeSentinelTlsFalseRootNode$Outbound>
    | undefined;
  commands: Array<RedisDeploymentTypeSentinelTlsFalseCommand$Outbound>;
  authType?: string | undefined;
  maxBlockSecs?: number | undefined;
  enableClientSideCaching?: boolean | undefined;
};

/** @internal */
export const RedisDeploymentTypeSentinelTlsFalse$outboundSchema: z.ZodType<
  RedisDeploymentTypeSentinelTlsFalse$Outbound,
  z.ZodTypeDef,
  RedisDeploymentTypeSentinelTlsFalse
> = z.object({
  tls: z.boolean().optional(),
  deploymentType:
    RedisDeploymentTypeSentinelTlsFalseDeploymentType$outboundSchema.optional(),
  masterName: z.string(),
  rootNodes: z.array(
    z.lazy(() => RedisDeploymentTypeSentinelTlsFalseRootNode$outboundSchema),
  ).optional(),
  commands: z.array(
    z.lazy(() => RedisDeploymentTypeSentinelTlsFalseCommand$outboundSchema),
  ),
  authType:
    RedisDeploymentTypeSentinelTlsFalseAuthenticationMethod$outboundSchema
      .optional(),
  maxBlockSecs: z.number().optional(),
  enableClientSideCaching: z.boolean().optional(),
});

export function redisDeploymentTypeSentinelTlsFalseToJSON(
  redisDeploymentTypeSentinelTlsFalse: RedisDeploymentTypeSentinelTlsFalse,
): string {
  return JSON.stringify(
    RedisDeploymentTypeSentinelTlsFalse$outboundSchema.parse(
      redisDeploymentTypeSentinelTlsFalse,
    ),
  );
}
export function redisDeploymentTypeSentinelTlsFalseFromJSON(
  jsonString: string,
): SafeParseResult<RedisDeploymentTypeSentinelTlsFalse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RedisDeploymentTypeSentinelTlsFalse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RedisDeploymentTypeSentinelTlsFalse' from JSON`,
  );
}

/** @internal */
export const RedisDeploymentTypeSentinelTlsTrueDeploymentType$inboundSchema:
  z.ZodType<
    RedisDeploymentTypeSentinelTlsTrueDeploymentType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RedisDeploymentTypeSentinelTlsTrueDeploymentType);
/** @internal */
export const RedisDeploymentTypeSentinelTlsTrueDeploymentType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RedisDeploymentTypeSentinelTlsTrueDeploymentType
  > = openEnums.outboundSchema(
    RedisDeploymentTypeSentinelTlsTrueDeploymentType,
  );

/** @internal */
export const RedisDeploymentTypeSentinelTlsTrueRootNode$inboundSchema:
  z.ZodType<RedisDeploymentTypeSentinelTlsTrueRootNode, z.ZodTypeDef, unknown> =
    z.object({
      host: types.string(),
      port: types.number(),
    });
/** @internal */
export type RedisDeploymentTypeSentinelTlsTrueRootNode$Outbound = {
  host: string;
  port: number;
};

/** @internal */
export const RedisDeploymentTypeSentinelTlsTrueRootNode$outboundSchema:
  z.ZodType<
    RedisDeploymentTypeSentinelTlsTrueRootNode$Outbound,
    z.ZodTypeDef,
    RedisDeploymentTypeSentinelTlsTrueRootNode
  > = z.object({
    host: z.string(),
    port: z.number(),
  });

export function redisDeploymentTypeSentinelTlsTrueRootNodeToJSON(
  redisDeploymentTypeSentinelTlsTrueRootNode:
    RedisDeploymentTypeSentinelTlsTrueRootNode,
): string {
  return JSON.stringify(
    RedisDeploymentTypeSentinelTlsTrueRootNode$outboundSchema.parse(
      redisDeploymentTypeSentinelTlsTrueRootNode,
    ),
  );
}
export function redisDeploymentTypeSentinelTlsTrueRootNodeFromJSON(
  jsonString: string,
): SafeParseResult<
  RedisDeploymentTypeSentinelTlsTrueRootNode,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RedisDeploymentTypeSentinelTlsTrueRootNode$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RedisDeploymentTypeSentinelTlsTrueRootNode' from JSON`,
  );
}

/** @internal */
export const RedisDeploymentTypeSentinelTlsTrueCommand$inboundSchema: z.ZodType<
  RedisDeploymentTypeSentinelTlsTrueCommand,
  z.ZodTypeDef,
  unknown
> = z.object({
  outField: types.optional(types.string()),
  command: types.string(),
  keyExpr: types.string(),
  argsExpr: types.optional(types.string()),
});
/** @internal */
export type RedisDeploymentTypeSentinelTlsTrueCommand$Outbound = {
  outField?: string | undefined;
  command: string;
  keyExpr: string;
  argsExpr?: string | undefined;
};

/** @internal */
export const RedisDeploymentTypeSentinelTlsTrueCommand$outboundSchema:
  z.ZodType<
    RedisDeploymentTypeSentinelTlsTrueCommand$Outbound,
    z.ZodTypeDef,
    RedisDeploymentTypeSentinelTlsTrueCommand
  > = z.object({
    outField: z.string().optional(),
    command: z.string(),
    keyExpr: z.string(),
    argsExpr: z.string().optional(),
  });

export function redisDeploymentTypeSentinelTlsTrueCommandToJSON(
  redisDeploymentTypeSentinelTlsTrueCommand:
    RedisDeploymentTypeSentinelTlsTrueCommand,
): string {
  return JSON.stringify(
    RedisDeploymentTypeSentinelTlsTrueCommand$outboundSchema.parse(
      redisDeploymentTypeSentinelTlsTrueCommand,
    ),
  );
}
export function redisDeploymentTypeSentinelTlsTrueCommandFromJSON(
  jsonString: string,
): SafeParseResult<
  RedisDeploymentTypeSentinelTlsTrueCommand,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RedisDeploymentTypeSentinelTlsTrueCommand$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RedisDeploymentTypeSentinelTlsTrueCommand' from JSON`,
  );
}

/** @internal */
export const RedisDeploymentTypeSentinelTlsTrueAuthenticationMethod$inboundSchema:
  z.ZodType<
    RedisDeploymentTypeSentinelTlsTrueAuthenticationMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RedisDeploymentTypeSentinelTlsTrueAuthenticationMethod,
  );
/** @internal */
export const RedisDeploymentTypeSentinelTlsTrueAuthenticationMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RedisDeploymentTypeSentinelTlsTrueAuthenticationMethod
  > = openEnums.outboundSchema(
    RedisDeploymentTypeSentinelTlsTrueAuthenticationMethod,
  );

/** @internal */
export const RedisDeploymentTypeSentinelTlsTrue$inboundSchema: z.ZodType<
  RedisDeploymentTypeSentinelTlsTrue,
  z.ZodTypeDef,
  unknown
> = z.object({
  tls: types.optional(types.boolean()),
  tlsOptions: types.optional(
    TlsOptionsTypeRedisDeploymentTypeClusterTlsTrue$inboundSchema,
  ),
  deploymentType: types.optional(
    RedisDeploymentTypeSentinelTlsTrueDeploymentType$inboundSchema,
  ),
  masterName: types.string(),
  rootNodes: types.optional(
    z.array(z.lazy(() =>
      RedisDeploymentTypeSentinelTlsTrueRootNode$inboundSchema
    )),
  ),
  commands: z.array(
    z.lazy(() => RedisDeploymentTypeSentinelTlsTrueCommand$inboundSchema),
  ),
  authType: types.optional(
    RedisDeploymentTypeSentinelTlsTrueAuthenticationMethod$inboundSchema,
  ),
  maxBlockSecs: types.optional(types.number()),
  enableClientSideCaching: types.optional(types.boolean()),
});
/** @internal */
export type RedisDeploymentTypeSentinelTlsTrue$Outbound = {
  tls?: boolean | undefined;
  tlsOptions?:
    | TlsOptionsTypeRedisDeploymentTypeClusterTlsTrue$Outbound
    | undefined;
  deploymentType?: string | undefined;
  masterName: string;
  rootNodes?:
    | Array<RedisDeploymentTypeSentinelTlsTrueRootNode$Outbound>
    | undefined;
  commands: Array<RedisDeploymentTypeSentinelTlsTrueCommand$Outbound>;
  authType?: string | undefined;
  maxBlockSecs?: number | undefined;
  enableClientSideCaching?: boolean | undefined;
};

/** @internal */
export const RedisDeploymentTypeSentinelTlsTrue$outboundSchema: z.ZodType<
  RedisDeploymentTypeSentinelTlsTrue$Outbound,
  z.ZodTypeDef,
  RedisDeploymentTypeSentinelTlsTrue
> = z.object({
  tls: z.boolean().optional(),
  tlsOptions: TlsOptionsTypeRedisDeploymentTypeClusterTlsTrue$outboundSchema
    .optional(),
  deploymentType:
    RedisDeploymentTypeSentinelTlsTrueDeploymentType$outboundSchema.optional(),
  masterName: z.string(),
  rootNodes: z.array(
    z.lazy(() => RedisDeploymentTypeSentinelTlsTrueRootNode$outboundSchema),
  ).optional(),
  commands: z.array(
    z.lazy(() => RedisDeploymentTypeSentinelTlsTrueCommand$outboundSchema),
  ),
  authType:
    RedisDeploymentTypeSentinelTlsTrueAuthenticationMethod$outboundSchema
      .optional(),
  maxBlockSecs: z.number().optional(),
  enableClientSideCaching: z.boolean().optional(),
});

export function redisDeploymentTypeSentinelTlsTrueToJSON(
  redisDeploymentTypeSentinelTlsTrue: RedisDeploymentTypeSentinelTlsTrue,
): string {
  return JSON.stringify(
    RedisDeploymentTypeSentinelTlsTrue$outboundSchema.parse(
      redisDeploymentTypeSentinelTlsTrue,
    ),
  );
}
export function redisDeploymentTypeSentinelTlsTrueFromJSON(
  jsonString: string,
): SafeParseResult<RedisDeploymentTypeSentinelTlsTrue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RedisDeploymentTypeSentinelTlsTrue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RedisDeploymentTypeSentinelTlsTrue' from JSON`,
  );
}

/** @internal */
export const RedisDeploymentTypeSentinel$inboundSchema: z.ZodType<
  RedisDeploymentTypeSentinel,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => RedisDeploymentTypeSentinelTlsTrue$inboundSchema),
  z.lazy(() => RedisDeploymentTypeSentinelTlsFalse$inboundSchema),
]);
/** @internal */
export type RedisDeploymentTypeSentinel$Outbound =
  | RedisDeploymentTypeSentinelTlsTrue$Outbound
  | RedisDeploymentTypeSentinelTlsFalse$Outbound;

/** @internal */
export const RedisDeploymentTypeSentinel$outboundSchema: z.ZodType<
  RedisDeploymentTypeSentinel$Outbound,
  z.ZodTypeDef,
  RedisDeploymentTypeSentinel
> = smartUnion([
  z.lazy(() => RedisDeploymentTypeSentinelTlsTrue$outboundSchema),
  z.lazy(() => RedisDeploymentTypeSentinelTlsFalse$outboundSchema),
]);

export function redisDeploymentTypeSentinelToJSON(
  redisDeploymentTypeSentinel: RedisDeploymentTypeSentinel,
): string {
  return JSON.stringify(
    RedisDeploymentTypeSentinel$outboundSchema.parse(
      redisDeploymentTypeSentinel,
    ),
  );
}
export function redisDeploymentTypeSentinelFromJSON(
  jsonString: string,
): SafeParseResult<RedisDeploymentTypeSentinel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RedisDeploymentTypeSentinel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RedisDeploymentTypeSentinel' from JSON`,
  );
}

/** @internal */
export const RedisDeploymentTypeClusterTlsFalseDeploymentType$inboundSchema:
  z.ZodType<
    RedisDeploymentTypeClusterTlsFalseDeploymentType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RedisDeploymentTypeClusterTlsFalseDeploymentType);
/** @internal */
export const RedisDeploymentTypeClusterTlsFalseDeploymentType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RedisDeploymentTypeClusterTlsFalseDeploymentType
  > = openEnums.outboundSchema(
    RedisDeploymentTypeClusterTlsFalseDeploymentType,
  );

/** @internal */
export const RedisDeploymentTypeClusterTlsFalseRootNode$inboundSchema:
  z.ZodType<RedisDeploymentTypeClusterTlsFalseRootNode, z.ZodTypeDef, unknown> =
    z.object({
      host: types.string(),
      port: types.number(),
    });
/** @internal */
export type RedisDeploymentTypeClusterTlsFalseRootNode$Outbound = {
  host: string;
  port: number;
};

/** @internal */
export const RedisDeploymentTypeClusterTlsFalseRootNode$outboundSchema:
  z.ZodType<
    RedisDeploymentTypeClusterTlsFalseRootNode$Outbound,
    z.ZodTypeDef,
    RedisDeploymentTypeClusterTlsFalseRootNode
  > = z.object({
    host: z.string(),
    port: z.number(),
  });

export function redisDeploymentTypeClusterTlsFalseRootNodeToJSON(
  redisDeploymentTypeClusterTlsFalseRootNode:
    RedisDeploymentTypeClusterTlsFalseRootNode,
): string {
  return JSON.stringify(
    RedisDeploymentTypeClusterTlsFalseRootNode$outboundSchema.parse(
      redisDeploymentTypeClusterTlsFalseRootNode,
    ),
  );
}
export function redisDeploymentTypeClusterTlsFalseRootNodeFromJSON(
  jsonString: string,
): SafeParseResult<
  RedisDeploymentTypeClusterTlsFalseRootNode,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RedisDeploymentTypeClusterTlsFalseRootNode$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RedisDeploymentTypeClusterTlsFalseRootNode' from JSON`,
  );
}

/** @internal */
export const RedisDeploymentTypeClusterTlsFalseScaleReads$inboundSchema:
  z.ZodType<
    RedisDeploymentTypeClusterTlsFalseScaleReads,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RedisDeploymentTypeClusterTlsFalseScaleReads);
/** @internal */
export const RedisDeploymentTypeClusterTlsFalseScaleReads$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RedisDeploymentTypeClusterTlsFalseScaleReads
  > = openEnums.outboundSchema(RedisDeploymentTypeClusterTlsFalseScaleReads);

/** @internal */
export const RedisDeploymentTypeClusterTlsFalseCommand$inboundSchema: z.ZodType<
  RedisDeploymentTypeClusterTlsFalseCommand,
  z.ZodTypeDef,
  unknown
> = z.object({
  outField: types.optional(types.string()),
  command: types.string(),
  keyExpr: types.string(),
  argsExpr: types.optional(types.string()),
});
/** @internal */
export type RedisDeploymentTypeClusterTlsFalseCommand$Outbound = {
  outField?: string | undefined;
  command: string;
  keyExpr: string;
  argsExpr?: string | undefined;
};

/** @internal */
export const RedisDeploymentTypeClusterTlsFalseCommand$outboundSchema:
  z.ZodType<
    RedisDeploymentTypeClusterTlsFalseCommand$Outbound,
    z.ZodTypeDef,
    RedisDeploymentTypeClusterTlsFalseCommand
  > = z.object({
    outField: z.string().optional(),
    command: z.string(),
    keyExpr: z.string(),
    argsExpr: z.string().optional(),
  });

export function redisDeploymentTypeClusterTlsFalseCommandToJSON(
  redisDeploymentTypeClusterTlsFalseCommand:
    RedisDeploymentTypeClusterTlsFalseCommand,
): string {
  return JSON.stringify(
    RedisDeploymentTypeClusterTlsFalseCommand$outboundSchema.parse(
      redisDeploymentTypeClusterTlsFalseCommand,
    ),
  );
}
export function redisDeploymentTypeClusterTlsFalseCommandFromJSON(
  jsonString: string,
): SafeParseResult<
  RedisDeploymentTypeClusterTlsFalseCommand,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RedisDeploymentTypeClusterTlsFalseCommand$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RedisDeploymentTypeClusterTlsFalseCommand' from JSON`,
  );
}

/** @internal */
export const RedisDeploymentTypeClusterTlsFalseAuthenticationMethod$inboundSchema:
  z.ZodType<
    RedisDeploymentTypeClusterTlsFalseAuthenticationMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RedisDeploymentTypeClusterTlsFalseAuthenticationMethod,
  );
/** @internal */
export const RedisDeploymentTypeClusterTlsFalseAuthenticationMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RedisDeploymentTypeClusterTlsFalseAuthenticationMethod
  > = openEnums.outboundSchema(
    RedisDeploymentTypeClusterTlsFalseAuthenticationMethod,
  );

/** @internal */
export const RedisDeploymentTypeClusterTlsFalse$inboundSchema: z.ZodType<
  RedisDeploymentTypeClusterTlsFalse,
  z.ZodTypeDef,
  unknown
> = z.object({
  tls: types.optional(types.boolean()),
  deploymentType: types.optional(
    RedisDeploymentTypeClusterTlsFalseDeploymentType$inboundSchema,
  ),
  rootNodes: types.optional(
    z.array(z.lazy(() =>
      RedisDeploymentTypeClusterTlsFalseRootNode$inboundSchema
    )),
  ),
  scaleReads: types.optional(
    RedisDeploymentTypeClusterTlsFalseScaleReads$inboundSchema,
  ),
  commands: z.array(
    z.lazy(() => RedisDeploymentTypeClusterTlsFalseCommand$inboundSchema),
  ),
  authType: types.optional(
    RedisDeploymentTypeClusterTlsFalseAuthenticationMethod$inboundSchema,
  ),
  maxBlockSecs: types.optional(types.number()),
  enableClientSideCaching: types.optional(types.boolean()),
});
/** @internal */
export type RedisDeploymentTypeClusterTlsFalse$Outbound = {
  tls?: boolean | undefined;
  deploymentType?: string | undefined;
  rootNodes?:
    | Array<RedisDeploymentTypeClusterTlsFalseRootNode$Outbound>
    | undefined;
  scaleReads?: string | undefined;
  commands: Array<RedisDeploymentTypeClusterTlsFalseCommand$Outbound>;
  authType?: string | undefined;
  maxBlockSecs?: number | undefined;
  enableClientSideCaching?: boolean | undefined;
};

/** @internal */
export const RedisDeploymentTypeClusterTlsFalse$outboundSchema: z.ZodType<
  RedisDeploymentTypeClusterTlsFalse$Outbound,
  z.ZodTypeDef,
  RedisDeploymentTypeClusterTlsFalse
> = z.object({
  tls: z.boolean().optional(),
  deploymentType:
    RedisDeploymentTypeClusterTlsFalseDeploymentType$outboundSchema.optional(),
  rootNodes: z.array(
    z.lazy(() => RedisDeploymentTypeClusterTlsFalseRootNode$outboundSchema),
  ).optional(),
  scaleReads: RedisDeploymentTypeClusterTlsFalseScaleReads$outboundSchema
    .optional(),
  commands: z.array(
    z.lazy(() => RedisDeploymentTypeClusterTlsFalseCommand$outboundSchema),
  ),
  authType:
    RedisDeploymentTypeClusterTlsFalseAuthenticationMethod$outboundSchema
      .optional(),
  maxBlockSecs: z.number().optional(),
  enableClientSideCaching: z.boolean().optional(),
});

export function redisDeploymentTypeClusterTlsFalseToJSON(
  redisDeploymentTypeClusterTlsFalse: RedisDeploymentTypeClusterTlsFalse,
): string {
  return JSON.stringify(
    RedisDeploymentTypeClusterTlsFalse$outboundSchema.parse(
      redisDeploymentTypeClusterTlsFalse,
    ),
  );
}
export function redisDeploymentTypeClusterTlsFalseFromJSON(
  jsonString: string,
): SafeParseResult<RedisDeploymentTypeClusterTlsFalse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RedisDeploymentTypeClusterTlsFalse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RedisDeploymentTypeClusterTlsFalse' from JSON`,
  );
}

/** @internal */
export const RedisDeploymentTypeClusterTlsTrueDeploymentType$inboundSchema:
  z.ZodType<
    RedisDeploymentTypeClusterTlsTrueDeploymentType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RedisDeploymentTypeClusterTlsTrueDeploymentType);
/** @internal */
export const RedisDeploymentTypeClusterTlsTrueDeploymentType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RedisDeploymentTypeClusterTlsTrueDeploymentType
  > = openEnums.outboundSchema(RedisDeploymentTypeClusterTlsTrueDeploymentType);

/** @internal */
export const RedisDeploymentTypeClusterTlsTrueRootNode$inboundSchema: z.ZodType<
  RedisDeploymentTypeClusterTlsTrueRootNode,
  z.ZodTypeDef,
  unknown
> = z.object({
  host: types.string(),
  port: types.number(),
});
/** @internal */
export type RedisDeploymentTypeClusterTlsTrueRootNode$Outbound = {
  host: string;
  port: number;
};

/** @internal */
export const RedisDeploymentTypeClusterTlsTrueRootNode$outboundSchema:
  z.ZodType<
    RedisDeploymentTypeClusterTlsTrueRootNode$Outbound,
    z.ZodTypeDef,
    RedisDeploymentTypeClusterTlsTrueRootNode
  > = z.object({
    host: z.string(),
    port: z.number(),
  });

export function redisDeploymentTypeClusterTlsTrueRootNodeToJSON(
  redisDeploymentTypeClusterTlsTrueRootNode:
    RedisDeploymentTypeClusterTlsTrueRootNode,
): string {
  return JSON.stringify(
    RedisDeploymentTypeClusterTlsTrueRootNode$outboundSchema.parse(
      redisDeploymentTypeClusterTlsTrueRootNode,
    ),
  );
}
export function redisDeploymentTypeClusterTlsTrueRootNodeFromJSON(
  jsonString: string,
): SafeParseResult<
  RedisDeploymentTypeClusterTlsTrueRootNode,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RedisDeploymentTypeClusterTlsTrueRootNode$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RedisDeploymentTypeClusterTlsTrueRootNode' from JSON`,
  );
}

/** @internal */
export const RedisDeploymentTypeClusterTlsTrueScaleReads$inboundSchema:
  z.ZodType<
    RedisDeploymentTypeClusterTlsTrueScaleReads,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RedisDeploymentTypeClusterTlsTrueScaleReads);
/** @internal */
export const RedisDeploymentTypeClusterTlsTrueScaleReads$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RedisDeploymentTypeClusterTlsTrueScaleReads> =
    openEnums.outboundSchema(RedisDeploymentTypeClusterTlsTrueScaleReads);

/** @internal */
export const RedisDeploymentTypeClusterTlsTrueCommand$inboundSchema: z.ZodType<
  RedisDeploymentTypeClusterTlsTrueCommand,
  z.ZodTypeDef,
  unknown
> = z.object({
  outField: types.optional(types.string()),
  command: types.string(),
  keyExpr: types.string(),
  argsExpr: types.optional(types.string()),
});
/** @internal */
export type RedisDeploymentTypeClusterTlsTrueCommand$Outbound = {
  outField?: string | undefined;
  command: string;
  keyExpr: string;
  argsExpr?: string | undefined;
};

/** @internal */
export const RedisDeploymentTypeClusterTlsTrueCommand$outboundSchema: z.ZodType<
  RedisDeploymentTypeClusterTlsTrueCommand$Outbound,
  z.ZodTypeDef,
  RedisDeploymentTypeClusterTlsTrueCommand
> = z.object({
  outField: z.string().optional(),
  command: z.string(),
  keyExpr: z.string(),
  argsExpr: z.string().optional(),
});

export function redisDeploymentTypeClusterTlsTrueCommandToJSON(
  redisDeploymentTypeClusterTlsTrueCommand:
    RedisDeploymentTypeClusterTlsTrueCommand,
): string {
  return JSON.stringify(
    RedisDeploymentTypeClusterTlsTrueCommand$outboundSchema.parse(
      redisDeploymentTypeClusterTlsTrueCommand,
    ),
  );
}
export function redisDeploymentTypeClusterTlsTrueCommandFromJSON(
  jsonString: string,
): SafeParseResult<
  RedisDeploymentTypeClusterTlsTrueCommand,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RedisDeploymentTypeClusterTlsTrueCommand$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RedisDeploymentTypeClusterTlsTrueCommand' from JSON`,
  );
}

/** @internal */
export const RedisDeploymentTypeClusterTlsTrueAuthenticationMethod$inboundSchema:
  z.ZodType<
    RedisDeploymentTypeClusterTlsTrueAuthenticationMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RedisDeploymentTypeClusterTlsTrueAuthenticationMethod,
  );
/** @internal */
export const RedisDeploymentTypeClusterTlsTrueAuthenticationMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RedisDeploymentTypeClusterTlsTrueAuthenticationMethod
  > = openEnums.outboundSchema(
    RedisDeploymentTypeClusterTlsTrueAuthenticationMethod,
  );

/** @internal */
export const RedisDeploymentTypeClusterTlsTrue$inboundSchema: z.ZodType<
  RedisDeploymentTypeClusterTlsTrue,
  z.ZodTypeDef,
  unknown
> = z.object({
  tls: types.optional(types.boolean()),
  tlsOptions: types.optional(
    TlsOptionsTypeRedisDeploymentTypeClusterTlsTrue$inboundSchema,
  ),
  deploymentType: types.optional(
    RedisDeploymentTypeClusterTlsTrueDeploymentType$inboundSchema,
  ),
  rootNodes: types.optional(
    z.array(
      z.lazy(() => RedisDeploymentTypeClusterTlsTrueRootNode$inboundSchema),
    ),
  ),
  scaleReads: types.optional(
    RedisDeploymentTypeClusterTlsTrueScaleReads$inboundSchema,
  ),
  commands: z.array(
    z.lazy(() => RedisDeploymentTypeClusterTlsTrueCommand$inboundSchema),
  ),
  authType: types.optional(
    RedisDeploymentTypeClusterTlsTrueAuthenticationMethod$inboundSchema,
  ),
  maxBlockSecs: types.optional(types.number()),
  enableClientSideCaching: types.optional(types.boolean()),
});
/** @internal */
export type RedisDeploymentTypeClusterTlsTrue$Outbound = {
  tls?: boolean | undefined;
  tlsOptions?:
    | TlsOptionsTypeRedisDeploymentTypeClusterTlsTrue$Outbound
    | undefined;
  deploymentType?: string | undefined;
  rootNodes?:
    | Array<RedisDeploymentTypeClusterTlsTrueRootNode$Outbound>
    | undefined;
  scaleReads?: string | undefined;
  commands: Array<RedisDeploymentTypeClusterTlsTrueCommand$Outbound>;
  authType?: string | undefined;
  maxBlockSecs?: number | undefined;
  enableClientSideCaching?: boolean | undefined;
};

/** @internal */
export const RedisDeploymentTypeClusterTlsTrue$outboundSchema: z.ZodType<
  RedisDeploymentTypeClusterTlsTrue$Outbound,
  z.ZodTypeDef,
  RedisDeploymentTypeClusterTlsTrue
> = z.object({
  tls: z.boolean().optional(),
  tlsOptions: TlsOptionsTypeRedisDeploymentTypeClusterTlsTrue$outboundSchema
    .optional(),
  deploymentType: RedisDeploymentTypeClusterTlsTrueDeploymentType$outboundSchema
    .optional(),
  rootNodes: z.array(
    z.lazy(() => RedisDeploymentTypeClusterTlsTrueRootNode$outboundSchema),
  ).optional(),
  scaleReads: RedisDeploymentTypeClusterTlsTrueScaleReads$outboundSchema
    .optional(),
  commands: z.array(
    z.lazy(() => RedisDeploymentTypeClusterTlsTrueCommand$outboundSchema),
  ),
  authType: RedisDeploymentTypeClusterTlsTrueAuthenticationMethod$outboundSchema
    .optional(),
  maxBlockSecs: z.number().optional(),
  enableClientSideCaching: z.boolean().optional(),
});

export function redisDeploymentTypeClusterTlsTrueToJSON(
  redisDeploymentTypeClusterTlsTrue: RedisDeploymentTypeClusterTlsTrue,
): string {
  return JSON.stringify(
    RedisDeploymentTypeClusterTlsTrue$outboundSchema.parse(
      redisDeploymentTypeClusterTlsTrue,
    ),
  );
}
export function redisDeploymentTypeClusterTlsTrueFromJSON(
  jsonString: string,
): SafeParseResult<RedisDeploymentTypeClusterTlsTrue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RedisDeploymentTypeClusterTlsTrue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RedisDeploymentTypeClusterTlsTrue' from JSON`,
  );
}

/** @internal */
export const RedisDeploymentTypeCluster$inboundSchema: z.ZodType<
  RedisDeploymentTypeCluster,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => RedisDeploymentTypeClusterTlsTrue$inboundSchema),
  z.lazy(() => RedisDeploymentTypeClusterTlsFalse$inboundSchema),
]);
/** @internal */
export type RedisDeploymentTypeCluster$Outbound =
  | RedisDeploymentTypeClusterTlsTrue$Outbound
  | RedisDeploymentTypeClusterTlsFalse$Outbound;

/** @internal */
export const RedisDeploymentTypeCluster$outboundSchema: z.ZodType<
  RedisDeploymentTypeCluster$Outbound,
  z.ZodTypeDef,
  RedisDeploymentTypeCluster
> = smartUnion([
  z.lazy(() => RedisDeploymentTypeClusterTlsTrue$outboundSchema),
  z.lazy(() => RedisDeploymentTypeClusterTlsFalse$outboundSchema),
]);

export function redisDeploymentTypeClusterToJSON(
  redisDeploymentTypeCluster: RedisDeploymentTypeCluster,
): string {
  return JSON.stringify(
    RedisDeploymentTypeCluster$outboundSchema.parse(redisDeploymentTypeCluster),
  );
}
export function redisDeploymentTypeClusterFromJSON(
  jsonString: string,
): SafeParseResult<RedisDeploymentTypeCluster, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RedisDeploymentTypeCluster$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RedisDeploymentTypeCluster' from JSON`,
  );
}

/** @internal */
export const RedisDeploymentTypeStandaloneDeploymentType$inboundSchema:
  z.ZodType<
    RedisDeploymentTypeStandaloneDeploymentType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RedisDeploymentTypeStandaloneDeploymentType);
/** @internal */
export const RedisDeploymentTypeStandaloneDeploymentType$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RedisDeploymentTypeStandaloneDeploymentType> =
    openEnums.outboundSchema(RedisDeploymentTypeStandaloneDeploymentType);

/** @internal */
export const TlsOptions$inboundSchema: z.ZodType<
  TlsOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  rejectUnauthorized: types.optional(types.boolean()),
  servername: types.optional(types.string()),
  certificateName: types.optional(types.string()),
  caPath: types.optional(types.string()),
  privKeyPath: types.optional(types.string()),
  certPath: types.optional(types.string()),
  passphrase: types.optional(types.string()),
  minVersion: types.optional(
    MinimumTlsVersionOptionsRedisDeploymentTypeStandaloneTlsOptions$inboundSchema,
  ),
  maxVersion: types.optional(
    MaximumTlsVersionOptionsRedisDeploymentTypeStandaloneTlsOptions$inboundSchema,
  ),
});
/** @internal */
export type TlsOptions$Outbound = {
  rejectUnauthorized?: boolean | undefined;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TlsOptions$outboundSchema: z.ZodType<
  TlsOptions$Outbound,
  z.ZodTypeDef,
  TlsOptions
> = z.object({
  rejectUnauthorized: z.boolean().optional(),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion:
    MinimumTlsVersionOptionsRedisDeploymentTypeStandaloneTlsOptions$outboundSchema
      .optional(),
  maxVersion:
    MaximumTlsVersionOptionsRedisDeploymentTypeStandaloneTlsOptions$outboundSchema
      .optional(),
});

export function tlsOptionsToJSON(tlsOptions: TlsOptions): string {
  return JSON.stringify(TlsOptions$outboundSchema.parse(tlsOptions));
}
export function tlsOptionsFromJSON(
  jsonString: string,
): SafeParseResult<TlsOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TlsOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TlsOptions' from JSON`,
  );
}

/** @internal */
export const RedisDeploymentTypeStandaloneCommand$inboundSchema: z.ZodType<
  RedisDeploymentTypeStandaloneCommand,
  z.ZodTypeDef,
  unknown
> = z.object({
  outField: types.optional(types.string()),
  command: types.string(),
  keyExpr: types.string(),
  argsExpr: types.optional(types.string()),
});
/** @internal */
export type RedisDeploymentTypeStandaloneCommand$Outbound = {
  outField?: string | undefined;
  command: string;
  keyExpr: string;
  argsExpr?: string | undefined;
};

/** @internal */
export const RedisDeploymentTypeStandaloneCommand$outboundSchema: z.ZodType<
  RedisDeploymentTypeStandaloneCommand$Outbound,
  z.ZodTypeDef,
  RedisDeploymentTypeStandaloneCommand
> = z.object({
  outField: z.string().optional(),
  command: z.string(),
  keyExpr: z.string(),
  argsExpr: z.string().optional(),
});

export function redisDeploymentTypeStandaloneCommandToJSON(
  redisDeploymentTypeStandaloneCommand: RedisDeploymentTypeStandaloneCommand,
): string {
  return JSON.stringify(
    RedisDeploymentTypeStandaloneCommand$outboundSchema.parse(
      redisDeploymentTypeStandaloneCommand,
    ),
  );
}
export function redisDeploymentTypeStandaloneCommandFromJSON(
  jsonString: string,
): SafeParseResult<RedisDeploymentTypeStandaloneCommand, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RedisDeploymentTypeStandaloneCommand$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RedisDeploymentTypeStandaloneCommand' from JSON`,
  );
}

/** @internal */
export const RedisDeploymentTypeStandaloneAuthenticationMethod$inboundSchema:
  z.ZodType<
    RedisDeploymentTypeStandaloneAuthenticationMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RedisDeploymentTypeStandaloneAuthenticationMethod,
  );
/** @internal */
export const RedisDeploymentTypeStandaloneAuthenticationMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RedisDeploymentTypeStandaloneAuthenticationMethod
  > = openEnums.outboundSchema(
    RedisDeploymentTypeStandaloneAuthenticationMethod,
  );

/** @internal */
export const RedisDeploymentTypeStandalone$inboundSchema: z.ZodType<
  RedisDeploymentTypeStandalone,
  z.ZodTypeDef,
  unknown
> = z.object({
  deploymentType: types.optional(
    RedisDeploymentTypeStandaloneDeploymentType$inboundSchema,
  ),
  url: types.string(),
  tlsOptions: types.optional(z.lazy(() => TlsOptions$inboundSchema)),
  commands: z.array(
    z.lazy(() => RedisDeploymentTypeStandaloneCommand$inboundSchema),
  ),
  authType: types.optional(
    RedisDeploymentTypeStandaloneAuthenticationMethod$inboundSchema,
  ),
  maxBlockSecs: types.optional(types.number()),
  enableClientSideCaching: types.optional(types.boolean()),
});
/** @internal */
export type RedisDeploymentTypeStandalone$Outbound = {
  deploymentType?: string | undefined;
  url: string;
  tlsOptions?: TlsOptions$Outbound | undefined;
  commands: Array<RedisDeploymentTypeStandaloneCommand$Outbound>;
  authType?: string | undefined;
  maxBlockSecs?: number | undefined;
  enableClientSideCaching?: boolean | undefined;
};

/** @internal */
export const RedisDeploymentTypeStandalone$outboundSchema: z.ZodType<
  RedisDeploymentTypeStandalone$Outbound,
  z.ZodTypeDef,
  RedisDeploymentTypeStandalone
> = z.object({
  deploymentType: RedisDeploymentTypeStandaloneDeploymentType$outboundSchema
    .optional(),
  url: z.string(),
  tlsOptions: z.lazy(() => TlsOptions$outboundSchema).optional(),
  commands: z.array(
    z.lazy(() => RedisDeploymentTypeStandaloneCommand$outboundSchema),
  ),
  authType: RedisDeploymentTypeStandaloneAuthenticationMethod$outboundSchema
    .optional(),
  maxBlockSecs: z.number().optional(),
  enableClientSideCaching: z.boolean().optional(),
});

export function redisDeploymentTypeStandaloneToJSON(
  redisDeploymentTypeStandalone: RedisDeploymentTypeStandalone,
): string {
  return JSON.stringify(
    RedisDeploymentTypeStandalone$outboundSchema.parse(
      redisDeploymentTypeStandalone,
    ),
  );
}
export function redisDeploymentTypeStandaloneFromJSON(
  jsonString: string,
): SafeParseResult<RedisDeploymentTypeStandalone, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RedisDeploymentTypeStandalone$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RedisDeploymentTypeStandalone' from JSON`,
  );
}

/** @internal */
export const PipelineFunctionRedisConf$inboundSchema: z.ZodType<
  PipelineFunctionRedisConf,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("authType", {
  none: z.lazy(() => RedisAuthTypeNone$inboundSchema),
  manual: z.lazy(() => RedisAuthTypeManual$inboundSchema),
  credentialsSecret: z.lazy(() => RedisAuthTypeCredentialsSecret$inboundSchema),
  textSecret: z.lazy(() => RedisAuthTypeTextSecret$inboundSchema),
});
/** @internal */
export type PipelineFunctionRedisConf$Outbound =
  | RedisAuthTypeNone$Outbound
  | RedisAuthTypeManual$Outbound
  | RedisAuthTypeCredentialsSecret$Outbound
  | RedisAuthTypeTextSecret$Outbound;

/** @internal */
export const PipelineFunctionRedisConf$outboundSchema: z.ZodType<
  PipelineFunctionRedisConf$Outbound,
  z.ZodTypeDef,
  PipelineFunctionRedisConf
> = z.union([
  z.lazy(() => RedisAuthTypeNone$outboundSchema),
  z.lazy(() => RedisAuthTypeManual$outboundSchema),
  z.lazy(() => RedisAuthTypeCredentialsSecret$outboundSchema),
  z.lazy(() => RedisAuthTypeTextSecret$outboundSchema),
]);

export function pipelineFunctionRedisConfToJSON(
  pipelineFunctionRedisConf: PipelineFunctionRedisConf,
): string {
  return JSON.stringify(
    PipelineFunctionRedisConf$outboundSchema.parse(pipelineFunctionRedisConf),
  );
}
export function pipelineFunctionRedisConfFromJSON(
  jsonString: string,
): SafeParseResult<PipelineFunctionRedisConf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PipelineFunctionRedisConf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PipelineFunctionRedisConf' from JSON`,
  );
}

/** @internal */
export const PipelineFunctionRedis$inboundSchema: z.ZodType<
  PipelineFunctionRedis,
  z.ZodTypeDef,
  unknown
> = z.object({
  filter: types.optional(types.string()),
  id: types.literal("redis"),
  description: types.optional(types.string()),
  disabled: types.optional(types.boolean()),
  final: types.optional(types.boolean()),
  conf: discriminatedUnion("authType", {
    none: z.lazy(() => RedisAuthTypeNone$inboundSchema),
    manual: z.lazy(() => RedisAuthTypeManual$inboundSchema),
    credentialsSecret: z.lazy(() =>
      RedisAuthTypeCredentialsSecret$inboundSchema
    ),
    textSecret: z.lazy(() => RedisAuthTypeTextSecret$inboundSchema),
  }),
  groupId: types.optional(types.string()),
});
/** @internal */
export type PipelineFunctionRedis$Outbound = {
  filter?: string | undefined;
  id: "redis";
  description?: string | undefined;
  disabled?: boolean | undefined;
  final?: boolean | undefined;
  conf:
    | RedisAuthTypeNone$Outbound
    | RedisAuthTypeManual$Outbound
    | RedisAuthTypeCredentialsSecret$Outbound
    | RedisAuthTypeTextSecret$Outbound;
  groupId?: string | undefined;
};

/** @internal */
export const PipelineFunctionRedis$outboundSchema: z.ZodType<
  PipelineFunctionRedis$Outbound,
  z.ZodTypeDef,
  PipelineFunctionRedis
> = z.object({
  filter: z.string().optional(),
  id: z.literal("redis"),
  description: z.string().optional(),
  disabled: z.boolean().optional(),
  final: z.boolean().optional(),
  conf: z.union([
    z.lazy(() => RedisAuthTypeNone$outboundSchema),
    z.lazy(() => RedisAuthTypeManual$outboundSchema),
    z.lazy(() => RedisAuthTypeCredentialsSecret$outboundSchema),
    z.lazy(() => RedisAuthTypeTextSecret$outboundSchema),
  ]),
  groupId: z.string().optional(),
});

export function pipelineFunctionRedisToJSON(
  pipelineFunctionRedis: PipelineFunctionRedis,
): string {
  return JSON.stringify(
    PipelineFunctionRedis$outboundSchema.parse(pipelineFunctionRedis),
  );
}
export function pipelineFunctionRedisFromJSON(
  jsonString: string,
): SafeParseResult<PipelineFunctionRedis, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PipelineFunctionRedis$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PipelineFunctionRedis' from JSON`,
  );
}
