/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { AwsType, AwsType$inboundSchema } from "./awstype.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import { HBCriblInfo, HBCriblInfo$inboundSchema } from "./hbcriblinfo.js";
import {
  HeartbeatMetadata,
  HeartbeatMetadata$inboundSchema,
} from "./heartbeatmetadata.js";
import { HostOsType, HostOsType$inboundSchema } from "./hostostype.js";
import { KubeType, KubeType$inboundSchema } from "./kubetype.js";
import {
  OutpostNodeInfo,
  OutpostNodeInfo$inboundSchema,
} from "./outpostnodeinfo.js";

export type Os2 = {
  addresses: Array<string>;
};

export type Os1 = {
  addresses: Array<string>;
  enabled: boolean;
  id: string;
  version: string;
};

export type OsUnion = Os1 | Os2;

export type NodeProvidedInfo = {
  architecture: string;
  aws?: AwsType | undefined;
  connIp?: string | undefined;
  cpus: number;
  cribl: HBCriblInfo;
  env: { [k: string]: string };
  freeDiskSpace: number;
  hostOs?: HostOsType | undefined;
  hostname: string;
  isSaasWorker?: boolean | undefined;
  kube?: KubeType | undefined;
  localTime?: number | undefined;
  metadata?: HeartbeatMetadata | undefined;
  node: string;
  os?: Os1 | Os2 | undefined;
  outpost?: OutpostNodeInfo | undefined;
  platform: string;
  release: string;
  totalDiskSpace: number;
  totalmem: number;
};

/** @internal */
export const Os2$inboundSchema: z.ZodType<Os2, z.ZodTypeDef, unknown> = z
  .object({
    addresses: z.array(z.string()),
  });

export function os2FromJSON(
  jsonString: string,
): SafeParseResult<Os2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Os2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Os2' from JSON`,
  );
}

/** @internal */
export const Os1$inboundSchema: z.ZodType<Os1, z.ZodTypeDef, unknown> = z
  .object({
    addresses: z.array(z.string()),
    enabled: z.boolean(),
    id: z.string(),
    version: z.string(),
  });

export function os1FromJSON(
  jsonString: string,
): SafeParseResult<Os1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Os1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Os1' from JSON`,
  );
}

/** @internal */
export const OsUnion$inboundSchema: z.ZodType<OsUnion, z.ZodTypeDef, unknown> =
  z.union([z.lazy(() => Os1$inboundSchema), z.lazy(() => Os2$inboundSchema)]);

export function osUnionFromJSON(
  jsonString: string,
): SafeParseResult<OsUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OsUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OsUnion' from JSON`,
  );
}

/** @internal */
export const NodeProvidedInfo$inboundSchema: z.ZodType<
  NodeProvidedInfo,
  z.ZodTypeDef,
  unknown
> = z.object({
  architecture: z.string(),
  aws: AwsType$inboundSchema.optional(),
  conn_ip: z.string().optional(),
  cpus: z.number(),
  cribl: HBCriblInfo$inboundSchema,
  env: z.record(z.string()),
  freeDiskSpace: z.number(),
  hostOs: HostOsType$inboundSchema.optional(),
  hostname: z.string(),
  isSaasWorker: z.boolean().optional(),
  kube: KubeType$inboundSchema.optional(),
  localTime: z.number().optional(),
  metadata: HeartbeatMetadata$inboundSchema.optional(),
  node: z.string(),
  os: z.union([
    z.lazy(() => Os1$inboundSchema),
    z.lazy(() => Os2$inboundSchema),
  ]).optional(),
  outpost: OutpostNodeInfo$inboundSchema.optional(),
  platform: z.string(),
  release: z.string(),
  totalDiskSpace: z.number(),
  totalmem: z.number(),
}).transform((v) => {
  return remap$(v, {
    "conn_ip": "connIp",
  });
});

export function nodeProvidedInfoFromJSON(
  jsonString: string,
): SafeParseResult<NodeProvidedInfo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NodeProvidedInfo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NodeProvidedInfo' from JSON`,
  );
}
