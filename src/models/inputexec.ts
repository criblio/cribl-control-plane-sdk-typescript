/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  ClosedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const InputExecType = {
  Exec: "exec",
} as const;
export type InputExecType = ClosedEnum<typeof InputExecType>;

export type InputExecConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputExecMode = {
  /**
   * Smart
   */
  Smart: "smart",
  /**
   * Always On
   */
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputExecMode = OpenEnum<typeof InputExecMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputExecCompression = {
  /**
   * None
   */
  None: "none",
  /**
   * Gzip
   */
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputExecCompression = OpenEnum<typeof InputExecCompression>;

export type InputExecPqControls = {};

export type InputExecPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputExecMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputExecCompression | undefined;
  pqControls?: InputExecPqControls | undefined;
};

/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export const ScheduleType = {
  Interval: "interval",
  CronSchedule: "cronSchedule",
} as const;
/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export type ScheduleType = OpenEnum<typeof ScheduleType>;

export type InputExecMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputExec = {
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputExecType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputExecConnection> | undefined;
  pq?: InputExecPq | undefined;
  /**
   * Command to execute; supports Bourne shell (or CMD on Windows) syntax
   */
  command: string;
  /**
   * Maximum number of retry attempts in the event that the command fails
   */
  retries?: number | undefined;
  /**
   * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
   */
  scheduleType?: ScheduleType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputExecMetadatum> | undefined;
  description?: string | undefined;
  /**
   * Interval between command executions in seconds.
   */
  interval?: number | undefined;
  /**
   * Cron schedule to execute the command on.
   */
  cronSchedule?: string | undefined;
};

/** @internal */
export const InputExecType$inboundSchema: z.ZodNativeEnum<
  typeof InputExecType
> = z.nativeEnum(InputExecType);

/** @internal */
export const InputExecType$outboundSchema: z.ZodNativeEnum<
  typeof InputExecType
> = InputExecType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputExecType$ {
  /** @deprecated use `InputExecType$inboundSchema` instead. */
  export const inboundSchema = InputExecType$inboundSchema;
  /** @deprecated use `InputExecType$outboundSchema` instead. */
  export const outboundSchema = InputExecType$outboundSchema;
}

/** @internal */
export const InputExecConnection$inboundSchema: z.ZodType<
  InputExecConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputExecConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputExecConnection$outboundSchema: z.ZodType<
  InputExecConnection$Outbound,
  z.ZodTypeDef,
  InputExecConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputExecConnection$ {
  /** @deprecated use `InputExecConnection$inboundSchema` instead. */
  export const inboundSchema = InputExecConnection$inboundSchema;
  /** @deprecated use `InputExecConnection$outboundSchema` instead. */
  export const outboundSchema = InputExecConnection$outboundSchema;
  /** @deprecated use `InputExecConnection$Outbound` instead. */
  export type Outbound = InputExecConnection$Outbound;
}

export function inputExecConnectionToJSON(
  inputExecConnection: InputExecConnection,
): string {
  return JSON.stringify(
    InputExecConnection$outboundSchema.parse(inputExecConnection),
  );
}

export function inputExecConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputExecConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputExecConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputExecConnection' from JSON`,
  );
}

/** @internal */
export const InputExecMode$inboundSchema: z.ZodType<
  InputExecMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputExecMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputExecMode$outboundSchema: z.ZodType<
  InputExecMode,
  z.ZodTypeDef,
  InputExecMode
> = z.union([
  z.nativeEnum(InputExecMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputExecMode$ {
  /** @deprecated use `InputExecMode$inboundSchema` instead. */
  export const inboundSchema = InputExecMode$inboundSchema;
  /** @deprecated use `InputExecMode$outboundSchema` instead. */
  export const outboundSchema = InputExecMode$outboundSchema;
}

/** @internal */
export const InputExecCompression$inboundSchema: z.ZodType<
  InputExecCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputExecCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputExecCompression$outboundSchema: z.ZodType<
  InputExecCompression,
  z.ZodTypeDef,
  InputExecCompression
> = z.union([
  z.nativeEnum(InputExecCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputExecCompression$ {
  /** @deprecated use `InputExecCompression$inboundSchema` instead. */
  export const inboundSchema = InputExecCompression$inboundSchema;
  /** @deprecated use `InputExecCompression$outboundSchema` instead. */
  export const outboundSchema = InputExecCompression$outboundSchema;
}

/** @internal */
export const InputExecPqControls$inboundSchema: z.ZodType<
  InputExecPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type InputExecPqControls$Outbound = {};

/** @internal */
export const InputExecPqControls$outboundSchema: z.ZodType<
  InputExecPqControls$Outbound,
  z.ZodTypeDef,
  InputExecPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputExecPqControls$ {
  /** @deprecated use `InputExecPqControls$inboundSchema` instead. */
  export const inboundSchema = InputExecPqControls$inboundSchema;
  /** @deprecated use `InputExecPqControls$outboundSchema` instead. */
  export const outboundSchema = InputExecPqControls$outboundSchema;
  /** @deprecated use `InputExecPqControls$Outbound` instead. */
  export type Outbound = InputExecPqControls$Outbound;
}

export function inputExecPqControlsToJSON(
  inputExecPqControls: InputExecPqControls,
): string {
  return JSON.stringify(
    InputExecPqControls$outboundSchema.parse(inputExecPqControls),
  );
}

export function inputExecPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<InputExecPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputExecPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputExecPqControls' from JSON`,
  );
}

/** @internal */
export const InputExecPq$inboundSchema: z.ZodType<
  InputExecPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputExecMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputExecCompression$inboundSchema.default("none"),
  pqControls: z.lazy(() => InputExecPqControls$inboundSchema).optional(),
});

/** @internal */
export type InputExecPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
  pqControls?: InputExecPqControls$Outbound | undefined;
};

/** @internal */
export const InputExecPq$outboundSchema: z.ZodType<
  InputExecPq$Outbound,
  z.ZodTypeDef,
  InputExecPq
> = z.object({
  mode: InputExecMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputExecCompression$outboundSchema.default("none"),
  pqControls: z.lazy(() => InputExecPqControls$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputExecPq$ {
  /** @deprecated use `InputExecPq$inboundSchema` instead. */
  export const inboundSchema = InputExecPq$inboundSchema;
  /** @deprecated use `InputExecPq$outboundSchema` instead. */
  export const outboundSchema = InputExecPq$outboundSchema;
  /** @deprecated use `InputExecPq$Outbound` instead. */
  export type Outbound = InputExecPq$Outbound;
}

export function inputExecPqToJSON(inputExecPq: InputExecPq): string {
  return JSON.stringify(InputExecPq$outboundSchema.parse(inputExecPq));
}

export function inputExecPqFromJSON(
  jsonString: string,
): SafeParseResult<InputExecPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputExecPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputExecPq' from JSON`,
  );
}

/** @internal */
export const ScheduleType$inboundSchema: z.ZodType<
  ScheduleType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ScheduleType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const ScheduleType$outboundSchema: z.ZodType<
  ScheduleType,
  z.ZodTypeDef,
  ScheduleType
> = z.union([
  z.nativeEnum(ScheduleType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ScheduleType$ {
  /** @deprecated use `ScheduleType$inboundSchema` instead. */
  export const inboundSchema = ScheduleType$inboundSchema;
  /** @deprecated use `ScheduleType$outboundSchema` instead. */
  export const outboundSchema = ScheduleType$outboundSchema;
}

/** @internal */
export const InputExecMetadatum$inboundSchema: z.ZodType<
  InputExecMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputExecMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputExecMetadatum$outboundSchema: z.ZodType<
  InputExecMetadatum$Outbound,
  z.ZodTypeDef,
  InputExecMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputExecMetadatum$ {
  /** @deprecated use `InputExecMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputExecMetadatum$inboundSchema;
  /** @deprecated use `InputExecMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputExecMetadatum$outboundSchema;
  /** @deprecated use `InputExecMetadatum$Outbound` instead. */
  export type Outbound = InputExecMetadatum$Outbound;
}

export function inputExecMetadatumToJSON(
  inputExecMetadatum: InputExecMetadatum,
): string {
  return JSON.stringify(
    InputExecMetadatum$outboundSchema.parse(inputExecMetadatum),
  );
}

export function inputExecMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputExecMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputExecMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputExecMetadatum' from JSON`,
  );
}

/** @internal */
export const InputExec$inboundSchema: z.ZodType<
  InputExec,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  type: InputExecType$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputExecConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputExecPq$inboundSchema).optional(),
  command: z.string(),
  retries: z.number().default(10),
  scheduleType: ScheduleType$inboundSchema.default("interval"),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  metadata: z.array(z.lazy(() => InputExecMetadatum$inboundSchema)).optional(),
  description: z.string().optional(),
  interval: z.number().default(60),
  cronSchedule: z.string().default("* * * * *"),
});

/** @internal */
export type InputExec$Outbound = {
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputExecConnection$Outbound> | undefined;
  pq?: InputExecPq$Outbound | undefined;
  command: string;
  retries: number;
  scheduleType: string;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  metadata?: Array<InputExecMetadatum$Outbound> | undefined;
  description?: string | undefined;
  interval: number;
  cronSchedule: string;
};

/** @internal */
export const InputExec$outboundSchema: z.ZodType<
  InputExec$Outbound,
  z.ZodTypeDef,
  InputExec
> = z.object({
  id: z.string().optional(),
  type: InputExecType$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputExecConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputExecPq$outboundSchema).optional(),
  command: z.string(),
  retries: z.number().default(10),
  scheduleType: ScheduleType$outboundSchema.default("interval"),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  metadata: z.array(z.lazy(() => InputExecMetadatum$outboundSchema)).optional(),
  description: z.string().optional(),
  interval: z.number().default(60),
  cronSchedule: z.string().default("* * * * *"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputExec$ {
  /** @deprecated use `InputExec$inboundSchema` instead. */
  export const inboundSchema = InputExec$inboundSchema;
  /** @deprecated use `InputExec$outboundSchema` instead. */
  export const outboundSchema = InputExec$outboundSchema;
  /** @deprecated use `InputExec$Outbound` instead. */
  export type Outbound = InputExec$Outbound;
}

export function inputExecToJSON(inputExec: InputExec): string {
  return JSON.stringify(InputExec$outboundSchema.parse(inputExec));
}

export function inputExecFromJSON(
  jsonString: string,
): SafeParseResult<InputExec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputExec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputExec' from JSON`,
  );
}
