/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const Library = {
  Custom: "custom",
  CriblCustom: "cribl-custom",
} as const;
export type Library = OpenEnum<typeof Library>;

export const EventBreakerType = {
  /**
   * Regex
   */
  Regex: "regex",
  /**
   * JSON Newline Delimited
   */
  Json: "json",
  /**
   * JSON Array
   */
  JsonArray: "json_array",
  /**
   * File Header
   */
  Header: "header",
  /**
   * Timestamp
   */
  Timestamp: "timestamp",
  /**
   * CSV
   */
  Csv: "csv",
  /**
   * AWS CloudTrail
   */
  AwsCloudtrail: "aws_cloudtrail",
  /**
   * AWS VPC Flow Log
   */
  AwsVpcflow: "aws_vpcflow",
} as const;
export type EventBreakerType = OpenEnum<typeof EventBreakerType>;

export const TimestampType = {
  Auto: "auto",
  Format: "format",
  Current: "current",
} as const;
export type TimestampType = OpenEnum<typeof TimestampType>;

/**
 * Auto, manual format (strptime), or current time
 */
export type EventBreakerRulesetTimestampFormat = {
  type?: TimestampType | undefined;
  length?: number | undefined;
  format?: string | undefined;
};

export type Field = {
  name?: string | undefined;
  /**
   * The JavaScript expression used to compute the field's value (can be constant)
   */
  value: string;
};

export type EventBreakerRulesetRule = {
  name: string;
  /**
   * JavaScript expression applied to the beginning of a file or object, to determine whether the rule applies to all contained events.
   */
  condition?: string | undefined;
  type?: EventBreakerType | undefined;
  /**
   * The regex to match before attempting timestamp extraction. Use $ (end-of-string anchor) to prevent extraction.
   */
  timestampAnchorRegex?: string | undefined;
  /**
   * Auto, manual format (strptime), or current time
   */
  timestamp: EventBreakerRulesetTimestampFormat;
  /**
   * Timezone to assign to timestamps without timezone info
   */
  timestampTimezone?: string | undefined;
  /**
   * The earliest timestamp value allowed relative to now. Example: -42years. Parsed values prior to this date will be set to current time.
   */
  timestampEarliest?: string | undefined;
  /**
   * The latest timestamp value allowed relative to now. Example: +42days. Parsed values after this date will be set to current time.
   */
  timestampLatest?: string | undefined;
  /**
   * The maximum number of bytes in an event before it is flushed to the pipelines
   */
  maxEventBytes?: number | undefined;
  /**
   * Key-value pairs to be added to each event
   */
  fields?: Array<Field> | undefined;
  /**
   * Disable this breaker rule (enabled by default)
   */
  disabled?: boolean | undefined;
  parserEnabled?: boolean | undefined;
  /**
   * Enable to set an internal field on events indicating that the field in the data called _raw should be used. This can be useful for post processors that want to use that field for event._raw, instead of replacing it with the actual raw event.
   */
  shouldUseDataRaw?: boolean | undefined;
};

export type EventBreakerRuleset = {
  id: string;
  lib?: Library | undefined;
  description?: string | undefined;
  tags?: string | undefined;
  /**
   * The  minimum number of characters in _raw to determine which rule to use
   */
  minRawLength?: number | undefined;
  /**
   * A list of rules that will be applied, in order, to the input data stream
   */
  rules?: Array<EventBreakerRulesetRule> | undefined;
};

/** @internal */
export const Library$inboundSchema: z.ZodType<Library, z.ZodTypeDef, unknown> =
  z
    .union([
      z.nativeEnum(Library),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const Library$outboundSchema: z.ZodType<Library, z.ZodTypeDef, Library> =
  z.union([
    z.nativeEnum(Library),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Library$ {
  /** @deprecated use `Library$inboundSchema` instead. */
  export const inboundSchema = Library$inboundSchema;
  /** @deprecated use `Library$outboundSchema` instead. */
  export const outboundSchema = Library$outboundSchema;
}

/** @internal */
export const EventBreakerType$inboundSchema: z.ZodType<
  EventBreakerType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EventBreakerType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EventBreakerType$outboundSchema: z.ZodType<
  EventBreakerType,
  z.ZodTypeDef,
  EventBreakerType
> = z.union([
  z.nativeEnum(EventBreakerType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventBreakerType$ {
  /** @deprecated use `EventBreakerType$inboundSchema` instead. */
  export const inboundSchema = EventBreakerType$inboundSchema;
  /** @deprecated use `EventBreakerType$outboundSchema` instead. */
  export const outboundSchema = EventBreakerType$outboundSchema;
}

/** @internal */
export const TimestampType$inboundSchema: z.ZodType<
  TimestampType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(TimestampType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const TimestampType$outboundSchema: z.ZodType<
  TimestampType,
  z.ZodTypeDef,
  TimestampType
> = z.union([
  z.nativeEnum(TimestampType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimestampType$ {
  /** @deprecated use `TimestampType$inboundSchema` instead. */
  export const inboundSchema = TimestampType$inboundSchema;
  /** @deprecated use `TimestampType$outboundSchema` instead. */
  export const outboundSchema = TimestampType$outboundSchema;
}

/** @internal */
export const EventBreakerRulesetTimestampFormat$inboundSchema: z.ZodType<
  EventBreakerRulesetTimestampFormat,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: TimestampType$inboundSchema.default("auto"),
  length: z.number().default(150),
  format: z.string().optional(),
});

/** @internal */
export type EventBreakerRulesetTimestampFormat$Outbound = {
  type: string;
  length: number;
  format?: string | undefined;
};

/** @internal */
export const EventBreakerRulesetTimestampFormat$outboundSchema: z.ZodType<
  EventBreakerRulesetTimestampFormat$Outbound,
  z.ZodTypeDef,
  EventBreakerRulesetTimestampFormat
> = z.object({
  type: TimestampType$outboundSchema.default("auto"),
  length: z.number().default(150),
  format: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventBreakerRulesetTimestampFormat$ {
  /** @deprecated use `EventBreakerRulesetTimestampFormat$inboundSchema` instead. */
  export const inboundSchema = EventBreakerRulesetTimestampFormat$inboundSchema;
  /** @deprecated use `EventBreakerRulesetTimestampFormat$outboundSchema` instead. */
  export const outboundSchema =
    EventBreakerRulesetTimestampFormat$outboundSchema;
  /** @deprecated use `EventBreakerRulesetTimestampFormat$Outbound` instead. */
  export type Outbound = EventBreakerRulesetTimestampFormat$Outbound;
}

export function eventBreakerRulesetTimestampFormatToJSON(
  eventBreakerRulesetTimestampFormat: EventBreakerRulesetTimestampFormat,
): string {
  return JSON.stringify(
    EventBreakerRulesetTimestampFormat$outboundSchema.parse(
      eventBreakerRulesetTimestampFormat,
    ),
  );
}

export function eventBreakerRulesetTimestampFormatFromJSON(
  jsonString: string,
): SafeParseResult<EventBreakerRulesetTimestampFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      EventBreakerRulesetTimestampFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EventBreakerRulesetTimestampFormat' from JSON`,
  );
}

/** @internal */
export const Field$inboundSchema: z.ZodType<Field, z.ZodTypeDef, unknown> = z
  .object({
    name: z.string().optional(),
    value: z.string(),
  });

/** @internal */
export type Field$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const Field$outboundSchema: z.ZodType<
  Field$Outbound,
  z.ZodTypeDef,
  Field
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Field$ {
  /** @deprecated use `Field$inboundSchema` instead. */
  export const inboundSchema = Field$inboundSchema;
  /** @deprecated use `Field$outboundSchema` instead. */
  export const outboundSchema = Field$outboundSchema;
  /** @deprecated use `Field$Outbound` instead. */
  export type Outbound = Field$Outbound;
}

export function fieldToJSON(field: Field): string {
  return JSON.stringify(Field$outboundSchema.parse(field));
}

export function fieldFromJSON(
  jsonString: string,
): SafeParseResult<Field, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Field$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Field' from JSON`,
  );
}

/** @internal */
export const EventBreakerRulesetRule$inboundSchema: z.ZodType<
  EventBreakerRulesetRule,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  condition: z.string().default("true"),
  type: EventBreakerType$inboundSchema.default("regex"),
  timestampAnchorRegex: z.string().default("/^/"),
  timestamp: z.lazy(() => EventBreakerRulesetTimestampFormat$inboundSchema),
  timestampTimezone: z.string().default("local"),
  timestampEarliest: z.string().default("-420weeks"),
  timestampLatest: z.string().default("+1week"),
  maxEventBytes: z.number().default(51200),
  fields: z.array(z.lazy(() => Field$inboundSchema)).optional(),
  disabled: z.boolean().default(false),
  parserEnabled: z.boolean().default(false),
  shouldUseDataRaw: z.boolean().default(false),
});

/** @internal */
export type EventBreakerRulesetRule$Outbound = {
  name: string;
  condition: string;
  type: string;
  timestampAnchorRegex: string;
  timestamp: EventBreakerRulesetTimestampFormat$Outbound;
  timestampTimezone: string;
  timestampEarliest: string;
  timestampLatest: string;
  maxEventBytes: number;
  fields?: Array<Field$Outbound> | undefined;
  disabled: boolean;
  parserEnabled: boolean;
  shouldUseDataRaw: boolean;
};

/** @internal */
export const EventBreakerRulesetRule$outboundSchema: z.ZodType<
  EventBreakerRulesetRule$Outbound,
  z.ZodTypeDef,
  EventBreakerRulesetRule
> = z.object({
  name: z.string(),
  condition: z.string().default("true"),
  type: EventBreakerType$outboundSchema.default("regex"),
  timestampAnchorRegex: z.string().default("/^/"),
  timestamp: z.lazy(() => EventBreakerRulesetTimestampFormat$outboundSchema),
  timestampTimezone: z.string().default("local"),
  timestampEarliest: z.string().default("-420weeks"),
  timestampLatest: z.string().default("+1week"),
  maxEventBytes: z.number().default(51200),
  fields: z.array(z.lazy(() => Field$outboundSchema)).optional(),
  disabled: z.boolean().default(false),
  parserEnabled: z.boolean().default(false),
  shouldUseDataRaw: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventBreakerRulesetRule$ {
  /** @deprecated use `EventBreakerRulesetRule$inboundSchema` instead. */
  export const inboundSchema = EventBreakerRulesetRule$inboundSchema;
  /** @deprecated use `EventBreakerRulesetRule$outboundSchema` instead. */
  export const outboundSchema = EventBreakerRulesetRule$outboundSchema;
  /** @deprecated use `EventBreakerRulesetRule$Outbound` instead. */
  export type Outbound = EventBreakerRulesetRule$Outbound;
}

export function eventBreakerRulesetRuleToJSON(
  eventBreakerRulesetRule: EventBreakerRulesetRule,
): string {
  return JSON.stringify(
    EventBreakerRulesetRule$outboundSchema.parse(eventBreakerRulesetRule),
  );
}

export function eventBreakerRulesetRuleFromJSON(
  jsonString: string,
): SafeParseResult<EventBreakerRulesetRule, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EventBreakerRulesetRule$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EventBreakerRulesetRule' from JSON`,
  );
}

/** @internal */
export const EventBreakerRuleset$inboundSchema: z.ZodType<
  EventBreakerRuleset,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  lib: Library$inboundSchema.default("custom"),
  description: z.string().optional(),
  tags: z.string().optional(),
  minRawLength: z.number().default(256),
  rules: z.array(z.lazy(() => EventBreakerRulesetRule$inboundSchema))
    .optional(),
});

/** @internal */
export type EventBreakerRuleset$Outbound = {
  id: string;
  lib: string;
  description?: string | undefined;
  tags?: string | undefined;
  minRawLength: number;
  rules?: Array<EventBreakerRulesetRule$Outbound> | undefined;
};

/** @internal */
export const EventBreakerRuleset$outboundSchema: z.ZodType<
  EventBreakerRuleset$Outbound,
  z.ZodTypeDef,
  EventBreakerRuleset
> = z.object({
  id: z.string(),
  lib: Library$outboundSchema.default("custom"),
  description: z.string().optional(),
  tags: z.string().optional(),
  minRawLength: z.number().default(256),
  rules: z.array(z.lazy(() => EventBreakerRulesetRule$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventBreakerRuleset$ {
  /** @deprecated use `EventBreakerRuleset$inboundSchema` instead. */
  export const inboundSchema = EventBreakerRuleset$inboundSchema;
  /** @deprecated use `EventBreakerRuleset$outboundSchema` instead. */
  export const outboundSchema = EventBreakerRuleset$outboundSchema;
  /** @deprecated use `EventBreakerRuleset$Outbound` instead. */
  export type Outbound = EventBreakerRuleset$Outbound;
}

export function eventBreakerRulesetToJSON(
  eventBreakerRuleset: EventBreakerRuleset,
): string {
  return JSON.stringify(
    EventBreakerRuleset$outboundSchema.parse(eventBreakerRuleset),
  );
}

export function eventBreakerRulesetFromJSON(
  jsonString: string,
): SafeParseResult<EventBreakerRuleset, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EventBreakerRuleset$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EventBreakerRuleset' from JSON`,
  );
}
