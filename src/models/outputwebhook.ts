/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  ClosedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  AuthTypeOptions,
  AuthTypeOptions$inboundSchema,
  AuthTypeOptions$outboundSchema,
} from "./authtypeoptions.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ExtraHttpHeadersType,
  ExtraHttpHeadersType$inboundSchema,
  ExtraHttpHeadersType$Outbound,
  ExtraHttpHeadersType$outboundSchema,
} from "./extrahttpheaderstype.js";
import {
  FailedRequestLoggingModeOptions,
  FailedRequestLoggingModeOptions$inboundSchema,
  FailedRequestLoggingModeOptions$outboundSchema,
} from "./failedrequestloggingmodeoptions.js";
import {
  Metadata1Type,
  Metadata1Type$inboundSchema,
  Metadata1Type$Outbound,
  Metadata1Type$outboundSchema,
} from "./metadata1type.js";
import {
  MetadataType,
  MetadataType$inboundSchema,
  MetadataType$Outbound,
  MetadataType$outboundSchema,
} from "./metadatatype.js";
import {
  Method1Options,
  Method1Options$inboundSchema,
  Method1Options$outboundSchema,
} from "./method1options.js";
import {
  OnBackpressureOptions,
  OnBackpressureOptions$inboundSchema,
  OnBackpressureOptions$outboundSchema,
} from "./onbackpressureoptions.js";
import {
  PqCompressOptions,
  PqCompressOptions$inboundSchema,
  PqCompressOptions$outboundSchema,
} from "./pqcompressoptions.js";
import {
  PqModeOptions,
  PqModeOptions$inboundSchema,
  PqModeOptions$outboundSchema,
} from "./pqmodeoptions.js";
import {
  PqOnBackpressureOptions,
  PqOnBackpressureOptions$inboundSchema,
  PqOnBackpressureOptions$outboundSchema,
} from "./pqonbackpressureoptions.js";
import {
  ResponseRetrySettingsType,
  ResponseRetrySettingsType$inboundSchema,
  ResponseRetrySettingsType$Outbound,
  ResponseRetrySettingsType$outboundSchema,
} from "./responseretrysettingstype.js";
import {
  TimeoutRetrySettingsType,
  TimeoutRetrySettingsType$inboundSchema,
  TimeoutRetrySettingsType$Outbound,
  TimeoutRetrySettingsType$outboundSchema,
} from "./timeoutretrysettingstype.js";
import {
  Tls4Type,
  Tls4Type$inboundSchema,
  Tls4Type$Outbound,
  Tls4Type$outboundSchema,
} from "./tls4type.js";
import {
  UrlsType,
  UrlsType$inboundSchema,
  UrlsType$Outbound,
  UrlsType$outboundSchema,
} from "./urlstype.js";

export const OutputWebhookType14 = {
  Webhook: "webhook",
} as const;
export type OutputWebhookType14 = ClosedEnum<typeof OutputWebhookType14>;

/**
 * How to format events before sending out
 */
export const OutputWebhookFormat14 = {
  /**
   * NDJSON (Newline Delimited JSON)
   */
  Ndjson: "ndjson",
  /**
   * JSON Array
   */
  JsonArray: "json_array",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Advanced
   */
  Advanced: "advanced",
} as const;
/**
 * How to format events before sending out
 */
export type OutputWebhookFormat14 = OpenEnum<typeof OutputWebhookFormat14>;

export type OutputWebhookWebhook14 = {
  /**
   * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
   */
  loadBalanced?: boolean | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputWebhookType14;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The method to use when sending events
   */
  method?: Method1Options | undefined;
  /**
   * How to format events before sending out
   */
  format?: OutputWebhookFormat14 | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  tls?: Tls4Type | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  /**
   * Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON.
   */
  customSourceExpression?: string | undefined;
  /**
   * Whether to drop events when the source expression evaluates to null
   */
  customDropWhenNull?: boolean | undefined;
  /**
   * Delimiter string to insert between individual events. Defaults to newline character.
   */
  customEventDelimiter?: string | undefined;
  /**
   * Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry.
   */
  customContentType?: string | undefined;
  /**
   * Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object.
   */
  customPayloadExpression?: string | undefined;
  /**
   * HTTP content-type header value
   */
  advancedContentType?: string | undefined;
  /**
   * Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatEventCode?: string | undefined;
  /**
   * Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatPayloadCode?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls?: MetadataType | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
  /**
   * URL of a webhook endpoint to send events to, such as http://localhost:10200
   */
  url?: string | undefined;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  urls: Array<UrlsType>;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
};

export const OutputWebhookType13 = {
  Webhook: "webhook",
} as const;
export type OutputWebhookType13 = ClosedEnum<typeof OutputWebhookType13>;

/**
 * How to format events before sending out
 */
export const OutputWebhookFormat13 = {
  /**
   * NDJSON (Newline Delimited JSON)
   */
  Ndjson: "ndjson",
  /**
   * JSON Array
   */
  JsonArray: "json_array",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Advanced
   */
  Advanced: "advanced",
} as const;
/**
 * How to format events before sending out
 */
export type OutputWebhookFormat13 = OpenEnum<typeof OutputWebhookFormat13>;

export type OutputWebhookWebhook13 = {
  /**
   * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
   */
  loadBalanced?: boolean | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputWebhookType13;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The method to use when sending events
   */
  method?: Method1Options | undefined;
  /**
   * How to format events before sending out
   */
  format?: OutputWebhookFormat13 | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  tls?: Tls4Type | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  /**
   * Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON.
   */
  customSourceExpression?: string | undefined;
  /**
   * Whether to drop events when the source expression evaluates to null
   */
  customDropWhenNull?: boolean | undefined;
  /**
   * Delimiter string to insert between individual events. Defaults to newline character.
   */
  customEventDelimiter?: string | undefined;
  /**
   * Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry.
   */
  customContentType?: string | undefined;
  /**
   * Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object.
   */
  customPayloadExpression?: string | undefined;
  /**
   * HTTP content-type header value
   */
  advancedContentType?: string | undefined;
  /**
   * Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatEventCode?: string | undefined;
  /**
   * Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatPayloadCode?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls?: MetadataType | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
  /**
   * URL of a webhook endpoint to send events to, such as http://localhost:10200
   */
  url: string;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  urls?: Array<UrlsType> | undefined;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
};

export const OutputWebhookType12 = {
  Webhook: "webhook",
} as const;
export type OutputWebhookType12 = ClosedEnum<typeof OutputWebhookType12>;

/**
 * How to format events before sending out
 */
export const OutputWebhookFormat12 = {
  /**
   * NDJSON (Newline Delimited JSON)
   */
  Ndjson: "ndjson",
  /**
   * JSON Array
   */
  JsonArray: "json_array",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Advanced
   */
  Advanced: "advanced",
} as const;
/**
 * How to format events before sending out
 */
export type OutputWebhookFormat12 = OpenEnum<typeof OutputWebhookFormat12>;

export type OutputWebhookWebhook12 = {
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputWebhookType12;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The method to use when sending events
   */
  method?: Method1Options | undefined;
  /**
   * How to format events before sending out
   */
  format?: OutputWebhookFormat12 | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  tls?: Tls4Type | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  /**
   * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
   */
  loadBalanced?: boolean | undefined;
  description?: string | undefined;
  /**
   * Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON.
   */
  customSourceExpression?: string | undefined;
  /**
   * Whether to drop events when the source expression evaluates to null
   */
  customDropWhenNull?: boolean | undefined;
  /**
   * Delimiter string to insert between individual events. Defaults to newline character.
   */
  customEventDelimiter?: string | undefined;
  /**
   * Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry.
   */
  customContentType?: string | undefined;
  /**
   * Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object.
   */
  customPayloadExpression?: string | undefined;
  /**
   * HTTP content-type header value
   */
  advancedContentType?: string | undefined;
  /**
   * Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatEventCode?: string | undefined;
  /**
   * Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatPayloadCode?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls?: MetadataType | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl: string;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName: string;
  /**
   * Secret parameter value to pass in request body
   */
  secret: string;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName: string;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams: Array<Metadata1Type>;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders: Array<Metadata1Type>;
  /**
   * URL of a webhook endpoint to send events to, such as http://localhost:10200
   */
  url?: string | undefined;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  urls?: Array<UrlsType> | undefined;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
};

export const OutputWebhookType11 = {
  Webhook: "webhook",
} as const;
export type OutputWebhookType11 = ClosedEnum<typeof OutputWebhookType11>;

/**
 * How to format events before sending out
 */
export const OutputWebhookFormat11 = {
  /**
   * NDJSON (Newline Delimited JSON)
   */
  Ndjson: "ndjson",
  /**
   * JSON Array
   */
  JsonArray: "json_array",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Advanced
   */
  Advanced: "advanced",
} as const;
/**
 * How to format events before sending out
 */
export type OutputWebhookFormat11 = OpenEnum<typeof OutputWebhookFormat11>;

export type OutputWebhookWebhook11 = {
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputWebhookType11;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The method to use when sending events
   */
  method?: Method1Options | undefined;
  /**
   * How to format events before sending out
   */
  format?: OutputWebhookFormat11 | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  tls?: Tls4Type | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  /**
   * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
   */
  loadBalanced?: boolean | undefined;
  description?: string | undefined;
  /**
   * Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON.
   */
  customSourceExpression?: string | undefined;
  /**
   * Whether to drop events when the source expression evaluates to null
   */
  customDropWhenNull?: boolean | undefined;
  /**
   * Delimiter string to insert between individual events. Defaults to newline character.
   */
  customEventDelimiter?: string | undefined;
  /**
   * Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry.
   */
  customContentType?: string | undefined;
  /**
   * Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object.
   */
  customPayloadExpression?: string | undefined;
  /**
   * HTTP content-type header value
   */
  advancedContentType?: string | undefined;
  /**
   * Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatEventCode?: string | undefined;
  /**
   * Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatPayloadCode?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls?: MetadataType | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret: string;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
  /**
   * URL of a webhook endpoint to send events to, such as http://localhost:10200
   */
  url?: string | undefined;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  urls?: Array<UrlsType> | undefined;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
};

export const OutputWebhookType10 = {
  Webhook: "webhook",
} as const;
export type OutputWebhookType10 = ClosedEnum<typeof OutputWebhookType10>;

/**
 * How to format events before sending out
 */
export const OutputWebhookFormat10 = {
  /**
   * NDJSON (Newline Delimited JSON)
   */
  Ndjson: "ndjson",
  /**
   * JSON Array
   */
  JsonArray: "json_array",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Advanced
   */
  Advanced: "advanced",
} as const;
/**
 * How to format events before sending out
 */
export type OutputWebhookFormat10 = OpenEnum<typeof OutputWebhookFormat10>;

export type OutputWebhookWebhook10 = {
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputWebhookType10;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The method to use when sending events
   */
  method?: Method1Options | undefined;
  /**
   * How to format events before sending out
   */
  format?: OutputWebhookFormat10 | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  tls?: Tls4Type | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  /**
   * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
   */
  loadBalanced?: boolean | undefined;
  description?: string | undefined;
  /**
   * Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON.
   */
  customSourceExpression?: string | undefined;
  /**
   * Whether to drop events when the source expression evaluates to null
   */
  customDropWhenNull?: boolean | undefined;
  /**
   * Delimiter string to insert between individual events. Defaults to newline character.
   */
  customEventDelimiter?: string | undefined;
  /**
   * Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry.
   */
  customContentType?: string | undefined;
  /**
   * Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object.
   */
  customPayloadExpression?: string | undefined;
  /**
   * HTTP content-type header value
   */
  advancedContentType?: string | undefined;
  /**
   * Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatEventCode?: string | undefined;
  /**
   * Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatPayloadCode?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls?: MetadataType | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret: string;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
  /**
   * URL of a webhook endpoint to send events to, such as http://localhost:10200
   */
  url?: string | undefined;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  urls?: Array<UrlsType> | undefined;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
};

export const OutputWebhookType9 = {
  Webhook: "webhook",
} as const;
export type OutputWebhookType9 = ClosedEnum<typeof OutputWebhookType9>;

/**
 * How to format events before sending out
 */
export const OutputWebhookFormat9 = {
  /**
   * NDJSON (Newline Delimited JSON)
   */
  Ndjson: "ndjson",
  /**
   * JSON Array
   */
  JsonArray: "json_array",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Advanced
   */
  Advanced: "advanced",
} as const;
/**
 * How to format events before sending out
 */
export type OutputWebhookFormat9 = OpenEnum<typeof OutputWebhookFormat9>;

export type OutputWebhookWebhook9 = {
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputWebhookType9;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The method to use when sending events
   */
  method?: Method1Options | undefined;
  /**
   * How to format events before sending out
   */
  format?: OutputWebhookFormat9 | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  tls?: Tls4Type | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  /**
   * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
   */
  loadBalanced?: boolean | undefined;
  description?: string | undefined;
  /**
   * Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON.
   */
  customSourceExpression?: string | undefined;
  /**
   * Whether to drop events when the source expression evaluates to null
   */
  customDropWhenNull?: boolean | undefined;
  /**
   * Delimiter string to insert between individual events. Defaults to newline character.
   */
  customEventDelimiter?: string | undefined;
  /**
   * Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry.
   */
  customContentType?: string | undefined;
  /**
   * Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object.
   */
  customPayloadExpression?: string | undefined;
  /**
   * HTTP content-type header value
   */
  advancedContentType?: string | undefined;
  /**
   * Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatEventCode?: string | undefined;
  /**
   * Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatPayloadCode?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls?: MetadataType | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token: string;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
  /**
   * URL of a webhook endpoint to send events to, such as http://localhost:10200
   */
  url?: string | undefined;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  urls?: Array<UrlsType> | undefined;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
};

export const OutputWebhookType8 = {
  Webhook: "webhook",
} as const;
export type OutputWebhookType8 = ClosedEnum<typeof OutputWebhookType8>;

/**
 * How to format events before sending out
 */
export const OutputWebhookFormat8 = {
  /**
   * NDJSON (Newline Delimited JSON)
   */
  Ndjson: "ndjson",
  /**
   * JSON Array
   */
  JsonArray: "json_array",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Advanced
   */
  Advanced: "advanced",
} as const;
/**
 * How to format events before sending out
 */
export type OutputWebhookFormat8 = OpenEnum<typeof OutputWebhookFormat8>;

export type OutputWebhookWebhook8 = {
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputWebhookType8;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The method to use when sending events
   */
  method?: Method1Options | undefined;
  /**
   * How to format events before sending out
   */
  format?: OutputWebhookFormat8 | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  tls?: Tls4Type | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  /**
   * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
   */
  loadBalanced?: boolean | undefined;
  description?: string | undefined;
  /**
   * Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON.
   */
  customSourceExpression?: string | undefined;
  /**
   * Whether to drop events when the source expression evaluates to null
   */
  customDropWhenNull?: boolean | undefined;
  /**
   * Delimiter string to insert between individual events. Defaults to newline character.
   */
  customEventDelimiter?: string | undefined;
  /**
   * Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry.
   */
  customContentType?: string | undefined;
  /**
   * Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object.
   */
  customPayloadExpression?: string | undefined;
  /**
   * HTTP content-type header value
   */
  advancedContentType?: string | undefined;
  /**
   * Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatEventCode?: string | undefined;
  /**
   * Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatPayloadCode?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls?: MetadataType | undefined;
  username: string;
  password: string;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
  /**
   * URL of a webhook endpoint to send events to, such as http://localhost:10200
   */
  url?: string | undefined;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  urls?: Array<UrlsType> | undefined;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
};

export const OutputWebhookType7 = {
  Webhook: "webhook",
} as const;
export type OutputWebhookType7 = ClosedEnum<typeof OutputWebhookType7>;

/**
 * How to format events before sending out
 */
export const OutputWebhookFormat7 = {
  /**
   * NDJSON (Newline Delimited JSON)
   */
  Ndjson: "ndjson",
  /**
   * JSON Array
   */
  JsonArray: "json_array",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Advanced
   */
  Advanced: "advanced",
} as const;
/**
 * How to format events before sending out
 */
export type OutputWebhookFormat7 = OpenEnum<typeof OutputWebhookFormat7>;

export type OutputWebhookWebhook7 = {
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputWebhookType7;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The method to use when sending events
   */
  method?: Method1Options | undefined;
  /**
   * How to format events before sending out
   */
  format?: OutputWebhookFormat7 | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  tls?: Tls4Type | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  /**
   * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
   */
  loadBalanced?: boolean | undefined;
  description?: string | undefined;
  /**
   * Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON.
   */
  customSourceExpression?: string | undefined;
  /**
   * Whether to drop events when the source expression evaluates to null
   */
  customDropWhenNull?: boolean | undefined;
  /**
   * Delimiter string to insert between individual events. Defaults to newline character.
   */
  customEventDelimiter?: string | undefined;
  /**
   * Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry.
   */
  customContentType?: string | undefined;
  /**
   * Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object.
   */
  customPayloadExpression?: string | undefined;
  /**
   * HTTP content-type header value
   */
  advancedContentType?: string | undefined;
  /**
   * Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatEventCode?: string | undefined;
  /**
   * Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatPayloadCode?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls?: MetadataType | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
  /**
   * URL of a webhook endpoint to send events to, such as http://localhost:10200
   */
  url?: string | undefined;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  urls?: Array<UrlsType> | undefined;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
};

export const OutputWebhookType6 = {
  Webhook: "webhook",
} as const;
export type OutputWebhookType6 = ClosedEnum<typeof OutputWebhookType6>;

/**
 * How to format events before sending out
 */
export const OutputWebhookFormat6 = {
  /**
   * NDJSON (Newline Delimited JSON)
   */
  Ndjson: "ndjson",
  /**
   * JSON Array
   */
  JsonArray: "json_array",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Advanced
   */
  Advanced: "advanced",
} as const;
/**
 * How to format events before sending out
 */
export type OutputWebhookFormat6 = OpenEnum<typeof OutputWebhookFormat6>;

export type OutputWebhookWebhook6 = {
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputWebhookType6;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The method to use when sending events
   */
  method?: Method1Options | undefined;
  /**
   * How to format events before sending out
   */
  format?: OutputWebhookFormat6 | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  tls?: Tls4Type | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  /**
   * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
   */
  loadBalanced?: boolean | undefined;
  description?: string | undefined;
  /**
   * Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON.
   */
  customSourceExpression?: string | undefined;
  /**
   * Whether to drop events when the source expression evaluates to null
   */
  customDropWhenNull?: boolean | undefined;
  /**
   * Delimiter string to insert between individual events. Defaults to newline character.
   */
  customEventDelimiter?: string | undefined;
  /**
   * Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry.
   */
  customContentType?: string | undefined;
  /**
   * Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object.
   */
  customPayloadExpression?: string | undefined;
  /**
   * HTTP content-type header value
   */
  advancedContentType?: string | undefined;
  /**
   * Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatEventCode?: string | undefined;
  /**
   * Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatPayloadCode?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls: MetadataType;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
  /**
   * URL of a webhook endpoint to send events to, such as http://localhost:10200
   */
  url?: string | undefined;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  urls?: Array<UrlsType> | undefined;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
};

export const OutputWebhookType5 = {
  Webhook: "webhook",
} as const;
export type OutputWebhookType5 = ClosedEnum<typeof OutputWebhookType5>;

/**
 * How to format events before sending out
 */
export const OutputWebhookFormat5 = {
  /**
   * NDJSON (Newline Delimited JSON)
   */
  Ndjson: "ndjson",
  /**
   * JSON Array
   */
  JsonArray: "json_array",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Advanced
   */
  Advanced: "advanced",
} as const;
/**
 * How to format events before sending out
 */
export type OutputWebhookFormat5 = OpenEnum<typeof OutputWebhookFormat5>;

export type OutputWebhookWebhook5 = {
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputWebhookType5;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The method to use when sending events
   */
  method?: Method1Options | undefined;
  /**
   * How to format events before sending out
   */
  format?: OutputWebhookFormat5 | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  tls?: Tls4Type | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  /**
   * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
   */
  loadBalanced?: boolean | undefined;
  description?: string | undefined;
  /**
   * Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON.
   */
  customSourceExpression?: string | undefined;
  /**
   * Whether to drop events when the source expression evaluates to null
   */
  customDropWhenNull?: boolean | undefined;
  /**
   * Delimiter string to insert between individual events. Defaults to newline character.
   */
  customEventDelimiter?: string | undefined;
  /**
   * Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry.
   */
  customContentType?: string | undefined;
  /**
   * Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object.
   */
  customPayloadExpression?: string | undefined;
  /**
   * HTTP content-type header value
   */
  advancedContentType?: string | undefined;
  /**
   * Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatEventCode?: string | undefined;
  /**
   * Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatPayloadCode?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls?: MetadataType | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
  /**
   * URL of a webhook endpoint to send events to, such as http://localhost:10200
   */
  url?: string | undefined;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  urls?: Array<UrlsType> | undefined;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
};

/**
 * How to format events before sending out
 */
export const OutputWebhookFormat4 = {
  /**
   * NDJSON (Newline Delimited JSON)
   */
  Ndjson: "ndjson",
  /**
   * JSON Array
   */
  JsonArray: "json_array",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Advanced
   */
  Advanced: "advanced",
} as const;
/**
 * How to format events before sending out
 */
export type OutputWebhookFormat4 = OpenEnum<typeof OutputWebhookFormat4>;

export const OutputWebhookType4 = {
  Webhook: "webhook",
} as const;
export type OutputWebhookType4 = ClosedEnum<typeof OutputWebhookType4>;

export type OutputWebhookWebhook4 = {
  /**
   * How to format events before sending out
   */
  format?: OutputWebhookFormat4 | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputWebhookType4;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The method to use when sending events
   */
  method?: Method1Options | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  tls?: Tls4Type | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  /**
   * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
   */
  loadBalanced?: boolean | undefined;
  description?: string | undefined;
  /**
   * Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON.
   */
  customSourceExpression?: string | undefined;
  /**
   * Whether to drop events when the source expression evaluates to null
   */
  customDropWhenNull?: boolean | undefined;
  /**
   * Delimiter string to insert between individual events. Defaults to newline character.
   */
  customEventDelimiter?: string | undefined;
  /**
   * Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry.
   */
  customContentType?: string | undefined;
  /**
   * Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object.
   */
  customPayloadExpression?: string | undefined;
  /**
   * HTTP content-type header value
   */
  advancedContentType?: string | undefined;
  /**
   * Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatEventCode: string;
  /**
   * Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatPayloadCode: string;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls?: MetadataType | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
  /**
   * URL of a webhook endpoint to send events to, such as http://localhost:10200
   */
  url?: string | undefined;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  urls?: Array<UrlsType> | undefined;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
};

/**
 * How to format events before sending out
 */
export const OutputWebhookFormat3 = {
  /**
   * NDJSON (Newline Delimited JSON)
   */
  Ndjson: "ndjson",
  /**
   * JSON Array
   */
  JsonArray: "json_array",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Advanced
   */
  Advanced: "advanced",
} as const;
/**
 * How to format events before sending out
 */
export type OutputWebhookFormat3 = OpenEnum<typeof OutputWebhookFormat3>;

export const OutputWebhookType3 = {
  Webhook: "webhook",
} as const;
export type OutputWebhookType3 = ClosedEnum<typeof OutputWebhookType3>;

export type OutputWebhookWebhook3 = {
  /**
   * How to format events before sending out
   */
  format?: OutputWebhookFormat3 | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputWebhookType3;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The method to use when sending events
   */
  method?: Method1Options | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  tls?: Tls4Type | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  /**
   * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
   */
  loadBalanced?: boolean | undefined;
  description?: string | undefined;
  /**
   * Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON.
   */
  customSourceExpression?: string | undefined;
  /**
   * Whether to drop events when the source expression evaluates to null
   */
  customDropWhenNull?: boolean | undefined;
  /**
   * Delimiter string to insert between individual events. Defaults to newline character.
   */
  customEventDelimiter?: string | undefined;
  /**
   * Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry.
   */
  customContentType?: string | undefined;
  /**
   * Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object.
   */
  customPayloadExpression?: string | undefined;
  /**
   * HTTP content-type header value
   */
  advancedContentType?: string | undefined;
  /**
   * Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatEventCode?: string | undefined;
  /**
   * Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatPayloadCode?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls?: MetadataType | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
  /**
   * URL of a webhook endpoint to send events to, such as http://localhost:10200
   */
  url?: string | undefined;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  urls?: Array<UrlsType> | undefined;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
};

/**
 * How to format events before sending out
 */
export const OutputWebhookFormat2 = {
  /**
   * NDJSON (Newline Delimited JSON)
   */
  Ndjson: "ndjson",
  /**
   * JSON Array
   */
  JsonArray: "json_array",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Advanced
   */
  Advanced: "advanced",
} as const;
/**
 * How to format events before sending out
 */
export type OutputWebhookFormat2 = OpenEnum<typeof OutputWebhookFormat2>;

export const OutputWebhookType2 = {
  Webhook: "webhook",
} as const;
export type OutputWebhookType2 = ClosedEnum<typeof OutputWebhookType2>;

export type OutputWebhookWebhook2 = {
  /**
   * How to format events before sending out
   */
  format?: OutputWebhookFormat2 | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputWebhookType2;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The method to use when sending events
   */
  method?: Method1Options | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  tls?: Tls4Type | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  /**
   * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
   */
  loadBalanced?: boolean | undefined;
  description?: string | undefined;
  /**
   * Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON.
   */
  customSourceExpression?: string | undefined;
  /**
   * Whether to drop events when the source expression evaluates to null
   */
  customDropWhenNull?: boolean | undefined;
  /**
   * Delimiter string to insert between individual events. Defaults to newline character.
   */
  customEventDelimiter?: string | undefined;
  /**
   * Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry.
   */
  customContentType?: string | undefined;
  /**
   * Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object.
   */
  customPayloadExpression?: string | undefined;
  /**
   * HTTP content-type header value
   */
  advancedContentType?: string | undefined;
  /**
   * Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatEventCode?: string | undefined;
  /**
   * Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatPayloadCode?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls?: MetadataType | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
  /**
   * URL of a webhook endpoint to send events to, such as http://localhost:10200
   */
  url?: string | undefined;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  urls?: Array<UrlsType> | undefined;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
};

/**
 * How to format events before sending out
 */
export const OutputWebhookFormat1 = {
  /**
   * NDJSON (Newline Delimited JSON)
   */
  Ndjson: "ndjson",
  /**
   * JSON Array
   */
  JsonArray: "json_array",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Advanced
   */
  Advanced: "advanced",
} as const;
/**
 * How to format events before sending out
 */
export type OutputWebhookFormat1 = OpenEnum<typeof OutputWebhookFormat1>;

export const OutputWebhookType1 = {
  Webhook: "webhook",
} as const;
export type OutputWebhookType1 = ClosedEnum<typeof OutputWebhookType1>;

export type OutputWebhookWebhook1 = {
  /**
   * How to format events before sending out
   */
  format?: OutputWebhookFormat1 | undefined;
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: OutputWebhookType1;
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The method to use when sending events
   */
  method?: Method1Options | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
   */
  extraHttpHeaders?: Array<ExtraHttpHeadersType> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ResponseRetrySettingsType> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: OnBackpressureOptions | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: AuthTypeOptions | undefined;
  tls?: Tls4Type | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  /**
   * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
   */
  loadBalanced?: boolean | undefined;
  description?: string | undefined;
  /**
   * Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON.
   */
  customSourceExpression?: string | undefined;
  /**
   * Whether to drop events when the source expression evaluates to null
   */
  customDropWhenNull?: boolean | undefined;
  /**
   * Delimiter string to insert between individual events. Defaults to newline character.
   */
  customEventDelimiter?: string | undefined;
  /**
   * Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry.
   */
  customContentType?: string | undefined;
  /**
   * Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object.
   */
  customPayloadExpression?: string | undefined;
  /**
   * HTTP content-type header value
   */
  advancedContentType?: string | undefined;
  /**
   * Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatEventCode?: string | undefined;
  /**
   * Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatPayloadCode?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: PqModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: PqCompressOptions | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: PqOnBackpressureOptions | undefined;
  pqControls?: MetadataType | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<Metadata1Type> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<Metadata1Type> | undefined;
  /**
   * URL of a webhook endpoint to send events to, such as http://localhost:10200
   */
  url?: string | undefined;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  urls?: Array<UrlsType> | undefined;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
};

export type OutputWebhook =
  | OutputWebhookWebhook12
  | OutputWebhookWebhook4
  | OutputWebhookWebhook8
  | OutputWebhookWebhook6
  | OutputWebhookWebhook9
  | OutputWebhookWebhook10
  | OutputWebhookWebhook11
  | OutputWebhookWebhook13
  | OutputWebhookWebhook14
  | OutputWebhookWebhook1
  | OutputWebhookWebhook2
  | OutputWebhookWebhook3
  | OutputWebhookWebhook5
  | OutputWebhookWebhook7;

/** @internal */
export const OutputWebhookType14$inboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType14
> = z.nativeEnum(OutputWebhookType14);
/** @internal */
export const OutputWebhookType14$outboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType14
> = OutputWebhookType14$inboundSchema;

/** @internal */
export const OutputWebhookFormat14$inboundSchema: z.ZodType<
  OutputWebhookFormat14,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputWebhookFormat14),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputWebhookFormat14$outboundSchema: z.ZodType<
  OutputWebhookFormat14,
  z.ZodTypeDef,
  OutputWebhookFormat14
> = z.union([
  z.nativeEnum(OutputWebhookFormat14),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputWebhookWebhook14$inboundSchema: z.ZodType<
  OutputWebhookWebhook14,
  z.ZodTypeDef,
  unknown
> = z.object({
  loadBalanced: z.boolean().default(false),
  id: z.string().optional(),
  type: OutputWebhookType14$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$inboundSchema.default("POST"),
  format: OutputWebhookFormat14$inboundSchema.default("ndjson"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  tls: Tls4Type$inboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$inboundSchema),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});
/** @internal */
export type OutputWebhookWebhook14$Outbound = {
  loadBalanced: boolean;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  method: string;
  format: string;
  keepAlive: boolean;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  authType: string;
  tls?: Tls4Type$Outbound | undefined;
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  customSourceExpression: string;
  customDropWhenNull: boolean;
  customEventDelimiter: string;
  customContentType: string;
  customPayloadExpression: string;
  advancedContentType: string;
  formatEventCode?: string | undefined;
  formatPayloadCode?: string | undefined;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls?: MetadataType$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
  url?: string | undefined;
  excludeSelf: boolean;
  urls: Array<UrlsType$Outbound>;
  dnsResolvePeriodSec: number;
  loadBalanceStatsPeriodSec: number;
};

/** @internal */
export const OutputWebhookWebhook14$outboundSchema: z.ZodType<
  OutputWebhookWebhook14$Outbound,
  z.ZodTypeDef,
  OutputWebhookWebhook14
> = z.object({
  loadBalanced: z.boolean().default(false),
  id: z.string().optional(),
  type: OutputWebhookType14$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$outboundSchema.default("POST"),
  format: OutputWebhookFormat14$outboundSchema.default("ndjson"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  tls: Tls4Type$outboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$outboundSchema),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});

export function outputWebhookWebhook14ToJSON(
  outputWebhookWebhook14: OutputWebhookWebhook14,
): string {
  return JSON.stringify(
    OutputWebhookWebhook14$outboundSchema.parse(outputWebhookWebhook14),
  );
}
export function outputWebhookWebhook14FromJSON(
  jsonString: string,
): SafeParseResult<OutputWebhookWebhook14, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputWebhookWebhook14$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWebhookWebhook14' from JSON`,
  );
}

/** @internal */
export const OutputWebhookType13$inboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType13
> = z.nativeEnum(OutputWebhookType13);
/** @internal */
export const OutputWebhookType13$outboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType13
> = OutputWebhookType13$inboundSchema;

/** @internal */
export const OutputWebhookFormat13$inboundSchema: z.ZodType<
  OutputWebhookFormat13,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputWebhookFormat13),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputWebhookFormat13$outboundSchema: z.ZodType<
  OutputWebhookFormat13,
  z.ZodTypeDef,
  OutputWebhookFormat13
> = z.union([
  z.nativeEnum(OutputWebhookFormat13),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputWebhookWebhook13$inboundSchema: z.ZodType<
  OutputWebhookWebhook13,
  z.ZodTypeDef,
  unknown
> = z.object({
  loadBalanced: z.boolean().default(false),
  id: z.string().optional(),
  type: OutputWebhookType13$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$inboundSchema.default("POST"),
  format: OutputWebhookFormat13$inboundSchema.default("ndjson"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  tls: Tls4Type$inboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
  url: z.string(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$inboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});
/** @internal */
export type OutputWebhookWebhook13$Outbound = {
  loadBalanced: boolean;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  method: string;
  format: string;
  keepAlive: boolean;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  authType: string;
  tls?: Tls4Type$Outbound | undefined;
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  customSourceExpression: string;
  customDropWhenNull: boolean;
  customEventDelimiter: string;
  customContentType: string;
  customPayloadExpression: string;
  advancedContentType: string;
  formatEventCode?: string | undefined;
  formatPayloadCode?: string | undefined;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls?: MetadataType$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
  url: string;
  excludeSelf: boolean;
  urls?: Array<UrlsType$Outbound> | undefined;
  dnsResolvePeriodSec: number;
  loadBalanceStatsPeriodSec: number;
};

/** @internal */
export const OutputWebhookWebhook13$outboundSchema: z.ZodType<
  OutputWebhookWebhook13$Outbound,
  z.ZodTypeDef,
  OutputWebhookWebhook13
> = z.object({
  loadBalanced: z.boolean().default(false),
  id: z.string().optional(),
  type: OutputWebhookType13$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$outboundSchema.default("POST"),
  format: OutputWebhookFormat13$outboundSchema.default("ndjson"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  tls: Tls4Type$outboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
  url: z.string(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$outboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});

export function outputWebhookWebhook13ToJSON(
  outputWebhookWebhook13: OutputWebhookWebhook13,
): string {
  return JSON.stringify(
    OutputWebhookWebhook13$outboundSchema.parse(outputWebhookWebhook13),
  );
}
export function outputWebhookWebhook13FromJSON(
  jsonString: string,
): SafeParseResult<OutputWebhookWebhook13, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputWebhookWebhook13$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWebhookWebhook13' from JSON`,
  );
}

/** @internal */
export const OutputWebhookType12$inboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType12
> = z.nativeEnum(OutputWebhookType12);
/** @internal */
export const OutputWebhookType12$outboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType12
> = OutputWebhookType12$inboundSchema;

/** @internal */
export const OutputWebhookFormat12$inboundSchema: z.ZodType<
  OutputWebhookFormat12,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputWebhookFormat12),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputWebhookFormat12$outboundSchema: z.ZodType<
  OutputWebhookFormat12,
  z.ZodTypeDef,
  OutputWebhookFormat12
> = z.union([
  z.nativeEnum(OutputWebhookFormat12),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputWebhookWebhook12$inboundSchema: z.ZodType<
  OutputWebhookWebhook12,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputWebhookType12$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$inboundSchema.default("POST"),
  format: OutputWebhookFormat12$inboundSchema.default("ndjson"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  tls: Tls4Type$inboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string(),
  secretParamName: z.string(),
  secret: z.string(),
  tokenAttributeName: z.string(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema),
  oauthHeaders: z.array(Metadata1Type$inboundSchema),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$inboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});
/** @internal */
export type OutputWebhookWebhook12$Outbound = {
  authType: string;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  method: string;
  format: string;
  keepAlive: boolean;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  tls?: Tls4Type$Outbound | undefined;
  totalMemoryLimitKB?: number | undefined;
  loadBalanced: boolean;
  description?: string | undefined;
  customSourceExpression: string;
  customDropWhenNull: boolean;
  customEventDelimiter: string;
  customContentType: string;
  customPayloadExpression: string;
  advancedContentType: string;
  formatEventCode?: string | undefined;
  formatPayloadCode?: string | undefined;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls?: MetadataType$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl: string;
  secretParamName: string;
  secret: string;
  tokenAttributeName: string;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams: Array<Metadata1Type$Outbound>;
  oauthHeaders: Array<Metadata1Type$Outbound>;
  url?: string | undefined;
  excludeSelf: boolean;
  urls?: Array<UrlsType$Outbound> | undefined;
  dnsResolvePeriodSec: number;
  loadBalanceStatsPeriodSec: number;
};

/** @internal */
export const OutputWebhookWebhook12$outboundSchema: z.ZodType<
  OutputWebhookWebhook12$Outbound,
  z.ZodTypeDef,
  OutputWebhookWebhook12
> = z.object({
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputWebhookType12$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$outboundSchema.default("POST"),
  format: OutputWebhookFormat12$outboundSchema.default("ndjson"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  tls: Tls4Type$outboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string(),
  secretParamName: z.string(),
  secret: z.string(),
  tokenAttributeName: z.string(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema),
  oauthHeaders: z.array(Metadata1Type$outboundSchema),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$outboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});

export function outputWebhookWebhook12ToJSON(
  outputWebhookWebhook12: OutputWebhookWebhook12,
): string {
  return JSON.stringify(
    OutputWebhookWebhook12$outboundSchema.parse(outputWebhookWebhook12),
  );
}
export function outputWebhookWebhook12FromJSON(
  jsonString: string,
): SafeParseResult<OutputWebhookWebhook12, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputWebhookWebhook12$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWebhookWebhook12' from JSON`,
  );
}

/** @internal */
export const OutputWebhookType11$inboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType11
> = z.nativeEnum(OutputWebhookType11);
/** @internal */
export const OutputWebhookType11$outboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType11
> = OutputWebhookType11$inboundSchema;

/** @internal */
export const OutputWebhookFormat11$inboundSchema: z.ZodType<
  OutputWebhookFormat11,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputWebhookFormat11),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputWebhookFormat11$outboundSchema: z.ZodType<
  OutputWebhookFormat11,
  z.ZodTypeDef,
  OutputWebhookFormat11
> = z.union([
  z.nativeEnum(OutputWebhookFormat11),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputWebhookWebhook11$inboundSchema: z.ZodType<
  OutputWebhookWebhook11,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputWebhookType11$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$inboundSchema.default("POST"),
  format: OutputWebhookFormat11$inboundSchema.default("ndjson"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  tls: Tls4Type$inboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$inboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});
/** @internal */
export type OutputWebhookWebhook11$Outbound = {
  authType: string;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  method: string;
  format: string;
  keepAlive: boolean;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  tls?: Tls4Type$Outbound | undefined;
  totalMemoryLimitKB?: number | undefined;
  loadBalanced: boolean;
  description?: string | undefined;
  customSourceExpression: string;
  customDropWhenNull: boolean;
  customEventDelimiter: string;
  customContentType: string;
  customPayloadExpression: string;
  advancedContentType: string;
  formatEventCode?: string | undefined;
  formatPayloadCode?: string | undefined;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls?: MetadataType$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret: string;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
  url?: string | undefined;
  excludeSelf: boolean;
  urls?: Array<UrlsType$Outbound> | undefined;
  dnsResolvePeriodSec: number;
  loadBalanceStatsPeriodSec: number;
};

/** @internal */
export const OutputWebhookWebhook11$outboundSchema: z.ZodType<
  OutputWebhookWebhook11$Outbound,
  z.ZodTypeDef,
  OutputWebhookWebhook11
> = z.object({
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputWebhookType11$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$outboundSchema.default("POST"),
  format: OutputWebhookFormat11$outboundSchema.default("ndjson"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  tls: Tls4Type$outboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$outboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});

export function outputWebhookWebhook11ToJSON(
  outputWebhookWebhook11: OutputWebhookWebhook11,
): string {
  return JSON.stringify(
    OutputWebhookWebhook11$outboundSchema.parse(outputWebhookWebhook11),
  );
}
export function outputWebhookWebhook11FromJSON(
  jsonString: string,
): SafeParseResult<OutputWebhookWebhook11, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputWebhookWebhook11$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWebhookWebhook11' from JSON`,
  );
}

/** @internal */
export const OutputWebhookType10$inboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType10
> = z.nativeEnum(OutputWebhookType10);
/** @internal */
export const OutputWebhookType10$outboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType10
> = OutputWebhookType10$inboundSchema;

/** @internal */
export const OutputWebhookFormat10$inboundSchema: z.ZodType<
  OutputWebhookFormat10,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputWebhookFormat10),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputWebhookFormat10$outboundSchema: z.ZodType<
  OutputWebhookFormat10,
  z.ZodTypeDef,
  OutputWebhookFormat10
> = z.union([
  z.nativeEnum(OutputWebhookFormat10),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputWebhookWebhook10$inboundSchema: z.ZodType<
  OutputWebhookWebhook10,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputWebhookType10$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$inboundSchema.default("POST"),
  format: OutputWebhookFormat10$inboundSchema.default("ndjson"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  tls: Tls4Type$inboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$inboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});
/** @internal */
export type OutputWebhookWebhook10$Outbound = {
  authType: string;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  method: string;
  format: string;
  keepAlive: boolean;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  tls?: Tls4Type$Outbound | undefined;
  totalMemoryLimitKB?: number | undefined;
  loadBalanced: boolean;
  description?: string | undefined;
  customSourceExpression: string;
  customDropWhenNull: boolean;
  customEventDelimiter: string;
  customContentType: string;
  customPayloadExpression: string;
  advancedContentType: string;
  formatEventCode?: string | undefined;
  formatPayloadCode?: string | undefined;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls?: MetadataType$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret: string;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
  url?: string | undefined;
  excludeSelf: boolean;
  urls?: Array<UrlsType$Outbound> | undefined;
  dnsResolvePeriodSec: number;
  loadBalanceStatsPeriodSec: number;
};

/** @internal */
export const OutputWebhookWebhook10$outboundSchema: z.ZodType<
  OutputWebhookWebhook10$Outbound,
  z.ZodTypeDef,
  OutputWebhookWebhook10
> = z.object({
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputWebhookType10$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$outboundSchema.default("POST"),
  format: OutputWebhookFormat10$outboundSchema.default("ndjson"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  tls: Tls4Type$outboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$outboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});

export function outputWebhookWebhook10ToJSON(
  outputWebhookWebhook10: OutputWebhookWebhook10,
): string {
  return JSON.stringify(
    OutputWebhookWebhook10$outboundSchema.parse(outputWebhookWebhook10),
  );
}
export function outputWebhookWebhook10FromJSON(
  jsonString: string,
): SafeParseResult<OutputWebhookWebhook10, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputWebhookWebhook10$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWebhookWebhook10' from JSON`,
  );
}

/** @internal */
export const OutputWebhookType9$inboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType9
> = z.nativeEnum(OutputWebhookType9);
/** @internal */
export const OutputWebhookType9$outboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType9
> = OutputWebhookType9$inboundSchema;

/** @internal */
export const OutputWebhookFormat9$inboundSchema: z.ZodType<
  OutputWebhookFormat9,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputWebhookFormat9),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputWebhookFormat9$outboundSchema: z.ZodType<
  OutputWebhookFormat9,
  z.ZodTypeDef,
  OutputWebhookFormat9
> = z.union([
  z.nativeEnum(OutputWebhookFormat9),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputWebhookWebhook9$inboundSchema: z.ZodType<
  OutputWebhookWebhook9,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputWebhookType9$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$inboundSchema.default("POST"),
  format: OutputWebhookFormat9$inboundSchema.default("ndjson"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  tls: Tls4Type$inboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$inboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});
/** @internal */
export type OutputWebhookWebhook9$Outbound = {
  authType: string;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  method: string;
  format: string;
  keepAlive: boolean;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  tls?: Tls4Type$Outbound | undefined;
  totalMemoryLimitKB?: number | undefined;
  loadBalanced: boolean;
  description?: string | undefined;
  customSourceExpression: string;
  customDropWhenNull: boolean;
  customEventDelimiter: string;
  customContentType: string;
  customPayloadExpression: string;
  advancedContentType: string;
  formatEventCode?: string | undefined;
  formatPayloadCode?: string | undefined;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls?: MetadataType$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token: string;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
  url?: string | undefined;
  excludeSelf: boolean;
  urls?: Array<UrlsType$Outbound> | undefined;
  dnsResolvePeriodSec: number;
  loadBalanceStatsPeriodSec: number;
};

/** @internal */
export const OutputWebhookWebhook9$outboundSchema: z.ZodType<
  OutputWebhookWebhook9$Outbound,
  z.ZodTypeDef,
  OutputWebhookWebhook9
> = z.object({
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputWebhookType9$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$outboundSchema.default("POST"),
  format: OutputWebhookFormat9$outboundSchema.default("ndjson"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  tls: Tls4Type$outboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$outboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});

export function outputWebhookWebhook9ToJSON(
  outputWebhookWebhook9: OutputWebhookWebhook9,
): string {
  return JSON.stringify(
    OutputWebhookWebhook9$outboundSchema.parse(outputWebhookWebhook9),
  );
}
export function outputWebhookWebhook9FromJSON(
  jsonString: string,
): SafeParseResult<OutputWebhookWebhook9, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputWebhookWebhook9$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWebhookWebhook9' from JSON`,
  );
}

/** @internal */
export const OutputWebhookType8$inboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType8
> = z.nativeEnum(OutputWebhookType8);
/** @internal */
export const OutputWebhookType8$outboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType8
> = OutputWebhookType8$inboundSchema;

/** @internal */
export const OutputWebhookFormat8$inboundSchema: z.ZodType<
  OutputWebhookFormat8,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputWebhookFormat8),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputWebhookFormat8$outboundSchema: z.ZodType<
  OutputWebhookFormat8,
  z.ZodTypeDef,
  OutputWebhookFormat8
> = z.union([
  z.nativeEnum(OutputWebhookFormat8),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputWebhookWebhook8$inboundSchema: z.ZodType<
  OutputWebhookWebhook8,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputWebhookType8$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$inboundSchema.default("POST"),
  format: OutputWebhookFormat8$inboundSchema.default("ndjson"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  tls: Tls4Type$inboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema.optional(),
  username: z.string(),
  password: z.string(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$inboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});
/** @internal */
export type OutputWebhookWebhook8$Outbound = {
  authType: string;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  method: string;
  format: string;
  keepAlive: boolean;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  tls?: Tls4Type$Outbound | undefined;
  totalMemoryLimitKB?: number | undefined;
  loadBalanced: boolean;
  description?: string | undefined;
  customSourceExpression: string;
  customDropWhenNull: boolean;
  customEventDelimiter: string;
  customContentType: string;
  customPayloadExpression: string;
  advancedContentType: string;
  formatEventCode?: string | undefined;
  formatPayloadCode?: string | undefined;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls?: MetadataType$Outbound | undefined;
  username: string;
  password: string;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
  url?: string | undefined;
  excludeSelf: boolean;
  urls?: Array<UrlsType$Outbound> | undefined;
  dnsResolvePeriodSec: number;
  loadBalanceStatsPeriodSec: number;
};

/** @internal */
export const OutputWebhookWebhook8$outboundSchema: z.ZodType<
  OutputWebhookWebhook8$Outbound,
  z.ZodTypeDef,
  OutputWebhookWebhook8
> = z.object({
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputWebhookType8$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$outboundSchema.default("POST"),
  format: OutputWebhookFormat8$outboundSchema.default("ndjson"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  tls: Tls4Type$outboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema.optional(),
  username: z.string(),
  password: z.string(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$outboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});

export function outputWebhookWebhook8ToJSON(
  outputWebhookWebhook8: OutputWebhookWebhook8,
): string {
  return JSON.stringify(
    OutputWebhookWebhook8$outboundSchema.parse(outputWebhookWebhook8),
  );
}
export function outputWebhookWebhook8FromJSON(
  jsonString: string,
): SafeParseResult<OutputWebhookWebhook8, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputWebhookWebhook8$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWebhookWebhook8' from JSON`,
  );
}

/** @internal */
export const OutputWebhookType7$inboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType7
> = z.nativeEnum(OutputWebhookType7);
/** @internal */
export const OutputWebhookType7$outboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType7
> = OutputWebhookType7$inboundSchema;

/** @internal */
export const OutputWebhookFormat7$inboundSchema: z.ZodType<
  OutputWebhookFormat7,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputWebhookFormat7),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputWebhookFormat7$outboundSchema: z.ZodType<
  OutputWebhookFormat7,
  z.ZodTypeDef,
  OutputWebhookFormat7
> = z.union([
  z.nativeEnum(OutputWebhookFormat7),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputWebhookWebhook7$inboundSchema: z.ZodType<
  OutputWebhookWebhook7,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputWebhookType7$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$inboundSchema.default("POST"),
  format: OutputWebhookFormat7$inboundSchema.default("ndjson"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  tls: Tls4Type$inboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$inboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});
/** @internal */
export type OutputWebhookWebhook7$Outbound = {
  authType: string;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  method: string;
  format: string;
  keepAlive: boolean;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  tls?: Tls4Type$Outbound | undefined;
  totalMemoryLimitKB?: number | undefined;
  loadBalanced: boolean;
  description?: string | undefined;
  customSourceExpression: string;
  customDropWhenNull: boolean;
  customEventDelimiter: string;
  customContentType: string;
  customPayloadExpression: string;
  advancedContentType: string;
  formatEventCode?: string | undefined;
  formatPayloadCode?: string | undefined;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls?: MetadataType$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
  url?: string | undefined;
  excludeSelf: boolean;
  urls?: Array<UrlsType$Outbound> | undefined;
  dnsResolvePeriodSec: number;
  loadBalanceStatsPeriodSec: number;
};

/** @internal */
export const OutputWebhookWebhook7$outboundSchema: z.ZodType<
  OutputWebhookWebhook7$Outbound,
  z.ZodTypeDef,
  OutputWebhookWebhook7
> = z.object({
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  id: z.string().optional(),
  type: OutputWebhookType7$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$outboundSchema.default("POST"),
  format: OutputWebhookFormat7$outboundSchema.default("ndjson"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  tls: Tls4Type$outboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$outboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});

export function outputWebhookWebhook7ToJSON(
  outputWebhookWebhook7: OutputWebhookWebhook7,
): string {
  return JSON.stringify(
    OutputWebhookWebhook7$outboundSchema.parse(outputWebhookWebhook7),
  );
}
export function outputWebhookWebhook7FromJSON(
  jsonString: string,
): SafeParseResult<OutputWebhookWebhook7, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputWebhookWebhook7$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWebhookWebhook7' from JSON`,
  );
}

/** @internal */
export const OutputWebhookType6$inboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType6
> = z.nativeEnum(OutputWebhookType6);
/** @internal */
export const OutputWebhookType6$outboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType6
> = OutputWebhookType6$inboundSchema;

/** @internal */
export const OutputWebhookFormat6$inboundSchema: z.ZodType<
  OutputWebhookFormat6,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputWebhookFormat6),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputWebhookFormat6$outboundSchema: z.ZodType<
  OutputWebhookFormat6,
  z.ZodTypeDef,
  OutputWebhookFormat6
> = z.union([
  z.nativeEnum(OutputWebhookFormat6),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputWebhookWebhook6$inboundSchema: z.ZodType<
  OutputWebhookWebhook6,
  z.ZodTypeDef,
  unknown
> = z.object({
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  id: z.string().optional(),
  type: OutputWebhookType6$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$inboundSchema.default("POST"),
  format: OutputWebhookFormat6$inboundSchema.default("ndjson"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  tls: Tls4Type$inboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema,
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$inboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});
/** @internal */
export type OutputWebhookWebhook6$Outbound = {
  onBackpressure: string;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  method: string;
  format: string;
  keepAlive: boolean;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  authType: string;
  tls?: Tls4Type$Outbound | undefined;
  totalMemoryLimitKB?: number | undefined;
  loadBalanced: boolean;
  description?: string | undefined;
  customSourceExpression: string;
  customDropWhenNull: boolean;
  customEventDelimiter: string;
  customContentType: string;
  customPayloadExpression: string;
  advancedContentType: string;
  formatEventCode?: string | undefined;
  formatPayloadCode?: string | undefined;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls: MetadataType$Outbound;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
  url?: string | undefined;
  excludeSelf: boolean;
  urls?: Array<UrlsType$Outbound> | undefined;
  dnsResolvePeriodSec: number;
  loadBalanceStatsPeriodSec: number;
};

/** @internal */
export const OutputWebhookWebhook6$outboundSchema: z.ZodType<
  OutputWebhookWebhook6$Outbound,
  z.ZodTypeDef,
  OutputWebhookWebhook6
> = z.object({
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  id: z.string().optional(),
  type: OutputWebhookType6$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$outboundSchema.default("POST"),
  format: OutputWebhookFormat6$outboundSchema.default("ndjson"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  tls: Tls4Type$outboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema,
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$outboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});

export function outputWebhookWebhook6ToJSON(
  outputWebhookWebhook6: OutputWebhookWebhook6,
): string {
  return JSON.stringify(
    OutputWebhookWebhook6$outboundSchema.parse(outputWebhookWebhook6),
  );
}
export function outputWebhookWebhook6FromJSON(
  jsonString: string,
): SafeParseResult<OutputWebhookWebhook6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputWebhookWebhook6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWebhookWebhook6' from JSON`,
  );
}

/** @internal */
export const OutputWebhookType5$inboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType5
> = z.nativeEnum(OutputWebhookType5);
/** @internal */
export const OutputWebhookType5$outboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType5
> = OutputWebhookType5$inboundSchema;

/** @internal */
export const OutputWebhookFormat5$inboundSchema: z.ZodType<
  OutputWebhookFormat5,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputWebhookFormat5),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputWebhookFormat5$outboundSchema: z.ZodType<
  OutputWebhookFormat5,
  z.ZodTypeDef,
  OutputWebhookFormat5
> = z.union([
  z.nativeEnum(OutputWebhookFormat5),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputWebhookWebhook5$inboundSchema: z.ZodType<
  OutputWebhookWebhook5,
  z.ZodTypeDef,
  unknown
> = z.object({
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  id: z.string().optional(),
  type: OutputWebhookType5$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$inboundSchema.default("POST"),
  format: OutputWebhookFormat5$inboundSchema.default("ndjson"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  tls: Tls4Type$inboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$inboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});
/** @internal */
export type OutputWebhookWebhook5$Outbound = {
  onBackpressure: string;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  method: string;
  format: string;
  keepAlive: boolean;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  authType: string;
  tls?: Tls4Type$Outbound | undefined;
  totalMemoryLimitKB?: number | undefined;
  loadBalanced: boolean;
  description?: string | undefined;
  customSourceExpression: string;
  customDropWhenNull: boolean;
  customEventDelimiter: string;
  customContentType: string;
  customPayloadExpression: string;
  advancedContentType: string;
  formatEventCode?: string | undefined;
  formatPayloadCode?: string | undefined;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls?: MetadataType$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
  url?: string | undefined;
  excludeSelf: boolean;
  urls?: Array<UrlsType$Outbound> | undefined;
  dnsResolvePeriodSec: number;
  loadBalanceStatsPeriodSec: number;
};

/** @internal */
export const OutputWebhookWebhook5$outboundSchema: z.ZodType<
  OutputWebhookWebhook5$Outbound,
  z.ZodTypeDef,
  OutputWebhookWebhook5
> = z.object({
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  id: z.string().optional(),
  type: OutputWebhookType5$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$outboundSchema.default("POST"),
  format: OutputWebhookFormat5$outboundSchema.default("ndjson"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  tls: Tls4Type$outboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$outboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});

export function outputWebhookWebhook5ToJSON(
  outputWebhookWebhook5: OutputWebhookWebhook5,
): string {
  return JSON.stringify(
    OutputWebhookWebhook5$outboundSchema.parse(outputWebhookWebhook5),
  );
}
export function outputWebhookWebhook5FromJSON(
  jsonString: string,
): SafeParseResult<OutputWebhookWebhook5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputWebhookWebhook5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWebhookWebhook5' from JSON`,
  );
}

/** @internal */
export const OutputWebhookFormat4$inboundSchema: z.ZodType<
  OutputWebhookFormat4,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputWebhookFormat4),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputWebhookFormat4$outboundSchema: z.ZodType<
  OutputWebhookFormat4,
  z.ZodTypeDef,
  OutputWebhookFormat4
> = z.union([
  z.nativeEnum(OutputWebhookFormat4),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputWebhookType4$inboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType4
> = z.nativeEnum(OutputWebhookType4);
/** @internal */
export const OutputWebhookType4$outboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType4
> = OutputWebhookType4$inboundSchema;

/** @internal */
export const OutputWebhookWebhook4$inboundSchema: z.ZodType<
  OutputWebhookWebhook4,
  z.ZodTypeDef,
  unknown
> = z.object({
  format: OutputWebhookFormat4$inboundSchema.default("ndjson"),
  id: z.string().optional(),
  type: OutputWebhookType4$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$inboundSchema.default("POST"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  tls: Tls4Type$inboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string(),
  formatPayloadCode: z.string(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$inboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});
/** @internal */
export type OutputWebhookWebhook4$Outbound = {
  format: string;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  method: string;
  keepAlive: boolean;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  authType: string;
  tls?: Tls4Type$Outbound | undefined;
  totalMemoryLimitKB?: number | undefined;
  loadBalanced: boolean;
  description?: string | undefined;
  customSourceExpression: string;
  customDropWhenNull: boolean;
  customEventDelimiter: string;
  customContentType: string;
  customPayloadExpression: string;
  advancedContentType: string;
  formatEventCode: string;
  formatPayloadCode: string;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls?: MetadataType$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
  url?: string | undefined;
  excludeSelf: boolean;
  urls?: Array<UrlsType$Outbound> | undefined;
  dnsResolvePeriodSec: number;
  loadBalanceStatsPeriodSec: number;
};

/** @internal */
export const OutputWebhookWebhook4$outboundSchema: z.ZodType<
  OutputWebhookWebhook4$Outbound,
  z.ZodTypeDef,
  OutputWebhookWebhook4
> = z.object({
  format: OutputWebhookFormat4$outboundSchema.default("ndjson"),
  id: z.string().optional(),
  type: OutputWebhookType4$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$outboundSchema.default("POST"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  tls: Tls4Type$outboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string(),
  formatPayloadCode: z.string(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$outboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});

export function outputWebhookWebhook4ToJSON(
  outputWebhookWebhook4: OutputWebhookWebhook4,
): string {
  return JSON.stringify(
    OutputWebhookWebhook4$outboundSchema.parse(outputWebhookWebhook4),
  );
}
export function outputWebhookWebhook4FromJSON(
  jsonString: string,
): SafeParseResult<OutputWebhookWebhook4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputWebhookWebhook4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWebhookWebhook4' from JSON`,
  );
}

/** @internal */
export const OutputWebhookFormat3$inboundSchema: z.ZodType<
  OutputWebhookFormat3,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputWebhookFormat3),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputWebhookFormat3$outboundSchema: z.ZodType<
  OutputWebhookFormat3,
  z.ZodTypeDef,
  OutputWebhookFormat3
> = z.union([
  z.nativeEnum(OutputWebhookFormat3),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputWebhookType3$inboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType3
> = z.nativeEnum(OutputWebhookType3);
/** @internal */
export const OutputWebhookType3$outboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType3
> = OutputWebhookType3$inboundSchema;

/** @internal */
export const OutputWebhookWebhook3$inboundSchema: z.ZodType<
  OutputWebhookWebhook3,
  z.ZodTypeDef,
  unknown
> = z.object({
  format: OutputWebhookFormat3$inboundSchema.default("ndjson"),
  id: z.string().optional(),
  type: OutputWebhookType3$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$inboundSchema.default("POST"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  tls: Tls4Type$inboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$inboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});
/** @internal */
export type OutputWebhookWebhook3$Outbound = {
  format: string;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  method: string;
  keepAlive: boolean;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  authType: string;
  tls?: Tls4Type$Outbound | undefined;
  totalMemoryLimitKB?: number | undefined;
  loadBalanced: boolean;
  description?: string | undefined;
  customSourceExpression: string;
  customDropWhenNull: boolean;
  customEventDelimiter: string;
  customContentType: string;
  customPayloadExpression: string;
  advancedContentType: string;
  formatEventCode?: string | undefined;
  formatPayloadCode?: string | undefined;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls?: MetadataType$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
  url?: string | undefined;
  excludeSelf: boolean;
  urls?: Array<UrlsType$Outbound> | undefined;
  dnsResolvePeriodSec: number;
  loadBalanceStatsPeriodSec: number;
};

/** @internal */
export const OutputWebhookWebhook3$outboundSchema: z.ZodType<
  OutputWebhookWebhook3$Outbound,
  z.ZodTypeDef,
  OutputWebhookWebhook3
> = z.object({
  format: OutputWebhookFormat3$outboundSchema.default("ndjson"),
  id: z.string().optional(),
  type: OutputWebhookType3$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$outboundSchema.default("POST"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  tls: Tls4Type$outboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$outboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});

export function outputWebhookWebhook3ToJSON(
  outputWebhookWebhook3: OutputWebhookWebhook3,
): string {
  return JSON.stringify(
    OutputWebhookWebhook3$outboundSchema.parse(outputWebhookWebhook3),
  );
}
export function outputWebhookWebhook3FromJSON(
  jsonString: string,
): SafeParseResult<OutputWebhookWebhook3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputWebhookWebhook3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWebhookWebhook3' from JSON`,
  );
}

/** @internal */
export const OutputWebhookFormat2$inboundSchema: z.ZodType<
  OutputWebhookFormat2,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputWebhookFormat2),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputWebhookFormat2$outboundSchema: z.ZodType<
  OutputWebhookFormat2,
  z.ZodTypeDef,
  OutputWebhookFormat2
> = z.union([
  z.nativeEnum(OutputWebhookFormat2),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputWebhookType2$inboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType2
> = z.nativeEnum(OutputWebhookType2);
/** @internal */
export const OutputWebhookType2$outboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType2
> = OutputWebhookType2$inboundSchema;

/** @internal */
export const OutputWebhookWebhook2$inboundSchema: z.ZodType<
  OutputWebhookWebhook2,
  z.ZodTypeDef,
  unknown
> = z.object({
  format: OutputWebhookFormat2$inboundSchema.default("ndjson"),
  id: z.string().optional(),
  type: OutputWebhookType2$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$inboundSchema.default("POST"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  tls: Tls4Type$inboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$inboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});
/** @internal */
export type OutputWebhookWebhook2$Outbound = {
  format: string;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  method: string;
  keepAlive: boolean;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  authType: string;
  tls?: Tls4Type$Outbound | undefined;
  totalMemoryLimitKB?: number | undefined;
  loadBalanced: boolean;
  description?: string | undefined;
  customSourceExpression: string;
  customDropWhenNull: boolean;
  customEventDelimiter: string;
  customContentType: string;
  customPayloadExpression: string;
  advancedContentType: string;
  formatEventCode?: string | undefined;
  formatPayloadCode?: string | undefined;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls?: MetadataType$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
  url?: string | undefined;
  excludeSelf: boolean;
  urls?: Array<UrlsType$Outbound> | undefined;
  dnsResolvePeriodSec: number;
  loadBalanceStatsPeriodSec: number;
};

/** @internal */
export const OutputWebhookWebhook2$outboundSchema: z.ZodType<
  OutputWebhookWebhook2$Outbound,
  z.ZodTypeDef,
  OutputWebhookWebhook2
> = z.object({
  format: OutputWebhookFormat2$outboundSchema.default("ndjson"),
  id: z.string().optional(),
  type: OutputWebhookType2$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$outboundSchema.default("POST"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  tls: Tls4Type$outboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$outboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});

export function outputWebhookWebhook2ToJSON(
  outputWebhookWebhook2: OutputWebhookWebhook2,
): string {
  return JSON.stringify(
    OutputWebhookWebhook2$outboundSchema.parse(outputWebhookWebhook2),
  );
}
export function outputWebhookWebhook2FromJSON(
  jsonString: string,
): SafeParseResult<OutputWebhookWebhook2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputWebhookWebhook2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWebhookWebhook2' from JSON`,
  );
}

/** @internal */
export const OutputWebhookFormat1$inboundSchema: z.ZodType<
  OutputWebhookFormat1,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputWebhookFormat1),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const OutputWebhookFormat1$outboundSchema: z.ZodType<
  OutputWebhookFormat1,
  z.ZodTypeDef,
  OutputWebhookFormat1
> = z.union([
  z.nativeEnum(OutputWebhookFormat1),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const OutputWebhookType1$inboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType1
> = z.nativeEnum(OutputWebhookType1);
/** @internal */
export const OutputWebhookType1$outboundSchema: z.ZodNativeEnum<
  typeof OutputWebhookType1
> = OutputWebhookType1$inboundSchema;

/** @internal */
export const OutputWebhookWebhook1$inboundSchema: z.ZodType<
  OutputWebhookWebhook1,
  z.ZodTypeDef,
  unknown
> = z.object({
  format: OutputWebhookFormat1$inboundSchema.default("ndjson"),
  id: z.string().optional(),
  type: OutputWebhookType1$inboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$inboundSchema.default("POST"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$inboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$inboundSchema.default("block"),
  authType: AuthTypeOptions$inboundSchema.default("basic"),
  tls: Tls4Type$inboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$inboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$inboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$inboundSchema.default("block"),
  pqControls: MetadataType$inboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$inboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$inboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$inboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});
/** @internal */
export type OutputWebhookWebhook1$Outbound = {
  format: string;
  id?: string | undefined;
  type: string;
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  method: string;
  keepAlive: boolean;
  concurrency: number;
  maxPayloadSizeKB: number;
  maxPayloadEvents: number;
  compress: boolean;
  rejectUnauthorized: boolean;
  timeoutSec: number;
  flushPeriodSec: number;
  extraHttpHeaders?: Array<ExtraHttpHeadersType$Outbound> | undefined;
  useRoundRobinDns: boolean;
  failedRequestLoggingMode: string;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?: Array<ResponseRetrySettingsType$Outbound> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader: boolean;
  onBackpressure: string;
  authType: string;
  tls?: Tls4Type$Outbound | undefined;
  totalMemoryLimitKB?: number | undefined;
  loadBalanced: boolean;
  description?: string | undefined;
  customSourceExpression: string;
  customDropWhenNull: boolean;
  customEventDelimiter: string;
  customContentType: string;
  customPayloadExpression: string;
  advancedContentType: string;
  formatEventCode?: string | undefined;
  formatPayloadCode?: string | undefined;
  pqStrictOrdering: boolean;
  pqRatePerSec: number;
  pqMode: string;
  pqMaxBufferSize: number;
  pqMaxBackpressureSec: number;
  pqMaxFileSize: string;
  pqMaxSize: string;
  pqPath: string;
  pqCompress: string;
  pqOnBackpressure: string;
  pqControls?: MetadataType$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<Metadata1Type$Outbound> | undefined;
  oauthHeaders?: Array<Metadata1Type$Outbound> | undefined;
  url?: string | undefined;
  excludeSelf: boolean;
  urls?: Array<UrlsType$Outbound> | undefined;
  dnsResolvePeriodSec: number;
  loadBalanceStatsPeriodSec: number;
};

/** @internal */
export const OutputWebhookWebhook1$outboundSchema: z.ZodType<
  OutputWebhookWebhook1$Outbound,
  z.ZodTypeDef,
  OutputWebhookWebhook1
> = z.object({
  format: OutputWebhookFormat1$outboundSchema.default("ndjson"),
  id: z.string().optional(),
  type: OutputWebhookType1$outboundSchema,
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: Method1Options$outboundSchema.default("POST"),
  keepAlive: z.boolean().default(true),
  concurrency: z.number().default(5),
  maxPayloadSizeKB: z.number().default(4096),
  maxPayloadEvents: z.number().default(0),
  compress: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  timeoutSec: z.number().default(30),
  flushPeriodSec: z.number().default(1),
  extraHttpHeaders: z.array(ExtraHttpHeadersType$outboundSchema).optional(),
  useRoundRobinDns: z.boolean().default(false),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .default("none"),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(ResponseRetrySettingsType$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().default(false),
  onBackpressure: OnBackpressureOptions$outboundSchema.default("block"),
  authType: AuthTypeOptions$outboundSchema.default("basic"),
  tls: Tls4Type$outboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().default(false),
  description: z.string().optional(),
  customSourceExpression: z.string().default("__httpOut"),
  customDropWhenNull: z.boolean().default(false),
  customEventDelimiter: z.string().default("\\n"),
  customContentType: z.string().default("application/x-ndjson"),
  customPayloadExpression: z.string().default("`${events}`"),
  advancedContentType: z.string().default("application/json"),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().default(true),
  pqRatePerSec: z.number().default(0),
  pqMode: PqModeOptions$outboundSchema.default("error"),
  pqMaxBufferSize: z.number().default(42),
  pqMaxBackpressureSec: z.number().default(30),
  pqMaxFileSize: z.string().default("1 MB"),
  pqMaxSize: z.string().default("5GB"),
  pqPath: z.string().default("$CRIBL_HOME/state/queues"),
  pqCompress: PqCompressOptions$outboundSchema.default("none"),
  pqOnBackpressure: PqOnBackpressureOptions$outboundSchema.default("block"),
  pqControls: MetadataType$outboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(Metadata1Type$outboundSchema).optional(),
  oauthHeaders: z.array(Metadata1Type$outboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().default(false),
  urls: z.array(UrlsType$outboundSchema).optional(),
  dnsResolvePeriodSec: z.number().default(600),
  loadBalanceStatsPeriodSec: z.number().default(300),
});

export function outputWebhookWebhook1ToJSON(
  outputWebhookWebhook1: OutputWebhookWebhook1,
): string {
  return JSON.stringify(
    OutputWebhookWebhook1$outboundSchema.parse(outputWebhookWebhook1),
  );
}
export function outputWebhookWebhook1FromJSON(
  jsonString: string,
): SafeParseResult<OutputWebhookWebhook1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputWebhookWebhook1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWebhookWebhook1' from JSON`,
  );
}

/** @internal */
export const OutputWebhook$inboundSchema: z.ZodType<
  OutputWebhook,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => OutputWebhookWebhook12$inboundSchema),
  z.lazy(() => OutputWebhookWebhook4$inboundSchema),
  z.lazy(() => OutputWebhookWebhook8$inboundSchema),
  z.lazy(() => OutputWebhookWebhook6$inboundSchema),
  z.lazy(() => OutputWebhookWebhook9$inboundSchema),
  z.lazy(() => OutputWebhookWebhook10$inboundSchema),
  z.lazy(() => OutputWebhookWebhook11$inboundSchema),
  z.lazy(() => OutputWebhookWebhook13$inboundSchema),
  z.lazy(() => OutputWebhookWebhook14$inboundSchema),
  z.lazy(() => OutputWebhookWebhook1$inboundSchema),
  z.lazy(() => OutputWebhookWebhook2$inboundSchema),
  z.lazy(() => OutputWebhookWebhook3$inboundSchema),
  z.lazy(() => OutputWebhookWebhook5$inboundSchema),
  z.lazy(() => OutputWebhookWebhook7$inboundSchema),
]);
/** @internal */
export type OutputWebhook$Outbound =
  | OutputWebhookWebhook12$Outbound
  | OutputWebhookWebhook4$Outbound
  | OutputWebhookWebhook8$Outbound
  | OutputWebhookWebhook6$Outbound
  | OutputWebhookWebhook9$Outbound
  | OutputWebhookWebhook10$Outbound
  | OutputWebhookWebhook11$Outbound
  | OutputWebhookWebhook13$Outbound
  | OutputWebhookWebhook14$Outbound
  | OutputWebhookWebhook1$Outbound
  | OutputWebhookWebhook2$Outbound
  | OutputWebhookWebhook3$Outbound
  | OutputWebhookWebhook5$Outbound
  | OutputWebhookWebhook7$Outbound;

/** @internal */
export const OutputWebhook$outboundSchema: z.ZodType<
  OutputWebhook$Outbound,
  z.ZodTypeDef,
  OutputWebhook
> = z.union([
  z.lazy(() => OutputWebhookWebhook12$outboundSchema),
  z.lazy(() => OutputWebhookWebhook4$outboundSchema),
  z.lazy(() => OutputWebhookWebhook8$outboundSchema),
  z.lazy(() => OutputWebhookWebhook6$outboundSchema),
  z.lazy(() => OutputWebhookWebhook9$outboundSchema),
  z.lazy(() => OutputWebhookWebhook10$outboundSchema),
  z.lazy(() => OutputWebhookWebhook11$outboundSchema),
  z.lazy(() => OutputWebhookWebhook13$outboundSchema),
  z.lazy(() => OutputWebhookWebhook14$outboundSchema),
  z.lazy(() => OutputWebhookWebhook1$outboundSchema),
  z.lazy(() => OutputWebhookWebhook2$outboundSchema),
  z.lazy(() => OutputWebhookWebhook3$outboundSchema),
  z.lazy(() => OutputWebhookWebhook5$outboundSchema),
  z.lazy(() => OutputWebhookWebhook7$outboundSchema),
]);

export function outputWebhookToJSON(outputWebhook: OutputWebhook): string {
  return JSON.stringify(OutputWebhook$outboundSchema.parse(outputWebhook));
}
export function outputWebhookFromJSON(
  jsonString: string,
): SafeParseResult<OutputWebhook, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputWebhook$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWebhook' from JSON`,
  );
}
