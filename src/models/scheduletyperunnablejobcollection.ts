/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  LogLevelOptionsSavedJobCollectionScheduleRun,
  LogLevelOptionsSavedJobCollectionScheduleRun$inboundSchema,
} from "./logleveloptionssavedjobcollectionschedulerun.js";
import { MetricsStore, MetricsStore$inboundSchema } from "./metricsstore.js";

export const ScheduleTypeRunnableJobCollectionType = {
  Collection: "collection",
} as const;
export type ScheduleTypeRunnableJobCollectionType = OpenEnum<
  typeof ScheduleTypeRunnableJobCollectionType
>;

export type ScheduleTypeRunnableJobCollectionRunSettings = {
  type?: ScheduleTypeRunnableJobCollectionType | undefined;
  /**
   * Reschedule tasks that failed with non-fatal errors
   */
  rescheduleDroppedTasks: boolean;
  /**
   * Maximum number of times a task can be rescheduled
   */
  maxTaskReschedule: number;
  /**
   * Level at which to set task logging
   */
  logLevel: LogLevelOptionsSavedJobCollectionScheduleRun;
  /**
   * Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time.
   */
  jobTimeout: string;
  /**
   * Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job.
   */
  mode: string;
  timeRangeType: string;
  /**
   * Earliest time to collect data for the selected timezone
   */
  earliest?: number | undefined;
  /**
   * Latest time to collect data for the selected timezone
   */
  latest?: number | undefined;
  timestampTimezone?: any | undefined;
  timeWarning?: MetricsStore | undefined;
  /**
   * A filter for tokens in the provided collect path and/or the events being collected
   */
  expression: string;
  /**
   * Limits the bundle size for small tasks. For example,
   *
   * @remarks
   *
   *         if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task.
   */
  minTaskSize: string;
  /**
   * Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB,
   *
   * @remarks
   *
   *         you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks.
   */
  maxTaskSize: string;
};

/**
 * Configuration for a scheduled job
 */
export type ScheduleTypeRunnableJobCollection = {
  /**
   * Enable to configure scheduling for this Collector
   */
  enabled?: boolean | undefined;
  /**
   * Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits
   */
  skippable: boolean;
  /**
   * If Stream Leader (or single instance) restarts, run all missed jobs according to their original schedules
   */
  resumeMissed: boolean;
  /**
   * A cron schedule on which to run this job
   */
  cronSchedule: string;
  /**
   * The maximum number of instances of this scheduled job that may be running at any time
   */
  maxConcurrentRuns: number;
  run?: ScheduleTypeRunnableJobCollectionRunSettings | undefined;
};

/** @internal */
export const ScheduleTypeRunnableJobCollectionType$inboundSchema: z.ZodType<
  ScheduleTypeRunnableJobCollectionType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(ScheduleTypeRunnableJobCollectionType);

/** @internal */
export const ScheduleTypeRunnableJobCollectionRunSettings$inboundSchema:
  z.ZodType<
    ScheduleTypeRunnableJobCollectionRunSettings,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: ScheduleTypeRunnableJobCollectionType$inboundSchema.optional(),
    rescheduleDroppedTasks: z.boolean().default(true),
    maxTaskReschedule: z.number().default(1),
    logLevel: LogLevelOptionsSavedJobCollectionScheduleRun$inboundSchema
      .default("info"),
    jobTimeout: z.string().default("0"),
    mode: z.string().default("list"),
    timeRangeType: z.string().default("relative"),
    earliest: z.number().optional(),
    latest: z.number().optional(),
    timestampTimezone: z.any().optional(),
    timeWarning: MetricsStore$inboundSchema.optional(),
    expression: z.string().default("true"),
    minTaskSize: z.string().default("1MB"),
    maxTaskSize: z.string().default("10MB"),
  });

export function scheduleTypeRunnableJobCollectionRunSettingsFromJSON(
  jsonString: string,
): SafeParseResult<
  ScheduleTypeRunnableJobCollectionRunSettings,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ScheduleTypeRunnableJobCollectionRunSettings$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ScheduleTypeRunnableJobCollectionRunSettings' from JSON`,
  );
}

/** @internal */
export const ScheduleTypeRunnableJobCollection$inboundSchema: z.ZodType<
  ScheduleTypeRunnableJobCollection,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
  skippable: z.boolean().default(true),
  resumeMissed: z.boolean().default(false),
  cronSchedule: z.string().default("*/5 * * * *"),
  maxConcurrentRuns: z.number().default(1),
  run: z.lazy(() => ScheduleTypeRunnableJobCollectionRunSettings$inboundSchema)
    .optional(),
});

export function scheduleTypeRunnableJobCollectionFromJSON(
  jsonString: string,
): SafeParseResult<ScheduleTypeRunnableJobCollection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ScheduleTypeRunnableJobCollection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ScheduleTypeRunnableJobCollection' from JSON`,
  );
}
