/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as discriminatedUnionTypes from "../types/discriminatedUnion.js";
import { discriminatedUnion } from "../types/discriminatedUnion.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeRestCollectMethodGetCollectRequestParams,
  ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound,
  ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
} from "./itemstyperestcollectmethodgetcollectrequestparams.js";

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationHmacDiscovery =
  | (
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeJson
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeList
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationHmacCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationHmacCollectMethod = OpenEnum<
  typeof RestAuthenticationHmacCollectMethod
>;

export type RestAuthenticationHmacRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationHmacRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationHmacRestPaginationTypeResponseHeaderLink = {
  type: "response_header_link";
  /**
   * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
   */
  nextRelationAttribute: string;
  /**
   * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
   */
  curRelationAttribute?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationHmacRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationHmacRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestAuthenticationHmacRestPaginationTypeNone = {
  type: "none";
};

export type RestAuthenticationHmacPaginationUnion =
  | RestAuthenticationHmacRestPaginationTypeNone
  | RestAuthenticationHmacRestPaginationTypeResponseBody
  | RestAuthenticationHmacRestPaginationTypeResponseHeader
  | RestAuthenticationHmacRestPaginationTypeResponseHeaderLink
  | RestAuthenticationHmacRestPaginationTypeRequestOffset
  | RestAuthenticationHmacRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationHmacRestRetryRulesTypeBackoff = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationHmacRestRetryRulesTypeStatic = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestAuthenticationHmacRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationHmacRetryRules =
  | RestAuthenticationHmacRestRetryRulesTypeNone
  | RestAuthenticationHmacRestRetryRulesTypeStatic
  | RestAuthenticationHmacRestRetryRulesTypeBackoff
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationHmacStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationHmacScheduling = {
  stateTracking?: RestAuthenticationHmacStateTracking | undefined;
};

export type RestAuthenticationHmac = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "hmac";
  /**
   * Select or create an HMAC Function to use with authentication
   */
  hmacFunctionId: string;
  discovery?:
    | (
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeJson
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeList
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationHmacCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationHmacRestPaginationTypeNone
    | RestAuthenticationHmacRestPaginationTypeResponseBody
    | RestAuthenticationHmacRestPaginationTypeResponseHeader
    | RestAuthenticationHmacRestPaginationTypeResponseHeaderLink
    | RestAuthenticationHmacRestPaginationTypeRequestOffset
    | RestAuthenticationHmacRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationHmacRestRetryRulesTypeNone
    | RestAuthenticationHmacRestRetryRulesTypeStatic
    | RestAuthenticationHmacRestRetryRulesTypeBackoff
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestAuthenticationHmacScheduling | undefined;
};

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationGoogleOauthSecretDiscovery =
  | (
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationGoogleOauthSecretCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationGoogleOauthSecretCollectMethod = OpenEnum<
  typeof RestAuthenticationGoogleOauthSecretCollectMethod
>;

export type RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset =
  {
    type: "request_offset";
    /**
     * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
     */
    offsetField: string;
    /**
     * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
     */
    offset?: number | undefined;
    /**
     * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
     */
    limitField: string;
    /**
     * Maximum number of records to collect per request
     */
    limit: number;
    /**
     * Name of the attribute in the response that contains the total number of records for the query
     */
    totalRecordField?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
     */
    zeroIndexed: boolean;
  };

export type RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink =
  {
    type: "response_header_link";
    /**
     * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
     */
    nextRelationAttribute: string;
    /**
     * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
     */
    curRelationAttribute?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader =
  {
    type: "response_header";
    /**
     * Names of attributes within the response that contain next-page information
     */
    attribute: Array<string>;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody =
  {
    type: "response_body";
    /**
     * Names of attributes within the response that contain next-page information
     */
    attribute: Array<string>;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
     */
    lastPageExpr?: string | undefined;
  };

export type RestAuthenticationGoogleOauthSecretRestPaginationTypeNone = {
  type: "none";
};

export type RestAuthenticationGoogleOauthSecretPaginationUnion =
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeNone
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationGoogleOauthSecretRetryRules =
  | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone
  | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic
  | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationGoogleOauthSecretStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationGoogleOauthSecretScheduling = {
  stateTracking?: RestAuthenticationGoogleOauthSecretStateTracking | undefined;
};

export type RestAuthenticationGoogleOauthSecret = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "google_oauthSecret";
  /**
   * Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information.
   */
  scopes: Array<string>;
  /**
   * Select or create a text secret that contains the Google service account credentials value
   */
  textSecret: string;
  /**
   * Email address of a user account with Super Admin permissions to the resources the collector will retrieve
   */
  subject: string;
  discovery?:
    | (
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationGoogleOauthSecretCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeNone
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone
    | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic
    | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestAuthenticationGoogleOauthSecretScheduling | undefined;
};

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationGoogleOauthDiscovery =
  | (
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationGoogleOauthCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationGoogleOauthCollectMethod = OpenEnum<
  typeof RestAuthenticationGoogleOauthCollectMethod
>;

export type RestAuthenticationGoogleOauthRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink =
  {
    type: "response_header_link";
    /**
     * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
     */
    nextRelationAttribute: string;
    /**
     * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
     */
    curRelationAttribute?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationGoogleOauthRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestAuthenticationGoogleOauthRestPaginationTypeNone = {
  type: "none";
};

export type RestAuthenticationGoogleOauthPaginationUnion =
  | RestAuthenticationGoogleOauthRestPaginationTypeNone
  | RestAuthenticationGoogleOauthRestPaginationTypeResponseBody
  | RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader
  | RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink
  | RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset
  | RestAuthenticationGoogleOauthRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationGoogleOauthRestRetryRulesTypeStatic = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestAuthenticationGoogleOauthRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationGoogleOauthRetryRules =
  | RestAuthenticationGoogleOauthRestRetryRulesTypeNone
  | RestAuthenticationGoogleOauthRestRetryRulesTypeStatic
  | RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationGoogleOauthStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationGoogleOauthScheduling = {
  stateTracking?: RestAuthenticationGoogleOauthStateTracking | undefined;
};

export type RestAuthenticationGoogleOauth = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "google_oauth";
  /**
   * Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information.
   */
  scopes: Array<string>;
  /**
   * Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right.
   */
  serviceAccountCredentials: string;
  /**
   * Email address of a user account with Super Admin permissions to the resources the collector will retrieve
   */
  subject: string;
  discovery?:
    | (
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationGoogleOauthCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationGoogleOauthRestPaginationTypeNone
    | RestAuthenticationGoogleOauthRestPaginationTypeResponseBody
    | RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader
    | RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink
    | RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset
    | RestAuthenticationGoogleOauthRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationGoogleOauthRestRetryRulesTypeNone
    | RestAuthenticationGoogleOauthRestRetryRulesTypeStatic
    | RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestAuthenticationGoogleOauthScheduling | undefined;
};

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationOauthSecretDiscovery =
  | (
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationOauthSecretCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationOauthSecretCollectMethod = OpenEnum<
  typeof RestAuthenticationOauthSecretCollectMethod
>;

export type RestAuthenticationOauthSecretRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationOauthSecretRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink =
  {
    type: "response_header_link";
    /**
     * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
     */
    nextRelationAttribute: string;
    /**
     * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
     */
    curRelationAttribute?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationOauthSecretRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationOauthSecretRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestAuthenticationOauthSecretRestPaginationTypeNone = {
  type: "none";
};

export type RestAuthenticationOauthSecretPaginationUnion =
  | RestAuthenticationOauthSecretRestPaginationTypeNone
  | RestAuthenticationOauthSecretRestPaginationTypeResponseBody
  | RestAuthenticationOauthSecretRestPaginationTypeResponseHeader
  | RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink
  | RestAuthenticationOauthSecretRestPaginationTypeRequestOffset
  | RestAuthenticationOauthSecretRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationOauthSecretRestRetryRulesTypeBackoff = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationOauthSecretRestRetryRulesTypeStatic = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestAuthenticationOauthSecretRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationOauthSecretRetryRules =
  | RestAuthenticationOauthSecretRestRetryRulesTypeNone
  | RestAuthenticationOauthSecretRestRetryRulesTypeStatic
  | RestAuthenticationOauthSecretRestRetryRulesTypeBackoff
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationOauthSecretStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationOauthSecretScheduling = {
  stateTracking?: RestAuthenticationOauthSecretStateTracking | undefined;
};

export type RestAuthenticationOauthSecret = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "oauthSecret";
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl: string;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName: string;
  /**
   * Select or create a text secret that contains the client secret's value
   */
  textSecret: string;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationOauthSecretCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationOauthSecretRestPaginationTypeNone
    | RestAuthenticationOauthSecretRestPaginationTypeResponseBody
    | RestAuthenticationOauthSecretRestPaginationTypeResponseHeader
    | RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink
    | RestAuthenticationOauthSecretRestPaginationTypeRequestOffset
    | RestAuthenticationOauthSecretRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationOauthSecretRestRetryRulesTypeNone
    | RestAuthenticationOauthSecretRestRetryRulesTypeStatic
    | RestAuthenticationOauthSecretRestRetryRulesTypeBackoff
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestAuthenticationOauthSecretScheduling | undefined;
};

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationOauthDiscovery =
  | (
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeJson
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeList
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationOauthCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationOauthCollectMethod = OpenEnum<
  typeof RestAuthenticationOauthCollectMethod
>;

export type RestAuthenticationOauthRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationOauthRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationOauthRestPaginationTypeResponseHeaderLink = {
  type: "response_header_link";
  /**
   * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
   */
  nextRelationAttribute: string;
  /**
   * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
   */
  curRelationAttribute?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationOauthRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$Outbound = {
  discoverType: "none";
};

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeNone:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$outboundSchema.parse(
      restAuthenticationHmacRestDiscoveryDiscoverTypeNone,
    ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeList$Outbound = {
  discoverType: "list";
  itemList: Array<string>;
};

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeList:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeList$outboundSchema.parse(
      restAuthenticationHmacRestDiscoveryDiscoverTypeList,
    ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeList$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$Outbound = {
  discoverType: "json";
  manualDiscoverResult: string;
  discoverDataField?: string | undefined;
};

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeJson:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$outboundSchema.parse(
      restAuthenticationHmacRestDiscoveryDiscoverTypeJson,
    ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp$outboundSchema.parse(
      restAuthenticationHmacRestDiscoveryDiscoverTypeHttp,
    ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationHmacDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestAuthenticationHmacRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationHmacDiscovery$Outbound =
  | (
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationHmacDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationHmacDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmacDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationHmacRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restAuthenticationHmacDiscoveryToJSON(
  restAuthenticationHmacDiscovery: RestAuthenticationHmacDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationHmacDiscovery$outboundSchema.parse(
      restAuthenticationHmacDiscovery,
    ),
  );
}
export function restAuthenticationHmacDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmacDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationHmacDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacCollectMethod$inboundSchema: z.ZodType<
  RestAuthenticationHmacCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationHmacCollectMethod);
/** @internal */
export const RestAuthenticationHmacCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationHmacCollectMethod
> = openEnums.outboundSchema(RestAuthenticationHmacCollectMethod);

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationHmacRestPaginationTypeRequestPage$Outbound = {
  type: "request_page";
  pageField: string;
  page?: number | undefined;
  sizeField: string;
  size: number;
  totalPageField?: string | undefined;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationHmacRestPaginationTypeRequestPageToJSON(
  restAuthenticationHmacRestPaginationTypeRequestPage:
    RestAuthenticationHmacRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestPaginationTypeRequestPage$outboundSchema.parse(
      restAuthenticationHmacRestPaginationTypeRequestPage,
    ),
  );
}
export function restAuthenticationHmacRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestPaginationTypeRequestPage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationHmacRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationHmacRestPaginationTypeRequestOffset$Outbound = {
  type: "request_offset";
  offsetField: string;
  offset?: number | undefined;
  limitField: string;
  limit: number;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationHmacRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationHmacRestPaginationTypeRequestOffset:
    RestAuthenticationHmacRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestPaginationTypeRequestOffset$outboundSchema.parse(
      restAuthenticationHmacRestPaginationTypeRequestOffset,
    ),
  );
}
export function restAuthenticationHmacRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestPaginationTypeRequestOffset$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationHmacRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationHmacRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationHmacRestPaginationTypeResponseHeaderLink:
    RestAuthenticationHmacRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restAuthenticationHmacRestPaginationTypeResponseHeaderLink),
  );
}
export function restAuthenticationHmacRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationHmacRestPaginationTypeResponseHeader$Outbound = {
  type: "response_header";
  attribute: Array<string>;
  maxPages: number;
};

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationHmacRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationHmacRestPaginationTypeResponseHeader:
    RestAuthenticationHmacRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestPaginationTypeResponseHeader$outboundSchema.parse(
      restAuthenticationHmacRestPaginationTypeResponseHeader,
    ),
  );
}
export function restAuthenticationHmacRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationHmacRestPaginationTypeResponseBody$Outbound = {
  type: "response_body";
  attribute: Array<string>;
  maxPages: number;
  lastPageExpr?: string | undefined;
};

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationHmacRestPaginationTypeResponseBodyToJSON(
  restAuthenticationHmacRestPaginationTypeResponseBody:
    RestAuthenticationHmacRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestPaginationTypeResponseBody$outboundSchema.parse(
      restAuthenticationHmacRestPaginationTypeResponseBody,
    ),
  );
}
export function restAuthenticationHmacRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestPaginationTypeResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationHmacRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationHmacRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationHmacRestPaginationTypeNoneToJSON(
  restAuthenticationHmacRestPaginationTypeNone:
    RestAuthenticationHmacRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestPaginationTypeNone$outboundSchema.parse(
      restAuthenticationHmacRestPaginationTypeNone,
    ),
  );
}
export function restAuthenticationHmacRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationHmacRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacPaginationUnion$inboundSchema: z.ZodType<
  RestAuthenticationHmacPaginationUnion,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationHmacRestPaginationTypeNone$inboundSchema
  ),
  response_body: z.lazy(() =>
    RestAuthenticationHmacRestPaginationTypeResponseBody$inboundSchema
  ),
  response_header: z.lazy(() =>
    RestAuthenticationHmacRestPaginationTypeResponseHeader$inboundSchema
  ),
  response_header_link: z.lazy(() =>
    RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$inboundSchema
  ),
  request_offset: z.lazy(() =>
    RestAuthenticationHmacRestPaginationTypeRequestOffset$inboundSchema
  ),
  request_page: z.lazy(() =>
    RestAuthenticationHmacRestPaginationTypeRequestPage$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationHmacPaginationUnion$Outbound =
  | RestAuthenticationHmacRestPaginationTypeNone$Outbound
  | RestAuthenticationHmacRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationHmacRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationHmacRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationHmacRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationHmacPaginationUnion$outboundSchema: z.ZodType<
  RestAuthenticationHmacPaginationUnion$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmacPaginationUnion
> = z.union([
  z.lazy(() => RestAuthenticationHmacRestPaginationTypeNone$outboundSchema),
  z.lazy(() =>
    RestAuthenticationHmacRestPaginationTypeResponseBody$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationHmacRestPaginationTypeResponseHeader$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationHmacRestPaginationTypeRequestOffset$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationHmacRestPaginationTypeRequestPage$outboundSchema
  ),
]);

export function restAuthenticationHmacPaginationUnionToJSON(
  restAuthenticationHmacPaginationUnion: RestAuthenticationHmacPaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationHmacPaginationUnion$outboundSchema.parse(
      restAuthenticationHmacPaginationUnion,
    ),
  );
}
export function restAuthenticationHmacPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmacPaginationUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacPaginationUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("backoff"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationHmacRestRetryRulesTypeBackoff$Outbound = {
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationHmacRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestRetryRulesTypeBackoff
  > = z.object({
    type: z.literal("backoff"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationHmacRestRetryRulesTypeBackoffToJSON(
  restAuthenticationHmacRestRetryRulesTypeBackoff:
    RestAuthenticationHmacRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestRetryRulesTypeBackoff$outboundSchema.parse(
      restAuthenticationHmacRestRetryRulesTypeBackoff,
    ),
  );
}
export function restAuthenticationHmacRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestRetryRulesTypeBackoff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationHmacRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("static"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationHmacRestRetryRulesTypeStatic$Outbound = {
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

/** @internal */
export const RestAuthenticationHmacRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestRetryRulesTypeStatic
  > = z.object({
    type: z.literal("static"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationHmacRestRetryRulesTypeStaticToJSON(
  restAuthenticationHmacRestRetryRulesTypeStatic:
    RestAuthenticationHmacRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestRetryRulesTypeStatic$outboundSchema.parse(
      restAuthenticationHmacRestRetryRulesTypeStatic,
    ),
  );
}
export function restAuthenticationHmacRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationHmacRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationHmacRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationHmacRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationHmacRestRetryRulesTypeNoneToJSON(
  restAuthenticationHmacRestRetryRulesTypeNone:
    RestAuthenticationHmacRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestRetryRulesTypeNone$outboundSchema.parse(
      restAuthenticationHmacRestRetryRulesTypeNone,
    ),
  );
}
export function restAuthenticationHmacRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationHmacRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationHmacRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationHmacRestRetryRulesTypeNone$inboundSchema
  ),
  static: z.lazy(() =>
    RestAuthenticationHmacRestRetryRulesTypeStatic$inboundSchema
  ),
  backoff: z.lazy(() =>
    RestAuthenticationHmacRestRetryRulesTypeBackoff$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationHmacRetryRules$Outbound =
  | RestAuthenticationHmacRestRetryRulesTypeNone$Outbound
  | RestAuthenticationHmacRestRetryRulesTypeStatic$Outbound
  | RestAuthenticationHmacRestRetryRulesTypeBackoff$Outbound;

/** @internal */
export const RestAuthenticationHmacRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationHmacRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmacRetryRules
> = z.union([
  z.lazy(() => RestAuthenticationHmacRestRetryRulesTypeNone$outboundSchema),
  z.lazy(() => RestAuthenticationHmacRestRetryRulesTypeStatic$outboundSchema),
  z.lazy(() => RestAuthenticationHmacRestRetryRulesTypeBackoff$outboundSchema),
]);

export function restAuthenticationHmacRetryRulesToJSON(
  restAuthenticationHmacRetryRules: RestAuthenticationHmacRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRetryRules$outboundSchema.parse(
      restAuthenticationHmacRetryRules,
    ),
  );
}
export function restAuthenticationHmacRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmacRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationHmacRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacStateTracking$inboundSchema: z.ZodType<
  RestAuthenticationHmacStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: types.optional(types.boolean()),
});
/** @internal */
export type RestAuthenticationHmacStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationHmacStateTracking$outboundSchema: z.ZodType<
  RestAuthenticationHmacStateTracking$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmacStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restAuthenticationHmacStateTrackingToJSON(
  restAuthenticationHmacStateTracking: RestAuthenticationHmacStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationHmacStateTracking$outboundSchema.parse(
      restAuthenticationHmacStateTracking,
    ),
  );
}
export function restAuthenticationHmacStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmacStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacScheduling$inboundSchema: z.ZodType<
  RestAuthenticationHmacScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestAuthenticationHmacStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationHmacScheduling$Outbound = {
  stateTracking?: RestAuthenticationHmacStateTracking$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationHmacScheduling$outboundSchema: z.ZodType<
  RestAuthenticationHmacScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmacScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationHmacStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationHmacSchedulingToJSON(
  restAuthenticationHmacScheduling: RestAuthenticationHmacScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationHmacScheduling$outboundSchema.parse(
      restAuthenticationHmacScheduling,
    ),
  );
}
export function restAuthenticationHmacSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmacScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationHmacScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmac$inboundSchema: z.ZodType<
  RestAuthenticationHmac,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("hmac"),
  hmacFunctionId: types.string(),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectMethod: RestAuthenticationHmacCollectMethod$inboundSchema,
  collectVerb: types.optional(z.any()),
  collectRequestParams: types.optional(z.any()),
  collectBody: types.optional(z.any()),
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationHmacRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationHmacRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationHmacRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationHmacRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationHmacRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationHmacRestRetryRulesTypeNone$inboundSchema
    ),
    static: z.lazy(() =>
      RestAuthenticationHmacRestRetryRulesTypeStatic$inboundSchema
    ),
    backoff: z.lazy(() =>
      RestAuthenticationHmacRestRetryRulesTypeBackoff$inboundSchema
    ),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestAuthenticationHmacScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationHmac$Outbound = {
  authentication: "hmac";
  hmacFunctionId: string;
  discovery?:
    | (
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationHmacRestPaginationTypeNone$Outbound
    | RestAuthenticationHmacRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationHmacRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationHmacRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationHmacRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationHmacRestRetryRulesTypeNone$Outbound
    | RestAuthenticationHmacRestRetryRulesTypeStatic$Outbound
    | RestAuthenticationHmacRestRetryRulesTypeBackoff$Outbound
    | undefined;
  __scheduling?: RestAuthenticationHmacScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationHmac$outboundSchema: z.ZodType<
  RestAuthenticationHmac$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmac
> = z.object({
  authentication: z.literal("hmac"),
  hmacFunctionId: z.string(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationHmacCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() => RestAuthenticationHmacRestPaginationTypeNone$outboundSchema),
    z.lazy(() =>
      RestAuthenticationHmacRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() => RestAuthenticationHmacRestRetryRulesTypeNone$outboundSchema),
    z.lazy(() => RestAuthenticationHmacRestRetryRulesTypeStatic$outboundSchema),
    z.lazy(() =>
      RestAuthenticationHmacRestRetryRulesTypeBackoff$outboundSchema
    ),
  ]).optional(),
  __scheduling: z.lazy(() => RestAuthenticationHmacScheduling$outboundSchema)
    .optional(),
});

export function restAuthenticationHmacToJSON(
  restAuthenticationHmac: RestAuthenticationHmac,
): string {
  return JSON.stringify(
    RestAuthenticationHmac$outboundSchema.parse(restAuthenticationHmac),
  );
}
export function restAuthenticationHmacFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmac, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationHmac$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmac' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$Outbound =
  {
    discoverType: "none";
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$outboundSchema
      .parse(restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$Outbound =
  {
    discoverType: "list";
    itemList: Array<string>;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$outboundSchema
      .parse(restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$Outbound =
  {
    discoverType: "json";
    manualDiscoverResult: string;
    discoverDataField?: string | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$outboundSchema
      .parse(restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp$outboundSchema
      .parse(restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretDiscovery$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretDiscovery,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretDiscovery$Outbound =
  | (
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationGoogleOauthSecretDiscovery$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretDiscovery$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretDiscovery
  > = z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]);

export function restAuthenticationGoogleOauthSecretDiscoveryToJSON(
  restAuthenticationGoogleOauthSecretDiscovery:
    RestAuthenticationGoogleOauthSecretDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretDiscovery$outboundSchema.parse(
      restAuthenticationGoogleOauthSecretDiscovery,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretDiscovery,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretDiscovery$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretCollectMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretCollectMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RestAuthenticationGoogleOauthSecretCollectMethod);
/** @internal */
export const RestAuthenticationGoogleOauthSecretCollectMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretCollectMethod
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthSecretCollectMethod,
  );

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$Outbound =
  {
    type: "request_page";
    pageField: string;
    page?: number | undefined;
    sizeField: string;
    size: number;
    totalPageField?: string | undefined;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationGoogleOauthSecretRestPaginationTypeRequestPageToJSON(
  restAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage:
    RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$outboundSchema
      .parse(restAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage),
  );
}
export function restAuthenticationGoogleOauthSecretRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$Outbound =
  {
    type: "request_offset";
    offsetField: string;
    offset?: number | undefined;
    limitField: string;
    limit: number;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset:
    RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink:
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$Outbound =
  {
    type: "response_header";
    attribute: Array<string>;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader:
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$Outbound =
  {
    type: "response_body";
    attribute: Array<string>;
    maxPages: number;
    lastPageExpr?: string | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestPaginationTypeResponseBodyToJSON(
  restAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody:
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$outboundSchema
      .parse(restAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody),
  );
}
export function restAuthenticationGoogleOauthSecretRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$Outbound =
  {
    type: "none";
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationGoogleOauthSecretRestPaginationTypeNoneToJSON(
  restAuthenticationGoogleOauthSecretRestPaginationTypeNone:
    RestAuthenticationGoogleOauthSecretRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$outboundSchema
      .parse(restAuthenticationGoogleOauthSecretRestPaginationTypeNone),
  );
}
export function restAuthenticationGoogleOauthSecretRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretPaginationUnion$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretPaginationUnion,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretPaginationUnion$Outbound =
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$Outbound
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationGoogleOauthSecretPaginationUnion$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretPaginationUnion$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretPaginationUnion
  > = z.union([
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$outboundSchema
    ),
  ]);

export function restAuthenticationGoogleOauthSecretPaginationUnionToJSON(
  restAuthenticationGoogleOauthSecretPaginationUnion:
    RestAuthenticationGoogleOauthSecretPaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretPaginationUnion$outboundSchema.parse(
      restAuthenticationGoogleOauthSecretPaginationUnion,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretPaginationUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretPaginationUnion$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("backoff"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff$Outbound =
  {
    type: "backoff";
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    enableHeader?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff
  > = z.object({
    type: z.literal("backoff"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffToJSON(
  restAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff:
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff$outboundSchema
      .parse(restAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff),
  );
}
export function restAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("static"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic$Outbound =
  {
    type: "static";
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    enableHeader?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic
  > = z.object({
    type: z.literal("static"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticToJSON(
  restAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic:
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic$outboundSchema
      .parse(restAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic),
  );
}
export function restAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$Outbound =
  {
    type: "none";
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    enableHeader?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestRetryRulesTypeNoneToJSON(
  restAuthenticationGoogleOauthSecretRestRetryRulesTypeNone:
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$outboundSchema
      .parse(restAuthenticationGoogleOauthSecretRestRetryRulesTypeNone),
  );
}
export function restAuthenticationGoogleOauthSecretRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRetryRules$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRetryRules,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$inboundSchema
    ),
    static: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic$inboundSchema
    ),
    backoff: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRetryRules$Outbound =
  | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$Outbound
  | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic$Outbound
  | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff$Outbound;

/** @internal */
export const RestAuthenticationGoogleOauthSecretRetryRules$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRetryRules$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRetryRules
  > = z.union([
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff$outboundSchema
    ),
  ]);

export function restAuthenticationGoogleOauthSecretRetryRulesToJSON(
  restAuthenticationGoogleOauthSecretRetryRules:
    RestAuthenticationGoogleOauthSecretRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRetryRules$outboundSchema.parse(
      restAuthenticationGoogleOauthSecretRetryRules,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretStateTracking$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretStateTracking,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enabled: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthSecretStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthSecretStateTrackingToJSON(
  restAuthenticationGoogleOauthSecretStateTracking:
    RestAuthenticationGoogleOauthSecretStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretStateTracking$outboundSchema.parse(
      restAuthenticationGoogleOauthSecretStateTracking,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretScheduling$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretScheduling,
    z.ZodTypeDef,
    unknown
  > = z.object({
    stateTracking: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretStateTracking$inboundSchema
      ),
    ),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretScheduling$Outbound = {
  stateTracking?:
    | RestAuthenticationGoogleOauthSecretStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthSecretScheduling$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretScheduling$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretScheduling
  > = z.object({
    stateTracking: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretStateTracking$outboundSchema
    ).optional(),
  });

export function restAuthenticationGoogleOauthSecretSchedulingToJSON(
  restAuthenticationGoogleOauthSecretScheduling:
    RestAuthenticationGoogleOauthSecretScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretScheduling$outboundSchema.parse(
      restAuthenticationGoogleOauthSecretScheduling,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecret$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("google_oauthSecret"),
  scopes: z.array(types.string()),
  textSecret: types.string(),
  subject: types.string(),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectMethod: RestAuthenticationGoogleOauthSecretCollectMethod$inboundSchema,
  collectVerb: types.optional(z.any()),
  collectRequestParams: types.optional(z.any()),
  collectBody: types.optional(z.any()),
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$inboundSchema
    ),
    static: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic$inboundSchema
    ),
    backoff: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff$inboundSchema
    ),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestAuthenticationGoogleOauthSecretScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationGoogleOauthSecret$Outbound = {
  authentication: "google_oauthSecret";
  scopes: Array<string>;
  textSecret: string;
  subject: string;
  discovery?:
    | (
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$Outbound
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$Outbound
    | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic$Outbound
    | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff$Outbound
    | undefined;
  __scheduling?:
    | RestAuthenticationGoogleOauthSecretScheduling$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthSecret$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthSecret$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauthSecret
> = z.object({
  authentication: z.literal("google_oauthSecret"),
  scopes: z.array(z.string()),
  textSecret: z.string(),
  subject: z.string(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectMethod:
    RestAuthenticationGoogleOauthSecretCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff$outboundSchema
    ),
  ]).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationGoogleOauthSecretScheduling$outboundSchema
  ).optional(),
});

export function restAuthenticationGoogleOauthSecretToJSON(
  restAuthenticationGoogleOauthSecret: RestAuthenticationGoogleOauthSecret,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecret$outboundSchema.parse(
      restAuthenticationGoogleOauthSecret,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationGoogleOauthSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecret' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$Outbound =
  {
    discoverType: "none";
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$outboundSchema
      .parse(restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$Outbound =
  {
    discoverType: "list";
    itemList: Array<string>;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$outboundSchema
      .parse(restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$Outbound =
  {
    discoverType: "json";
    manualDiscoverResult: string;
    discoverDataField?: string | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$outboundSchema
      .parse(restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp$outboundSchema
      .parse(restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationGoogleOauthDiscovery$Outbound =
  | (
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationGoogleOauthDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauthDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restAuthenticationGoogleOauthDiscoveryToJSON(
  restAuthenticationGoogleOauthDiscovery:
    RestAuthenticationGoogleOauthDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthDiscovery$outboundSchema.parse(
      restAuthenticationGoogleOauthDiscovery,
    ),
  );
}
export function restAuthenticationGoogleOauthDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationGoogleOauthDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthCollectMethod$inboundSchema:
  z.ZodType<RestAuthenticationGoogleOauthCollectMethod, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(RestAuthenticationGoogleOauthCollectMethod);
/** @internal */
export const RestAuthenticationGoogleOauthCollectMethod$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationGoogleOauthCollectMethod> =
    openEnums.outboundSchema(RestAuthenticationGoogleOauthCollectMethod);

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$Outbound =
  {
    type: "request_page";
    pageField: string;
    page?: number | undefined;
    sizeField: string;
    size: number;
    totalPageField?: string | undefined;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationGoogleOauthRestPaginationTypeRequestPageToJSON(
  restAuthenticationGoogleOauthRestPaginationTypeRequestPage:
    RestAuthenticationGoogleOauthRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$outboundSchema
      .parse(restAuthenticationGoogleOauthRestPaginationTypeRequestPage),
  );
}
export function restAuthenticationGoogleOauthRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$Outbound =
  {
    type: "request_offset";
    offsetField: string;
    offset?: number | undefined;
    limitField: string;
    limit: number;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationGoogleOauthRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationGoogleOauthRestPaginationTypeRequestOffset:
    RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$outboundSchema
      .parse(restAuthenticationGoogleOauthRestPaginationTypeRequestOffset),
  );
}
export function restAuthenticationGoogleOauthRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink:
    RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink),
  );
}
export function restAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$Outbound =
  {
    type: "response_header";
    attribute: Array<string>;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationGoogleOauthRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationGoogleOauthRestPaginationTypeResponseHeader:
    RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$outboundSchema
      .parse(restAuthenticationGoogleOauthRestPaginationTypeResponseHeader),
  );
}
export function restAuthenticationGoogleOauthRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$Outbound =
  {
    type: "response_body";
    attribute: Array<string>;
    maxPages: number;
    lastPageExpr?: string | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationGoogleOauthRestPaginationTypeResponseBodyToJSON(
  restAuthenticationGoogleOauthRestPaginationTypeResponseBody:
    RestAuthenticationGoogleOauthRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$outboundSchema
      .parse(restAuthenticationGoogleOauthRestPaginationTypeResponseBody),
  );
}
export function restAuthenticationGoogleOauthRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationGoogleOauthRestPaginationTypeNoneToJSON(
  restAuthenticationGoogleOauthRestPaginationTypeNone:
    RestAuthenticationGoogleOauthRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestPaginationTypeNone$outboundSchema.parse(
      restAuthenticationGoogleOauthRestPaginationTypeNone,
    ),
  );
}
export function restAuthenticationGoogleOauthRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthPaginationUnion$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthPaginationUnion,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationGoogleOauthPaginationUnion$Outbound =
  | RestAuthenticationGoogleOauthRestPaginationTypeNone$Outbound
  | RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationGoogleOauthPaginationUnion$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthPaginationUnion$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthPaginationUnion
  > = z.union([
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$outboundSchema
    ),
  ]);

export function restAuthenticationGoogleOauthPaginationUnionToJSON(
  restAuthenticationGoogleOauthPaginationUnion:
    RestAuthenticationGoogleOauthPaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthPaginationUnion$outboundSchema.parse(
      restAuthenticationGoogleOauthPaginationUnion,
    ),
  );
}
export function restAuthenticationGoogleOauthPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthPaginationUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthPaginationUnion$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("backoff"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$Outbound = {
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff
  > = z.object({
    type: z.literal("backoff"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationGoogleOauthRestRetryRulesTypeBackoffToJSON(
  restAuthenticationGoogleOauthRestRetryRulesTypeBackoff:
    RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$outboundSchema.parse(
      restAuthenticationGoogleOauthRestRetryRulesTypeBackoff,
    ),
  );
}
export function restAuthenticationGoogleOauthRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("static"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$Outbound = {
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestRetryRulesTypeStatic
  > = z.object({
    type: z.literal("static"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationGoogleOauthRestRetryRulesTypeStaticToJSON(
  restAuthenticationGoogleOauthRestRetryRulesTypeStatic:
    RestAuthenticationGoogleOauthRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$outboundSchema.parse(
      restAuthenticationGoogleOauthRestRetryRulesTypeStatic,
    ),
  );
}
export function restAuthenticationGoogleOauthRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationGoogleOauthRestRetryRulesTypeNoneToJSON(
  restAuthenticationGoogleOauthRestRetryRulesTypeNone:
    RestAuthenticationGoogleOauthRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestRetryRulesTypeNone$outboundSchema.parse(
      restAuthenticationGoogleOauthRestRetryRulesTypeNone,
    ),
  );
}
export function restAuthenticationGoogleOauthRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationGoogleOauthRestRetryRulesTypeNone$inboundSchema
  ),
  static: z.lazy(() =>
    RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$inboundSchema
  ),
  backoff: z.lazy(() =>
    RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationGoogleOauthRetryRules$Outbound =
  | RestAuthenticationGoogleOauthRestRetryRulesTypeNone$Outbound
  | RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$Outbound
  | RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$Outbound;

/** @internal */
export const RestAuthenticationGoogleOauthRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauthRetryRules
> = z.union([
  z.lazy(() =>
    RestAuthenticationGoogleOauthRestRetryRulesTypeNone$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$outboundSchema
  ),
]);

export function restAuthenticationGoogleOauthRetryRulesToJSON(
  restAuthenticationGoogleOauthRetryRules:
    RestAuthenticationGoogleOauthRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRetryRules$outboundSchema.parse(
      restAuthenticationGoogleOauthRetryRules,
    ),
  );
}
export function restAuthenticationGoogleOauthRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthStateTracking$inboundSchema:
  z.ZodType<RestAuthenticationGoogleOauthStateTracking, z.ZodTypeDef, unknown> =
    z.object({
      enabled: types.optional(types.boolean()),
    });
/** @internal */
export type RestAuthenticationGoogleOauthStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthStateTrackingToJSON(
  restAuthenticationGoogleOauthStateTracking:
    RestAuthenticationGoogleOauthStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthStateTracking$outboundSchema.parse(
      restAuthenticationGoogleOauthStateTracking,
    ),
  );
}
export function restAuthenticationGoogleOauthStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthScheduling$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestAuthenticationGoogleOauthStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationGoogleOauthScheduling$Outbound = {
  stateTracking?:
    | RestAuthenticationGoogleOauthStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthScheduling$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauthScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationGoogleOauthStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationGoogleOauthSchedulingToJSON(
  restAuthenticationGoogleOauthScheduling:
    RestAuthenticationGoogleOauthScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthScheduling$outboundSchema.parse(
      restAuthenticationGoogleOauthScheduling,
    ),
  );
}
export function restAuthenticationGoogleOauthSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauth$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauth,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("google_oauth"),
  scopes: z.array(types.string()),
  serviceAccountCredentials: types.string(),
  subject: types.string(),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectMethod: RestAuthenticationGoogleOauthCollectMethod$inboundSchema,
  collectVerb: types.optional(z.any()),
  collectRequestParams: types.optional(z.any()),
  collectBody: types.optional(z.any()),
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeNone$inboundSchema
    ),
    static: z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$inboundSchema
    ),
    backoff: z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$inboundSchema
    ),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestAuthenticationGoogleOauthScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationGoogleOauth$Outbound = {
  authentication: "google_oauth";
  scopes: Array<string>;
  serviceAccountCredentials: string;
  subject: string;
  discovery?:
    | (
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationGoogleOauthRestPaginationTypeNone$Outbound
    | RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationGoogleOauthRestRetryRulesTypeNone$Outbound
    | RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$Outbound
    | RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$Outbound
    | undefined;
  __scheduling?: RestAuthenticationGoogleOauthScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauth$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauth$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauth
> = z.object({
  authentication: z.literal("google_oauth"),
  scopes: z.array(z.string()),
  serviceAccountCredentials: z.string(),
  subject: z.string(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationGoogleOauthCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$outboundSchema
    ),
  ]).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationGoogleOauthScheduling$outboundSchema
  ).optional(),
});

export function restAuthenticationGoogleOauthToJSON(
  restAuthenticationGoogleOauth: RestAuthenticationGoogleOauth,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauth$outboundSchema.parse(
      restAuthenticationGoogleOauth,
    ),
  );
}
export function restAuthenticationGoogleOauthFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationGoogleOauth, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationGoogleOauth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauth' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$Outbound =
  {
    discoverType: "none";
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$outboundSchema
      .parse(restAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$Outbound =
  {
    discoverType: "list";
    itemList: Array<string>;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeList:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$outboundSchema
      .parse(restAuthenticationOauthSecretRestDiscoveryDiscoverTypeList),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$Outbound =
  {
    discoverType: "json";
    manualDiscoverResult: string;
    discoverDataField?: string | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$outboundSchema
      .parse(restAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp$outboundSchema
      .parse(restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecretDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationOauthSecretDiscovery$Outbound =
  | (
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationOauthSecretDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationOauthSecretDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthSecretDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restAuthenticationOauthSecretDiscoveryToJSON(
  restAuthenticationOauthSecretDiscovery:
    RestAuthenticationOauthSecretDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretDiscovery$outboundSchema.parse(
      restAuthenticationOauthSecretDiscovery,
    ),
  );
}
export function restAuthenticationOauthSecretDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthSecretDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretCollectMethod$inboundSchema:
  z.ZodType<RestAuthenticationOauthSecretCollectMethod, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(RestAuthenticationOauthSecretCollectMethod);
/** @internal */
export const RestAuthenticationOauthSecretCollectMethod$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationOauthSecretCollectMethod> =
    openEnums.outboundSchema(RestAuthenticationOauthSecretCollectMethod);

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestPaginationTypeRequestPage$Outbound =
  {
    type: "request_page";
    pageField: string;
    page?: number | undefined;
    sizeField: string;
    size: number;
    totalPageField?: string | undefined;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationOauthSecretRestPaginationTypeRequestPageToJSON(
  restAuthenticationOauthSecretRestPaginationTypeRequestPage:
    RestAuthenticationOauthSecretRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestPaginationTypeRequestPage$outboundSchema
      .parse(restAuthenticationOauthSecretRestPaginationTypeRequestPage),
  );
}
export function restAuthenticationOauthSecretRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestPage$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$Outbound =
  {
    type: "request_offset";
    offsetField: string;
    offset?: number | undefined;
    limitField: string;
    limit: number;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationOauthSecretRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationOauthSecretRestPaginationTypeRequestOffset:
    RestAuthenticationOauthSecretRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$outboundSchema
      .parse(restAuthenticationOauthSecretRestPaginationTypeRequestOffset),
  );
}
export function restAuthenticationOauthSecretRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationOauthSecretRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink:
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink),
  );
}
export function restAuthenticationOauthSecretRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$Outbound =
  {
    type: "response_header";
    attribute: Array<string>;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationOauthSecretRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationOauthSecretRestPaginationTypeResponseHeader:
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$outboundSchema
      .parse(restAuthenticationOauthSecretRestPaginationTypeResponseHeader),
  );
}
export function restAuthenticationOauthSecretRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestPaginationTypeResponseBody$Outbound =
  {
    type: "response_body";
    attribute: Array<string>;
    maxPages: number;
    lastPageExpr?: string | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationOauthSecretRestPaginationTypeResponseBodyToJSON(
  restAuthenticationOauthSecretRestPaginationTypeResponseBody:
    RestAuthenticationOauthSecretRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestPaginationTypeResponseBody$outboundSchema
      .parse(restAuthenticationOauthSecretRestPaginationTypeResponseBody),
  );
}
export function restAuthenticationOauthSecretRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationOauthSecretRestPaginationTypeNoneToJSON(
  restAuthenticationOauthSecretRestPaginationTypeNone:
    RestAuthenticationOauthSecretRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestPaginationTypeNone$outboundSchema.parse(
      restAuthenticationOauthSecretRestPaginationTypeNone,
    ),
  );
}
export function restAuthenticationOauthSecretRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretPaginationUnion$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretPaginationUnion,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestPage$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationOauthSecretPaginationUnion$Outbound =
  | RestAuthenticationOauthSecretRestPaginationTypeNone$Outbound
  | RestAuthenticationOauthSecretRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationOauthSecretRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationOauthSecretPaginationUnion$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretPaginationUnion$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretPaginationUnion
  > = z.union([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestPage$outboundSchema
    ),
  ]);

export function restAuthenticationOauthSecretPaginationUnionToJSON(
  restAuthenticationOauthSecretPaginationUnion:
    RestAuthenticationOauthSecretPaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretPaginationUnion$outboundSchema.parse(
      restAuthenticationOauthSecretPaginationUnion,
    ),
  );
}
export function restAuthenticationOauthSecretPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretPaginationUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretPaginationUnion$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("backoff"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$Outbound = {
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoff
  > = z.object({
    type: z.literal("backoff"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationOauthSecretRestRetryRulesTypeBackoffToJSON(
  restAuthenticationOauthSecretRestRetryRulesTypeBackoff:
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$outboundSchema.parse(
      restAuthenticationOauthSecretRestRetryRulesTypeBackoff,
    ),
  );
}
export function restAuthenticationOauthSecretRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("static"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestRetryRulesTypeStatic$Outbound = {
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestRetryRulesTypeStatic
  > = z.object({
    type: z.literal("static"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationOauthSecretRestRetryRulesTypeStaticToJSON(
  restAuthenticationOauthSecretRestRetryRulesTypeStatic:
    RestAuthenticationOauthSecretRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestRetryRulesTypeStatic$outboundSchema.parse(
      restAuthenticationOauthSecretRestRetryRulesTypeStatic,
    ),
  );
}
export function restAuthenticationOauthSecretRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationOauthSecretRestRetryRulesTypeNoneToJSON(
  restAuthenticationOauthSecretRestRetryRulesTypeNone:
    RestAuthenticationOauthSecretRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestRetryRulesTypeNone$outboundSchema.parse(
      restAuthenticationOauthSecretRestRetryRulesTypeNone,
    ),
  );
}
export function restAuthenticationOauthSecretRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecretRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationOauthSecretRestRetryRulesTypeNone$inboundSchema
  ),
  static: z.lazy(() =>
    RestAuthenticationOauthSecretRestRetryRulesTypeStatic$inboundSchema
  ),
  backoff: z.lazy(() =>
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationOauthSecretRetryRules$Outbound =
  | RestAuthenticationOauthSecretRestRetryRulesTypeNone$Outbound
  | RestAuthenticationOauthSecretRestRetryRulesTypeStatic$Outbound
  | RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$Outbound;

/** @internal */
export const RestAuthenticationOauthSecretRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationOauthSecretRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthSecretRetryRules
> = z.union([
  z.lazy(() =>
    RestAuthenticationOauthSecretRestRetryRulesTypeNone$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationOauthSecretRestRetryRulesTypeStatic$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$outboundSchema
  ),
]);

export function restAuthenticationOauthSecretRetryRulesToJSON(
  restAuthenticationOauthSecretRetryRules:
    RestAuthenticationOauthSecretRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRetryRules$outboundSchema.parse(
      restAuthenticationOauthSecretRetryRules,
    ),
  );
}
export function restAuthenticationOauthSecretRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretStateTracking$inboundSchema:
  z.ZodType<RestAuthenticationOauthSecretStateTracking, z.ZodTypeDef, unknown> =
    z.object({
      enabled: types.optional(types.boolean()),
    });
/** @internal */
export type RestAuthenticationOauthSecretStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationOauthSecretStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretStateTrackingToJSON(
  restAuthenticationOauthSecretStateTracking:
    RestAuthenticationOauthSecretStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretStateTracking$outboundSchema.parse(
      restAuthenticationOauthSecretStateTracking,
    ),
  );
}
export function restAuthenticationOauthSecretStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretScheduling$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecretScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestAuthenticationOauthSecretStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationOauthSecretScheduling$Outbound = {
  stateTracking?:
    | RestAuthenticationOauthSecretStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationOauthSecretScheduling$outboundSchema: z.ZodType<
  RestAuthenticationOauthSecretScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthSecretScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationOauthSecretStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationOauthSecretSchedulingToJSON(
  restAuthenticationOauthSecretScheduling:
    RestAuthenticationOauthSecretScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretScheduling$outboundSchema.parse(
      restAuthenticationOauthSecretScheduling,
    ),
  );
}
export function restAuthenticationOauthSecretSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecret$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("oauthSecret"),
  loginUrl: types.string(),
  tokenRespAttribute: types.optional(types.string()),
  authHeaderKey: types.optional(types.string()),
  authHeaderExpr: types.string(),
  clientSecretParamName: types.string(),
  textSecret: types.string(),
  authRequestParams: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  authRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectMethod: RestAuthenticationOauthSecretCollectMethod$inboundSchema,
  collectVerb: types.optional(z.any()),
  collectRequestParams: types.optional(z.any()),
  collectBody: types.optional(z.any()),
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeNone$inboundSchema
    ),
    static: z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStatic$inboundSchema
    ),
    backoff: z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$inboundSchema
    ),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestAuthenticationOauthSecretScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationOauthSecret$Outbound = {
  authentication: "oauthSecret";
  loginUrl: string;
  tokenRespAttribute?: string | undefined;
  authHeaderKey?: string | undefined;
  authHeaderExpr: string;
  clientSecretParamName: string;
  textSecret: string;
  authRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationOauthSecretRestPaginationTypeNone$Outbound
    | RestAuthenticationOauthSecretRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationOauthSecretRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationOauthSecretRestRetryRulesTypeNone$Outbound
    | RestAuthenticationOauthSecretRestRetryRulesTypeStatic$Outbound
    | RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$Outbound
    | undefined;
  __scheduling?: RestAuthenticationOauthSecretScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationOauthSecret$outboundSchema: z.ZodType<
  RestAuthenticationOauthSecret$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthSecret
> = z.object({
  authentication: z.literal("oauthSecret"),
  loginUrl: z.string(),
  tokenRespAttribute: z.string().optional(),
  authHeaderKey: z.string().optional(),
  authHeaderExpr: z.string(),
  clientSecretParamName: z.string(),
  textSecret: z.string(),
  authRequestParams: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  authRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationOauthSecretCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStatic$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$outboundSchema
    ),
  ]).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationOauthSecretScheduling$outboundSchema
  ).optional(),
});

export function restAuthenticationOauthSecretToJSON(
  restAuthenticationOauthSecret: RestAuthenticationOauthSecret,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecret$outboundSchema.parse(
      restAuthenticationOauthSecret,
    ),
  );
}
export function restAuthenticationOauthSecretFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauthSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecret' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$Outbound = {
  discoverType: "none";
};

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeNone:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$outboundSchema.parse(
      restAuthenticationOauthRestDiscoveryDiscoverTypeNone,
    ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeList$Outbound = {
  discoverType: "list";
  itemList: Array<string>;
};

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeList:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeList$outboundSchema.parse(
      restAuthenticationOauthRestDiscoveryDiscoverTypeList,
    ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeList$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$Outbound = {
  discoverType: "json";
  manualDiscoverResult: string;
  discoverDataField?: string | undefined;
};

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeJson:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$outboundSchema.parse(
      restAuthenticationOauthRestDiscoveryDiscoverTypeJson,
    ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp$outboundSchema.parse(
      restAuthenticationOauthRestDiscoveryDiscoverTypeHttp,
    ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationOauthDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestAuthenticationOauthRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationOauthDiscovery$Outbound =
  | (
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationOauthDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationOauthDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationOauthRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restAuthenticationOauthDiscoveryToJSON(
  restAuthenticationOauthDiscovery: RestAuthenticationOauthDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationOauthDiscovery$outboundSchema.parse(
      restAuthenticationOauthDiscovery,
    ),
  );
}
export function restAuthenticationOauthDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauthDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthCollectMethod$inboundSchema: z.ZodType<
  RestAuthenticationOauthCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationOauthCollectMethod);
/** @internal */
export const RestAuthenticationOauthCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationOauthCollectMethod
> = openEnums.outboundSchema(RestAuthenticationOauthCollectMethod);

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationOauthRestPaginationTypeRequestPage$Outbound = {
  type: "request_page";
  pageField: string;
  page?: number | undefined;
  sizeField: string;
  size: number;
  totalPageField?: string | undefined;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationOauthRestPaginationTypeRequestPageToJSON(
  restAuthenticationOauthRestPaginationTypeRequestPage:
    RestAuthenticationOauthRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestPaginationTypeRequestPage$outboundSchema.parse(
      restAuthenticationOauthRestPaginationTypeRequestPage,
    ),
  );
}
export function restAuthenticationOauthRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestPaginationTypeRequestPage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationOauthRestPaginationTypeRequestOffset$Outbound = {
  type: "request_offset";
  offsetField: string;
  offset?: number | undefined;
  limitField: string;
  limit: number;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationOauthRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationOauthRestPaginationTypeRequestOffset:
    RestAuthenticationOauthRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestPaginationTypeRequestOffset$outboundSchema.parse(
      restAuthenticationOauthRestPaginationTypeRequestOffset,
    ),
  );
}
export function restAuthenticationOauthRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationOauthRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationOauthRestPaginationTypeResponseHeaderLink:
    RestAuthenticationOauthRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restAuthenticationOauthRestPaginationTypeResponseHeaderLink),
  );
}
export function restAuthenticationOauthRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationOauthRestPaginationTypeResponseHeader$Outbound = {
  type: "response_header";
  attribute: Array<string>;
  maxPages: number;
};

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationOauthRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationOauthRestPaginationTypeResponseHeader:
    RestAuthenticationOauthRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestPaginationTypeResponseHeader$outboundSchema
      .parse(restAuthenticationOauthRestPaginationTypeResponseHeader),
  );
}
export function restAuthenticationOauthRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestPaginationTypeResponseHeader' from JSON`,
  );
}
