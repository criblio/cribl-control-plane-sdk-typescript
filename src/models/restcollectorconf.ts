/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeRestCollectMethodGetCollectRequestParams,
  ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound,
  ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
} from "./itemstyperestcollectmethodgetcollectrequestparams.js";
import {
  RetryTypeOptionsHealthCheckCollectorConfRetryRules,
  RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
} from "./retrytypeoptionshealthcheckcollectorconfretryrules.js";

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationHmacDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationHmacDiscoverType = OpenEnum<
  typeof RestAuthenticationHmacDiscoverType
>;

export type RestAuthenticationHmacDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestAuthenticationHmacDiscoverType;
};

export const RestAuthenticationHmacCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationHmacCollectMethod = OpenEnum<
  typeof RestAuthenticationHmacCollectMethod
>;

export const RestAuthenticationHmacPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestAuthenticationHmacPaginationEnum = OpenEnum<
  typeof RestAuthenticationHmacPaginationEnum
>;

export type RestAuthenticationHmacPagination = {
  type: RestAuthenticationHmacPaginationEnum;
};

export type RestAuthenticationHmacRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationHmacStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationHmacScheduling = {
  stateTracking?: RestAuthenticationHmacStateTracking | undefined;
};

export type RestAuthenticationHmac = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "hmac";
  /**
   * Select or create an HMAC Function to use with authentication
   */
  hmacFunctionId: string;
  discovery?: RestAuthenticationHmacDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationHmacCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestAuthenticationHmacPagination | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationHmacRetryRules | undefined;
  __scheduling?: RestAuthenticationHmacScheduling | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthSecretDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthSecretDiscoverType = OpenEnum<
  typeof RestAuthenticationGoogleOauthSecretDiscoverType
>;

export type RestAuthenticationGoogleOauthSecretDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestAuthenticationGoogleOauthSecretDiscoverType;
};

export const RestAuthenticationGoogleOauthSecretCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationGoogleOauthSecretCollectMethod = OpenEnum<
  typeof RestAuthenticationGoogleOauthSecretCollectMethod
>;

export const RestAuthenticationGoogleOauthSecretPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestAuthenticationGoogleOauthSecretPaginationEnum = OpenEnum<
  typeof RestAuthenticationGoogleOauthSecretPaginationEnum
>;

export type RestAuthenticationGoogleOauthSecretPagination = {
  type: RestAuthenticationGoogleOauthSecretPaginationEnum;
};

export type RestAuthenticationGoogleOauthSecretRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationGoogleOauthSecretStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationGoogleOauthSecretScheduling = {
  stateTracking?: RestAuthenticationGoogleOauthSecretStateTracking | undefined;
};

export type RestAuthenticationGoogleOauthSecret = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "google_oauthSecret";
  /**
   * Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information.
   */
  scopes: Array<string>;
  /**
   * Select or create a text secret that contains the Google service account credentials value
   */
  textSecret: string;
  /**
   * Email address of a user account with Super Admin permissions to the resources the collector will retrieve
   */
  subject: string;
  discovery?: RestAuthenticationGoogleOauthSecretDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationGoogleOauthSecretCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestAuthenticationGoogleOauthSecretPagination | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationGoogleOauthSecretRetryRules | undefined;
  __scheduling?: RestAuthenticationGoogleOauthSecretScheduling | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthDiscoverType = OpenEnum<
  typeof RestAuthenticationGoogleOauthDiscoverType
>;

export type RestAuthenticationGoogleOauthDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestAuthenticationGoogleOauthDiscoverType;
};

export const RestAuthenticationGoogleOauthCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationGoogleOauthCollectMethod = OpenEnum<
  typeof RestAuthenticationGoogleOauthCollectMethod
>;

export const RestAuthenticationGoogleOauthPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestAuthenticationGoogleOauthPaginationEnum = OpenEnum<
  typeof RestAuthenticationGoogleOauthPaginationEnum
>;

export type RestAuthenticationGoogleOauthPagination = {
  type: RestAuthenticationGoogleOauthPaginationEnum;
};

export type RestAuthenticationGoogleOauthRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationGoogleOauthStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationGoogleOauthScheduling = {
  stateTracking?: RestAuthenticationGoogleOauthStateTracking | undefined;
};

export type RestAuthenticationGoogleOauth = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "google_oauth";
  /**
   * Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information.
   */
  scopes: Array<string>;
  /**
   * Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right.
   */
  serviceAccountCredentials: string;
  /**
   * Email address of a user account with Super Admin permissions to the resources the collector will retrieve
   */
  subject: string;
  discovery?: RestAuthenticationGoogleOauthDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationGoogleOauthCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestAuthenticationGoogleOauthPagination | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationGoogleOauthRetryRules | undefined;
  __scheduling?: RestAuthenticationGoogleOauthScheduling | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthSecretDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthSecretDiscoverType = OpenEnum<
  typeof RestAuthenticationOauthSecretDiscoverType
>;

export type RestAuthenticationOauthSecretDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestAuthenticationOauthSecretDiscoverType;
};

export const RestAuthenticationOauthSecretCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationOauthSecretCollectMethod = OpenEnum<
  typeof RestAuthenticationOauthSecretCollectMethod
>;

export const RestAuthenticationOauthSecretPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestAuthenticationOauthSecretPaginationEnum = OpenEnum<
  typeof RestAuthenticationOauthSecretPaginationEnum
>;

export type RestAuthenticationOauthSecretPagination = {
  type: RestAuthenticationOauthSecretPaginationEnum;
};

export type RestAuthenticationOauthSecretRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationOauthSecretStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationOauthSecretScheduling = {
  stateTracking?: RestAuthenticationOauthSecretStateTracking | undefined;
};

export type RestAuthenticationOauthSecret = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "oauthSecret";
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl: string;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName: string;
  /**
   * Select or create a text secret that contains the client secret's value
   */
  textSecret: string;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?: RestAuthenticationOauthSecretDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationOauthSecretCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestAuthenticationOauthSecretPagination | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationOauthSecretRetryRules | undefined;
  __scheduling?: RestAuthenticationOauthSecretScheduling | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthDiscoverType = OpenEnum<
  typeof RestAuthenticationOauthDiscoverType
>;

export type RestAuthenticationOauthDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestAuthenticationOauthDiscoverType;
};

export const RestAuthenticationOauthCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationOauthCollectMethod = OpenEnum<
  typeof RestAuthenticationOauthCollectMethod
>;

export const RestAuthenticationOauthPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestAuthenticationOauthPaginationEnum = OpenEnum<
  typeof RestAuthenticationOauthPaginationEnum
>;

export type RestAuthenticationOauthPagination = {
  type: RestAuthenticationOauthPaginationEnum;
};

export type RestAuthenticationOauthRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationOauthStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationOauthScheduling = {
  stateTracking?: RestAuthenticationOauthStateTracking | undefined;
};

export type RestAuthenticationOauth = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "oauth";
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl: string;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName: string;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters.
   */
  clientSecretParamValue: string;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?: RestAuthenticationOauthDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationOauthCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestAuthenticationOauthPagination | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationOauthRetryRules | undefined;
  __scheduling?: RestAuthenticationOauthScheduling | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretDiscoverType = OpenEnum<
  typeof RestAuthenticationLoginSecretDiscoverType
>;

export type RestAuthenticationLoginSecretDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestAuthenticationLoginSecretDiscoverType;
};

export const RestAuthenticationLoginSecretCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationLoginSecretCollectMethod = OpenEnum<
  typeof RestAuthenticationLoginSecretCollectMethod
>;

export const RestAuthenticationLoginSecretPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestAuthenticationLoginSecretPaginationEnum = OpenEnum<
  typeof RestAuthenticationLoginSecretPaginationEnum
>;

export type RestAuthenticationLoginSecretPagination = {
  type: RestAuthenticationLoginSecretPaginationEnum;
};

export type RestAuthenticationLoginSecretRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationLoginSecretStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationLoginSecretScheduling = {
  stateTracking?: RestAuthenticationLoginSecretStateTracking | undefined;
};

export type RestAuthenticationLoginSecret = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "loginSecret";
  /**
   * URL to use for login API call. This call is expected to be a POST.
   */
  loginUrl: string;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret: string;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody: string;
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?: RestAuthenticationLoginSecretDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationLoginSecretCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestAuthenticationLoginSecretPagination | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationLoginSecretRetryRules | undefined;
  __scheduling?: RestAuthenticationLoginSecretScheduling | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginDiscoverType = OpenEnum<
  typeof RestAuthenticationLoginDiscoverType
>;

export type RestAuthenticationLoginDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestAuthenticationLoginDiscoverType;
};

export const RestAuthenticationLoginCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationLoginCollectMethod = OpenEnum<
  typeof RestAuthenticationLoginCollectMethod
>;

export const RestAuthenticationLoginPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestAuthenticationLoginPaginationEnum = OpenEnum<
  typeof RestAuthenticationLoginPaginationEnum
>;

export type RestAuthenticationLoginPagination = {
  type: RestAuthenticationLoginPaginationEnum;
};

export type RestAuthenticationLoginRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationLoginStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationLoginScheduling = {
  stateTracking?: RestAuthenticationLoginStateTracking | undefined;
};

export type RestAuthenticationLogin = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "login";
  /**
   * URL to use for login API call. This call is expected to be a POST.
   */
  loginUrl: string;
  username: string;
  password: string;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody: string;
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression used to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?: RestAuthenticationLoginDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationLoginCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestAuthenticationLoginPagination | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationLoginRetryRules | undefined;
  __scheduling?: RestAuthenticationLoginScheduling | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicSecretDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicSecretDiscoverType = OpenEnum<
  typeof RestAuthenticationBasicSecretDiscoverType
>;

export type RestAuthenticationBasicSecretDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestAuthenticationBasicSecretDiscoverType;
};

export const RestAuthenticationBasicSecretCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationBasicSecretCollectMethod = OpenEnum<
  typeof RestAuthenticationBasicSecretCollectMethod
>;

export const RestAuthenticationBasicSecretPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestAuthenticationBasicSecretPaginationEnum = OpenEnum<
  typeof RestAuthenticationBasicSecretPaginationEnum
>;

export type RestAuthenticationBasicSecretPagination = {
  type: RestAuthenticationBasicSecretPaginationEnum;
};

export type RestAuthenticationBasicSecretRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationBasicSecretStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationBasicSecretScheduling = {
  stateTracking?: RestAuthenticationBasicSecretStateTracking | undefined;
};

export type RestAuthenticationBasicSecret = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "basicSecret";
  /**
   * Select or create a stored secret that references your credentials
   */
  credentialsSecret: string;
  discovery?: RestAuthenticationBasicSecretDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationBasicSecretCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestAuthenticationBasicSecretPagination | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationBasicSecretRetryRules | undefined;
  __scheduling?: RestAuthenticationBasicSecretScheduling | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicDiscoverType = OpenEnum<
  typeof RestAuthenticationBasicDiscoverType
>;

export type RestAuthenticationBasicDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestAuthenticationBasicDiscoverType;
};

export const RestAuthenticationBasicCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationBasicCollectMethod = OpenEnum<
  typeof RestAuthenticationBasicCollectMethod
>;

export const RestAuthenticationBasicPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestAuthenticationBasicPaginationEnum = OpenEnum<
  typeof RestAuthenticationBasicPaginationEnum
>;

export type RestAuthenticationBasicPagination = {
  type: RestAuthenticationBasicPaginationEnum;
};

export type RestAuthenticationBasicRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationBasicStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationBasicScheduling = {
  stateTracking?: RestAuthenticationBasicStateTracking | undefined;
};

export type RestAuthenticationBasic = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "basic";
  username: string;
  password: string;
  discovery?: RestAuthenticationBasicDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationBasicCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestAuthenticationBasicPagination | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationBasicRetryRules | undefined;
  __scheduling?: RestAuthenticationBasicScheduling | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationNoneDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationNoneDiscoverType = OpenEnum<
  typeof RestAuthenticationNoneDiscoverType
>;

export type RestAuthenticationNoneDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestAuthenticationNoneDiscoverType;
};

export const RestAuthenticationNoneCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationNoneCollectMethod = OpenEnum<
  typeof RestAuthenticationNoneCollectMethod
>;

export const RestAuthenticationNonePaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestAuthenticationNonePaginationEnum = OpenEnum<
  typeof RestAuthenticationNonePaginationEnum
>;

export type RestAuthenticationNonePagination = {
  type: RestAuthenticationNonePaginationEnum;
};

export type RestAuthenticationNoneRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationNoneStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationNoneScheduling = {
  stateTracking?: RestAuthenticationNoneStateTracking | undefined;
};

export type RestAuthenticationNone = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "none";
  discovery?: RestAuthenticationNoneDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationNoneCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestAuthenticationNonePagination | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationNoneRetryRules | undefined;
  __scheduling?: RestAuthenticationNoneScheduling | undefined;
};

export const RestCollectMethodOtherCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestCollectMethodOtherCollectMethod = OpenEnum<
  typeof RestCollectMethodOtherCollectMethod
>;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodOtherDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodOtherDiscoverType = OpenEnum<
  typeof RestCollectMethodOtherDiscoverType
>;

export type RestCollectMethodOtherDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestCollectMethodOtherDiscoverType;
};

export const RestCollectMethodOtherPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestCollectMethodOtherPaginationEnum = OpenEnum<
  typeof RestCollectMethodOtherPaginationEnum
>;

export type RestCollectMethodOtherPagination = {
  type: RestCollectMethodOtherPaginationEnum;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const RestCollectMethodOtherAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type RestCollectMethodOtherAuthentication = OpenEnum<
  typeof RestCollectMethodOtherAuthentication
>;

export type RestCollectMethodOtherRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodOtherStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestCollectMethodOtherScheduling = {
  stateTracking?: RestCollectMethodOtherStateTracking | undefined;
};

export type RestCollectMethodOther = {
  collectMethod: RestCollectMethodOtherCollectMethod;
  collectVerb?: any | undefined;
  collectBody?: any | undefined;
  collectRequestParams?: any | undefined;
  discovery?: RestCollectMethodOtherDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestCollectMethodOtherPagination | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: RestCollectMethodOtherAuthentication;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestCollectMethodOtherRetryRules | undefined;
  __scheduling?: RestCollectMethodOtherScheduling | undefined;
};

export const RestCollectMethodPostWithBodyCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestCollectMethodPostWithBodyCollectMethod = OpenEnum<
  typeof RestCollectMethodPostWithBodyCollectMethod
>;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostWithBodyDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostWithBodyDiscoverType = OpenEnum<
  typeof RestCollectMethodPostWithBodyDiscoverType
>;

export type RestCollectMethodPostWithBodyDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestCollectMethodPostWithBodyDiscoverType;
};

export const RestCollectMethodPostWithBodyPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestCollectMethodPostWithBodyPaginationEnum = OpenEnum<
  typeof RestCollectMethodPostWithBodyPaginationEnum
>;

export type RestCollectMethodPostWithBodyPagination = {
  type: RestCollectMethodPostWithBodyPaginationEnum;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const RestCollectMethodPostWithBodyAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type RestCollectMethodPostWithBodyAuthentication = OpenEnum<
  typeof RestCollectMethodPostWithBodyAuthentication
>;

export type RestCollectMethodPostWithBodyRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodPostWithBodyStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestCollectMethodPostWithBodyScheduling = {
  stateTracking?: RestCollectMethodPostWithBodyStateTracking | undefined;
};

export type RestCollectMethodPostWithBody = {
  collectMethod: RestCollectMethodPostWithBodyCollectMethod;
  collectBody?: any | undefined;
  discovery?: RestCollectMethodPostWithBodyDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestCollectMethodPostWithBodyPagination | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: RestCollectMethodPostWithBodyAuthentication;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestCollectMethodPostWithBodyRetryRules | undefined;
  __scheduling?: RestCollectMethodPostWithBodyScheduling | undefined;
};

export const RestCollectMethodPostCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestCollectMethodPostCollectMethod = OpenEnum<
  typeof RestCollectMethodPostCollectMethod
>;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostDiscoverType = OpenEnum<
  typeof RestCollectMethodPostDiscoverType
>;

export type RestCollectMethodPostDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestCollectMethodPostDiscoverType;
};

export const RestCollectMethodPostPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestCollectMethodPostPaginationEnum = OpenEnum<
  typeof RestCollectMethodPostPaginationEnum
>;

export type RestCollectMethodPostPagination = {
  type: RestCollectMethodPostPaginationEnum;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const RestCollectMethodPostAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type RestCollectMethodPostAuthentication = OpenEnum<
  typeof RestCollectMethodPostAuthentication
>;

export type RestCollectMethodPostRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodPostStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestCollectMethodPostScheduling = {
  stateTracking?: RestCollectMethodPostStateTracking | undefined;
};

export type RestCollectMethodPost = {
  collectMethod: RestCollectMethodPostCollectMethod;
  collectRequestParams?: any | undefined;
  discovery?: RestCollectMethodPostDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectVerb?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestCollectMethodPostPagination | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: RestCollectMethodPostAuthentication;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestCollectMethodPostRetryRules | undefined;
  __scheduling?: RestCollectMethodPostScheduling | undefined;
};

export const RestCollectMethodGetCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestCollectMethodGetCollectMethod = OpenEnum<
  typeof RestCollectMethodGetCollectMethod
>;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodGetDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodGetDiscoverType = OpenEnum<
  typeof RestCollectMethodGetDiscoverType
>;

export type RestCollectMethodGetDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestCollectMethodGetDiscoverType;
};

export const RestCollectMethodGetPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestCollectMethodGetPaginationEnum = OpenEnum<
  typeof RestCollectMethodGetPaginationEnum
>;

export type RestCollectMethodGetPagination = {
  type: RestCollectMethodGetPaginationEnum;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const RestCollectMethodGetAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type RestCollectMethodGetAuthentication = OpenEnum<
  typeof RestCollectMethodGetAuthentication
>;

export type RestCollectMethodGetRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodGetStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestCollectMethodGetScheduling = {
  stateTracking?: RestCollectMethodGetStateTracking | undefined;
};

export type RestCollectMethodGet = {
  collectMethod: RestCollectMethodGetCollectMethod;
  collectRequestParams?: any | undefined;
  discovery?: RestCollectMethodGetDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectVerb?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestCollectMethodGetPagination | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: RestCollectMethodGetAuthentication;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestCollectMethodGetRetryRules | undefined;
  __scheduling?: RestCollectMethodGetScheduling | undefined;
};

export type RestCollectorConf =
  | RestAuthenticationNone
  | RestAuthenticationBasic
  | RestAuthenticationBasicSecret
  | RestAuthenticationLogin
  | RestAuthenticationLoginSecret
  | RestAuthenticationOauth
  | RestAuthenticationOauthSecret
  | RestAuthenticationGoogleOauth
  | RestAuthenticationGoogleOauthSecret
  | RestAuthenticationHmac;

/** @internal */
export const RestAuthenticationHmacDiscoverType$inboundSchema: z.ZodType<
  RestAuthenticationHmacDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationHmacDiscoverType);
/** @internal */
export const RestAuthenticationHmacDiscoverType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationHmacDiscoverType
> = openEnums.outboundSchema(RestAuthenticationHmacDiscoverType);

/** @internal */
export const RestAuthenticationHmacDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationHmacDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestAuthenticationHmacDiscoverType$inboundSchema,
});
/** @internal */
export type RestAuthenticationHmacDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestAuthenticationHmacDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationHmacDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmacDiscovery
> = z.object({
  discoverType: RestAuthenticationHmacDiscoverType$outboundSchema,
});

export function restAuthenticationHmacDiscoveryToJSON(
  restAuthenticationHmacDiscovery: RestAuthenticationHmacDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationHmacDiscovery$outboundSchema.parse(
      restAuthenticationHmacDiscovery,
    ),
  );
}
export function restAuthenticationHmacDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmacDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationHmacDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacCollectMethod$inboundSchema: z.ZodType<
  RestAuthenticationHmacCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationHmacCollectMethod);
/** @internal */
export const RestAuthenticationHmacCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationHmacCollectMethod
> = openEnums.outboundSchema(RestAuthenticationHmacCollectMethod);

/** @internal */
export const RestAuthenticationHmacPaginationEnum$inboundSchema: z.ZodType<
  RestAuthenticationHmacPaginationEnum,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationHmacPaginationEnum);
/** @internal */
export const RestAuthenticationHmacPaginationEnum$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationHmacPaginationEnum
> = openEnums.outboundSchema(RestAuthenticationHmacPaginationEnum);

/** @internal */
export const RestAuthenticationHmacPagination$inboundSchema: z.ZodType<
  RestAuthenticationHmacPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestAuthenticationHmacPaginationEnum$inboundSchema,
});
/** @internal */
export type RestAuthenticationHmacPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestAuthenticationHmacPagination$outboundSchema: z.ZodType<
  RestAuthenticationHmacPagination$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmacPagination
> = z.object({
  type: RestAuthenticationHmacPaginationEnum$outboundSchema,
});

export function restAuthenticationHmacPaginationToJSON(
  restAuthenticationHmacPagination: RestAuthenticationHmacPagination,
): string {
  return JSON.stringify(
    RestAuthenticationHmacPagination$outboundSchema.parse(
      restAuthenticationHmacPagination,
    ),
  );
}
export function restAuthenticationHmacPaginationFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmacPagination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationHmacPagination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationHmacRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestAuthenticationHmacRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationHmacRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationHmacRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmacRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restAuthenticationHmacRetryRulesToJSON(
  restAuthenticationHmacRetryRules: RestAuthenticationHmacRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRetryRules$outboundSchema.parse(
      restAuthenticationHmacRetryRules,
    ),
  );
}
export function restAuthenticationHmacRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmacRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationHmacRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacStateTracking$inboundSchema: z.ZodType<
  RestAuthenticationHmacStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type RestAuthenticationHmacStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationHmacStateTracking$outboundSchema: z.ZodType<
  RestAuthenticationHmacStateTracking$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmacStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restAuthenticationHmacStateTrackingToJSON(
  restAuthenticationHmacStateTracking: RestAuthenticationHmacStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationHmacStateTracking$outboundSchema.parse(
      restAuthenticationHmacStateTracking,
    ),
  );
}
export function restAuthenticationHmacStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmacStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacScheduling$inboundSchema: z.ZodType<
  RestAuthenticationHmacScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => RestAuthenticationHmacStateTracking$inboundSchema)
    .optional(),
});
/** @internal */
export type RestAuthenticationHmacScheduling$Outbound = {
  stateTracking?: RestAuthenticationHmacStateTracking$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationHmacScheduling$outboundSchema: z.ZodType<
  RestAuthenticationHmacScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmacScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationHmacStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationHmacSchedulingToJSON(
  restAuthenticationHmacScheduling: RestAuthenticationHmacScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationHmacScheduling$outboundSchema.parse(
      restAuthenticationHmacScheduling,
    ),
  );
}
export function restAuthenticationHmacSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmacScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationHmacScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmac$inboundSchema: z.ZodType<
  RestAuthenticationHmac,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("hmac"),
  hmacFunctionId: z.string(),
  discovery: z.lazy(() => RestAuthenticationHmacDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationHmacCollectMethod$inboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestAuthenticationHmacPagination$inboundSchema)
    .optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestAuthenticationHmacRetryRules$inboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestAuthenticationHmacScheduling$inboundSchema)
    .optional(),
});
/** @internal */
export type RestAuthenticationHmac$Outbound = {
  authentication: "hmac";
  hmacFunctionId: string;
  discovery?: RestAuthenticationHmacDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestAuthenticationHmacPagination$Outbound | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationHmacRetryRules$Outbound | undefined;
  __scheduling?: RestAuthenticationHmacScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationHmac$outboundSchema: z.ZodType<
  RestAuthenticationHmac$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmac
> = z.object({
  authentication: z.literal("hmac"),
  hmacFunctionId: z.string(),
  discovery: z.lazy(() => RestAuthenticationHmacDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationHmacCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestAuthenticationHmacPagination$outboundSchema)
    .optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestAuthenticationHmacRetryRules$outboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestAuthenticationHmacScheduling$outboundSchema)
    .optional(),
});

export function restAuthenticationHmacToJSON(
  restAuthenticationHmac: RestAuthenticationHmac,
): string {
  return JSON.stringify(
    RestAuthenticationHmac$outboundSchema.parse(restAuthenticationHmac),
  );
}
export function restAuthenticationHmacFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmac, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationHmac$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmac' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RestAuthenticationGoogleOauthSecretDiscoverType);
/** @internal */
export const RestAuthenticationGoogleOauthSecretDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretDiscoverType
  > = openEnums.outboundSchema(RestAuthenticationGoogleOauthSecretDiscoverType);

/** @internal */
export const RestAuthenticationGoogleOauthSecretDiscovery$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretDiscovery,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: RestAuthenticationGoogleOauthSecretDiscoverType$inboundSchema,
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestAuthenticationGoogleOauthSecretDiscovery$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretDiscovery$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretDiscovery
  > = z.object({
    discoverType:
      RestAuthenticationGoogleOauthSecretDiscoverType$outboundSchema,
  });

export function restAuthenticationGoogleOauthSecretDiscoveryToJSON(
  restAuthenticationGoogleOauthSecretDiscovery:
    RestAuthenticationGoogleOauthSecretDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretDiscovery$outboundSchema.parse(
      restAuthenticationGoogleOauthSecretDiscovery,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretDiscovery,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretDiscovery$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretCollectMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretCollectMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RestAuthenticationGoogleOauthSecretCollectMethod);
/** @internal */
export const RestAuthenticationGoogleOauthSecretCollectMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretCollectMethod
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthSecretCollectMethod,
  );

/** @internal */
export const RestAuthenticationGoogleOauthSecretPaginationEnum$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretPaginationEnum,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthSecretPaginationEnum,
  );
/** @internal */
export const RestAuthenticationGoogleOauthSecretPaginationEnum$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretPaginationEnum
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthSecretPaginationEnum,
  );

/** @internal */
export const RestAuthenticationGoogleOauthSecretPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: RestAuthenticationGoogleOauthSecretPaginationEnum$inboundSchema,
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestAuthenticationGoogleOauthSecretPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretPagination
  > = z.object({
    type: RestAuthenticationGoogleOauthSecretPaginationEnum$outboundSchema,
  });

export function restAuthenticationGoogleOauthSecretPaginationToJSON(
  restAuthenticationGoogleOauthSecretPagination:
    RestAuthenticationGoogleOauthSecretPagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretPagination$outboundSchema.parse(
      restAuthenticationGoogleOauthSecretPagination,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretPagination$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRetryRules$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRetryRules,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthSecretRetryRules$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRetryRules$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRetryRules
  > = z.object({
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationGoogleOauthSecretRetryRulesToJSON(
  restAuthenticationGoogleOauthSecretRetryRules:
    RestAuthenticationGoogleOauthSecretRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRetryRules$outboundSchema.parse(
      restAuthenticationGoogleOauthSecretRetryRules,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretStateTracking$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretStateTracking,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enabled: z.boolean().optional(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthSecretStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthSecretStateTrackingToJSON(
  restAuthenticationGoogleOauthSecretStateTracking:
    RestAuthenticationGoogleOauthSecretStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretStateTracking$outboundSchema.parse(
      restAuthenticationGoogleOauthSecretStateTracking,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretScheduling$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretScheduling,
    z.ZodTypeDef,
    unknown
  > = z.object({
    stateTracking: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretStateTracking$inboundSchema
    ).optional(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretScheduling$Outbound = {
  stateTracking?:
    | RestAuthenticationGoogleOauthSecretStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthSecretScheduling$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretScheduling$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretScheduling
  > = z.object({
    stateTracking: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretStateTracking$outboundSchema
    ).optional(),
  });

export function restAuthenticationGoogleOauthSecretSchedulingToJSON(
  restAuthenticationGoogleOauthSecretScheduling:
    RestAuthenticationGoogleOauthSecretScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretScheduling$outboundSchema.parse(
      restAuthenticationGoogleOauthSecretScheduling,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecret$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("google_oauthSecret"),
  scopes: z.array(z.string()),
  textSecret: z.string(),
  subject: z.string(),
  discovery: z.lazy(() =>
    RestAuthenticationGoogleOauthSecretDiscovery$inboundSchema
  ).optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationGoogleOauthSecretCollectMethod$inboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() =>
    RestAuthenticationGoogleOauthSecretPagination$inboundSchema
  ).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    RestAuthenticationGoogleOauthSecretRetryRules$inboundSchema
  ).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationGoogleOauthSecretScheduling$inboundSchema
  ).optional(),
});
/** @internal */
export type RestAuthenticationGoogleOauthSecret$Outbound = {
  authentication: "google_oauthSecret";
  scopes: Array<string>;
  textSecret: string;
  subject: string;
  discovery?: RestAuthenticationGoogleOauthSecretDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationGoogleOauthSecretPagination$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationGoogleOauthSecretRetryRules$Outbound
    | undefined;
  __scheduling?:
    | RestAuthenticationGoogleOauthSecretScheduling$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthSecret$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthSecret$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauthSecret
> = z.object({
  authentication: z.literal("google_oauthSecret"),
  scopes: z.array(z.string()),
  textSecret: z.string(),
  subject: z.string(),
  discovery: z.lazy(() =>
    RestAuthenticationGoogleOauthSecretDiscovery$outboundSchema
  ).optional(),
  collectUrl: z.string(),
  collectMethod:
    RestAuthenticationGoogleOauthSecretCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() =>
    RestAuthenticationGoogleOauthSecretPagination$outboundSchema
  ).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    RestAuthenticationGoogleOauthSecretRetryRules$outboundSchema
  ).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationGoogleOauthSecretScheduling$outboundSchema
  ).optional(),
});

export function restAuthenticationGoogleOauthSecretToJSON(
  restAuthenticationGoogleOauthSecret: RestAuthenticationGoogleOauthSecret,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecret$outboundSchema.parse(
      restAuthenticationGoogleOauthSecret,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationGoogleOauthSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecret' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthDiscoverType$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationGoogleOauthDiscoverType);
/** @internal */
export const RestAuthenticationGoogleOauthDiscoverType$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationGoogleOauthDiscoverType> =
    openEnums.outboundSchema(RestAuthenticationGoogleOauthDiscoverType);

/** @internal */
export const RestAuthenticationGoogleOauthDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestAuthenticationGoogleOauthDiscoverType$inboundSchema,
});
/** @internal */
export type RestAuthenticationGoogleOauthDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestAuthenticationGoogleOauthDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauthDiscovery
> = z.object({
  discoverType: RestAuthenticationGoogleOauthDiscoverType$outboundSchema,
});

export function restAuthenticationGoogleOauthDiscoveryToJSON(
  restAuthenticationGoogleOauthDiscovery:
    RestAuthenticationGoogleOauthDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthDiscovery$outboundSchema.parse(
      restAuthenticationGoogleOauthDiscovery,
    ),
  );
}
export function restAuthenticationGoogleOauthDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationGoogleOauthDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthCollectMethod$inboundSchema:
  z.ZodType<RestAuthenticationGoogleOauthCollectMethod, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(RestAuthenticationGoogleOauthCollectMethod);
/** @internal */
export const RestAuthenticationGoogleOauthCollectMethod$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationGoogleOauthCollectMethod> =
    openEnums.outboundSchema(RestAuthenticationGoogleOauthCollectMethod);

/** @internal */
export const RestAuthenticationGoogleOauthPaginationEnum$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthPaginationEnum,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RestAuthenticationGoogleOauthPaginationEnum);
/** @internal */
export const RestAuthenticationGoogleOauthPaginationEnum$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationGoogleOauthPaginationEnum> =
    openEnums.outboundSchema(RestAuthenticationGoogleOauthPaginationEnum);

/** @internal */
export const RestAuthenticationGoogleOauthPagination$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestAuthenticationGoogleOauthPaginationEnum$inboundSchema,
});
/** @internal */
export type RestAuthenticationGoogleOauthPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestAuthenticationGoogleOauthPagination$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthPagination$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauthPagination
> = z.object({
  type: RestAuthenticationGoogleOauthPaginationEnum$outboundSchema,
});

export function restAuthenticationGoogleOauthPaginationToJSON(
  restAuthenticationGoogleOauthPagination:
    RestAuthenticationGoogleOauthPagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthPagination$outboundSchema.parse(
      restAuthenticationGoogleOauthPagination,
    ),
  );
}
export function restAuthenticationGoogleOauthPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthPagination$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestAuthenticationGoogleOauthRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauthRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restAuthenticationGoogleOauthRetryRulesToJSON(
  restAuthenticationGoogleOauthRetryRules:
    RestAuthenticationGoogleOauthRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRetryRules$outboundSchema.parse(
      restAuthenticationGoogleOauthRetryRules,
    ),
  );
}
export function restAuthenticationGoogleOauthRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthStateTracking$inboundSchema:
  z.ZodType<RestAuthenticationGoogleOauthStateTracking, z.ZodTypeDef, unknown> =
    z.object({
      enabled: z.boolean().optional(),
    });
/** @internal */
export type RestAuthenticationGoogleOauthStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthStateTrackingToJSON(
  restAuthenticationGoogleOauthStateTracking:
    RestAuthenticationGoogleOauthStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthStateTracking$outboundSchema.parse(
      restAuthenticationGoogleOauthStateTracking,
    ),
  );
}
export function restAuthenticationGoogleOauthStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthScheduling$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationGoogleOauthStateTracking$inboundSchema
  ).optional(),
});
/** @internal */
export type RestAuthenticationGoogleOauthScheduling$Outbound = {
  stateTracking?:
    | RestAuthenticationGoogleOauthStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthScheduling$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauthScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationGoogleOauthStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationGoogleOauthSchedulingToJSON(
  restAuthenticationGoogleOauthScheduling:
    RestAuthenticationGoogleOauthScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthScheduling$outboundSchema.parse(
      restAuthenticationGoogleOauthScheduling,
    ),
  );
}
export function restAuthenticationGoogleOauthSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauth$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauth,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("google_oauth"),
  scopes: z.array(z.string()),
  serviceAccountCredentials: z.string(),
  subject: z.string(),
  discovery: z.lazy(() => RestAuthenticationGoogleOauthDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationGoogleOauthCollectMethod$inboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() =>
    RestAuthenticationGoogleOauthPagination$inboundSchema
  ).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    RestAuthenticationGoogleOauthRetryRules$inboundSchema
  ).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationGoogleOauthScheduling$inboundSchema
  ).optional(),
});
/** @internal */
export type RestAuthenticationGoogleOauth$Outbound = {
  authentication: "google_oauth";
  scopes: Array<string>;
  serviceAccountCredentials: string;
  subject: string;
  discovery?: RestAuthenticationGoogleOauthDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestAuthenticationGoogleOauthPagination$Outbound | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationGoogleOauthRetryRules$Outbound | undefined;
  __scheduling?: RestAuthenticationGoogleOauthScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauth$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauth$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauth
> = z.object({
  authentication: z.literal("google_oauth"),
  scopes: z.array(z.string()),
  serviceAccountCredentials: z.string(),
  subject: z.string(),
  discovery: z.lazy(() => RestAuthenticationGoogleOauthDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationGoogleOauthCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() =>
    RestAuthenticationGoogleOauthPagination$outboundSchema
  ).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    RestAuthenticationGoogleOauthRetryRules$outboundSchema
  ).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationGoogleOauthScheduling$outboundSchema
  ).optional(),
});

export function restAuthenticationGoogleOauthToJSON(
  restAuthenticationGoogleOauth: RestAuthenticationGoogleOauth,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauth$outboundSchema.parse(
      restAuthenticationGoogleOauth,
    ),
  );
}
export function restAuthenticationGoogleOauthFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationGoogleOauth, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationGoogleOauth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauth' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretDiscoverType$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecretDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationOauthSecretDiscoverType);
/** @internal */
export const RestAuthenticationOauthSecretDiscoverType$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationOauthSecretDiscoverType> =
    openEnums.outboundSchema(RestAuthenticationOauthSecretDiscoverType);

/** @internal */
export const RestAuthenticationOauthSecretDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecretDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestAuthenticationOauthSecretDiscoverType$inboundSchema,
});
/** @internal */
export type RestAuthenticationOauthSecretDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestAuthenticationOauthSecretDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationOauthSecretDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthSecretDiscovery
> = z.object({
  discoverType: RestAuthenticationOauthSecretDiscoverType$outboundSchema,
});

export function restAuthenticationOauthSecretDiscoveryToJSON(
  restAuthenticationOauthSecretDiscovery:
    RestAuthenticationOauthSecretDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretDiscovery$outboundSchema.parse(
      restAuthenticationOauthSecretDiscovery,
    ),
  );
}
export function restAuthenticationOauthSecretDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthSecretDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretCollectMethod$inboundSchema:
  z.ZodType<RestAuthenticationOauthSecretCollectMethod, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(RestAuthenticationOauthSecretCollectMethod);
/** @internal */
export const RestAuthenticationOauthSecretCollectMethod$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationOauthSecretCollectMethod> =
    openEnums.outboundSchema(RestAuthenticationOauthSecretCollectMethod);

/** @internal */
export const RestAuthenticationOauthSecretPaginationEnum$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretPaginationEnum,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RestAuthenticationOauthSecretPaginationEnum);
/** @internal */
export const RestAuthenticationOauthSecretPaginationEnum$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationOauthSecretPaginationEnum> =
    openEnums.outboundSchema(RestAuthenticationOauthSecretPaginationEnum);

/** @internal */
export const RestAuthenticationOauthSecretPagination$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecretPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestAuthenticationOauthSecretPaginationEnum$inboundSchema,
});
/** @internal */
export type RestAuthenticationOauthSecretPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestAuthenticationOauthSecretPagination$outboundSchema: z.ZodType<
  RestAuthenticationOauthSecretPagination$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthSecretPagination
> = z.object({
  type: RestAuthenticationOauthSecretPaginationEnum$outboundSchema,
});

export function restAuthenticationOauthSecretPaginationToJSON(
  restAuthenticationOauthSecretPagination:
    RestAuthenticationOauthSecretPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretPagination$outboundSchema.parse(
      restAuthenticationOauthSecretPagination,
    ),
  );
}
export function restAuthenticationOauthSecretPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretPagination$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecretRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestAuthenticationOauthSecretRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationOauthSecretRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationOauthSecretRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthSecretRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restAuthenticationOauthSecretRetryRulesToJSON(
  restAuthenticationOauthSecretRetryRules:
    RestAuthenticationOauthSecretRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRetryRules$outboundSchema.parse(
      restAuthenticationOauthSecretRetryRules,
    ),
  );
}
export function restAuthenticationOauthSecretRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretStateTracking$inboundSchema:
  z.ZodType<RestAuthenticationOauthSecretStateTracking, z.ZodTypeDef, unknown> =
    z.object({
      enabled: z.boolean().optional(),
    });
/** @internal */
export type RestAuthenticationOauthSecretStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationOauthSecretStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretStateTrackingToJSON(
  restAuthenticationOauthSecretStateTracking:
    RestAuthenticationOauthSecretStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretStateTracking$outboundSchema.parse(
      restAuthenticationOauthSecretStateTracking,
    ),
  );
}
export function restAuthenticationOauthSecretStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretScheduling$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecretScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationOauthSecretStateTracking$inboundSchema
  ).optional(),
});
/** @internal */
export type RestAuthenticationOauthSecretScheduling$Outbound = {
  stateTracking?:
    | RestAuthenticationOauthSecretStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationOauthSecretScheduling$outboundSchema: z.ZodType<
  RestAuthenticationOauthSecretScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthSecretScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationOauthSecretStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationOauthSecretSchedulingToJSON(
  restAuthenticationOauthSecretScheduling:
    RestAuthenticationOauthSecretScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretScheduling$outboundSchema.parse(
      restAuthenticationOauthSecretScheduling,
    ),
  );
}
export function restAuthenticationOauthSecretSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecret$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("oauthSecret"),
  loginUrl: z.string(),
  tokenRespAttribute: z.string().optional(),
  authHeaderKey: z.string().optional(),
  authHeaderExpr: z.string(),
  clientSecretParamName: z.string(),
  textSecret: z.string(),
  authRequestParams: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  authRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  discovery: z.lazy(() => RestAuthenticationOauthSecretDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationOauthSecretCollectMethod$inboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() =>
    RestAuthenticationOauthSecretPagination$inboundSchema
  ).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    RestAuthenticationOauthSecretRetryRules$inboundSchema
  ).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationOauthSecretScheduling$inboundSchema
  ).optional(),
});
/** @internal */
export type RestAuthenticationOauthSecret$Outbound = {
  authentication: "oauthSecret";
  loginUrl: string;
  tokenRespAttribute?: string | undefined;
  authHeaderKey?: string | undefined;
  authHeaderExpr: string;
  clientSecretParamName: string;
  textSecret: string;
  authRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?: RestAuthenticationOauthSecretDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestAuthenticationOauthSecretPagination$Outbound | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationOauthSecretRetryRules$Outbound | undefined;
  __scheduling?: RestAuthenticationOauthSecretScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationOauthSecret$outboundSchema: z.ZodType<
  RestAuthenticationOauthSecret$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthSecret
> = z.object({
  authentication: z.literal("oauthSecret"),
  loginUrl: z.string(),
  tokenRespAttribute: z.string().optional(),
  authHeaderKey: z.string().optional(),
  authHeaderExpr: z.string(),
  clientSecretParamName: z.string(),
  textSecret: z.string(),
  authRequestParams: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  authRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  discovery: z.lazy(() => RestAuthenticationOauthSecretDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationOauthSecretCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() =>
    RestAuthenticationOauthSecretPagination$outboundSchema
  ).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    RestAuthenticationOauthSecretRetryRules$outboundSchema
  ).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationOauthSecretScheduling$outboundSchema
  ).optional(),
});

export function restAuthenticationOauthSecretToJSON(
  restAuthenticationOauthSecret: RestAuthenticationOauthSecret,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecret$outboundSchema.parse(
      restAuthenticationOauthSecret,
    ),
  );
}
export function restAuthenticationOauthSecretFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauthSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecret' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthDiscoverType$inboundSchema: z.ZodType<
  RestAuthenticationOauthDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationOauthDiscoverType);
/** @internal */
export const RestAuthenticationOauthDiscoverType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationOauthDiscoverType
> = openEnums.outboundSchema(RestAuthenticationOauthDiscoverType);

/** @internal */
export const RestAuthenticationOauthDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationOauthDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestAuthenticationOauthDiscoverType$inboundSchema,
});
/** @internal */
export type RestAuthenticationOauthDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestAuthenticationOauthDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationOauthDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthDiscovery
> = z.object({
  discoverType: RestAuthenticationOauthDiscoverType$outboundSchema,
});

export function restAuthenticationOauthDiscoveryToJSON(
  restAuthenticationOauthDiscovery: RestAuthenticationOauthDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationOauthDiscovery$outboundSchema.parse(
      restAuthenticationOauthDiscovery,
    ),
  );
}
export function restAuthenticationOauthDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauthDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthCollectMethod$inboundSchema: z.ZodType<
  RestAuthenticationOauthCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationOauthCollectMethod);
/** @internal */
export const RestAuthenticationOauthCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationOauthCollectMethod
> = openEnums.outboundSchema(RestAuthenticationOauthCollectMethod);

/** @internal */
export const RestAuthenticationOauthPaginationEnum$inboundSchema: z.ZodType<
  RestAuthenticationOauthPaginationEnum,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationOauthPaginationEnum);
/** @internal */
export const RestAuthenticationOauthPaginationEnum$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationOauthPaginationEnum
> = openEnums.outboundSchema(RestAuthenticationOauthPaginationEnum);

/** @internal */
export const RestAuthenticationOauthPagination$inboundSchema: z.ZodType<
  RestAuthenticationOauthPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestAuthenticationOauthPaginationEnum$inboundSchema,
});
/** @internal */
export type RestAuthenticationOauthPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestAuthenticationOauthPagination$outboundSchema: z.ZodType<
  RestAuthenticationOauthPagination$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthPagination
> = z.object({
  type: RestAuthenticationOauthPaginationEnum$outboundSchema,
});

export function restAuthenticationOauthPaginationToJSON(
  restAuthenticationOauthPagination: RestAuthenticationOauthPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthPagination$outboundSchema.parse(
      restAuthenticationOauthPagination,
    ),
  );
}
export function restAuthenticationOauthPaginationFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthPagination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauthPagination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationOauthRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestAuthenticationOauthRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationOauthRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationOauthRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restAuthenticationOauthRetryRulesToJSON(
  restAuthenticationOauthRetryRules: RestAuthenticationOauthRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRetryRules$outboundSchema.parse(
      restAuthenticationOauthRetryRules,
    ),
  );
}
export function restAuthenticationOauthRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauthRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthStateTracking$inboundSchema: z.ZodType<
  RestAuthenticationOauthStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type RestAuthenticationOauthStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationOauthStateTracking$outboundSchema: z.ZodType<
  RestAuthenticationOauthStateTracking$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restAuthenticationOauthStateTrackingToJSON(
  restAuthenticationOauthStateTracking: RestAuthenticationOauthStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationOauthStateTracking$outboundSchema.parse(
      restAuthenticationOauthStateTracking,
    ),
  );
}
export function restAuthenticationOauthStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthScheduling$inboundSchema: z.ZodType<
  RestAuthenticationOauthScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationOauthStateTracking$inboundSchema
  ).optional(),
});
/** @internal */
export type RestAuthenticationOauthScheduling$Outbound = {
  stateTracking?: RestAuthenticationOauthStateTracking$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationOauthScheduling$outboundSchema: z.ZodType<
  RestAuthenticationOauthScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationOauthStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationOauthSchedulingToJSON(
  restAuthenticationOauthScheduling: RestAuthenticationOauthScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationOauthScheduling$outboundSchema.parse(
      restAuthenticationOauthScheduling,
    ),
  );
}
export function restAuthenticationOauthSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauthScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauth$inboundSchema: z.ZodType<
  RestAuthenticationOauth,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("oauth"),
  loginUrl: z.string(),
  tokenRespAttribute: z.string().optional(),
  authHeaderKey: z.string().optional(),
  authHeaderExpr: z.string(),
  clientSecretParamName: z.string(),
  clientSecretParamValue: z.string(),
  authRequestParams: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  authRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  discovery: z.lazy(() => RestAuthenticationOauthDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationOauthCollectMethod$inboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestAuthenticationOauthPagination$inboundSchema)
    .optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestAuthenticationOauthRetryRules$inboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestAuthenticationOauthScheduling$inboundSchema)
    .optional(),
});
/** @internal */
export type RestAuthenticationOauth$Outbound = {
  authentication: "oauth";
  loginUrl: string;
  tokenRespAttribute?: string | undefined;
  authHeaderKey?: string | undefined;
  authHeaderExpr: string;
  clientSecretParamName: string;
  clientSecretParamValue: string;
  authRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?: RestAuthenticationOauthDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestAuthenticationOauthPagination$Outbound | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationOauthRetryRules$Outbound | undefined;
  __scheduling?: RestAuthenticationOauthScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationOauth$outboundSchema: z.ZodType<
  RestAuthenticationOauth$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauth
> = z.object({
  authentication: z.literal("oauth"),
  loginUrl: z.string(),
  tokenRespAttribute: z.string().optional(),
  authHeaderKey: z.string().optional(),
  authHeaderExpr: z.string(),
  clientSecretParamName: z.string(),
  clientSecretParamValue: z.string(),
  authRequestParams: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  authRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  discovery: z.lazy(() => RestAuthenticationOauthDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationOauthCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestAuthenticationOauthPagination$outboundSchema)
    .optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestAuthenticationOauthRetryRules$outboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestAuthenticationOauthScheduling$outboundSchema)
    .optional(),
});

export function restAuthenticationOauthToJSON(
  restAuthenticationOauth: RestAuthenticationOauth,
): string {
  return JSON.stringify(
    RestAuthenticationOauth$outboundSchema.parse(restAuthenticationOauth),
  );
}
export function restAuthenticationOauthFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauth, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauth' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretDiscoverType$inboundSchema: z.ZodType<
  RestAuthenticationLoginSecretDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationLoginSecretDiscoverType);
/** @internal */
export const RestAuthenticationLoginSecretDiscoverType$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationLoginSecretDiscoverType> =
    openEnums.outboundSchema(RestAuthenticationLoginSecretDiscoverType);

/** @internal */
export const RestAuthenticationLoginSecretDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationLoginSecretDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestAuthenticationLoginSecretDiscoverType$inboundSchema,
});
/** @internal */
export type RestAuthenticationLoginSecretDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestAuthenticationLoginSecretDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationLoginSecretDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLoginSecretDiscovery
> = z.object({
  discoverType: RestAuthenticationLoginSecretDiscoverType$outboundSchema,
});

export function restAuthenticationLoginSecretDiscoveryToJSON(
  restAuthenticationLoginSecretDiscovery:
    RestAuthenticationLoginSecretDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretDiscovery$outboundSchema.parse(
      restAuthenticationLoginSecretDiscovery,
    ),
  );
}
export function restAuthenticationLoginSecretDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationLoginSecretDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretCollectMethod$inboundSchema:
  z.ZodType<RestAuthenticationLoginSecretCollectMethod, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(RestAuthenticationLoginSecretCollectMethod);
/** @internal */
export const RestAuthenticationLoginSecretCollectMethod$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationLoginSecretCollectMethod> =
    openEnums.outboundSchema(RestAuthenticationLoginSecretCollectMethod);

/** @internal */
export const RestAuthenticationLoginSecretPaginationEnum$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretPaginationEnum,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RestAuthenticationLoginSecretPaginationEnum);
/** @internal */
export const RestAuthenticationLoginSecretPaginationEnum$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationLoginSecretPaginationEnum> =
    openEnums.outboundSchema(RestAuthenticationLoginSecretPaginationEnum);

/** @internal */
export const RestAuthenticationLoginSecretPagination$inboundSchema: z.ZodType<
  RestAuthenticationLoginSecretPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestAuthenticationLoginSecretPaginationEnum$inboundSchema,
});
/** @internal */
export type RestAuthenticationLoginSecretPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestAuthenticationLoginSecretPagination$outboundSchema: z.ZodType<
  RestAuthenticationLoginSecretPagination$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLoginSecretPagination
> = z.object({
  type: RestAuthenticationLoginSecretPaginationEnum$outboundSchema,
});

export function restAuthenticationLoginSecretPaginationToJSON(
  restAuthenticationLoginSecretPagination:
    RestAuthenticationLoginSecretPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretPagination$outboundSchema.parse(
      restAuthenticationLoginSecretPagination,
    ),
  );
}
export function restAuthenticationLoginSecretPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretPagination$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginSecretPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationLoginSecretRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestAuthenticationLoginSecretRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationLoginSecretRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationLoginSecretRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLoginSecretRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restAuthenticationLoginSecretRetryRulesToJSON(
  restAuthenticationLoginSecretRetryRules:
    RestAuthenticationLoginSecretRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretRetryRules$outboundSchema.parse(
      restAuthenticationLoginSecretRetryRules,
    ),
  );
}
export function restAuthenticationLoginSecretRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginSecretRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretStateTracking$inboundSchema:
  z.ZodType<RestAuthenticationLoginSecretStateTracking, z.ZodTypeDef, unknown> =
    z.object({
      enabled: z.boolean().optional(),
    });
/** @internal */
export type RestAuthenticationLoginSecretStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationLoginSecretStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretStateTrackingToJSON(
  restAuthenticationLoginSecretStateTracking:
    RestAuthenticationLoginSecretStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretStateTracking$outboundSchema.parse(
      restAuthenticationLoginSecretStateTracking,
    ),
  );
}
export function restAuthenticationLoginSecretStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginSecretStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretScheduling$inboundSchema: z.ZodType<
  RestAuthenticationLoginSecretScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationLoginSecretStateTracking$inboundSchema
  ).optional(),
});
/** @internal */
export type RestAuthenticationLoginSecretScheduling$Outbound = {
  stateTracking?:
    | RestAuthenticationLoginSecretStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationLoginSecretScheduling$outboundSchema: z.ZodType<
  RestAuthenticationLoginSecretScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLoginSecretScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationLoginSecretStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationLoginSecretSchedulingToJSON(
  restAuthenticationLoginSecretScheduling:
    RestAuthenticationLoginSecretScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretScheduling$outboundSchema.parse(
      restAuthenticationLoginSecretScheduling,
    ),
  );
}
export function restAuthenticationLoginSecretSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginSecretScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecret$inboundSchema: z.ZodType<
  RestAuthenticationLoginSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("loginSecret"),
  loginUrl: z.string(),
  credentialsSecret: z.string(),
  loginBody: z.string(),
  getAuthTokenFromHeader: z.boolean().optional(),
  authHeaderKey: z.string().optional(),
  authHeaderExpr: z.string(),
  authRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  discovery: z.lazy(() => RestAuthenticationLoginSecretDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationLoginSecretCollectMethod$inboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() =>
    RestAuthenticationLoginSecretPagination$inboundSchema
  ).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    RestAuthenticationLoginSecretRetryRules$inboundSchema
  ).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationLoginSecretScheduling$inboundSchema
  ).optional(),
});
/** @internal */
export type RestAuthenticationLoginSecret$Outbound = {
  authentication: "loginSecret";
  loginUrl: string;
  credentialsSecret: string;
  loginBody: string;
  getAuthTokenFromHeader?: boolean | undefined;
  authHeaderKey?: string | undefined;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?: RestAuthenticationLoginSecretDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestAuthenticationLoginSecretPagination$Outbound | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationLoginSecretRetryRules$Outbound | undefined;
  __scheduling?: RestAuthenticationLoginSecretScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationLoginSecret$outboundSchema: z.ZodType<
  RestAuthenticationLoginSecret$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLoginSecret
> = z.object({
  authentication: z.literal("loginSecret"),
  loginUrl: z.string(),
  credentialsSecret: z.string(),
  loginBody: z.string(),
  getAuthTokenFromHeader: z.boolean().optional(),
  authHeaderKey: z.string().optional(),
  authHeaderExpr: z.string(),
  authRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  discovery: z.lazy(() => RestAuthenticationLoginSecretDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationLoginSecretCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() =>
    RestAuthenticationLoginSecretPagination$outboundSchema
  ).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    RestAuthenticationLoginSecretRetryRules$outboundSchema
  ).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationLoginSecretScheduling$outboundSchema
  ).optional(),
});

export function restAuthenticationLoginSecretToJSON(
  restAuthenticationLoginSecret: RestAuthenticationLoginSecret,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecret$outboundSchema.parse(
      restAuthenticationLoginSecret,
    ),
  );
}
export function restAuthenticationLoginSecretFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationLoginSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationLoginSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecret' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginDiscoverType$inboundSchema: z.ZodType<
  RestAuthenticationLoginDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationLoginDiscoverType);
/** @internal */
export const RestAuthenticationLoginDiscoverType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationLoginDiscoverType
> = openEnums.outboundSchema(RestAuthenticationLoginDiscoverType);

/** @internal */
export const RestAuthenticationLoginDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationLoginDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestAuthenticationLoginDiscoverType$inboundSchema,
});
/** @internal */
export type RestAuthenticationLoginDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestAuthenticationLoginDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationLoginDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLoginDiscovery
> = z.object({
  discoverType: RestAuthenticationLoginDiscoverType$outboundSchema,
});

export function restAuthenticationLoginDiscoveryToJSON(
  restAuthenticationLoginDiscovery: RestAuthenticationLoginDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationLoginDiscovery$outboundSchema.parse(
      restAuthenticationLoginDiscovery,
    ),
  );
}
export function restAuthenticationLoginDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationLoginDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationLoginDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginCollectMethod$inboundSchema: z.ZodType<
  RestAuthenticationLoginCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationLoginCollectMethod);
/** @internal */
export const RestAuthenticationLoginCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationLoginCollectMethod
> = openEnums.outboundSchema(RestAuthenticationLoginCollectMethod);

/** @internal */
export const RestAuthenticationLoginPaginationEnum$inboundSchema: z.ZodType<
  RestAuthenticationLoginPaginationEnum,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationLoginPaginationEnum);
/** @internal */
export const RestAuthenticationLoginPaginationEnum$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationLoginPaginationEnum
> = openEnums.outboundSchema(RestAuthenticationLoginPaginationEnum);

/** @internal */
export const RestAuthenticationLoginPagination$inboundSchema: z.ZodType<
  RestAuthenticationLoginPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestAuthenticationLoginPaginationEnum$inboundSchema,
});
/** @internal */
export type RestAuthenticationLoginPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestAuthenticationLoginPagination$outboundSchema: z.ZodType<
  RestAuthenticationLoginPagination$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLoginPagination
> = z.object({
  type: RestAuthenticationLoginPaginationEnum$outboundSchema,
});

export function restAuthenticationLoginPaginationToJSON(
  restAuthenticationLoginPagination: RestAuthenticationLoginPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginPagination$outboundSchema.parse(
      restAuthenticationLoginPagination,
    ),
  );
}
export function restAuthenticationLoginPaginationFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationLoginPagination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationLoginPagination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationLoginRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestAuthenticationLoginRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationLoginRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationLoginRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLoginRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restAuthenticationLoginRetryRulesToJSON(
  restAuthenticationLoginRetryRules: RestAuthenticationLoginRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationLoginRetryRules$outboundSchema.parse(
      restAuthenticationLoginRetryRules,
    ),
  );
}
export function restAuthenticationLoginRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationLoginRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationLoginRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginStateTracking$inboundSchema: z.ZodType<
  RestAuthenticationLoginStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type RestAuthenticationLoginStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationLoginStateTracking$outboundSchema: z.ZodType<
  RestAuthenticationLoginStateTracking$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLoginStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restAuthenticationLoginStateTrackingToJSON(
  restAuthenticationLoginStateTracking: RestAuthenticationLoginStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationLoginStateTracking$outboundSchema.parse(
      restAuthenticationLoginStateTracking,
    ),
  );
}
export function restAuthenticationLoginStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationLoginStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginScheduling$inboundSchema: z.ZodType<
  RestAuthenticationLoginScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationLoginStateTracking$inboundSchema
  ).optional(),
});
/** @internal */
export type RestAuthenticationLoginScheduling$Outbound = {
  stateTracking?: RestAuthenticationLoginStateTracking$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationLoginScheduling$outboundSchema: z.ZodType<
  RestAuthenticationLoginScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLoginScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationLoginStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationLoginSchedulingToJSON(
  restAuthenticationLoginScheduling: RestAuthenticationLoginScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationLoginScheduling$outboundSchema.parse(
      restAuthenticationLoginScheduling,
    ),
  );
}
export function restAuthenticationLoginSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationLoginScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationLoginScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLogin$inboundSchema: z.ZodType<
  RestAuthenticationLogin,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("login"),
  loginUrl: z.string(),
  username: z.string(),
  password: z.string(),
  loginBody: z.string(),
  getAuthTokenFromHeader: z.boolean().optional(),
  authHeaderKey: z.string().optional(),
  authHeaderExpr: z.string(),
  authRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  discovery: z.lazy(() => RestAuthenticationLoginDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationLoginCollectMethod$inboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestAuthenticationLoginPagination$inboundSchema)
    .optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestAuthenticationLoginRetryRules$inboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestAuthenticationLoginScheduling$inboundSchema)
    .optional(),
});
/** @internal */
export type RestAuthenticationLogin$Outbound = {
  authentication: "login";
  loginUrl: string;
  username: string;
  password: string;
  loginBody: string;
  getAuthTokenFromHeader?: boolean | undefined;
  authHeaderKey?: string | undefined;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?: RestAuthenticationLoginDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestAuthenticationLoginPagination$Outbound | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationLoginRetryRules$Outbound | undefined;
  __scheduling?: RestAuthenticationLoginScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationLogin$outboundSchema: z.ZodType<
  RestAuthenticationLogin$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLogin
> = z.object({
  authentication: z.literal("login"),
  loginUrl: z.string(),
  username: z.string(),
  password: z.string(),
  loginBody: z.string(),
  getAuthTokenFromHeader: z.boolean().optional(),
  authHeaderKey: z.string().optional(),
  authHeaderExpr: z.string(),
  authRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  discovery: z.lazy(() => RestAuthenticationLoginDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationLoginCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestAuthenticationLoginPagination$outboundSchema)
    .optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestAuthenticationLoginRetryRules$outboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestAuthenticationLoginScheduling$outboundSchema)
    .optional(),
});

export function restAuthenticationLoginToJSON(
  restAuthenticationLogin: RestAuthenticationLogin,
): string {
  return JSON.stringify(
    RestAuthenticationLogin$outboundSchema.parse(restAuthenticationLogin),
  );
}
export function restAuthenticationLoginFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationLogin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationLogin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLogin' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretDiscoverType$inboundSchema: z.ZodType<
  RestAuthenticationBasicSecretDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationBasicSecretDiscoverType);
/** @internal */
export const RestAuthenticationBasicSecretDiscoverType$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationBasicSecretDiscoverType> =
    openEnums.outboundSchema(RestAuthenticationBasicSecretDiscoverType);

/** @internal */
export const RestAuthenticationBasicSecretDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationBasicSecretDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestAuthenticationBasicSecretDiscoverType$inboundSchema,
});
/** @internal */
export type RestAuthenticationBasicSecretDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestAuthenticationBasicSecretDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationBasicSecretDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicSecretDiscovery
> = z.object({
  discoverType: RestAuthenticationBasicSecretDiscoverType$outboundSchema,
});

export function restAuthenticationBasicSecretDiscoveryToJSON(
  restAuthenticationBasicSecretDiscovery:
    RestAuthenticationBasicSecretDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretDiscovery$outboundSchema.parse(
      restAuthenticationBasicSecretDiscovery,
    ),
  );
}
export function restAuthenticationBasicSecretDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicSecretDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretCollectMethod$inboundSchema:
  z.ZodType<RestAuthenticationBasicSecretCollectMethod, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(RestAuthenticationBasicSecretCollectMethod);
/** @internal */
export const RestAuthenticationBasicSecretCollectMethod$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationBasicSecretCollectMethod> =
    openEnums.outboundSchema(RestAuthenticationBasicSecretCollectMethod);

/** @internal */
export const RestAuthenticationBasicSecretPaginationEnum$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretPaginationEnum,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RestAuthenticationBasicSecretPaginationEnum);
/** @internal */
export const RestAuthenticationBasicSecretPaginationEnum$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationBasicSecretPaginationEnum> =
    openEnums.outboundSchema(RestAuthenticationBasicSecretPaginationEnum);

/** @internal */
export const RestAuthenticationBasicSecretPagination$inboundSchema: z.ZodType<
  RestAuthenticationBasicSecretPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestAuthenticationBasicSecretPaginationEnum$inboundSchema,
});
/** @internal */
export type RestAuthenticationBasicSecretPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestAuthenticationBasicSecretPagination$outboundSchema: z.ZodType<
  RestAuthenticationBasicSecretPagination$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicSecretPagination
> = z.object({
  type: RestAuthenticationBasicSecretPaginationEnum$outboundSchema,
});

export function restAuthenticationBasicSecretPaginationToJSON(
  restAuthenticationBasicSecretPagination:
    RestAuthenticationBasicSecretPagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretPagination$outboundSchema.parse(
      restAuthenticationBasicSecretPagination,
    ),
  );
}
export function restAuthenticationBasicSecretPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretPagination$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicSecretPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationBasicSecretRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestAuthenticationBasicSecretRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationBasicSecretRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationBasicSecretRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicSecretRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restAuthenticationBasicSecretRetryRulesToJSON(
  restAuthenticationBasicSecretRetryRules:
    RestAuthenticationBasicSecretRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRetryRules$outboundSchema.parse(
      restAuthenticationBasicSecretRetryRules,
    ),
  );
}
export function restAuthenticationBasicSecretRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicSecretRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretStateTracking$inboundSchema:
  z.ZodType<RestAuthenticationBasicSecretStateTracking, z.ZodTypeDef, unknown> =
    z.object({
      enabled: z.boolean().optional(),
    });
/** @internal */
export type RestAuthenticationBasicSecretStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationBasicSecretStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationBasicSecretStateTrackingToJSON(
  restAuthenticationBasicSecretStateTracking:
    RestAuthenticationBasicSecretStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretStateTracking$outboundSchema.parse(
      restAuthenticationBasicSecretStateTracking,
    ),
  );
}
export function restAuthenticationBasicSecretStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicSecretStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretScheduling$inboundSchema: z.ZodType<
  RestAuthenticationBasicSecretScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationBasicSecretStateTracking$inboundSchema
  ).optional(),
});
/** @internal */
export type RestAuthenticationBasicSecretScheduling$Outbound = {
  stateTracking?:
    | RestAuthenticationBasicSecretStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationBasicSecretScheduling$outboundSchema: z.ZodType<
  RestAuthenticationBasicSecretScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicSecretScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationBasicSecretStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationBasicSecretSchedulingToJSON(
  restAuthenticationBasicSecretScheduling:
    RestAuthenticationBasicSecretScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretScheduling$outboundSchema.parse(
      restAuthenticationBasicSecretScheduling,
    ),
  );
}
export function restAuthenticationBasicSecretSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicSecretScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecret$inboundSchema: z.ZodType<
  RestAuthenticationBasicSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("basicSecret"),
  credentialsSecret: z.string(),
  discovery: z.lazy(() => RestAuthenticationBasicSecretDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationBasicSecretCollectMethod$inboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() =>
    RestAuthenticationBasicSecretPagination$inboundSchema
  ).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    RestAuthenticationBasicSecretRetryRules$inboundSchema
  ).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationBasicSecretScheduling$inboundSchema
  ).optional(),
});
/** @internal */
export type RestAuthenticationBasicSecret$Outbound = {
  authentication: "basicSecret";
  credentialsSecret: string;
  discovery?: RestAuthenticationBasicSecretDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestAuthenticationBasicSecretPagination$Outbound | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationBasicSecretRetryRules$Outbound | undefined;
  __scheduling?: RestAuthenticationBasicSecretScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationBasicSecret$outboundSchema: z.ZodType<
  RestAuthenticationBasicSecret$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicSecret
> = z.object({
  authentication: z.literal("basicSecret"),
  credentialsSecret: z.string(),
  discovery: z.lazy(() => RestAuthenticationBasicSecretDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationBasicSecretCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() =>
    RestAuthenticationBasicSecretPagination$outboundSchema
  ).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    RestAuthenticationBasicSecretRetryRules$outboundSchema
  ).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationBasicSecretScheduling$outboundSchema
  ).optional(),
});

export function restAuthenticationBasicSecretToJSON(
  restAuthenticationBasicSecret: RestAuthenticationBasicSecret,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecret$outboundSchema.parse(
      restAuthenticationBasicSecret,
    ),
  );
}
export function restAuthenticationBasicSecretFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationBasicSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecret' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicDiscoverType$inboundSchema: z.ZodType<
  RestAuthenticationBasicDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationBasicDiscoverType);
/** @internal */
export const RestAuthenticationBasicDiscoverType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationBasicDiscoverType
> = openEnums.outboundSchema(RestAuthenticationBasicDiscoverType);

/** @internal */
export const RestAuthenticationBasicDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationBasicDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestAuthenticationBasicDiscoverType$inboundSchema,
});
/** @internal */
export type RestAuthenticationBasicDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestAuthenticationBasicDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationBasicDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicDiscovery
> = z.object({
  discoverType: RestAuthenticationBasicDiscoverType$outboundSchema,
});

export function restAuthenticationBasicDiscoveryToJSON(
  restAuthenticationBasicDiscovery: RestAuthenticationBasicDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationBasicDiscovery$outboundSchema.parse(
      restAuthenticationBasicDiscovery,
    ),
  );
}
export function restAuthenticationBasicDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationBasicDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicCollectMethod$inboundSchema: z.ZodType<
  RestAuthenticationBasicCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationBasicCollectMethod);
/** @internal */
export const RestAuthenticationBasicCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationBasicCollectMethod
> = openEnums.outboundSchema(RestAuthenticationBasicCollectMethod);

/** @internal */
export const RestAuthenticationBasicPaginationEnum$inboundSchema: z.ZodType<
  RestAuthenticationBasicPaginationEnum,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationBasicPaginationEnum);
/** @internal */
export const RestAuthenticationBasicPaginationEnum$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationBasicPaginationEnum
> = openEnums.outboundSchema(RestAuthenticationBasicPaginationEnum);

/** @internal */
export const RestAuthenticationBasicPagination$inboundSchema: z.ZodType<
  RestAuthenticationBasicPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestAuthenticationBasicPaginationEnum$inboundSchema,
});
/** @internal */
export type RestAuthenticationBasicPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestAuthenticationBasicPagination$outboundSchema: z.ZodType<
  RestAuthenticationBasicPagination$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicPagination
> = z.object({
  type: RestAuthenticationBasicPaginationEnum$outboundSchema,
});

export function restAuthenticationBasicPaginationToJSON(
  restAuthenticationBasicPagination: RestAuthenticationBasicPagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicPagination$outboundSchema.parse(
      restAuthenticationBasicPagination,
    ),
  );
}
export function restAuthenticationBasicPaginationFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicPagination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationBasicPagination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationBasicRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestAuthenticationBasicRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationBasicRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationBasicRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restAuthenticationBasicRetryRulesToJSON(
  restAuthenticationBasicRetryRules: RestAuthenticationBasicRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRetryRules$outboundSchema.parse(
      restAuthenticationBasicRetryRules,
    ),
  );
}
export function restAuthenticationBasicRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationBasicRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicStateTracking$inboundSchema: z.ZodType<
  RestAuthenticationBasicStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type RestAuthenticationBasicStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationBasicStateTracking$outboundSchema: z.ZodType<
  RestAuthenticationBasicStateTracking$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restAuthenticationBasicStateTrackingToJSON(
  restAuthenticationBasicStateTracking: RestAuthenticationBasicStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationBasicStateTracking$outboundSchema.parse(
      restAuthenticationBasicStateTracking,
    ),
  );
}
export function restAuthenticationBasicStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicScheduling$inboundSchema: z.ZodType<
  RestAuthenticationBasicScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationBasicStateTracking$inboundSchema
  ).optional(),
});
/** @internal */
export type RestAuthenticationBasicScheduling$Outbound = {
  stateTracking?: RestAuthenticationBasicStateTracking$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationBasicScheduling$outboundSchema: z.ZodType<
  RestAuthenticationBasicScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationBasicStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationBasicSchedulingToJSON(
  restAuthenticationBasicScheduling: RestAuthenticationBasicScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationBasicScheduling$outboundSchema.parse(
      restAuthenticationBasicScheduling,
    ),
  );
}
export function restAuthenticationBasicSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationBasicScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasic$inboundSchema: z.ZodType<
  RestAuthenticationBasic,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("basic"),
  username: z.string(),
  password: z.string(),
  discovery: z.lazy(() => RestAuthenticationBasicDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationBasicCollectMethod$inboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestAuthenticationBasicPagination$inboundSchema)
    .optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestAuthenticationBasicRetryRules$inboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestAuthenticationBasicScheduling$inboundSchema)
    .optional(),
});
/** @internal */
export type RestAuthenticationBasic$Outbound = {
  authentication: "basic";
  username: string;
  password: string;
  discovery?: RestAuthenticationBasicDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestAuthenticationBasicPagination$Outbound | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationBasicRetryRules$Outbound | undefined;
  __scheduling?: RestAuthenticationBasicScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationBasic$outboundSchema: z.ZodType<
  RestAuthenticationBasic$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasic
> = z.object({
  authentication: z.literal("basic"),
  username: z.string(),
  password: z.string(),
  discovery: z.lazy(() => RestAuthenticationBasicDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationBasicCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestAuthenticationBasicPagination$outboundSchema)
    .optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestAuthenticationBasicRetryRules$outboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestAuthenticationBasicScheduling$outboundSchema)
    .optional(),
});

export function restAuthenticationBasicToJSON(
  restAuthenticationBasic: RestAuthenticationBasic,
): string {
  return JSON.stringify(
    RestAuthenticationBasic$outboundSchema.parse(restAuthenticationBasic),
  );
}
export function restAuthenticationBasicFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationBasic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneDiscoverType$inboundSchema: z.ZodType<
  RestAuthenticationNoneDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationNoneDiscoverType);
/** @internal */
export const RestAuthenticationNoneDiscoverType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationNoneDiscoverType
> = openEnums.outboundSchema(RestAuthenticationNoneDiscoverType);

/** @internal */
export const RestAuthenticationNoneDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationNoneDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestAuthenticationNoneDiscoverType$inboundSchema,
});
/** @internal */
export type RestAuthenticationNoneDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestAuthenticationNoneDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationNoneDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNoneDiscovery
> = z.object({
  discoverType: RestAuthenticationNoneDiscoverType$outboundSchema,
});

export function restAuthenticationNoneDiscoveryToJSON(
  restAuthenticationNoneDiscovery: RestAuthenticationNoneDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationNoneDiscovery$outboundSchema.parse(
      restAuthenticationNoneDiscovery,
    ),
  );
}
export function restAuthenticationNoneDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNoneDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationNoneDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneCollectMethod$inboundSchema: z.ZodType<
  RestAuthenticationNoneCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationNoneCollectMethod);
/** @internal */
export const RestAuthenticationNoneCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationNoneCollectMethod
> = openEnums.outboundSchema(RestAuthenticationNoneCollectMethod);

/** @internal */
export const RestAuthenticationNonePaginationEnum$inboundSchema: z.ZodType<
  RestAuthenticationNonePaginationEnum,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationNonePaginationEnum);
/** @internal */
export const RestAuthenticationNonePaginationEnum$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationNonePaginationEnum
> = openEnums.outboundSchema(RestAuthenticationNonePaginationEnum);

/** @internal */
export const RestAuthenticationNonePagination$inboundSchema: z.ZodType<
  RestAuthenticationNonePagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestAuthenticationNonePaginationEnum$inboundSchema,
});
/** @internal */
export type RestAuthenticationNonePagination$Outbound = {
  type: string;
};

/** @internal */
export const RestAuthenticationNonePagination$outboundSchema: z.ZodType<
  RestAuthenticationNonePagination$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNonePagination
> = z.object({
  type: RestAuthenticationNonePaginationEnum$outboundSchema,
});

export function restAuthenticationNonePaginationToJSON(
  restAuthenticationNonePagination: RestAuthenticationNonePagination,
): string {
  return JSON.stringify(
    RestAuthenticationNonePagination$outboundSchema.parse(
      restAuthenticationNonePagination,
    ),
  );
}
export function restAuthenticationNonePaginationFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNonePagination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationNonePagination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNonePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationNoneRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestAuthenticationNoneRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationNoneRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationNoneRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNoneRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restAuthenticationNoneRetryRulesToJSON(
  restAuthenticationNoneRetryRules: RestAuthenticationNoneRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRetryRules$outboundSchema.parse(
      restAuthenticationNoneRetryRules,
    ),
  );
}
export function restAuthenticationNoneRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNoneRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationNoneRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneStateTracking$inboundSchema: z.ZodType<
  RestAuthenticationNoneStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type RestAuthenticationNoneStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationNoneStateTracking$outboundSchema: z.ZodType<
  RestAuthenticationNoneStateTracking$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNoneStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restAuthenticationNoneStateTrackingToJSON(
  restAuthenticationNoneStateTracking: RestAuthenticationNoneStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationNoneStateTracking$outboundSchema.parse(
      restAuthenticationNoneStateTracking,
    ),
  );
}
export function restAuthenticationNoneStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNoneStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneScheduling$inboundSchema: z.ZodType<
  RestAuthenticationNoneScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => RestAuthenticationNoneStateTracking$inboundSchema)
    .optional(),
});
/** @internal */
export type RestAuthenticationNoneScheduling$Outbound = {
  stateTracking?: RestAuthenticationNoneStateTracking$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationNoneScheduling$outboundSchema: z.ZodType<
  RestAuthenticationNoneScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNoneScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationNoneStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationNoneSchedulingToJSON(
  restAuthenticationNoneScheduling: RestAuthenticationNoneScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationNoneScheduling$outboundSchema.parse(
      restAuthenticationNoneScheduling,
    ),
  );
}
export function restAuthenticationNoneSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNoneScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationNoneScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNone$inboundSchema: z.ZodType<
  RestAuthenticationNone,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("none"),
  discovery: z.lazy(() => RestAuthenticationNoneDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationNoneCollectMethod$inboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestAuthenticationNonePagination$inboundSchema)
    .optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestAuthenticationNoneRetryRules$inboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestAuthenticationNoneScheduling$inboundSchema)
    .optional(),
});
/** @internal */
export type RestAuthenticationNone$Outbound = {
  authentication: "none";
  discovery?: RestAuthenticationNoneDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestAuthenticationNonePagination$Outbound | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationNoneRetryRules$Outbound | undefined;
  __scheduling?: RestAuthenticationNoneScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationNone$outboundSchema: z.ZodType<
  RestAuthenticationNone$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNone
> = z.object({
  authentication: z.literal("none"),
  discovery: z.lazy(() => RestAuthenticationNoneDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationNoneCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestAuthenticationNonePagination$outboundSchema)
    .optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestAuthenticationNoneRetryRules$outboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestAuthenticationNoneScheduling$outboundSchema)
    .optional(),
});

export function restAuthenticationNoneToJSON(
  restAuthenticationNone: RestAuthenticationNone,
): string {
  return JSON.stringify(
    RestAuthenticationNone$outboundSchema.parse(restAuthenticationNone),
  );
}
export function restAuthenticationNoneFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNone, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationNone$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherCollectMethod$inboundSchema: z.ZodType<
  RestCollectMethodOtherCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodOtherCollectMethod);
/** @internal */
export const RestCollectMethodOtherCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodOtherCollectMethod
> = openEnums.outboundSchema(RestCollectMethodOtherCollectMethod);

/** @internal */
export const RestCollectMethodOtherDiscoverType$inboundSchema: z.ZodType<
  RestCollectMethodOtherDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodOtherDiscoverType);
/** @internal */
export const RestCollectMethodOtherDiscoverType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodOtherDiscoverType
> = openEnums.outboundSchema(RestCollectMethodOtherDiscoverType);

/** @internal */
export const RestCollectMethodOtherDiscovery$inboundSchema: z.ZodType<
  RestCollectMethodOtherDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestCollectMethodOtherDiscoverType$inboundSchema,
});
/** @internal */
export type RestCollectMethodOtherDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestCollectMethodOtherDiscovery$outboundSchema: z.ZodType<
  RestCollectMethodOtherDiscovery$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherDiscovery
> = z.object({
  discoverType: RestCollectMethodOtherDiscoverType$outboundSchema,
});

export function restCollectMethodOtherDiscoveryToJSON(
  restCollectMethodOtherDiscovery: RestCollectMethodOtherDiscovery,
): string {
  return JSON.stringify(
    RestCollectMethodOtherDiscovery$outboundSchema.parse(
      restCollectMethodOtherDiscovery,
    ),
  );
}
export function restCollectMethodOtherDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodOtherDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherDiscovery' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherPaginationEnum$inboundSchema: z.ZodType<
  RestCollectMethodOtherPaginationEnum,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodOtherPaginationEnum);
/** @internal */
export const RestCollectMethodOtherPaginationEnum$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodOtherPaginationEnum
> = openEnums.outboundSchema(RestCollectMethodOtherPaginationEnum);

/** @internal */
export const RestCollectMethodOtherPagination$inboundSchema: z.ZodType<
  RestCollectMethodOtherPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestCollectMethodOtherPaginationEnum$inboundSchema,
});
/** @internal */
export type RestCollectMethodOtherPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestCollectMethodOtherPagination$outboundSchema: z.ZodType<
  RestCollectMethodOtherPagination$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherPagination
> = z.object({
  type: RestCollectMethodOtherPaginationEnum$outboundSchema,
});

export function restCollectMethodOtherPaginationToJSON(
  restCollectMethodOtherPagination: RestCollectMethodOtherPagination,
): string {
  return JSON.stringify(
    RestCollectMethodOtherPagination$outboundSchema.parse(
      restCollectMethodOtherPagination,
    ),
  );
}
export function restCollectMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherPagination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodOtherPagination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherAuthentication$inboundSchema: z.ZodType<
  RestCollectMethodOtherAuthentication,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodOtherAuthentication);
/** @internal */
export const RestCollectMethodOtherAuthentication$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodOtherAuthentication
> = openEnums.outboundSchema(RestCollectMethodOtherAuthentication);

/** @internal */
export const RestCollectMethodOtherRetryRules$inboundSchema: z.ZodType<
  RestCollectMethodOtherRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestCollectMethodOtherRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestCollectMethodOtherRetryRules$outboundSchema: z.ZodType<
  RestCollectMethodOtherRetryRules$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restCollectMethodOtherRetryRulesToJSON(
  restCollectMethodOtherRetryRules: RestCollectMethodOtherRetryRules,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRetryRules$outboundSchema.parse(
      restCollectMethodOtherRetryRules,
    ),
  );
}
export function restCollectMethodOtherRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodOtherRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRetryRules' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherStateTracking$inboundSchema: z.ZodType<
  RestCollectMethodOtherStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type RestCollectMethodOtherStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestCollectMethodOtherStateTracking$outboundSchema: z.ZodType<
  RestCollectMethodOtherStateTracking$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restCollectMethodOtherStateTrackingToJSON(
  restCollectMethodOtherStateTracking: RestCollectMethodOtherStateTracking,
): string {
  return JSON.stringify(
    RestCollectMethodOtherStateTracking$outboundSchema.parse(
      restCollectMethodOtherStateTracking,
    ),
  );
}
export function restCollectMethodOtherStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherStateTracking' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherScheduling$inboundSchema: z.ZodType<
  RestCollectMethodOtherScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => RestCollectMethodOtherStateTracking$inboundSchema)
    .optional(),
});
/** @internal */
export type RestCollectMethodOtherScheduling$Outbound = {
  stateTracking?: RestCollectMethodOtherStateTracking$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodOtherScheduling$outboundSchema: z.ZodType<
  RestCollectMethodOtherScheduling$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestCollectMethodOtherStateTracking$outboundSchema
  ).optional(),
});

export function restCollectMethodOtherSchedulingToJSON(
  restCollectMethodOtherScheduling: RestCollectMethodOtherScheduling,
): string {
  return JSON.stringify(
    RestCollectMethodOtherScheduling$outboundSchema.parse(
      restCollectMethodOtherScheduling,
    ),
  );
}
export function restCollectMethodOtherSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodOtherScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherScheduling' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOther$inboundSchema: z.ZodType<
  RestCollectMethodOther,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: RestCollectMethodOtherCollectMethod$inboundSchema,
  collectVerb: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestParams: z.any().optional(),
  discovery: z.lazy(() => RestCollectMethodOtherDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestCollectMethodOtherPagination$inboundSchema)
    .optional(),
  authentication: RestCollectMethodOtherAuthentication$inboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestCollectMethodOtherRetryRules$inboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestCollectMethodOtherScheduling$inboundSchema)
    .optional(),
});
/** @internal */
export type RestCollectMethodOther$Outbound = {
  collectMethod: string;
  collectVerb?: any | undefined;
  collectBody?: any | undefined;
  collectRequestParams?: any | undefined;
  discovery?: RestCollectMethodOtherDiscovery$Outbound | undefined;
  collectUrl: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestCollectMethodOtherPagination$Outbound | undefined;
  authentication: string;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestCollectMethodOtherRetryRules$Outbound | undefined;
  __scheduling?: RestCollectMethodOtherScheduling$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodOther$outboundSchema: z.ZodType<
  RestCollectMethodOther$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOther
> = z.object({
  collectMethod: RestCollectMethodOtherCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestParams: z.any().optional(),
  discovery: z.lazy(() => RestCollectMethodOtherDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestCollectMethodOtherPagination$outboundSchema)
    .optional(),
  authentication: RestCollectMethodOtherAuthentication$outboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestCollectMethodOtherRetryRules$outboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestCollectMethodOtherScheduling$outboundSchema)
    .optional(),
});

export function restCollectMethodOtherToJSON(
  restCollectMethodOther: RestCollectMethodOther,
): string {
  return JSON.stringify(
    RestCollectMethodOther$outboundSchema.parse(restCollectMethodOther),
  );
}
export function restCollectMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOther, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodOther$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOther' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyCollectMethod$inboundSchema:
  z.ZodType<RestCollectMethodPostWithBodyCollectMethod, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(RestCollectMethodPostWithBodyCollectMethod);
/** @internal */
export const RestCollectMethodPostWithBodyCollectMethod$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestCollectMethodPostWithBodyCollectMethod> =
    openEnums.outboundSchema(RestCollectMethodPostWithBodyCollectMethod);

/** @internal */
export const RestCollectMethodPostWithBodyDiscoverType$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodPostWithBodyDiscoverType);
/** @internal */
export const RestCollectMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestCollectMethodPostWithBodyDiscoverType> =
    openEnums.outboundSchema(RestCollectMethodPostWithBodyDiscoverType);

/** @internal */
export const RestCollectMethodPostWithBodyDiscovery$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestCollectMethodPostWithBodyDiscoverType$inboundSchema,
});
/** @internal */
export type RestCollectMethodPostWithBodyDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestCollectMethodPostWithBodyDiscovery$outboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyDiscovery$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostWithBodyDiscovery
> = z.object({
  discoverType: RestCollectMethodPostWithBodyDiscoverType$outboundSchema,
});

export function restCollectMethodPostWithBodyDiscoveryToJSON(
  restCollectMethodPostWithBodyDiscovery:
    RestCollectMethodPostWithBodyDiscovery,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyDiscovery$outboundSchema.parse(
      restCollectMethodPostWithBodyDiscovery,
    ),
  );
}
export function restCollectMethodPostWithBodyDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostWithBodyDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyDiscovery' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyPaginationEnum$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyPaginationEnum,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RestCollectMethodPostWithBodyPaginationEnum);
/** @internal */
export const RestCollectMethodPostWithBodyPaginationEnum$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestCollectMethodPostWithBodyPaginationEnum> =
    openEnums.outboundSchema(RestCollectMethodPostWithBodyPaginationEnum);

/** @internal */
export const RestCollectMethodPostWithBodyPagination$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestCollectMethodPostWithBodyPaginationEnum$inboundSchema,
});
/** @internal */
export type RestCollectMethodPostWithBodyPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestCollectMethodPostWithBodyPagination$outboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyPagination$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostWithBodyPagination
> = z.object({
  type: RestCollectMethodPostWithBodyPaginationEnum$outboundSchema,
});

export function restCollectMethodPostWithBodyPaginationToJSON(
  restCollectMethodPostWithBodyPagination:
    RestCollectMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyPagination$outboundSchema.parse(
      restCollectMethodPostWithBodyPagination,
    ),
  );
}
export function restCollectMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyPagination$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyAuthentication$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyAuthentication,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RestCollectMethodPostWithBodyAuthentication);
/** @internal */
export const RestCollectMethodPostWithBodyAuthentication$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestCollectMethodPostWithBodyAuthentication> =
    openEnums.outboundSchema(RestCollectMethodPostWithBodyAuthentication);

/** @internal */
export const RestCollectMethodPostWithBodyRetryRules$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestCollectMethodPostWithBodyRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestCollectMethodPostWithBodyRetryRules$outboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyRetryRules$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostWithBodyRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restCollectMethodPostWithBodyRetryRulesToJSON(
  restCollectMethodPostWithBodyRetryRules:
    RestCollectMethodPostWithBodyRetryRules,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRetryRules$outboundSchema.parse(
      restCollectMethodPostWithBodyRetryRules,
    ),
  );
}
export function restCollectMethodPostWithBodyRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyRetryRules' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyStateTracking$inboundSchema:
  z.ZodType<RestCollectMethodPostWithBodyStateTracking, z.ZodTypeDef, unknown> =
    z.object({
      enabled: z.boolean().optional(),
    });
/** @internal */
export type RestCollectMethodPostWithBodyStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestCollectMethodPostWithBodyStateTracking$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyStateTracking$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyStateTrackingToJSON(
  restCollectMethodPostWithBodyStateTracking:
    RestCollectMethodPostWithBodyStateTracking,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyStateTracking$outboundSchema.parse(
      restCollectMethodPostWithBodyStateTracking,
    ),
  );
}
export function restCollectMethodPostWithBodyStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyStateTracking' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyScheduling$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() =>
    RestCollectMethodPostWithBodyStateTracking$inboundSchema
  ).optional(),
});
/** @internal */
export type RestCollectMethodPostWithBodyScheduling$Outbound = {
  stateTracking?:
    | RestCollectMethodPostWithBodyStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestCollectMethodPostWithBodyScheduling$outboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyScheduling$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostWithBodyScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestCollectMethodPostWithBodyStateTracking$outboundSchema
  ).optional(),
});

export function restCollectMethodPostWithBodySchedulingToJSON(
  restCollectMethodPostWithBodyScheduling:
    RestCollectMethodPostWithBodyScheduling,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyScheduling$outboundSchema.parse(
      restCollectMethodPostWithBodyScheduling,
    ),
  );
}
export function restCollectMethodPostWithBodySchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyScheduling' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBody$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: RestCollectMethodPostWithBodyCollectMethod$inboundSchema,
  collectBody: z.any().optional(),
  discovery: z.lazy(() => RestCollectMethodPostWithBodyDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() =>
    RestCollectMethodPostWithBodyPagination$inboundSchema
  ).optional(),
  authentication: RestCollectMethodPostWithBodyAuthentication$inboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    RestCollectMethodPostWithBodyRetryRules$inboundSchema
  ).optional(),
  __scheduling: z.lazy(() =>
    RestCollectMethodPostWithBodyScheduling$inboundSchema
  ).optional(),
});
/** @internal */
export type RestCollectMethodPostWithBody$Outbound = {
  collectMethod: string;
  collectBody?: any | undefined;
  discovery?: RestCollectMethodPostWithBodyDiscovery$Outbound | undefined;
  collectUrl: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestCollectMethodPostWithBodyPagination$Outbound | undefined;
  authentication: string;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestCollectMethodPostWithBodyRetryRules$Outbound | undefined;
  __scheduling?: RestCollectMethodPostWithBodyScheduling$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodPostWithBody$outboundSchema: z.ZodType<
  RestCollectMethodPostWithBody$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostWithBody
> = z.object({
  collectMethod: RestCollectMethodPostWithBodyCollectMethod$outboundSchema,
  collectBody: z.any().optional(),
  discovery: z.lazy(() => RestCollectMethodPostWithBodyDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() =>
    RestCollectMethodPostWithBodyPagination$outboundSchema
  ).optional(),
  authentication: RestCollectMethodPostWithBodyAuthentication$outboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    RestCollectMethodPostWithBodyRetryRules$outboundSchema
  ).optional(),
  __scheduling: z.lazy(() =>
    RestCollectMethodPostWithBodyScheduling$outboundSchema
  ).optional(),
});

export function restCollectMethodPostWithBodyToJSON(
  restCollectMethodPostWithBody: RestCollectMethodPostWithBody,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBody$outboundSchema.parse(
      restCollectMethodPostWithBody,
    ),
  );
}
export function restCollectMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostWithBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPostWithBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostCollectMethod$inboundSchema: z.ZodType<
  RestCollectMethodPostCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodPostCollectMethod);
/** @internal */
export const RestCollectMethodPostCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodPostCollectMethod
> = openEnums.outboundSchema(RestCollectMethodPostCollectMethod);

/** @internal */
export const RestCollectMethodPostDiscoverType$inboundSchema: z.ZodType<
  RestCollectMethodPostDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodPostDiscoverType);
/** @internal */
export const RestCollectMethodPostDiscoverType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodPostDiscoverType
> = openEnums.outboundSchema(RestCollectMethodPostDiscoverType);

/** @internal */
export const RestCollectMethodPostDiscovery$inboundSchema: z.ZodType<
  RestCollectMethodPostDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestCollectMethodPostDiscoverType$inboundSchema,
});
/** @internal */
export type RestCollectMethodPostDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestCollectMethodPostDiscovery$outboundSchema: z.ZodType<
  RestCollectMethodPostDiscovery$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostDiscovery
> = z.object({
  discoverType: RestCollectMethodPostDiscoverType$outboundSchema,
});

export function restCollectMethodPostDiscoveryToJSON(
  restCollectMethodPostDiscovery: RestCollectMethodPostDiscovery,
): string {
  return JSON.stringify(
    RestCollectMethodPostDiscovery$outboundSchema.parse(
      restCollectMethodPostDiscovery,
    ),
  );
}
export function restCollectMethodPostDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPostDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostDiscovery' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostPaginationEnum$inboundSchema: z.ZodType<
  RestCollectMethodPostPaginationEnum,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodPostPaginationEnum);
/** @internal */
export const RestCollectMethodPostPaginationEnum$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodPostPaginationEnum
> = openEnums.outboundSchema(RestCollectMethodPostPaginationEnum);

/** @internal */
export const RestCollectMethodPostPagination$inboundSchema: z.ZodType<
  RestCollectMethodPostPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestCollectMethodPostPaginationEnum$inboundSchema,
});
/** @internal */
export type RestCollectMethodPostPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestCollectMethodPostPagination$outboundSchema: z.ZodType<
  RestCollectMethodPostPagination$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostPagination
> = z.object({
  type: RestCollectMethodPostPaginationEnum$outboundSchema,
});

export function restCollectMethodPostPaginationToJSON(
  restCollectMethodPostPagination: RestCollectMethodPostPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostPagination$outboundSchema.parse(
      restCollectMethodPostPagination,
    ),
  );
}
export function restCollectMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostPagination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPostPagination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostAuthentication$inboundSchema: z.ZodType<
  RestCollectMethodPostAuthentication,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodPostAuthentication);
/** @internal */
export const RestCollectMethodPostAuthentication$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodPostAuthentication
> = openEnums.outboundSchema(RestCollectMethodPostAuthentication);

/** @internal */
export const RestCollectMethodPostRetryRules$inboundSchema: z.ZodType<
  RestCollectMethodPostRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestCollectMethodPostRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestCollectMethodPostRetryRules$outboundSchema: z.ZodType<
  RestCollectMethodPostRetryRules$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restCollectMethodPostRetryRulesToJSON(
  restCollectMethodPostRetryRules: RestCollectMethodPostRetryRules,
): string {
  return JSON.stringify(
    RestCollectMethodPostRetryRules$outboundSchema.parse(
      restCollectMethodPostRetryRules,
    ),
  );
}
export function restCollectMethodPostRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPostRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRetryRules' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostStateTracking$inboundSchema: z.ZodType<
  RestCollectMethodPostStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type RestCollectMethodPostStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestCollectMethodPostStateTracking$outboundSchema: z.ZodType<
  RestCollectMethodPostStateTracking$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restCollectMethodPostStateTrackingToJSON(
  restCollectMethodPostStateTracking: RestCollectMethodPostStateTracking,
): string {
  return JSON.stringify(
    RestCollectMethodPostStateTracking$outboundSchema.parse(
      restCollectMethodPostStateTracking,
    ),
  );
}
export function restCollectMethodPostStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostStateTracking' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostScheduling$inboundSchema: z.ZodType<
  RestCollectMethodPostScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => RestCollectMethodPostStateTracking$inboundSchema)
    .optional(),
});
/** @internal */
export type RestCollectMethodPostScheduling$Outbound = {
  stateTracking?: RestCollectMethodPostStateTracking$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodPostScheduling$outboundSchema: z.ZodType<
  RestCollectMethodPostScheduling$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostScheduling
> = z.object({
  stateTracking: z.lazy(() => RestCollectMethodPostStateTracking$outboundSchema)
    .optional(),
});

export function restCollectMethodPostSchedulingToJSON(
  restCollectMethodPostScheduling: RestCollectMethodPostScheduling,
): string {
  return JSON.stringify(
    RestCollectMethodPostScheduling$outboundSchema.parse(
      restCollectMethodPostScheduling,
    ),
  );
}
export function restCollectMethodPostSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPostScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostScheduling' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPost$inboundSchema: z.ZodType<
  RestCollectMethodPost,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: RestCollectMethodPostCollectMethod$inboundSchema,
  collectRequestParams: z.any().optional(),
  discovery: z.lazy(() => RestCollectMethodPostDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectVerb: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestCollectMethodPostPagination$inboundSchema)
    .optional(),
  authentication: RestCollectMethodPostAuthentication$inboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestCollectMethodPostRetryRules$inboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestCollectMethodPostScheduling$inboundSchema)
    .optional(),
});
/** @internal */
export type RestCollectMethodPost$Outbound = {
  collectMethod: string;
  collectRequestParams?: any | undefined;
  discovery?: RestCollectMethodPostDiscovery$Outbound | undefined;
  collectUrl: string;
  collectVerb?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestCollectMethodPostPagination$Outbound | undefined;
  authentication: string;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestCollectMethodPostRetryRules$Outbound | undefined;
  __scheduling?: RestCollectMethodPostScheduling$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodPost$outboundSchema: z.ZodType<
  RestCollectMethodPost$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPost
> = z.object({
  collectMethod: RestCollectMethodPostCollectMethod$outboundSchema,
  collectRequestParams: z.any().optional(),
  discovery: z.lazy(() => RestCollectMethodPostDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectVerb: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestCollectMethodPostPagination$outboundSchema)
    .optional(),
  authentication: RestCollectMethodPostAuthentication$outboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestCollectMethodPostRetryRules$outboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestCollectMethodPostScheduling$outboundSchema)
    .optional(),
});

export function restCollectMethodPostToJSON(
  restCollectMethodPost: RestCollectMethodPost,
): string {
  return JSON.stringify(
    RestCollectMethodPost$outboundSchema.parse(restCollectMethodPost),
  );
}
export function restCollectMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPost, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPost$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPost' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetCollectMethod$inboundSchema: z.ZodType<
  RestCollectMethodGetCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodGetCollectMethod);
/** @internal */
export const RestCollectMethodGetCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodGetCollectMethod
> = openEnums.outboundSchema(RestCollectMethodGetCollectMethod);

/** @internal */
export const RestCollectMethodGetDiscoverType$inboundSchema: z.ZodType<
  RestCollectMethodGetDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodGetDiscoverType);
/** @internal */
export const RestCollectMethodGetDiscoverType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodGetDiscoverType
> = openEnums.outboundSchema(RestCollectMethodGetDiscoverType);

/** @internal */
export const RestCollectMethodGetDiscovery$inboundSchema: z.ZodType<
  RestCollectMethodGetDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestCollectMethodGetDiscoverType$inboundSchema,
});
/** @internal */
export type RestCollectMethodGetDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestCollectMethodGetDiscovery$outboundSchema: z.ZodType<
  RestCollectMethodGetDiscovery$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetDiscovery
> = z.object({
  discoverType: RestCollectMethodGetDiscoverType$outboundSchema,
});

export function restCollectMethodGetDiscoveryToJSON(
  restCollectMethodGetDiscovery: RestCollectMethodGetDiscovery,
): string {
  return JSON.stringify(
    RestCollectMethodGetDiscovery$outboundSchema.parse(
      restCollectMethodGetDiscovery,
    ),
  );
}
export function restCollectMethodGetDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGetDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetDiscovery' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetPaginationEnum$inboundSchema: z.ZodType<
  RestCollectMethodGetPaginationEnum,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodGetPaginationEnum);
/** @internal */
export const RestCollectMethodGetPaginationEnum$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodGetPaginationEnum
> = openEnums.outboundSchema(RestCollectMethodGetPaginationEnum);

/** @internal */
export const RestCollectMethodGetPagination$inboundSchema: z.ZodType<
  RestCollectMethodGetPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestCollectMethodGetPaginationEnum$inboundSchema,
});
/** @internal */
export type RestCollectMethodGetPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestCollectMethodGetPagination$outboundSchema: z.ZodType<
  RestCollectMethodGetPagination$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetPagination
> = z.object({
  type: RestCollectMethodGetPaginationEnum$outboundSchema,
});

export function restCollectMethodGetPaginationToJSON(
  restCollectMethodGetPagination: RestCollectMethodGetPagination,
): string {
  return JSON.stringify(
    RestCollectMethodGetPagination$outboundSchema.parse(
      restCollectMethodGetPagination,
    ),
  );
}
export function restCollectMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetPagination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGetPagination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetAuthentication$inboundSchema: z.ZodType<
  RestCollectMethodGetAuthentication,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodGetAuthentication);
/** @internal */
export const RestCollectMethodGetAuthentication$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodGetAuthentication
> = openEnums.outboundSchema(RestCollectMethodGetAuthentication);

/** @internal */
export const RestCollectMethodGetRetryRules$inboundSchema: z.ZodType<
  RestCollectMethodGetRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestCollectMethodGetRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestCollectMethodGetRetryRules$outboundSchema: z.ZodType<
  RestCollectMethodGetRetryRules$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restCollectMethodGetRetryRulesToJSON(
  restCollectMethodGetRetryRules: RestCollectMethodGetRetryRules,
): string {
  return JSON.stringify(
    RestCollectMethodGetRetryRules$outboundSchema.parse(
      restCollectMethodGetRetryRules,
    ),
  );
}
export function restCollectMethodGetRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGetRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRetryRules' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetStateTracking$inboundSchema: z.ZodType<
  RestCollectMethodGetStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type RestCollectMethodGetStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestCollectMethodGetStateTracking$outboundSchema: z.ZodType<
  RestCollectMethodGetStateTracking$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restCollectMethodGetStateTrackingToJSON(
  restCollectMethodGetStateTracking: RestCollectMethodGetStateTracking,
): string {
  return JSON.stringify(
    RestCollectMethodGetStateTracking$outboundSchema.parse(
      restCollectMethodGetStateTracking,
    ),
  );
}
export function restCollectMethodGetStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGetStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetStateTracking' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetScheduling$inboundSchema: z.ZodType<
  RestCollectMethodGetScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => RestCollectMethodGetStateTracking$inboundSchema)
    .optional(),
});
/** @internal */
export type RestCollectMethodGetScheduling$Outbound = {
  stateTracking?: RestCollectMethodGetStateTracking$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodGetScheduling$outboundSchema: z.ZodType<
  RestCollectMethodGetScheduling$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetScheduling
> = z.object({
  stateTracking: z.lazy(() => RestCollectMethodGetStateTracking$outboundSchema)
    .optional(),
});

export function restCollectMethodGetSchedulingToJSON(
  restCollectMethodGetScheduling: RestCollectMethodGetScheduling,
): string {
  return JSON.stringify(
    RestCollectMethodGetScheduling$outboundSchema.parse(
      restCollectMethodGetScheduling,
    ),
  );
}
export function restCollectMethodGetSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGetScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetScheduling' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGet$inboundSchema: z.ZodType<
  RestCollectMethodGet,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: RestCollectMethodGetCollectMethod$inboundSchema,
  collectRequestParams: z.any().optional(),
  discovery: z.lazy(() => RestCollectMethodGetDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectVerb: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestCollectMethodGetPagination$inboundSchema)
    .optional(),
  authentication: RestCollectMethodGetAuthentication$inboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestCollectMethodGetRetryRules$inboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestCollectMethodGetScheduling$inboundSchema)
    .optional(),
});
/** @internal */
export type RestCollectMethodGet$Outbound = {
  collectMethod: string;
  collectRequestParams?: any | undefined;
  discovery?: RestCollectMethodGetDiscovery$Outbound | undefined;
  collectUrl: string;
  collectVerb?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestCollectMethodGetPagination$Outbound | undefined;
  authentication: string;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestCollectMethodGetRetryRules$Outbound | undefined;
  __scheduling?: RestCollectMethodGetScheduling$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodGet$outboundSchema: z.ZodType<
  RestCollectMethodGet$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGet
> = z.object({
  collectMethod: RestCollectMethodGetCollectMethod$outboundSchema,
  collectRequestParams: z.any().optional(),
  discovery: z.lazy(() => RestCollectMethodGetDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectVerb: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestCollectMethodGetPagination$outboundSchema)
    .optional(),
  authentication: RestCollectMethodGetAuthentication$outboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestCollectMethodGetRetryRules$outboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestCollectMethodGetScheduling$outboundSchema)
    .optional(),
});

export function restCollectMethodGetToJSON(
  restCollectMethodGet: RestCollectMethodGet,
): string {
  return JSON.stringify(
    RestCollectMethodGet$outboundSchema.parse(restCollectMethodGet),
  );
}
export function restCollectMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGet, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGet$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGet' from JSON`,
  );
}

/** @internal */
export const RestCollectorConf$inboundSchema: z.ZodType<
  RestCollectorConf,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => RestAuthenticationNone$inboundSchema),
  z.lazy(() => RestAuthenticationBasic$inboundSchema),
  z.lazy(() => RestAuthenticationBasicSecret$inboundSchema),
  z.lazy(() => RestAuthenticationLogin$inboundSchema),
  z.lazy(() => RestAuthenticationLoginSecret$inboundSchema),
  z.lazy(() => RestAuthenticationOauth$inboundSchema),
  z.lazy(() => RestAuthenticationOauthSecret$inboundSchema),
  z.lazy(() => RestAuthenticationGoogleOauth$inboundSchema),
  z.lazy(() => RestAuthenticationGoogleOauthSecret$inboundSchema),
  z.lazy(() => RestAuthenticationHmac$inboundSchema),
]);
/** @internal */
export type RestCollectorConf$Outbound =
  | RestAuthenticationNone$Outbound
  | RestAuthenticationBasic$Outbound
  | RestAuthenticationBasicSecret$Outbound
  | RestAuthenticationLogin$Outbound
  | RestAuthenticationLoginSecret$Outbound
  | RestAuthenticationOauth$Outbound
  | RestAuthenticationOauthSecret$Outbound
  | RestAuthenticationGoogleOauth$Outbound
  | RestAuthenticationGoogleOauthSecret$Outbound
  | RestAuthenticationHmac$Outbound;

/** @internal */
export const RestCollectorConf$outboundSchema: z.ZodType<
  RestCollectorConf$Outbound,
  z.ZodTypeDef,
  RestCollectorConf
> = z.union([
  z.lazy(() => RestAuthenticationNone$outboundSchema),
  z.lazy(() => RestAuthenticationBasic$outboundSchema),
  z.lazy(() => RestAuthenticationBasicSecret$outboundSchema),
  z.lazy(() => RestAuthenticationLogin$outboundSchema),
  z.lazy(() => RestAuthenticationLoginSecret$outboundSchema),
  z.lazy(() => RestAuthenticationOauth$outboundSchema),
  z.lazy(() => RestAuthenticationOauthSecret$outboundSchema),
  z.lazy(() => RestAuthenticationGoogleOauth$outboundSchema),
  z.lazy(() => RestAuthenticationGoogleOauthSecret$outboundSchema),
  z.lazy(() => RestAuthenticationHmac$outboundSchema),
]);

export function restCollectorConfToJSON(
  restCollectorConf: RestCollectorConf,
): string {
  return JSON.stringify(
    RestCollectorConf$outboundSchema.parse(restCollectorConf),
  );
}
export function restCollectorConfFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectorConf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectorConf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectorConf' from JSON`,
  );
}
