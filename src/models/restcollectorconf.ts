/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as discriminatedUnionTypes from "../types/discriminatedUnion.js";
import { discriminatedUnion } from "../types/discriminatedUnion.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeRestCollectMethodGetCollectRequestParams,
  ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound,
  ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
} from "./itemstyperestcollectmethodgetcollectrequestparams.js";
import {
  RestAuthenticationBasic,
  RestAuthenticationBasic$inboundSchema,
  RestAuthenticationBasic$Outbound,
  RestAuthenticationBasic$outboundSchema,
  RestAuthenticationBasicSecret,
  RestAuthenticationBasicSecret$inboundSchema,
  RestAuthenticationBasicSecret$Outbound,
  RestAuthenticationBasicSecret$outboundSchema,
  RestAuthenticationLogin,
  RestAuthenticationLogin$inboundSchema,
  RestAuthenticationLogin$Outbound,
  RestAuthenticationLogin$outboundSchema,
  RestAuthenticationLoginSecret,
  RestAuthenticationLoginSecret$inboundSchema,
  RestAuthenticationLoginSecret$Outbound,
  RestAuthenticationLoginSecret$outboundSchema,
  RestAuthenticationOauth,
  RestAuthenticationOauth$inboundSchema,
  RestAuthenticationOauth$Outbound,
  RestAuthenticationOauth$outboundSchema,
} from "./restauthenticationnonerestdiscoverydiscovertypehttpdiscovermethodpost.js";
import {
  RestAuthenticationGoogleOauth,
  RestAuthenticationGoogleOauth$inboundSchema,
  RestAuthenticationGoogleOauth$Outbound,
  RestAuthenticationGoogleOauth$outboundSchema,
  RestAuthenticationGoogleOauthSecret,
  RestAuthenticationGoogleOauthSecret$inboundSchema,
  RestAuthenticationGoogleOauthSecret$Outbound,
  RestAuthenticationGoogleOauthSecret$outboundSchema,
  RestAuthenticationHmac,
  RestAuthenticationHmac$inboundSchema,
  RestAuthenticationHmac$Outbound,
  RestAuthenticationHmac$outboundSchema,
  RestAuthenticationOauthSecret,
  RestAuthenticationOauthSecret$inboundSchema,
  RestAuthenticationOauthSecret$Outbound,
  RestAuthenticationOauthSecret$outboundSchema,
} from "./restauthenticationoauthrestpaginationtyperesponseheader.js";
import {
  RestAuthenticationNone,
  RestAuthenticationNone$inboundSchema,
  RestAuthenticationNone$Outbound,
  RestAuthenticationNone$outboundSchema,
  RestCollectMethodGetAuthentication,
  RestCollectMethodGetAuthentication$inboundSchema,
  RestCollectMethodGetAuthentication$outboundSchema,
  RestCollectMethodGetCollectMethod,
  RestCollectMethodGetCollectMethod$inboundSchema,
  RestCollectMethodGetCollectMethod$outboundSchema,
  RestCollectMethodGetDiscovery,
  RestCollectMethodGetDiscovery$inboundSchema,
  RestCollectMethodGetDiscovery$Outbound,
  RestCollectMethodGetDiscovery$outboundSchema,
  RestCollectMethodGetPaginationUnion,
  RestCollectMethodGetPaginationUnion$inboundSchema,
  RestCollectMethodGetPaginationUnion$Outbound,
  RestCollectMethodGetPaginationUnion$outboundSchema,
  RestCollectMethodGetRetryRules,
  RestCollectMethodGetRetryRules$inboundSchema,
  RestCollectMethodGetRetryRules$Outbound,
  RestCollectMethodGetRetryRules$outboundSchema,
  RestCollectMethodGetStateTracking,
  RestCollectMethodGetStateTracking$inboundSchema,
  RestCollectMethodGetStateTracking$Outbound,
  RestCollectMethodGetStateTracking$outboundSchema,
} from "./restcollectmethodgetstatetracking.js";

export type RestCollectMethodGetScheduling = {
  stateTracking?: RestCollectMethodGetStateTracking | undefined;
};

export type RestCollectMethodGet = {
  collectMethod: RestCollectMethodGetCollectMethod;
  collectRequestParams?: any | undefined;
  discovery?: RestCollectMethodGetDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectVerb?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestCollectMethodGetPaginationUnion | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
   */
  authentication: RestCollectMethodGetAuthentication;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestCollectMethodGetRetryRules | undefined;
  __scheduling?: RestCollectMethodGetScheduling | undefined;
};

export type RestCollectorConf =
  | RestAuthenticationNone
  | RestAuthenticationBasic
  | RestAuthenticationBasicSecret
  | RestAuthenticationLogin
  | RestAuthenticationLoginSecret
  | RestAuthenticationOauth
  | RestAuthenticationOauthSecret
  | RestAuthenticationGoogleOauth
  | RestAuthenticationGoogleOauthSecret
  | RestAuthenticationHmac
  | discriminatedUnionTypes.Unknown<"authentication">;

/** @internal */
export const RestCollectMethodGetScheduling$inboundSchema: z.ZodType<
  RestCollectMethodGetScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    RestCollectMethodGetStateTracking$inboundSchema,
  ),
});
/** @internal */
export type RestCollectMethodGetScheduling$Outbound = {
  stateTracking?: RestCollectMethodGetStateTracking$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodGetScheduling$outboundSchema: z.ZodType<
  RestCollectMethodGetScheduling$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetScheduling
> = z.object({
  stateTracking: RestCollectMethodGetStateTracking$outboundSchema.optional(),
});

export function restCollectMethodGetSchedulingToJSON(
  restCollectMethodGetScheduling: RestCollectMethodGetScheduling,
): string {
  return JSON.stringify(
    RestCollectMethodGetScheduling$outboundSchema.parse(
      restCollectMethodGetScheduling,
    ),
  );
}
export function restCollectMethodGetSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGetScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetScheduling' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGet$inboundSchema: z.ZodType<
  RestCollectMethodGet,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: RestCollectMethodGetCollectMethod$inboundSchema,
  collectRequestParams: types.optional(z.any()),
  discovery: types.optional(RestCollectMethodGetDiscovery$inboundSchema),
  collectUrl: types.string(),
  collectVerb: types.optional(z.any()),
  collectBody: types.optional(z.any()),
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(RestCollectMethodGetPaginationUnion$inboundSchema),
  authentication: RestCollectMethodGetAuthentication$inboundSchema,
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(RestCollectMethodGetRetryRules$inboundSchema),
  __scheduling: types.optional(
    z.lazy(() => RestCollectMethodGetScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestCollectMethodGet$Outbound = {
  collectMethod: string;
  collectRequestParams?: any | undefined;
  discovery?: RestCollectMethodGetDiscovery$Outbound | undefined;
  collectUrl: string;
  collectVerb?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestCollectMethodGetPaginationUnion$Outbound | undefined;
  authentication: string;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestCollectMethodGetRetryRules$Outbound | undefined;
  __scheduling?: RestCollectMethodGetScheduling$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodGet$outboundSchema: z.ZodType<
  RestCollectMethodGet$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGet
> = z.object({
  collectMethod: RestCollectMethodGetCollectMethod$outboundSchema,
  collectRequestParams: z.any().optional(),
  discovery: RestCollectMethodGetDiscovery$outboundSchema.optional(),
  collectUrl: z.string(),
  collectVerb: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: RestCollectMethodGetPaginationUnion$outboundSchema.optional(),
  authentication: RestCollectMethodGetAuthentication$outboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: RestCollectMethodGetRetryRules$outboundSchema.optional(),
  __scheduling: z.lazy(() => RestCollectMethodGetScheduling$outboundSchema)
    .optional(),
});

export function restCollectMethodGetToJSON(
  restCollectMethodGet: RestCollectMethodGet,
): string {
  return JSON.stringify(
    RestCollectMethodGet$outboundSchema.parse(restCollectMethodGet),
  );
}
export function restCollectMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGet, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGet$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGet' from JSON`,
  );
}

/** @internal */
export const RestCollectorConf$inboundSchema: z.ZodType<
  RestCollectorConf,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("authentication", {
  none: RestAuthenticationNone$inboundSchema,
  basic: RestAuthenticationBasic$inboundSchema,
  basicSecret: RestAuthenticationBasicSecret$inboundSchema,
  login: RestAuthenticationLogin$inboundSchema,
  loginSecret: RestAuthenticationLoginSecret$inboundSchema,
  oauth: RestAuthenticationOauth$inboundSchema,
  oauthSecret: RestAuthenticationOauthSecret$inboundSchema,
  google_oauth: RestAuthenticationGoogleOauth$inboundSchema,
  google_oauthSecret: RestAuthenticationGoogleOauthSecret$inboundSchema,
  hmac: RestAuthenticationHmac$inboundSchema,
});
/** @internal */
export type RestCollectorConf$Outbound =
  | RestAuthenticationNone$Outbound
  | RestAuthenticationBasic$Outbound
  | RestAuthenticationBasicSecret$Outbound
  | RestAuthenticationLogin$Outbound
  | RestAuthenticationLoginSecret$Outbound
  | RestAuthenticationOauth$Outbound
  | RestAuthenticationOauthSecret$Outbound
  | RestAuthenticationGoogleOauth$Outbound
  | RestAuthenticationGoogleOauthSecret$Outbound
  | RestAuthenticationHmac$Outbound;

/** @internal */
export const RestCollectorConf$outboundSchema: z.ZodType<
  RestCollectorConf$Outbound,
  z.ZodTypeDef,
  RestCollectorConf
> = z.union([
  RestAuthenticationNone$outboundSchema,
  RestAuthenticationBasic$outboundSchema,
  RestAuthenticationBasicSecret$outboundSchema,
  RestAuthenticationLogin$outboundSchema,
  RestAuthenticationLoginSecret$outboundSchema,
  RestAuthenticationOauth$outboundSchema,
  RestAuthenticationOauthSecret$outboundSchema,
  RestAuthenticationGoogleOauth$outboundSchema,
  RestAuthenticationGoogleOauthSecret$outboundSchema,
  RestAuthenticationHmac$outboundSchema,
]);

export function restCollectorConfToJSON(
  restCollectorConf: RestCollectorConf,
): string {
  return JSON.stringify(
    RestCollectorConf$outboundSchema.parse(restCollectorConf),
  );
}
export function restCollectorConfFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectorConf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectorConf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectorConf' from JSON`,
  );
}
