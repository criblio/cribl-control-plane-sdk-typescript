/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as discriminatedUnionTypes from "../types/discriminatedUnion.js";
import { discriminatedUnion } from "../types/discriminatedUnion.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeRestCollectMethodGetCollectRequestParams,
  ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound,
  ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
} from "./itemstyperestcollectmethodgetcollectrequestparams.js";
import {
  RestAuthenticationGoogleOauthSecret,
  RestAuthenticationGoogleOauthSecret$inboundSchema,
  RestAuthenticationGoogleOauthSecret$Outbound,
  RestAuthenticationGoogleOauthSecret$outboundSchema,
  RestAuthenticationHmac,
  RestAuthenticationHmac$inboundSchema,
  RestAuthenticationHmac$Outbound,
  RestAuthenticationHmac$outboundSchema,
} from "./restauthenticationgoogleoauthrestretryrulestypestaticenableheaderfalse.js";
import {
  RestAuthenticationLoginSecret,
  RestAuthenticationLoginSecret$inboundSchema,
  RestAuthenticationLoginSecret$Outbound,
  RestAuthenticationLoginSecret$outboundSchema,
} from "./restauthenticationlogingetauthtokenfromheaderfalserestdiscoverydiscovertypehttpenablestrictdiscoverparsingfalsediscovermethod.js";
import {
  RestAuthenticationGoogleOauth,
  RestAuthenticationGoogleOauth$inboundSchema,
  RestAuthenticationGoogleOauth$Outbound,
  RestAuthenticationGoogleOauth$outboundSchema,
  RestAuthenticationOauth,
  RestAuthenticationOauth$inboundSchema,
  RestAuthenticationOauth$Outbound,
  RestAuthenticationOauth$outboundSchema,
  RestAuthenticationOauthSecret,
  RestAuthenticationOauthSecret$inboundSchema,
  RestAuthenticationOauthSecret$Outbound,
  RestAuthenticationOauthSecret$outboundSchema,
} from "./restauthenticationloginsecretgetauthtokenfromheadertruerestpaginationtyperesponsebody.js";
import {
  RestAuthenticationBasic,
  RestAuthenticationBasic$inboundSchema,
  RestAuthenticationBasic$Outbound,
  RestAuthenticationBasic$outboundSchema,
  RestAuthenticationBasicSecret,
  RestAuthenticationBasicSecret$inboundSchema,
  RestAuthenticationBasicSecret$Outbound,
  RestAuthenticationBasicSecret$outboundSchema,
  RestAuthenticationLogin,
  RestAuthenticationLogin$inboundSchema,
  RestAuthenticationLogin$Outbound,
  RestAuthenticationLogin$outboundSchema,
} from "./restauthenticationnonerestdiscoverydiscovertypehttpenablediscovercodefalsepagination.js";
import {
  RestAuthenticationNone,
  RestAuthenticationNone$inboundSchema,
  RestAuthenticationNone$Outbound,
  RestAuthenticationNone$outboundSchema,
  RestCollectMethodPostCollectMethod,
  RestCollectMethodPostCollectMethod$inboundSchema,
  RestCollectMethodPostCollectMethod$outboundSchema,
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema,
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema,
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema,
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema,
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema,
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema,
  RestCollectMethodPostRestDiscoveryDiscoverTypeJson,
  RestCollectMethodPostRestDiscoveryDiscoverTypeJson$inboundSchema,
  RestCollectMethodPostRestDiscoveryDiscoverTypeJson$Outbound,
  RestCollectMethodPostRestDiscoveryDiscoverTypeJson$outboundSchema,
  RestCollectMethodPostRestDiscoveryDiscoverTypeList,
  RestCollectMethodPostRestDiscoveryDiscoverTypeList$inboundSchema,
  RestCollectMethodPostRestDiscoveryDiscoverTypeList$Outbound,
  RestCollectMethodPostRestDiscoveryDiscoverTypeList$outboundSchema,
  RestCollectMethodPostRestDiscoveryDiscoverTypeNone,
  RestCollectMethodPostRestDiscoveryDiscoverTypeNone$inboundSchema,
  RestCollectMethodPostRestDiscoveryDiscoverTypeNone$Outbound,
  RestCollectMethodPostRestDiscoveryDiscoverTypeNone$outboundSchema,
} from "./restcollectmethodpostrestdiscoverydiscovertypehttpdiscovermethodgetdiscovertype.js";

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * If 'Strict discover response parsing' parsing is enabled, provide the response format
     */
    discoverResponseFormat: string;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttp =
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestCollectMethodPostDiscovery =
  | (
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestCollectMethodPostRestDiscoveryDiscoverTypeJson
  | RestCollectMethodPostRestDiscoveryDiscoverTypeList
  | RestCollectMethodPostRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export type RestCollectMethodPostRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodPostRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodPostRestPaginationTypeResponseHeaderLink = {
  type: "response_header_link";
  /**
   * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
   */
  nextRelationAttribute: string;
  /**
   * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
   */
  curRelationAttribute?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestCollectMethodPostRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestCollectMethodPostRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestCollectMethodPostRestPaginationTypeNone = {
  type: "none";
};

export type RestCollectMethodPostPaginationUnion =
  | RestCollectMethodPostRestPaginationTypeNone
  | RestCollectMethodPostRestPaginationTypeResponseBody
  | RestCollectMethodPostRestPaginationTypeResponseHeader
  | RestCollectMethodPostRestPaginationTypeResponseHeaderLink
  | RestCollectMethodPostRestPaginationTypeRequestOffset
  | RestCollectMethodPostRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const RestCollectMethodPostAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type RestCollectMethodPostAuthentication = OpenEnum<
  typeof RestCollectMethodPostAuthentication
>;

export type RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue = {
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  /**
   * Time interval between a failed request and the first retry
   */
  interval?: number | undefined;
  /**
   * Maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
   */
  multiplier?: number | undefined;
  maxIntervalMs?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

export type RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse = {
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  /**
   * Time interval between a failed request and the first retry
   */
  interval?: number | undefined;
  /**
   * Maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
   */
  multiplier?: number | undefined;
  maxIntervalMs?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

export type RestCollectMethodPostRestRetryRulesTypeBackoff =
  | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue = {
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  /**
   * Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * Maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

export type RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse = {
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  /**
   * Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * Maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

export type RestCollectMethodPostRestRetryRulesTypeStatic =
  | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse
  | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestCollectMethodPostRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
};

export type RestCollectMethodPostRetryRules =
  | RestCollectMethodPostRestRetryRulesTypeNone
  | (
    | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse
    | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue & {
      type: "static";
    }
  )
  | (
    | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue & {
      type: "backoff";
    }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestCollectMethodPostStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestCollectMethodPostScheduling = {
  stateTracking?: RestCollectMethodPostStateTracking | undefined;
};

export type RestCollectMethodPost = {
  collectMethod: RestCollectMethodPostCollectMethod;
  collectRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | (
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestCollectMethodPostRestDiscoveryDiscoverTypeJson
    | RestCollectMethodPostRestDiscoveryDiscoverTypeList
    | RestCollectMethodPostRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestCollectMethodPostRestPaginationTypeNone
    | RestCollectMethodPostRestPaginationTypeResponseBody
    | RestCollectMethodPostRestPaginationTypeResponseHeader
    | RestCollectMethodPostRestPaginationTypeResponseHeaderLink
    | RestCollectMethodPostRestPaginationTypeRequestOffset
    | RestCollectMethodPostRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: RestCollectMethodPostAuthentication;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestCollectMethodPostRestRetryRulesTypeNone
    | (
      | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse
      | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue & {
        type: "static";
      }
    )
    | (
      | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue & {
        type: "backoff";
      }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestCollectMethodPostScheduling | undefined;
};

export const RestCollectMethodGetCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestCollectMethodGetCollectMethod = OpenEnum<
  typeof RestCollectMethodGetCollectMethod
>;

export type RestCollectMethodGetRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestCollectMethodGetRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestCollectMethodGetRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    /**
     * Custom HTTP method to use for the Discover operation
     */
    discoverVerb: string;
    /**
     * Template for body to send with the discover request
     */
    discoverBody?: string | undefined;
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    /**
     * Template for POST body to send with the discover request. To reference global variables or functions, use template parameters: `{ myVar: ${C.vars.myVar}, secret: ${C.Secret('mySecret','text').value} }`
     */
    discoverBody: string;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * If 'Strict discover response parsing' parsing is enabled, provide the response format
     */
    discoverResponseFormat: string;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttp =
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestCollectMethodGetDiscovery =
  | (
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestCollectMethodGetRestDiscoveryDiscoverTypeJson
  | RestCollectMethodGetRestDiscoveryDiscoverTypeList
  | RestCollectMethodGetRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export type RestCollectMethodGetRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodGetRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodGetRestPaginationTypeResponseHeaderLink = {
  type: "response_header_link";
  /**
   * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
   */
  nextRelationAttribute: string;
  /**
   * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
   */
  curRelationAttribute?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestCollectMethodGetRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestCollectMethodGetRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestCollectMethodGetRestPaginationTypeNone = {
  type: "none";
};

export type RestCollectMethodGetPaginationUnion =
  | RestCollectMethodGetRestPaginationTypeNone
  | RestCollectMethodGetRestPaginationTypeResponseBody
  | RestCollectMethodGetRestPaginationTypeResponseHeader
  | RestCollectMethodGetRestPaginationTypeResponseHeaderLink
  | RestCollectMethodGetRestPaginationTypeRequestOffset
  | RestCollectMethodGetRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const RestCollectMethodGetAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type RestCollectMethodGetAuthentication = OpenEnum<
  typeof RestCollectMethodGetAuthentication
>;

export type RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue = {
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  /**
   * Time interval between a failed request and the first retry
   */
  interval?: number | undefined;
  /**
   * Maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
   */
  multiplier?: number | undefined;
  maxIntervalMs?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

export type RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse = {
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  /**
   * Time interval between a failed request and the first retry
   */
  interval?: number | undefined;
  /**
   * Maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
   */
  multiplier?: number | undefined;
  maxIntervalMs?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

export type RestCollectMethodGetRestRetryRulesTypeBackoff =
  | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue = {
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  /**
   * Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * Maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

export type RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse = {
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  /**
   * Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * Maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

export type RestCollectMethodGetRestRetryRulesTypeStatic =
  | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse
  | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestCollectMethodGetRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
};

export type RestCollectMethodGetRetryRules =
  | RestCollectMethodGetRestRetryRulesTypeNone
  | (
    | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse
    | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue & {
      type: "static";
    }
  )
  | (
    | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue & {
      type: "backoff";
    }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestCollectMethodGetStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestCollectMethodGetScheduling = {
  stateTracking?: RestCollectMethodGetStateTracking | undefined;
};

export type RestCollectMethodGet = {
  collectMethod: RestCollectMethodGetCollectMethod;
  collectRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | (
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestCollectMethodGetRestDiscoveryDiscoverTypeJson
    | RestCollectMethodGetRestDiscoveryDiscoverTypeList
    | RestCollectMethodGetRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestCollectMethodGetRestPaginationTypeNone
    | RestCollectMethodGetRestPaginationTypeResponseBody
    | RestCollectMethodGetRestPaginationTypeResponseHeader
    | RestCollectMethodGetRestPaginationTypeResponseHeaderLink
    | RestCollectMethodGetRestPaginationTypeRequestOffset
    | RestCollectMethodGetRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: RestCollectMethodGetAuthentication;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestCollectMethodGetRestRetryRulesTypeNone
    | (
      | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse
      | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue & {
        type: "static";
      }
    )
    | (
      | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue & {
        type: "backoff";
      }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestCollectMethodGetScheduling | undefined;
};

export type RestCollectorConf =
  | RestAuthenticationNone
  | RestAuthenticationBasic
  | RestAuthenticationBasicSecret
  | (RestAuthenticationLogin & { authentication: "login" })
  | (RestAuthenticationLoginSecret & { authentication: "loginSecret" })
  | RestAuthenticationOauth
  | RestAuthenticationOauthSecret
  | RestAuthenticationGoogleOauth
  | RestAuthenticationGoogleOauthSecret
  | RestAuthenticationHmac
  | discriminatedUnionTypes.Unknown<"authentication">;

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.string(),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat: string;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.string(),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema,
    post_with_body:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema,
    other:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema,
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema,
  ]);

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttp:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttp$outboundSchema.parse(
      restCollectMethodPostRestDiscoveryDiscoverTypeHttp,
    ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttp$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostDiscovery$inboundSchema: z.ZodType<
  RestCollectMethodPostDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema,
    post_with_body:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema,
    other:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema,
  }).and(z.object({ discoverType: z.literal("http") })),
  json: RestCollectMethodPostRestDiscoveryDiscoverTypeJson$inboundSchema,
  list: RestCollectMethodPostRestDiscoveryDiscoverTypeList$inboundSchema,
  none: RestCollectMethodPostRestDiscoveryDiscoverTypeNone$inboundSchema,
});
/** @internal */
export type RestCollectMethodPostDiscovery$Outbound =
  | (
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestCollectMethodPostRestDiscoveryDiscoverTypeJson$Outbound
  | RestCollectMethodPostRestDiscoveryDiscoverTypeList$Outbound
  | RestCollectMethodPostRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestCollectMethodPostDiscovery$outboundSchema: z.ZodType<
  RestCollectMethodPostDiscovery$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema,
  ]).and(z.object({ discoverType: z.literal("http") })),
  RestCollectMethodPostRestDiscoveryDiscoverTypeJson$outboundSchema,
  RestCollectMethodPostRestDiscoveryDiscoverTypeList$outboundSchema,
  RestCollectMethodPostRestDiscoveryDiscoverTypeNone$outboundSchema,
]);

export function restCollectMethodPostDiscoveryToJSON(
  restCollectMethodPostDiscovery: RestCollectMethodPostDiscovery,
): string {
  return JSON.stringify(
    RestCollectMethodPostDiscovery$outboundSchema.parse(
      restCollectMethodPostDiscovery,
    ),
  );
}
export function restCollectMethodPostDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPostDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostDiscovery' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodPostRestPaginationTypeRequestPage$Outbound = {
  type: "request_page";
  pageField: string;
  page?: number | undefined;
  sizeField: string;
  size: number;
  totalPageField?: string | undefined;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestCollectMethodPostRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodPostRestPaginationTypeRequestPageToJSON(
  restCollectMethodPostRestPaginationTypeRequestPage:
    RestCollectMethodPostRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestPaginationTypeRequestPage$outboundSchema.parse(
      restCollectMethodPostRestPaginationTypeRequestPage,
    ),
  );
}
export function restCollectMethodPostRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestPaginationTypeRequestPage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodPostRestPaginationTypeRequestOffset$Outbound = {
  type: "request_offset";
  offsetField: string;
  offset?: number | undefined;
  limitField: string;
  limit: number;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestCollectMethodPostRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodPostRestPaginationTypeRequestOffsetToJSON(
  restCollectMethodPostRestPaginationTypeRequestOffset:
    RestCollectMethodPostRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestPaginationTypeRequestOffset$outboundSchema.parse(
      restCollectMethodPostRestPaginationTypeRequestOffset,
    ),
  );
}
export function restCollectMethodPostRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestPaginationTypeRequestOffset$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodPostRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestCollectMethodPostRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restCollectMethodPostRestPaginationTypeResponseHeaderLinkToJSON(
  restCollectMethodPostRestPaginationTypeResponseHeaderLink:
    RestCollectMethodPostRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restCollectMethodPostRestPaginationTypeResponseHeaderLink),
  );
}
export function restCollectMethodPostRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodPostRestPaginationTypeResponseHeader$Outbound = {
  type: "response_header";
  attribute: Array<string>;
  maxPages: number;
};

/** @internal */
export const RestCollectMethodPostRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restCollectMethodPostRestPaginationTypeResponseHeaderToJSON(
  restCollectMethodPostRestPaginationTypeResponseHeader:
    RestCollectMethodPostRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestPaginationTypeResponseHeader$outboundSchema.parse(
      restCollectMethodPostRestPaginationTypeResponseHeader,
    ),
  );
}
export function restCollectMethodPostRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestPaginationTypeResponseHeader$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodPostRestPaginationTypeResponseBody$Outbound = {
  type: "response_body";
  attribute: Array<string>;
  maxPages: number;
  lastPageExpr?: string | undefined;
};

/** @internal */
export const RestCollectMethodPostRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restCollectMethodPostRestPaginationTypeResponseBodyToJSON(
  restCollectMethodPostRestPaginationTypeResponseBody:
    RestCollectMethodPostRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestPaginationTypeResponseBody$outboundSchema.parse(
      restCollectMethodPostRestPaginationTypeResponseBody,
    ),
  );
}
export function restCollectMethodPostRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestPaginationTypeResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodPostRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestCollectMethodPostRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restCollectMethodPostRestPaginationTypeNoneToJSON(
  restCollectMethodPostRestPaginationTypeNone:
    RestCollectMethodPostRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestPaginationTypeNone$outboundSchema.parse(
      restCollectMethodPostRestPaginationTypeNone,
    ),
  );
}
export function restCollectMethodPostRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostPaginationUnion$inboundSchema: z.ZodType<
  RestCollectMethodPostPaginationUnion,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() => RestCollectMethodPostRestPaginationTypeNone$inboundSchema),
  response_body: z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeResponseBody$inboundSchema
  ),
  response_header: z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeResponseHeader$inboundSchema
  ),
  response_header_link: z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeResponseHeaderLink$inboundSchema
  ),
  request_offset: z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeRequestOffset$inboundSchema
  ),
  request_page: z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeRequestPage$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodPostPaginationUnion$Outbound =
  | RestCollectMethodPostRestPaginationTypeNone$Outbound
  | RestCollectMethodPostRestPaginationTypeResponseBody$Outbound
  | RestCollectMethodPostRestPaginationTypeResponseHeader$Outbound
  | RestCollectMethodPostRestPaginationTypeResponseHeaderLink$Outbound
  | RestCollectMethodPostRestPaginationTypeRequestOffset$Outbound
  | RestCollectMethodPostRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestCollectMethodPostPaginationUnion$outboundSchema: z.ZodType<
  RestCollectMethodPostPaginationUnion$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostPaginationUnion
> = z.union([
  z.lazy(() => RestCollectMethodPostRestPaginationTypeNone$outboundSchema),
  z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeResponseBody$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeResponseHeader$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeResponseHeaderLink$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeRequestOffset$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeRequestPage$outboundSchema
  ),
]);

export function restCollectMethodPostPaginationUnionToJSON(
  restCollectMethodPostPaginationUnion: RestCollectMethodPostPaginationUnion,
): string {
  return JSON.stringify(
    RestCollectMethodPostPaginationUnion$outboundSchema.parse(
      restCollectMethodPostPaginationUnion,
    ),
  );
}
export function restCollectMethodPostPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostPaginationUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostPaginationUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostAuthentication$inboundSchema: z.ZodType<
  RestCollectMethodPostAuthentication,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodPostAuthentication);
/** @internal */
export const RestCollectMethodPostAuthentication$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodPostAuthentication
> = openEnums.outboundSchema(RestCollectMethodPostAuthentication);

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    multiplier: types.optional(types.number()),
    maxIntervalMs: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.boolean().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    multiplier: z.number().optional(),
    maxIntervalMs: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(restCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue),
  );
}
export function restCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    multiplier: types.optional(types.number()),
    maxIntervalMs: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: boolean | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.boolean().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    multiplier: z.number().optional(),
    maxIntervalMs: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(restCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse),
  );
}
export function restCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestCollectMethodPostRestRetryRulesTypeBackoff$Outbound =
  | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restCollectMethodPostRestRetryRulesTypeBackoffToJSON(
  restCollectMethodPostRestRetryRulesTypeBackoff:
    RestCollectMethodPostRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestRetryRulesTypeBackoff$outboundSchema.parse(
      restCollectMethodPostRestRetryRulesTypeBackoff,
    ),
  );
}
export function restCollectMethodPostRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestRetryRulesTypeBackoff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.boolean().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue:
    RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(restCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue),
  );
}
export function restCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: boolean | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.boolean().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse:
    RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(restCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse),
  );
}
export function restCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestCollectMethodPostRestRetryRulesTypeStatic$Outbound =
  | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restCollectMethodPostRestRetryRulesTypeStaticToJSON(
  restCollectMethodPostRestRetryRulesTypeStatic:
    RestCollectMethodPostRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestRetryRulesTypeStatic$outboundSchema.parse(
      restCollectMethodPostRestRetryRulesTypeStatic,
    ),
  );
}
export function restCollectMethodPostRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodPostRestRetryRulesTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restCollectMethodPostRestRetryRulesTypeNoneToJSON(
  restCollectMethodPostRestRetryRulesTypeNone:
    RestCollectMethodPostRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestRetryRulesTypeNone$outboundSchema.parse(
      restCollectMethodPostRestRetryRulesTypeNone,
    ),
  );
}
export function restCollectMethodPostRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRetryRules$inboundSchema: z.ZodType<
  RestCollectMethodPostRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() => RestCollectMethodPostRestRetryRulesTypeNone$inboundSchema),
  static: smartUnion([
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  backoff: smartUnion([
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
});
/** @internal */
export type RestCollectMethodPostRetryRules$Outbound =
  | RestCollectMethodPostRestRetryRulesTypeNone$Outbound
  | (
    | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$Outbound & {
      type: "static";
    }
  )
  | (
    | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestCollectMethodPostRetryRules$outboundSchema: z.ZodType<
  RestCollectMethodPostRetryRules$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostRetryRules
> = z.union([
  z.lazy(() => RestCollectMethodPostRestRetryRulesTypeNone$outboundSchema),
  smartUnion([
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  smartUnion([
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
]);

export function restCollectMethodPostRetryRulesToJSON(
  restCollectMethodPostRetryRules: RestCollectMethodPostRetryRules,
): string {
  return JSON.stringify(
    RestCollectMethodPostRetryRules$outboundSchema.parse(
      restCollectMethodPostRetryRules,
    ),
  );
}
export function restCollectMethodPostRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPostRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRetryRules' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostStateTracking$inboundSchema: z.ZodType<
  RestCollectMethodPostStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: types.optional(types.boolean()),
});
/** @internal */
export type RestCollectMethodPostStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestCollectMethodPostStateTracking$outboundSchema: z.ZodType<
  RestCollectMethodPostStateTracking$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restCollectMethodPostStateTrackingToJSON(
  restCollectMethodPostStateTracking: RestCollectMethodPostStateTracking,
): string {
  return JSON.stringify(
    RestCollectMethodPostStateTracking$outboundSchema.parse(
      restCollectMethodPostStateTracking,
    ),
  );
}
export function restCollectMethodPostStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostStateTracking' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostScheduling$inboundSchema: z.ZodType<
  RestCollectMethodPostScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestCollectMethodPostStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestCollectMethodPostScheduling$Outbound = {
  stateTracking?: RestCollectMethodPostStateTracking$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodPostScheduling$outboundSchema: z.ZodType<
  RestCollectMethodPostScheduling$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostScheduling
> = z.object({
  stateTracking: z.lazy(() => RestCollectMethodPostStateTracking$outboundSchema)
    .optional(),
});

export function restCollectMethodPostSchedulingToJSON(
  restCollectMethodPostScheduling: RestCollectMethodPostScheduling,
): string {
  return JSON.stringify(
    RestCollectMethodPostScheduling$outboundSchema.parse(
      restCollectMethodPostScheduling,
    ),
  );
}
export function restCollectMethodPostSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPostScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostScheduling' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPost$inboundSchema: z.ZodType<
  RestCollectMethodPost,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: RestCollectMethodPostCollectMethod$inboundSchema,
  collectRequestParams: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post:
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema,
      post_with_body:
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema,
      other:
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema,
    }).and(z.object({ discoverType: z.literal("http") })),
    json: RestCollectMethodPostRestDiscoveryDiscoverTypeJson$inboundSchema,
    list: RestCollectMethodPostRestDiscoveryDiscoverTypeList$inboundSchema,
    none: RestCollectMethodPostRestDiscoveryDiscoverTypeNone$inboundSchema,
  })),
  collectUrl: types.string(),
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  authentication: RestCollectMethodPostAuthentication$inboundSchema,
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestCollectMethodPostScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestCollectMethodPost$Outbound = {
  collectMethod: string;
  collectRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?:
    | (
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestCollectMethodPostRestDiscoveryDiscoverTypeJson$Outbound
    | RestCollectMethodPostRestDiscoveryDiscoverTypeList$Outbound
    | RestCollectMethodPostRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestCollectMethodPostRestPaginationTypeNone$Outbound
    | RestCollectMethodPostRestPaginationTypeResponseBody$Outbound
    | RestCollectMethodPostRestPaginationTypeResponseHeader$Outbound
    | RestCollectMethodPostRestPaginationTypeResponseHeaderLink$Outbound
    | RestCollectMethodPostRestPaginationTypeRequestOffset$Outbound
    | RestCollectMethodPostRestPaginationTypeRequestPage$Outbound
    | undefined;
  authentication: string;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestCollectMethodPostRestRetryRulesTypeNone$Outbound
    | (
      | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?: RestCollectMethodPostScheduling$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodPost$outboundSchema: z.ZodType<
  RestCollectMethodPost$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPost
> = z.object({
  collectMethod: RestCollectMethodPostCollectMethod$outboundSchema,
  collectRequestParams: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema,
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema,
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema,
    ]).and(z.object({ discoverType: z.literal("http") })),
    RestCollectMethodPostRestDiscoveryDiscoverTypeJson$outboundSchema,
    RestCollectMethodPostRestDiscoveryDiscoverTypeList$outboundSchema,
    RestCollectMethodPostRestDiscoveryDiscoverTypeNone$outboundSchema,
  ]).optional(),
  collectUrl: z.string(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() => RestCollectMethodPostRestPaginationTypeNone$outboundSchema),
    z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  authentication: RestCollectMethodPostAuthentication$outboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() => RestCollectMethodPostRestRetryRulesTypeNone$outboundSchema),
    smartUnion([
      z.lazy(() =>
        RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]).optional(),
  __scheduling: z.lazy(() => RestCollectMethodPostScheduling$outboundSchema)
    .optional(),
});

export function restCollectMethodPostToJSON(
  restCollectMethodPost: RestCollectMethodPost,
): string {
  return JSON.stringify(
    RestCollectMethodPost$outboundSchema.parse(restCollectMethodPost),
  );
}
export function restCollectMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPost, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPost$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPost' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetCollectMethod$inboundSchema: z.ZodType<
  RestCollectMethodGetCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodGetCollectMethod);
/** @internal */
export const RestCollectMethodGetCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodGetCollectMethod
> = openEnums.outboundSchema(RestCollectMethodGetCollectMethod);

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeNone$Outbound = {
  discoverType: "none";
};

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeNoneToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeNone:
    RestCollectMethodGetRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeNone$outboundSchema.parse(
      restCollectMethodGetRestDiscoveryDiscoverTypeNone,
    ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeList$Outbound = {
  discoverType: "list";
  itemList: Array<string>;
};

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeListToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeList:
    RestCollectMethodGetRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeList$outboundSchema.parse(
      restCollectMethodGetRestDiscoveryDiscoverTypeList,
    ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeList$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeJson$Outbound = {
  discoverType: "json";
  manualDiscoverResult: string;
  discoverDataField?: string | undefined;
};

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeJsonToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeJson:
    RestCollectMethodGetRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeJson$outboundSchema.parse(
      restCollectMethodGetRestDiscoveryDiscoverTypeJson,
    ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeJson$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.string(),
    discoverBody: types.optional(types.string()),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb: string;
    discoverBody?: string | undefined;
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.string(),
    discoverBody: z.string().optional(),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.string(),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody: string;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.string(),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.string(),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat: string;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.string(),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttp:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttp$outboundSchema.parse(
      restCollectMethodGetRestDiscoveryDiscoverTypeHttp,
    ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttp$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetDiscovery$inboundSchema: z.ZodType<
  RestCollectMethodGetDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestCollectMethodGetRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestCollectMethodGetRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestCollectMethodGetRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodGetDiscovery$Outbound =
  | (
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestCollectMethodGetRestDiscoveryDiscoverTypeJson$Outbound
  | RestCollectMethodGetRestDiscoveryDiscoverTypeList$Outbound
  | RestCollectMethodGetRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestCollectMethodGetDiscovery$outboundSchema: z.ZodType<
  RestCollectMethodGetDiscovery$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestCollectMethodGetRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodGetRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodGetRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restCollectMethodGetDiscoveryToJSON(
  restCollectMethodGetDiscovery: RestCollectMethodGetDiscovery,
): string {
  return JSON.stringify(
    RestCollectMethodGetDiscovery$outboundSchema.parse(
      restCollectMethodGetDiscovery,
    ),
  );
}
export function restCollectMethodGetDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGetDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetDiscovery' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodGetRestPaginationTypeRequestPage$Outbound = {
  type: "request_page";
  pageField: string;
  page?: number | undefined;
  sizeField: string;
  size: number;
  totalPageField?: string | undefined;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestCollectMethodGetRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodGetRestPaginationTypeRequestPageToJSON(
  restCollectMethodGetRestPaginationTypeRequestPage:
    RestCollectMethodGetRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestPaginationTypeRequestPage$outboundSchema.parse(
      restCollectMethodGetRestPaginationTypeRequestPage,
    ),
  );
}
export function restCollectMethodGetRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestPaginationTypeRequestPage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodGetRestPaginationTypeRequestOffset$Outbound = {
  type: "request_offset";
  offsetField: string;
  offset?: number | undefined;
  limitField: string;
  limit: number;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestCollectMethodGetRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodGetRestPaginationTypeRequestOffsetToJSON(
  restCollectMethodGetRestPaginationTypeRequestOffset:
    RestCollectMethodGetRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestPaginationTypeRequestOffset$outboundSchema.parse(
      restCollectMethodGetRestPaginationTypeRequestOffset,
    ),
  );
}
export function restCollectMethodGetRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestPaginationTypeRequestOffset$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodGetRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestCollectMethodGetRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restCollectMethodGetRestPaginationTypeResponseHeaderLinkToJSON(
  restCollectMethodGetRestPaginationTypeResponseHeaderLink:
    RestCollectMethodGetRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restCollectMethodGetRestPaginationTypeResponseHeaderLink),
  );
}
export function restCollectMethodGetRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodGetRestPaginationTypeResponseHeader$Outbound = {
  type: "response_header";
  attribute: Array<string>;
  maxPages: number;
};

/** @internal */
export const RestCollectMethodGetRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restCollectMethodGetRestPaginationTypeResponseHeaderToJSON(
  restCollectMethodGetRestPaginationTypeResponseHeader:
    RestCollectMethodGetRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestPaginationTypeResponseHeader$outboundSchema.parse(
      restCollectMethodGetRestPaginationTypeResponseHeader,
    ),
  );
}
export function restCollectMethodGetRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestPaginationTypeResponseHeader$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodGetRestPaginationTypeResponseBody$Outbound = {
  type: "response_body";
  attribute: Array<string>;
  maxPages: number;
  lastPageExpr?: string | undefined;
};

/** @internal */
export const RestCollectMethodGetRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restCollectMethodGetRestPaginationTypeResponseBodyToJSON(
  restCollectMethodGetRestPaginationTypeResponseBody:
    RestCollectMethodGetRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestPaginationTypeResponseBody$outboundSchema.parse(
      restCollectMethodGetRestPaginationTypeResponseBody,
    ),
  );
}
export function restCollectMethodGetRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestPaginationTypeResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestPaginationTypeNone$inboundSchema:
  z.ZodType<RestCollectMethodGetRestPaginationTypeNone, z.ZodTypeDef, unknown> =
    z.object({
      type: types.literal("none"),
    });
/** @internal */
export type RestCollectMethodGetRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestCollectMethodGetRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restCollectMethodGetRestPaginationTypeNoneToJSON(
  restCollectMethodGetRestPaginationTypeNone:
    RestCollectMethodGetRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestPaginationTypeNone$outboundSchema.parse(
      restCollectMethodGetRestPaginationTypeNone,
    ),
  );
}
export function restCollectMethodGetRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetPaginationUnion$inboundSchema: z.ZodType<
  RestCollectMethodGetPaginationUnion,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() => RestCollectMethodGetRestPaginationTypeNone$inboundSchema),
  response_body: z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeResponseBody$inboundSchema
  ),
  response_header: z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeResponseHeader$inboundSchema
  ),
  response_header_link: z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeResponseHeaderLink$inboundSchema
  ),
  request_offset: z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeRequestOffset$inboundSchema
  ),
  request_page: z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeRequestPage$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodGetPaginationUnion$Outbound =
  | RestCollectMethodGetRestPaginationTypeNone$Outbound
  | RestCollectMethodGetRestPaginationTypeResponseBody$Outbound
  | RestCollectMethodGetRestPaginationTypeResponseHeader$Outbound
  | RestCollectMethodGetRestPaginationTypeResponseHeaderLink$Outbound
  | RestCollectMethodGetRestPaginationTypeRequestOffset$Outbound
  | RestCollectMethodGetRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestCollectMethodGetPaginationUnion$outboundSchema: z.ZodType<
  RestCollectMethodGetPaginationUnion$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetPaginationUnion
> = z.union([
  z.lazy(() => RestCollectMethodGetRestPaginationTypeNone$outboundSchema),
  z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeResponseBody$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeResponseHeader$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeResponseHeaderLink$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeRequestOffset$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeRequestPage$outboundSchema
  ),
]);

export function restCollectMethodGetPaginationUnionToJSON(
  restCollectMethodGetPaginationUnion: RestCollectMethodGetPaginationUnion,
): string {
  return JSON.stringify(
    RestCollectMethodGetPaginationUnion$outboundSchema.parse(
      restCollectMethodGetPaginationUnion,
    ),
  );
}
export function restCollectMethodGetPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetPaginationUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetPaginationUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetAuthentication$inboundSchema: z.ZodType<
  RestCollectMethodGetAuthentication,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodGetAuthentication);
/** @internal */
export const RestCollectMethodGetAuthentication$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodGetAuthentication
> = openEnums.outboundSchema(RestCollectMethodGetAuthentication);

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    multiplier: types.optional(types.number()),
    maxIntervalMs: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.boolean().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    multiplier: z.number().optional(),
    maxIntervalMs: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(restCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue),
  );
}
export function restCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    multiplier: types.optional(types.number()),
    maxIntervalMs: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: boolean | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.boolean().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    multiplier: z.number().optional(),
    maxIntervalMs: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(restCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse),
  );
}
export function restCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestCollectMethodGetRestRetryRulesTypeBackoff$Outbound =
  | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restCollectMethodGetRestRetryRulesTypeBackoffToJSON(
  restCollectMethodGetRestRetryRulesTypeBackoff:
    RestCollectMethodGetRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestRetryRulesTypeBackoff$outboundSchema.parse(
      restCollectMethodGetRestRetryRulesTypeBackoff,
    ),
  );
}
export function restCollectMethodGetRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestRetryRulesTypeBackoff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.boolean().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue:
    RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(restCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue),
  );
}
export function restCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: boolean | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.boolean().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse:
    RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(restCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse),
  );
}
export function restCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestCollectMethodGetRestRetryRulesTypeStatic$Outbound =
  | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restCollectMethodGetRestRetryRulesTypeStaticToJSON(
  restCollectMethodGetRestRetryRulesTypeStatic:
    RestCollectMethodGetRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestRetryRulesTypeStatic$outboundSchema.parse(
      restCollectMethodGetRestRetryRulesTypeStatic,
    ),
  );
}
export function restCollectMethodGetRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<RestCollectMethodGetRestRetryRulesTypeNone, z.ZodTypeDef, unknown> =
    z.object({
      type: types.literal("none"),
    });
/** @internal */
export type RestCollectMethodGetRestRetryRulesTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restCollectMethodGetRestRetryRulesTypeNoneToJSON(
  restCollectMethodGetRestRetryRulesTypeNone:
    RestCollectMethodGetRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestRetryRulesTypeNone$outboundSchema.parse(
      restCollectMethodGetRestRetryRulesTypeNone,
    ),
  );
}
export function restCollectMethodGetRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRetryRules$inboundSchema: z.ZodType<
  RestCollectMethodGetRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() => RestCollectMethodGetRestRetryRulesTypeNone$inboundSchema),
  static: smartUnion([
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  backoff: smartUnion([
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
});
/** @internal */
export type RestCollectMethodGetRetryRules$Outbound =
  | RestCollectMethodGetRestRetryRulesTypeNone$Outbound
  | (
    | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$Outbound & {
      type: "static";
    }
  )
  | (
    | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound & {
      type: "backoff";
    }
  );

/** @internal */
export const RestCollectMethodGetRetryRules$outboundSchema: z.ZodType<
  RestCollectMethodGetRetryRules$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetRetryRules
> = z.union([
  z.lazy(() => RestCollectMethodGetRestRetryRulesTypeNone$outboundSchema),
  smartUnion([
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  smartUnion([
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
]);

export function restCollectMethodGetRetryRulesToJSON(
  restCollectMethodGetRetryRules: RestCollectMethodGetRetryRules,
): string {
  return JSON.stringify(
    RestCollectMethodGetRetryRules$outboundSchema.parse(
      restCollectMethodGetRetryRules,
    ),
  );
}
export function restCollectMethodGetRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGetRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRetryRules' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetStateTracking$inboundSchema: z.ZodType<
  RestCollectMethodGetStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: types.optional(types.boolean()),
});
/** @internal */
export type RestCollectMethodGetStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestCollectMethodGetStateTracking$outboundSchema: z.ZodType<
  RestCollectMethodGetStateTracking$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restCollectMethodGetStateTrackingToJSON(
  restCollectMethodGetStateTracking: RestCollectMethodGetStateTracking,
): string {
  return JSON.stringify(
    RestCollectMethodGetStateTracking$outboundSchema.parse(
      restCollectMethodGetStateTracking,
    ),
  );
}
export function restCollectMethodGetStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGetStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetStateTracking' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetScheduling$inboundSchema: z.ZodType<
  RestCollectMethodGetScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestCollectMethodGetStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestCollectMethodGetScheduling$Outbound = {
  stateTracking?: RestCollectMethodGetStateTracking$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodGetScheduling$outboundSchema: z.ZodType<
  RestCollectMethodGetScheduling$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetScheduling
> = z.object({
  stateTracking: z.lazy(() => RestCollectMethodGetStateTracking$outboundSchema)
    .optional(),
});

export function restCollectMethodGetSchedulingToJSON(
  restCollectMethodGetScheduling: RestCollectMethodGetScheduling,
): string {
  return JSON.stringify(
    RestCollectMethodGetScheduling$outboundSchema.parse(
      restCollectMethodGetScheduling,
    ),
  );
}
export function restCollectMethodGetSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGetScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetScheduling' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGet$inboundSchema: z.ZodType<
  RestCollectMethodGet,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: RestCollectMethodGetCollectMethod$inboundSchema,
  collectRequestParams: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodGetRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestCollectMethodGetRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestCollectMethodGetRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestCollectMethodGetRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestCollectMethodGetRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestCollectMethodGetRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  authentication: RestCollectMethodGetAuthentication$inboundSchema,
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestCollectMethodGetScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestCollectMethodGet$Outbound = {
  collectMethod: string;
  collectRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?:
    | (
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestCollectMethodGetRestDiscoveryDiscoverTypeJson$Outbound
    | RestCollectMethodGetRestDiscoveryDiscoverTypeList$Outbound
    | RestCollectMethodGetRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestCollectMethodGetRestPaginationTypeNone$Outbound
    | RestCollectMethodGetRestPaginationTypeResponseBody$Outbound
    | RestCollectMethodGetRestPaginationTypeResponseHeader$Outbound
    | RestCollectMethodGetRestPaginationTypeResponseHeaderLink$Outbound
    | RestCollectMethodGetRestPaginationTypeRequestOffset$Outbound
    | RestCollectMethodGetRestPaginationTypeRequestPage$Outbound
    | undefined;
  authentication: string;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestCollectMethodGetRestRetryRulesTypeNone$Outbound
    | (
      | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?: RestCollectMethodGetScheduling$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodGet$outboundSchema: z.ZodType<
  RestCollectMethodGet$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGet
> = z.object({
  collectMethod: RestCollectMethodGetCollectMethod$outboundSchema,
  collectRequestParams: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() => RestCollectMethodGetRestPaginationTypeNone$outboundSchema),
    z.lazy(() =>
      RestCollectMethodGetRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  authentication: RestCollectMethodGetAuthentication$outboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() => RestCollectMethodGetRestRetryRulesTypeNone$outboundSchema),
    smartUnion([
      z.lazy(() =>
        RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]).optional(),
  __scheduling: z.lazy(() => RestCollectMethodGetScheduling$outboundSchema)
    .optional(),
});

export function restCollectMethodGetToJSON(
  restCollectMethodGet: RestCollectMethodGet,
): string {
  return JSON.stringify(
    RestCollectMethodGet$outboundSchema.parse(restCollectMethodGet),
  );
}
export function restCollectMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGet, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGet$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGet' from JSON`,
  );
}

/** @internal */
export const RestCollectorConf$inboundSchema: z.ZodType<
  RestCollectorConf,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("authentication", {
  none: RestAuthenticationNone$inboundSchema,
  basic: RestAuthenticationBasic$inboundSchema,
  basicSecret: RestAuthenticationBasicSecret$inboundSchema,
  login: RestAuthenticationLogin$inboundSchema.and(
    z.object({ authentication: z.literal("login") }),
  ),
  loginSecret: RestAuthenticationLoginSecret$inboundSchema.and(
    z.object({ authentication: z.literal("loginSecret") }),
  ),
  oauth: RestAuthenticationOauth$inboundSchema,
  oauthSecret: RestAuthenticationOauthSecret$inboundSchema,
  google_oauth: RestAuthenticationGoogleOauth$inboundSchema,
  google_oauthSecret: RestAuthenticationGoogleOauthSecret$inboundSchema,
  hmac: RestAuthenticationHmac$inboundSchema,
});
/** @internal */
export type RestCollectorConf$Outbound =
  | RestAuthenticationNone$Outbound
  | RestAuthenticationBasic$Outbound
  | RestAuthenticationBasicSecret$Outbound
  | (RestAuthenticationLogin$Outbound & { authentication: "login" })
  | (RestAuthenticationLoginSecret$Outbound & { authentication: "loginSecret" })
  | RestAuthenticationOauth$Outbound
  | RestAuthenticationOauthSecret$Outbound
  | RestAuthenticationGoogleOauth$Outbound
  | RestAuthenticationGoogleOauthSecret$Outbound
  | RestAuthenticationHmac$Outbound;

/** @internal */
export const RestCollectorConf$outboundSchema: z.ZodType<
  RestCollectorConf$Outbound,
  z.ZodTypeDef,
  RestCollectorConf
> = z.union([
  RestAuthenticationNone$outboundSchema,
  RestAuthenticationBasic$outboundSchema,
  RestAuthenticationBasicSecret$outboundSchema,
  RestAuthenticationLogin$outboundSchema.and(
    z.object({ authentication: z.literal("login") }),
  ),
  RestAuthenticationLoginSecret$outboundSchema.and(
    z.object({ authentication: z.literal("loginSecret") }),
  ),
  RestAuthenticationOauth$outboundSchema,
  RestAuthenticationOauthSecret$outboundSchema,
  RestAuthenticationGoogleOauth$outboundSchema,
  RestAuthenticationGoogleOauthSecret$outboundSchema,
  RestAuthenticationHmac$outboundSchema,
]);

export function restCollectorConfToJSON(
  restCollectorConf: RestCollectorConf,
): string {
  return JSON.stringify(
    RestCollectorConf$outboundSchema.parse(restCollectorConf),
  );
}
export function restCollectorConfFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectorConf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectorConf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectorConf' from JSON`,
  );
}
