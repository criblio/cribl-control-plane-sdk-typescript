/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as discriminatedUnionTypes from "../types/discriminatedUnion.js";
import { discriminatedUnion } from "../types/discriminatedUnion.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeRestCollectMethodGetCollectRequestParams,
  ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound,
  ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
} from "./itemstyperestcollectmethodgetcollectrequestparams.js";

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationHmacDiscovery =
  | (
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeJson
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeList
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationHmacCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationHmacCollectMethod = OpenEnum<
  typeof RestAuthenticationHmacCollectMethod
>;

export type RestAuthenticationHmacRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationHmacRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationHmacRestPaginationTypeResponseHeaderLink = {
  type: "response_header_link";
  /**
   * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
   */
  nextRelationAttribute: string;
  /**
   * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
   */
  curRelationAttribute?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationHmacRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationHmacRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestAuthenticationHmacRestPaginationTypeNone = {
  type: "none";
};

export type RestAuthenticationHmacPaginationUnion =
  | RestAuthenticationHmacRestPaginationTypeNone
  | RestAuthenticationHmacRestPaginationTypeResponseBody
  | RestAuthenticationHmacRestPaginationTypeResponseHeader
  | RestAuthenticationHmacRestPaginationTypeResponseHeaderLink
  | RestAuthenticationHmacRestPaginationTypeRequestOffset
  | RestAuthenticationHmacRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue = {
  enableHeader?: any | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse = {
  enableHeader?: any | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationHmacRestRetryRulesTypeBackoff =
  | RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue = {
  enableHeader?: any | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse = {
  enableHeader?: any | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestAuthenticationHmacRestRetryRulesTypeStatic =
  | RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse
  | RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestAuthenticationHmacRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationHmacRetryRules =
  | RestAuthenticationHmacRestRetryRulesTypeNone
  | (
    | RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse
    | RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue & {
      type: "static";
    }
  )
  | (
    | RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue & {
      type: "backoff";
    }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationHmacStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationHmacScheduling = {
  stateTracking?: RestAuthenticationHmacStateTracking | undefined;
};

export type RestAuthenticationHmac = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
   */
  authentication: "hmac";
  /**
   * Select or create an HMAC Function to use with authentication
   */
  hmacFunctionId: string;
  discovery?:
    | (
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeJson
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeList
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationHmacCollectMethod;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationHmacRestPaginationTypeNone
    | RestAuthenticationHmacRestPaginationTypeResponseBody
    | RestAuthenticationHmacRestPaginationTypeResponseHeader
    | RestAuthenticationHmacRestPaginationTypeResponseHeaderLink
    | RestAuthenticationHmacRestPaginationTypeRequestOffset
    | RestAuthenticationHmacRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationHmacRestRetryRulesTypeNone
    | (
      | RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse
      | RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue & {
        type: "static";
      }
    )
    | (
      | RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue & {
        type: "backoff";
      }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestAuthenticationHmacScheduling | undefined;
};

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationGoogleOauthSecretDiscovery =
  | (
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationGoogleOauthSecretCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationGoogleOauthSecretCollectMethod = OpenEnum<
  typeof RestAuthenticationGoogleOauthSecretCollectMethod
>;

export type RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset =
  {
    type: "request_offset";
    /**
     * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
     */
    offsetField: string;
    /**
     * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
     */
    offset?: number | undefined;
    /**
     * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
     */
    limitField: string;
    /**
     * Maximum number of records to collect per request
     */
    limit: number;
    /**
     * Name of the attribute in the response that contains the total number of records for the query
     */
    totalRecordField?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
     */
    zeroIndexed: boolean;
  };

export type RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink =
  {
    type: "response_header_link";
    /**
     * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
     */
    nextRelationAttribute: string;
    /**
     * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
     */
    curRelationAttribute?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader =
  {
    type: "response_header";
    /**
     * Names of attributes within the response that contain next-page information
     */
    attribute: Array<string>;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody =
  {
    type: "response_body";
    /**
     * Names of attributes within the response that contain next-page information
     */
    attribute: Array<string>;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
     */
    lastPageExpr?: string | undefined;
  };

export type RestAuthenticationGoogleOauthSecretRestPaginationTypeNone = {
  type: "none";
};

export type RestAuthenticationGoogleOauthSecretPaginationUnion =
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeNone
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse =
  {
    enableHeader?: any | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff =
  | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

export type RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse =
  {
    enableHeader?: any | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

export type RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic =
  | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse
  | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationGoogleOauthSecretRetryRules =
  | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone
  | (
    | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse
    | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue
      & { type: "static" }
  )
  | (
    | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue
      & { type: "backoff" }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationGoogleOauthSecretStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationGoogleOauthSecretScheduling = {
  stateTracking?: RestAuthenticationGoogleOauthSecretStateTracking | undefined;
};

export type RestAuthenticationGoogleOauthSecret = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
   */
  authentication: "google_oauthSecret";
  /**
   * Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information.
   */
  scopes: Array<string>;
  /**
   * Select or create a text secret that contains the Google service account credentials value
   */
  textSecret: string;
  /**
   * Email address of a user account with Super Admin permissions to the resources the collector will retrieve
   */
  subject: string;
  discovery?:
    | (
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationGoogleOauthSecretCollectMethod;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeNone
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone
    | (
      | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse
      | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue
        & { type: "static" }
    )
    | (
      | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue
        & { type: "backoff" }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestAuthenticationGoogleOauthSecretScheduling | undefined;
};

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationGoogleOauthDiscovery =
  | (
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationGoogleOauthCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationGoogleOauthCollectMethod = OpenEnum<
  typeof RestAuthenticationGoogleOauthCollectMethod
>;

export type RestAuthenticationGoogleOauthRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink =
  {
    type: "response_header_link";
    /**
     * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
     */
    nextRelationAttribute: string;
    /**
     * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
     */
    curRelationAttribute?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationGoogleOauthRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestAuthenticationGoogleOauthRestPaginationTypeNone = {
  type: "none";
};

export type RestAuthenticationGoogleOauthPaginationUnion =
  | RestAuthenticationGoogleOauthRestPaginationTypeNone
  | RestAuthenticationGoogleOauthRestPaginationTypeResponseBody
  | RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader
  | RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink
  | RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset
  | RestAuthenticationGoogleOauthRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse =
  {
    enableHeader?: any | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff =
  | RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

export type RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse =
  {
    enableHeader?: any | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

export type RestAuthenticationGoogleOauthRestRetryRulesTypeStatic =
  | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse
  | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestAuthenticationGoogleOauthRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationGoogleOauthRetryRules =
  | RestAuthenticationGoogleOauthRestRetryRulesTypeNone
  | (
    | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse
    | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue & {
      type: "static";
    }
  )
  | (
    | RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue & {
      type: "backoff";
    }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationGoogleOauthStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationGoogleOauthScheduling = {
  stateTracking?: RestAuthenticationGoogleOauthStateTracking | undefined;
};

export type RestAuthenticationGoogleOauth = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
   */
  authentication: "google_oauth";
  /**
   * Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information.
   */
  scopes: Array<string>;
  /**
   * Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right.
   */
  serviceAccountCredentials: string;
  /**
   * Email address of a user account with Super Admin permissions to the resources the collector will retrieve
   */
  subject: string;
  discovery?:
    | (
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationGoogleOauthCollectMethod;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationGoogleOauthRestPaginationTypeNone
    | RestAuthenticationGoogleOauthRestPaginationTypeResponseBody
    | RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader
    | RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink
    | RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset
    | RestAuthenticationGoogleOauthRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationGoogleOauthRestRetryRulesTypeNone
    | (
      | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse
      | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue
        & { type: "static" }
    )
    | (
      | RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue
        & { type: "backoff" }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestAuthenticationGoogleOauthScheduling | undefined;
};

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationOauthSecretDiscovery =
  | (
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationOauthSecretCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationOauthSecretCollectMethod = OpenEnum<
  typeof RestAuthenticationOauthSecretCollectMethod
>;

export type RestAuthenticationOauthSecretRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationOauthSecretRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink =
  {
    type: "response_header_link";
    /**
     * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
     */
    nextRelationAttribute: string;
    /**
     * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
     */
    curRelationAttribute?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationOauthSecretRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationOauthSecretRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestAuthenticationOauthSecretRestPaginationTypeNone = {
  type: "none";
};

export type RestAuthenticationOauthSecretPaginationUnion =
  | RestAuthenticationOauthSecretRestPaginationTypeNone
  | RestAuthenticationOauthSecretRestPaginationTypeResponseBody
  | RestAuthenticationOauthSecretRestPaginationTypeResponseHeader
  | RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink
  | RestAuthenticationOauthSecretRestPaginationTypeRequestOffset
  | RestAuthenticationOauthSecretRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse =
  {
    enableHeader?: any | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationOauthSecretRestRetryRulesTypeBackoff =
  | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

export type RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse =
  {
    enableHeader?: any | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

export type RestAuthenticationOauthSecretRestRetryRulesTypeStatic =
  | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse
  | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestAuthenticationOauthSecretRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationOauthSecretRetryRules =
  | RestAuthenticationOauthSecretRestRetryRulesTypeNone
  | (
    | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse
    | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue & {
      type: "static";
    }
  )
  | (
    | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue & {
      type: "backoff";
    }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationOauthSecretStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationOauthSecretScheduling = {
  stateTracking?: RestAuthenticationOauthSecretStateTracking | undefined;
};

export type RestAuthenticationOauthSecret = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
   */
  authentication: "oauthSecret";
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl: string;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName: string;
  /**
   * Select or create a text secret that contains the client secret's value
   */
  textSecret: string;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationOauthSecretCollectMethod;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationOauthSecretRestPaginationTypeNone
    | RestAuthenticationOauthSecretRestPaginationTypeResponseBody
    | RestAuthenticationOauthSecretRestPaginationTypeResponseHeader
    | RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink
    | RestAuthenticationOauthSecretRestPaginationTypeRequestOffset
    | RestAuthenticationOauthSecretRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationOauthSecretRestRetryRulesTypeNone
    | (
      | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse
      | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue
        & { type: "static" }
    )
    | (
      | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue
        & { type: "backoff" }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestAuthenticationOauthSecretScheduling | undefined;
};

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationOauthDiscovery =
  | (
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeJson
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeList
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationOauthCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationOauthCollectMethod = OpenEnum<
  typeof RestAuthenticationOauthCollectMethod
>;

export type RestAuthenticationOauthRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationOauthRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationOauthRestPaginationTypeResponseHeaderLink = {
  type: "response_header_link";
  /**
   * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
   */
  nextRelationAttribute: string;
  /**
   * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
   */
  curRelationAttribute?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationOauthRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationOauthRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestAuthenticationOauthRestPaginationTypeNone = {
  type: "none";
};

export type RestAuthenticationOauthPaginationUnion =
  | RestAuthenticationOauthRestPaginationTypeNone
  | RestAuthenticationOauthRestPaginationTypeResponseBody
  | RestAuthenticationOauthRestPaginationTypeResponseHeader
  | RestAuthenticationOauthRestPaginationTypeResponseHeaderLink
  | RestAuthenticationOauthRestPaginationTypeRequestOffset
  | RestAuthenticationOauthRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue = {
  enableHeader?: any | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse =
  {
    enableHeader?: any | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationOauthRestRetryRulesTypeBackoff =
  | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue = {
  enableHeader?: any | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse = {
  enableHeader?: any | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestAuthenticationOauthRestRetryRulesTypeStatic =
  | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse
  | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestAuthenticationOauthRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationOauthRetryRules =
  | RestAuthenticationOauthRestRetryRulesTypeNone
  | (
    | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse
    | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue & {
      type: "static";
    }
  )
  | (
    | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue & {
      type: "backoff";
    }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationOauthStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationOauthScheduling = {
  stateTracking?: RestAuthenticationOauthStateTracking | undefined;
};

export type RestAuthenticationOauth = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
   */
  authentication: "oauth";
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl: string;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName: string;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters.
   */
  clientSecretParamValue: string;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeJson
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeList
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationOauthCollectMethod;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationOauthRestPaginationTypeNone
    | RestAuthenticationOauthRestPaginationTypeResponseBody
    | RestAuthenticationOauthRestPaginationTypeResponseHeader
    | RestAuthenticationOauthRestPaginationTypeResponseHeaderLink
    | RestAuthenticationOauthRestPaginationTypeRequestOffset
    | RestAuthenticationOauthRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationOauthRestRetryRulesTypeNone
    | (
      | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse
      | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue & {
        type: "static";
      }
    )
    | (
      | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue & {
        type: "backoff";
      }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestAuthenticationOauthScheduling | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication =
  {
    None: "none",
    Basic: "basic",
    BasicSecret: "basicSecret",
    Login: "login",
    LoginSecret: "loginSecret",
    Oauth: "oauth",
    OauthSecret: "oauthSecret",
    GoogleOauth: "google_oauth",
    GoogleOauthSecret: "google_oauthSecret",
    Hmac: "hmac",
  } as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "none";
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "list";
    /**
     * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
     */
    itemList: Array<string>;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "json";
    /**
     * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
     */
    manualDiscoverResult: string;
    /**
     * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
     */
    discoverDataField?: string | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery =
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage =
  {
    type: "request_page";
    /**
     * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
     */
    pageField: string;
    /**
     * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
     */
    page?: number | undefined;
    /**
     * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
     */
    sizeField: string;
    /**
     * Maximum number of records to collect per page
     */
    size: number;
    /**
     * Name of the attribute in the response that contains the total number of pages for the query
     */
    totalPageField?: string | undefined;
    /**
     * Name of the attribute in the response that contains the total number of records for the query
     */
    totalRecordField?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
     */
    zeroIndexed: boolean;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset =
  {
    type: "request_offset";
    /**
     * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
     */
    offsetField: string;
    /**
     * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
     */
    offset?: number | undefined;
    /**
     * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
     */
    limitField: string;
    /**
     * Maximum number of records to collect per request
     */
    limit: number;
    /**
     * Name of the attribute in the response that contains the total number of records for the query
     */
    totalRecordField?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
     */
    zeroIndexed: boolean;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink =
  {
    type: "response_header_link";
    /**
     * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
     */
    nextRelationAttribute: string;
    /**
     * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
     */
    curRelationAttribute?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader =
  {
    type: "response_header";
    /**
     * Names of attributes within the response that contain next-page information
     */
    attribute: Array<string>;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody =
  {
    type: "response_body";
    /**
     * Names of attributes within the response that contain next-page information
     */
    attribute: Array<string>;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
     */
    lastPageExpr?: string | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone =
  {
    type: "none";
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse =
  {
    enableHeader?: any | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse =
  {
    enableHeader?: any | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone =
  {
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: "none";
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    enableHeader?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue
      & { type: "static" }
  )
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue
      & { type: "backoff" }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking =
  {
    /**
     * Track collection progress between consecutive scheduled executions
     */
    enabled?: boolean | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling =
  {
    stateTracking?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking
      | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue = {
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
   */
  authentication:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication;
  /**
   * URL to use for login API call. This call is expected to be a POST.
   */
  loginUrl: string;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret: string;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody: string;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone
    | (
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue
        & { type: "static" }
    )
    | (
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue
        & { type: "backoff" }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling
    | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication =
  {
    None: "none",
    Basic: "basic",
    BasicSecret: "basicSecret",
    Login: "login",
    LoginSecret: "loginSecret",
    Oauth: "oauth",
    OauthSecret: "oauthSecret",
    GoogleOauth: "google_oauth",
    GoogleOauthSecret: "google_oauthSecret",
    Hmac: "hmac",
  } as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "none";
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "list";
    /**
     * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
     */
    itemList: Array<string>;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "json";
    /**
     * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
     */
    manualDiscoverResult: string;
    /**
     * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
     */
    discoverDataField?: string | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery =
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage =
  {
    type: "request_page";
    /**
     * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
     */
    pageField: string;
    /**
     * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
     */
    page?: number | undefined;
    /**
     * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
     */
    sizeField: string;
    /**
     * Maximum number of records to collect per page
     */
    size: number;
    /**
     * Name of the attribute in the response that contains the total number of pages for the query
     */
    totalPageField?: string | undefined;
    /**
     * Name of the attribute in the response that contains the total number of records for the query
     */
    totalRecordField?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
     */
    zeroIndexed: boolean;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset =
  {
    type: "request_offset";
    /**
     * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
     */
    offsetField: string;
    /**
     * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
     */
    offset?: number | undefined;
    /**
     * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
     */
    limitField: string;
    /**
     * Maximum number of records to collect per request
     */
    limit: number;
    /**
     * Name of the attribute in the response that contains the total number of records for the query
     */
    totalRecordField?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
     */
    zeroIndexed: boolean;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink =
  {
    type: "response_header_link";
    /**
     * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
     */
    nextRelationAttribute: string;
    /**
     * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
     */
    curRelationAttribute?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader =
  {
    type: "response_header";
    /**
     * Names of attributes within the response that contain next-page information
     */
    attribute: Array<string>;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody =
  {
    type: "response_body";
    /**
     * Names of attributes within the response that contain next-page information
     */
    attribute: Array<string>;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
     */
    lastPageExpr?: string | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone =
  {
    type: "none";
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse =
  {
    enableHeader?: any | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse =
  {
    enableHeader?: any | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone =
  {
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: "none";
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    enableHeader?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue
      & { type: "static" }
  )
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue
      & { type: "backoff" }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking =
  {
    /**
     * Track collection progress between consecutive scheduled executions
     */
    enabled?: boolean | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling =
  {
    stateTracking?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking
      | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse = {
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
   */
  authentication:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication;
  /**
   * URL to use for login API call. This call is expected to be a POST.
   */
  loginUrl: string;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret: string;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody: string;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone
    | (
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue
        & { type: "static" }
    )
    | (
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue
        & { type: "backoff" }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling
    | undefined;
};

export type RestAuthenticationLoginSecret =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue;

/**
 * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "none";
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "list";
    /**
     * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
     */
    itemList: Array<string>;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "json";
    /**
     * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
     */
    manualDiscoverResult: string;
    /**
     * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
     */
    discoverDataField?: string | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery =
  | (
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage =
  {
    type: "request_page";
    /**
     * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
     */
    pageField: string;
    /**
     * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
     */
    page?: number | undefined;
    /**
     * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
     */
    sizeField: string;
    /**
     * Maximum number of records to collect per page
     */
    size: number;
    /**
     * Name of the attribute in the response that contains the total number of pages for the query
     */
    totalPageField?: string | undefined;
    /**
     * Name of the attribute in the response that contains the total number of records for the query
     */
    totalRecordField?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
     */
    zeroIndexed: boolean;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset =
  {
    type: "request_offset";
    /**
     * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
     */
    offsetField: string;
    /**
     * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
     */
    offset?: number | undefined;
    /**
     * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
     */
    limitField: string;
    /**
     * Maximum number of records to collect per request
     */
    limit: number;
    /**
     * Name of the attribute in the response that contains the total number of records for the query
     */
    totalRecordField?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
     */
    zeroIndexed: boolean;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink =
  {
    type: "response_header_link";
    /**
     * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
     */
    nextRelationAttribute: string;
    /**
     * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
     */
    curRelationAttribute?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader =
  {
    type: "response_header";
    /**
     * Names of attributes within the response that contain next-page information
     */
    attribute: Array<string>;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody =
  {
    type: "response_body";
    /**
     * Names of attributes within the response that contain next-page information
     */
    attribute: Array<string>;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
     */
    lastPageExpr?: string | undefined;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone =
  {
    type: "none";
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion =
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse =
  {
    enableHeader?: any | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff =
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse =
  {
    enableHeader?: any | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic =
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone =
  {
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: "none";
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    enableHeader?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules =
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone
  | (
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue
      & { type: "static" }
  )
  | (
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue
      & { type: "backoff" }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling = {
  stateTracking?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking
    | undefined;
};

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrue = {
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
   */
  authentication:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication;
  /**
   * URL to use for login API call. This call is expected to be a POST.
   */
  loginUrl: string;
  username: string;
  password: string;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody: string;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression used to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone
    | (
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue
        & { type: "static" }
    )
    | (
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue
        & { type: "backoff" }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling
    | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication =
  {
    None: "none",
    Basic: "basic",
    BasicSecret: "basicSecret",
    Login: "login",
    LoginSecret: "loginSecret",
    Oauth: "oauth",
    OauthSecret: "oauthSecret",
    GoogleOauth: "google_oauth",
    GoogleOauthSecret: "google_oauthSecret",
    Hmac: "hmac",
  } as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "none";
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "list";
    /**
     * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
     */
    itemList: Array<string>;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "json";
    /**
     * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
     */
    manualDiscoverResult: string;
    /**
     * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
     */
    discoverDataField?: string | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery =
  | (
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage =
  {
    type: "request_page";
    /**
     * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
     */
    pageField: string;
    /**
     * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
     */
    page?: number | undefined;
    /**
     * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
     */
    sizeField: string;
    /**
     * Maximum number of records to collect per page
     */
    size: number;
    /**
     * Name of the attribute in the response that contains the total number of pages for the query
     */
    totalPageField?: string | undefined;
    /**
     * Name of the attribute in the response that contains the total number of records for the query
     */
    totalRecordField?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
     */
    zeroIndexed: boolean;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset =
  {
    type: "request_offset";
    /**
     * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
     */
    offsetField: string;
    /**
     * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
     */
    offset?: number | undefined;
    /**
     * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
     */
    limitField: string;
    /**
     * Maximum number of records to collect per request
     */
    limit: number;
    /**
     * Name of the attribute in the response that contains the total number of records for the query
     */
    totalRecordField?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
     */
    zeroIndexed: boolean;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink =
  {
    type: "response_header_link";
    /**
     * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
     */
    nextRelationAttribute: string;
    /**
     * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
     */
    curRelationAttribute?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader =
  {
    type: "response_header";
    /**
     * Names of attributes within the response that contain next-page information
     */
    attribute: Array<string>;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody =
  {
    type: "response_body";
    /**
     * Names of attributes within the response that contain next-page information
     */
    attribute: Array<string>;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
     */
    lastPageExpr?: string | undefined;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone =
  {
    type: "none";
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnion =
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse =
  {
    enableHeader?: any | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff =
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse =
  {
    enableHeader?: any | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic =
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone =
  {
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: "none";
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    enableHeader?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules =
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone
  | (
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue
      & { type: "static" }
  )
  | (
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue
      & { type: "backoff" }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling = {
  stateTracking?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking
    | undefined;
};

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalse = {
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
   */
  authentication:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication;
  /**
   * URL to use for login API call. This call is expected to be a POST.
   */
  loginUrl: string;
  username: string;
  password: string;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody: string;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression used to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone
    | (
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue
        & { type: "static" }
    )
    | (
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue
        & { type: "backoff" }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling
    | undefined;
};

export type RestAuthenticationLogin =
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalse
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrue;

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationBasicSecretDiscovery =
  | (
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationBasicSecretCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationBasicSecretCollectMethod = OpenEnum<
  typeof RestAuthenticationBasicSecretCollectMethod
>;

export type RestAuthenticationBasicSecretRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationBasicSecretRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink =
  {
    type: "response_header_link";
    /**
     * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
     */
    nextRelationAttribute: string;
    /**
     * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
     */
    curRelationAttribute?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationBasicSecretRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationBasicSecretRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestAuthenticationBasicSecretRestPaginationTypeNone = {
  type: "none";
};

export type RestAuthenticationBasicSecretPaginationUnion =
  | RestAuthenticationBasicSecretRestPaginationTypeNone
  | RestAuthenticationBasicSecretRestPaginationTypeResponseBody
  | RestAuthenticationBasicSecretRestPaginationTypeResponseHeader
  | RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink
  | RestAuthenticationBasicSecretRestPaginationTypeRequestOffset
  | RestAuthenticationBasicSecretRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse =
  {
    enableHeader?: any | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationBasicSecretRestRetryRulesTypeBackoff =
  | RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

export type RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse =
  {
    enableHeader?: any | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

export type RestAuthenticationBasicSecretRestRetryRulesTypeStatic =
  | RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse
  | RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestAuthenticationBasicSecretRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationBasicSecretRetryRules =
  | RestAuthenticationBasicSecretRestRetryRulesTypeNone
  | (
    | RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse
    | RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue & {
      type: "static";
    }
  )
  | (
    | RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue & {
      type: "backoff";
    }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationBasicSecretStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationBasicSecretScheduling = {
  stateTracking?: RestAuthenticationBasicSecretStateTracking | undefined;
};

export type RestAuthenticationBasicSecret = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
   */
  authentication: "basicSecret";
  /**
   * Select or create a stored secret that references your credentials
   */
  credentialsSecret: string;
  discovery?:
    | (
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationBasicSecretCollectMethod;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationBasicSecretRestPaginationTypeNone
    | RestAuthenticationBasicSecretRestPaginationTypeResponseBody
    | RestAuthenticationBasicSecretRestPaginationTypeResponseHeader
    | RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink
    | RestAuthenticationBasicSecretRestPaginationTypeRequestOffset
    | RestAuthenticationBasicSecretRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationBasicSecretRestRetryRulesTypeNone
    | (
      | RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse
      | RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue
        & { type: "static" }
    )
    | (
      | RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue
        & { type: "backoff" }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestAuthenticationBasicSecretScheduling | undefined;
};

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationBasicDiscovery =
  | (
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeJson
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeList
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationBasicCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationBasicCollectMethod = OpenEnum<
  typeof RestAuthenticationBasicCollectMethod
>;

export type RestAuthenticationBasicRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationBasicRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationBasicRestPaginationTypeResponseHeaderLink = {
  type: "response_header_link";
  /**
   * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
   */
  nextRelationAttribute: string;
  /**
   * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
   */
  curRelationAttribute?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationBasicRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationBasicRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestAuthenticationBasicRestPaginationTypeNone = {
  type: "none";
};

export type RestAuthenticationBasicPaginationUnion =
  | RestAuthenticationBasicRestPaginationTypeNone
  | RestAuthenticationBasicRestPaginationTypeResponseBody
  | RestAuthenticationBasicRestPaginationTypeResponseHeader
  | RestAuthenticationBasicRestPaginationTypeResponseHeaderLink
  | RestAuthenticationBasicRestPaginationTypeRequestOffset
  | RestAuthenticationBasicRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue = {
  enableHeader?: any | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse =
  {
    enableHeader?: any | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationBasicRestRetryRulesTypeBackoff =
  | RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue = {
  enableHeader?: any | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse = {
  enableHeader?: any | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestAuthenticationBasicRestRetryRulesTypeStatic =
  | RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse
  | RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestAuthenticationBasicRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationBasicRetryRules =
  | RestAuthenticationBasicRestRetryRulesTypeNone
  | (
    | RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse
    | RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue & {
      type: "static";
    }
  )
  | (
    | RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue & {
      type: "backoff";
    }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationBasicStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationBasicScheduling = {
  stateTracking?: RestAuthenticationBasicStateTracking | undefined;
};

export type RestAuthenticationBasic = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
   */
  authentication: "basic";
  username: string;
  password: string;
  discovery?:
    | (
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeJson
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeList
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationBasicCollectMethod;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationBasicRestPaginationTypeNone
    | RestAuthenticationBasicRestPaginationTypeResponseBody
    | RestAuthenticationBasicRestPaginationTypeResponseHeader
    | RestAuthenticationBasicRestPaginationTypeResponseHeaderLink
    | RestAuthenticationBasicRestPaginationTypeRequestOffset
    | RestAuthenticationBasicRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationBasicRestRetryRulesTypeNone
    | (
      | RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse
      | RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue & {
        type: "static";
      }
    )
    | (
      | RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue & {
        type: "backoff";
      }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestAuthenticationBasicScheduling | undefined;
};

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationNoneDiscovery =
  | (
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeJson
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeList
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationNoneCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationNoneCollectMethod = OpenEnum<
  typeof RestAuthenticationNoneCollectMethod
>;

export type RestAuthenticationNoneRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationNoneRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationNoneRestPaginationTypeResponseHeaderLink = {
  type: "response_header_link";
  /**
   * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
   */
  nextRelationAttribute: string;
  /**
   * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
   */
  curRelationAttribute?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationNoneRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationNoneRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestAuthenticationNoneRestPaginationTypeNone = {
  type: "none";
};

export type RestAuthenticationNonePaginationUnion =
  | RestAuthenticationNoneRestPaginationTypeNone
  | RestAuthenticationNoneRestPaginationTypeResponseBody
  | RestAuthenticationNoneRestPaginationTypeResponseHeader
  | RestAuthenticationNoneRestPaginationTypeResponseHeaderLink
  | RestAuthenticationNoneRestPaginationTypeRequestOffset
  | RestAuthenticationNoneRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue = {
  enableHeader?: any | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse = {
  enableHeader?: any | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationNoneRestRetryRulesTypeBackoff =
  | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue = {
  enableHeader?: any | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse = {
  enableHeader?: any | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestAuthenticationNoneRestRetryRulesTypeStatic =
  | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse
  | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestAuthenticationNoneRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationNoneRetryRules =
  | RestAuthenticationNoneRestRetryRulesTypeNone
  | (
    | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse
    | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue & {
      type: "static";
    }
  )
  | (
    | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue & {
      type: "backoff";
    }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationNoneStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationNoneScheduling = {
  stateTracking?: RestAuthenticationNoneStateTracking | undefined;
};

export type RestAuthenticationNone = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
   */
  authentication: "none";
  discovery?:
    | (
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeJson
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeList
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationNoneCollectMethod;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationNoneRestPaginationTypeNone
    | RestAuthenticationNoneRestPaginationTypeResponseBody
    | RestAuthenticationNoneRestPaginationTypeResponseHeader
    | RestAuthenticationNoneRestPaginationTypeResponseHeaderLink
    | RestAuthenticationNoneRestPaginationTypeRequestOffset
    | RestAuthenticationNoneRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationNoneRestRetryRulesTypeNone
    | (
      | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse
      | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue & {
        type: "static";
      }
    )
    | (
      | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue & {
        type: "backoff";
      }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestAuthenticationNoneScheduling | undefined;
};

export const RestCollectMethodOtherCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestCollectMethodOtherCollectMethod = OpenEnum<
  typeof RestCollectMethodOtherCollectMethod
>;

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp =
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestCollectMethodOtherDiscovery =
  | (
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeJson
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeList
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export type RestCollectMethodOtherRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodOtherRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodOtherRestPaginationTypeResponseHeaderLink = {
  type: "response_header_link";
  /**
   * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
   */
  nextRelationAttribute: string;
  /**
   * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
   */
  curRelationAttribute?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestCollectMethodOtherRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestCollectMethodOtherRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestCollectMethodOtherRestPaginationTypeNone = {
  type: "none";
};

export type RestCollectMethodOtherPaginationUnion =
  | RestCollectMethodOtherRestPaginationTypeNone
  | RestCollectMethodOtherRestPaginationTypeResponseBody
  | RestCollectMethodOtherRestPaginationTypeResponseHeader
  | RestCollectMethodOtherRestPaginationTypeResponseHeaderLink
  | RestCollectMethodOtherRestPaginationTypeRequestOffset
  | RestCollectMethodOtherRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

/**
 * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
 */
export const RestCollectMethodOtherAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
 */
export type RestCollectMethodOtherAuthentication = OpenEnum<
  typeof RestCollectMethodOtherAuthentication
>;

export type RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue = {
  enableHeader?: any | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse = {
  enableHeader?: any | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodOtherRestRetryRulesTypeBackoff =
  | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue = {
  enableHeader?: any | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse = {
  enableHeader?: any | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestCollectMethodOtherRestRetryRulesTypeStatic =
  | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse
  | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestCollectMethodOtherRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodOtherRetryRules =
  | RestCollectMethodOtherRestRetryRulesTypeNone
  | (
    | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse
    | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue & {
      type: "static";
    }
  )
  | (
    | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue & {
      type: "backoff";
    }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestCollectMethodOtherStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestCollectMethodOtherScheduling = {
  stateTracking?: RestCollectMethodOtherStateTracking | undefined;
};

export type RestCollectMethodOther = {
  collectMethod: RestCollectMethodOtherCollectMethod;
  /**
   * Custom HTTP method to use for the Collect operation
   */
  collectVerb: string;
  /**
   * Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`
   */
  collectBody?: string | undefined;
  collectRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | (
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeJson
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeList
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestCollectMethodOtherRestPaginationTypeNone
    | RestCollectMethodOtherRestPaginationTypeResponseBody
    | RestCollectMethodOtherRestPaginationTypeResponseHeader
    | RestCollectMethodOtherRestPaginationTypeResponseHeaderLink
    | RestCollectMethodOtherRestPaginationTypeRequestOffset
    | RestCollectMethodOtherRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
   */
  authentication: RestCollectMethodOtherAuthentication;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestCollectMethodOtherRestRetryRulesTypeNone
    | (
      | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse
      | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue & {
        type: "static";
      }
    )
    | (
      | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue & {
        type: "backoff";
      }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestCollectMethodOtherScheduling | undefined;
};

export const RestCollectMethodPostWithBodyCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestCollectMethodPostWithBodyCollectMethod = OpenEnum<
  typeof RestCollectMethodPostWithBodyCollectMethod
>;

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp =
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestCollectMethodPostWithBodyDiscovery =
  | (
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export type RestCollectMethodPostWithBodyRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink =
  {
    type: "response_header_link";
    /**
     * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
     */
    nextRelationAttribute: string;
    /**
     * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
     */
    curRelationAttribute?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestCollectMethodPostWithBodyRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestCollectMethodPostWithBodyRestPaginationTypeNone = {
  type: "none";
};

export type RestCollectMethodPostWithBodyPaginationUnion =
  | RestCollectMethodPostWithBodyRestPaginationTypeNone
  | RestCollectMethodPostWithBodyRestPaginationTypeResponseBody
  | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader
  | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink
  | RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset
  | RestCollectMethodPostWithBodyRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

/**
 * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
 */
export const RestCollectMethodPostWithBodyAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
 */
export type RestCollectMethodPostWithBodyAuthentication = OpenEnum<
  typeof RestCollectMethodPostWithBodyAuthentication
>;

export type RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse =
  {
    enableHeader?: any | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff =
  | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

export type RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse =
  {
    enableHeader?: any | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

export type RestCollectMethodPostWithBodyRestRetryRulesTypeStatic =
  | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse
  | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestCollectMethodPostWithBodyRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodPostWithBodyRetryRules =
  | RestCollectMethodPostWithBodyRestRetryRulesTypeNone
  | (
    | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse
    | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue & {
      type: "static";
    }
  )
  | (
    | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue & {
      type: "backoff";
    }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestCollectMethodPostWithBodyStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestCollectMethodPostWithBodyScheduling = {
  stateTracking?: RestCollectMethodPostWithBodyStateTracking | undefined;
};

export type RestCollectMethodPostWithBody = {
  collectMethod: RestCollectMethodPostWithBodyCollectMethod;
  /**
   * Template for POST body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template params: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`
   */
  collectBody: string;
  discovery?:
    | (
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestCollectMethodPostWithBodyRestPaginationTypeNone
    | RestCollectMethodPostWithBodyRestPaginationTypeResponseBody
    | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader
    | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink
    | RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset
    | RestCollectMethodPostWithBodyRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
   */
  authentication: RestCollectMethodPostWithBodyAuthentication;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestCollectMethodPostWithBodyRestRetryRulesTypeNone
    | (
      | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse
      | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue
        & { type: "static" }
    )
    | (
      | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue
        & { type: "backoff" }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestCollectMethodPostWithBodyScheduling | undefined;
};

export const RestCollectMethodPostCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestCollectMethodPostCollectMethod = OpenEnum<
  typeof RestCollectMethodPostCollectMethod
>;

export type RestCollectMethodPostRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestCollectMethodPostRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestCollectMethodPostRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttp =
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestCollectMethodPostDiscovery =
  | (
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestCollectMethodPostRestDiscoveryDiscoverTypeJson
  | RestCollectMethodPostRestDiscoveryDiscoverTypeList
  | RestCollectMethodPostRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export type RestCollectMethodPostRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodPostRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodPostRestPaginationTypeResponseHeaderLink = {
  type: "response_header_link";
  /**
   * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
   */
  nextRelationAttribute: string;
  /**
   * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
   */
  curRelationAttribute?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestCollectMethodPostRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestCollectMethodPostRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestCollectMethodPostRestPaginationTypeNone = {
  type: "none";
};

export type RestCollectMethodPostPaginationUnion =
  | RestCollectMethodPostRestPaginationTypeNone
  | RestCollectMethodPostRestPaginationTypeResponseBody
  | RestCollectMethodPostRestPaginationTypeResponseHeader
  | RestCollectMethodPostRestPaginationTypeResponseHeaderLink
  | RestCollectMethodPostRestPaginationTypeRequestOffset
  | RestCollectMethodPostRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

/**
 * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
 */
export const RestCollectMethodPostAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
 */
export type RestCollectMethodPostAuthentication = OpenEnum<
  typeof RestCollectMethodPostAuthentication
>;

export type RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue = {
  enableHeader?: any | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse = {
  enableHeader?: any | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodPostRestRetryRulesTypeBackoff =
  | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue = {
  enableHeader?: any | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse = {
  enableHeader?: any | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestCollectMethodPostRestRetryRulesTypeStatic =
  | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse
  | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestCollectMethodPostRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodPostRetryRules =
  | RestCollectMethodPostRestRetryRulesTypeNone
  | (
    | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse
    | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue & {
      type: "static";
    }
  )
  | (
    | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue & {
      type: "backoff";
    }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestCollectMethodPostStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestCollectMethodPostScheduling = {
  stateTracking?: RestCollectMethodPostStateTracking | undefined;
};

export type RestCollectMethodPost = {
  collectMethod: RestCollectMethodPostCollectMethod;
  collectRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | (
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestCollectMethodPostRestDiscoveryDiscoverTypeJson
    | RestCollectMethodPostRestDiscoveryDiscoverTypeList
    | RestCollectMethodPostRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestCollectMethodPostRestPaginationTypeNone
    | RestCollectMethodPostRestPaginationTypeResponseBody
    | RestCollectMethodPostRestPaginationTypeResponseHeader
    | RestCollectMethodPostRestPaginationTypeResponseHeaderLink
    | RestCollectMethodPostRestPaginationTypeRequestOffset
    | RestCollectMethodPostRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
   */
  authentication: RestCollectMethodPostAuthentication;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestCollectMethodPostRestRetryRulesTypeNone
    | (
      | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse
      | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue & {
        type: "static";
      }
    )
    | (
      | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue & {
        type: "backoff";
      }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestCollectMethodPostScheduling | undefined;
};

export const RestCollectMethodGetCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestCollectMethodGetCollectMethod = OpenEnum<
  typeof RestCollectMethodGetCollectMethod
>;

export type RestCollectMethodGetRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestCollectMethodGetRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestCollectMethodGetRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttp =
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestCollectMethodGetDiscovery =
  | (
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestCollectMethodGetRestDiscoveryDiscoverTypeJson
  | RestCollectMethodGetRestDiscoveryDiscoverTypeList
  | RestCollectMethodGetRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export type RestCollectMethodGetRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodGetRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodGetRestPaginationTypeResponseHeaderLink = {
  type: "response_header_link";
  /**
   * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
   */
  nextRelationAttribute: string;
  /**
   * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
   */
  curRelationAttribute?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestCollectMethodGetRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestCollectMethodGetRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestCollectMethodGetRestPaginationTypeNone = {
  type: "none";
};

export type RestCollectMethodGetPaginationUnion =
  | RestCollectMethodGetRestPaginationTypeNone
  | RestCollectMethodGetRestPaginationTypeResponseBody
  | RestCollectMethodGetRestPaginationTypeResponseHeader
  | RestCollectMethodGetRestPaginationTypeResponseHeaderLink
  | RestCollectMethodGetRestPaginationTypeRequestOffset
  | RestCollectMethodGetRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

/**
 * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
 */
export const RestCollectMethodGetAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
 */
export type RestCollectMethodGetAuthentication = OpenEnum<
  typeof RestCollectMethodGetAuthentication
>;

export type RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue = {
  enableHeader?: any | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse = {
  enableHeader?: any | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodGetRestRetryRulesTypeBackoff =
  | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue = {
  enableHeader?: any | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse = {
  enableHeader?: any | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestCollectMethodGetRestRetryRulesTypeStatic =
  | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse
  | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestCollectMethodGetRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodGetRetryRules =
  | RestCollectMethodGetRestRetryRulesTypeNone
  | (
    | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse
    | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue & {
      type: "static";
    }
  )
  | (
    | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue & {
      type: "backoff";
    }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestCollectMethodGetStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestCollectMethodGetScheduling = {
  stateTracking?: RestCollectMethodGetStateTracking | undefined;
};

export type RestCollectMethodGet = {
  collectMethod: RestCollectMethodGetCollectMethod;
  collectRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | (
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestCollectMethodGetRestDiscoveryDiscoverTypeJson
    | RestCollectMethodGetRestDiscoveryDiscoverTypeList
    | RestCollectMethodGetRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestCollectMethodGetRestPaginationTypeNone
    | RestCollectMethodGetRestPaginationTypeResponseBody
    | RestCollectMethodGetRestPaginationTypeResponseHeader
    | RestCollectMethodGetRestPaginationTypeResponseHeaderLink
    | RestCollectMethodGetRestPaginationTypeRequestOffset
    | RestCollectMethodGetRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
   */
  authentication: RestCollectMethodGetAuthentication;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestCollectMethodGetRestRetryRulesTypeNone
    | (
      | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse
      | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue & {
        type: "static";
      }
    )
    | (
      | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue & {
        type: "backoff";
      }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestCollectMethodGetScheduling | undefined;
};

export type RestCollectorConf =
  | RestAuthenticationNone
  | RestAuthenticationBasic
  | RestAuthenticationBasicSecret
  | (
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalse
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrue & {
      authentication: "login";
    }
  )
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue & {
      authentication: "loginSecret";
    }
  )
  | RestAuthenticationOauth
  | RestAuthenticationOauthSecret
  | RestAuthenticationGoogleOauth
  | RestAuthenticationGoogleOauthSecret
  | RestAuthenticationHmac
  | discriminatedUnionTypes.Unknown<"authentication">;

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$Outbound = {
  discoverType: "none";
};

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeNone:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$outboundSchema.parse(
      restAuthenticationHmacRestDiscoveryDiscoverTypeNone,
    ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeList$Outbound = {
  discoverType: "list";
  itemList: Array<string>;
};

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeList:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeList$outboundSchema.parse(
      restAuthenticationHmacRestDiscoveryDiscoverTypeList,
    ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeList$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$Outbound = {
  discoverType: "json";
  manualDiscoverResult: string;
  discoverDataField?: string | undefined;
};

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeJson:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$outboundSchema.parse(
      restAuthenticationHmacRestDiscoveryDiscoverTypeJson,
    ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationHmacRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp$outboundSchema.parse(
      restAuthenticationHmacRestDiscoveryDiscoverTypeHttp,
    ),
  );
}
export function restAuthenticationHmacRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationHmacRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationHmacDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestAuthenticationHmacRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationHmacDiscovery$Outbound =
  | (
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationHmacDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationHmacDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmacDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationHmacRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restAuthenticationHmacDiscoveryToJSON(
  restAuthenticationHmacDiscovery: RestAuthenticationHmacDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationHmacDiscovery$outboundSchema.parse(
      restAuthenticationHmacDiscovery,
    ),
  );
}
export function restAuthenticationHmacDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmacDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationHmacDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacCollectMethod$inboundSchema: z.ZodType<
  RestAuthenticationHmacCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationHmacCollectMethod);
/** @internal */
export const RestAuthenticationHmacCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationHmacCollectMethod
> = openEnums.outboundSchema(RestAuthenticationHmacCollectMethod);

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationHmacRestPaginationTypeRequestPage$Outbound = {
  type: "request_page";
  pageField: string;
  page?: number | undefined;
  sizeField: string;
  size: number;
  totalPageField?: string | undefined;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationHmacRestPaginationTypeRequestPageToJSON(
  restAuthenticationHmacRestPaginationTypeRequestPage:
    RestAuthenticationHmacRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestPaginationTypeRequestPage$outboundSchema.parse(
      restAuthenticationHmacRestPaginationTypeRequestPage,
    ),
  );
}
export function restAuthenticationHmacRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestPaginationTypeRequestPage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationHmacRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationHmacRestPaginationTypeRequestOffset$Outbound = {
  type: "request_offset";
  offsetField: string;
  offset?: number | undefined;
  limitField: string;
  limit: number;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationHmacRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationHmacRestPaginationTypeRequestOffset:
    RestAuthenticationHmacRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestPaginationTypeRequestOffset$outboundSchema.parse(
      restAuthenticationHmacRestPaginationTypeRequestOffset,
    ),
  );
}
export function restAuthenticationHmacRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestPaginationTypeRequestOffset$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationHmacRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationHmacRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationHmacRestPaginationTypeResponseHeaderLink:
    RestAuthenticationHmacRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restAuthenticationHmacRestPaginationTypeResponseHeaderLink),
  );
}
export function restAuthenticationHmacRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationHmacRestPaginationTypeResponseHeader$Outbound = {
  type: "response_header";
  attribute: Array<string>;
  maxPages: number;
};

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationHmacRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationHmacRestPaginationTypeResponseHeader:
    RestAuthenticationHmacRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestPaginationTypeResponseHeader$outboundSchema.parse(
      restAuthenticationHmacRestPaginationTypeResponseHeader,
    ),
  );
}
export function restAuthenticationHmacRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationHmacRestPaginationTypeResponseBody$Outbound = {
  type: "response_body";
  attribute: Array<string>;
  maxPages: number;
  lastPageExpr?: string | undefined;
};

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationHmacRestPaginationTypeResponseBodyToJSON(
  restAuthenticationHmacRestPaginationTypeResponseBody:
    RestAuthenticationHmacRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestPaginationTypeResponseBody$outboundSchema.parse(
      restAuthenticationHmacRestPaginationTypeResponseBody,
    ),
  );
}
export function restAuthenticationHmacRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestPaginationTypeResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationHmacRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationHmacRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestAuthenticationHmacRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationHmacRestPaginationTypeNoneToJSON(
  restAuthenticationHmacRestPaginationTypeNone:
    RestAuthenticationHmacRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestPaginationTypeNone$outboundSchema.parse(
      restAuthenticationHmacRestPaginationTypeNone,
    ),
  );
}
export function restAuthenticationHmacRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationHmacRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacPaginationUnion$inboundSchema: z.ZodType<
  RestAuthenticationHmacPaginationUnion,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationHmacRestPaginationTypeNone$inboundSchema
  ),
  response_body: z.lazy(() =>
    RestAuthenticationHmacRestPaginationTypeResponseBody$inboundSchema
  ),
  response_header: z.lazy(() =>
    RestAuthenticationHmacRestPaginationTypeResponseHeader$inboundSchema
  ),
  response_header_link: z.lazy(() =>
    RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$inboundSchema
  ),
  request_offset: z.lazy(() =>
    RestAuthenticationHmacRestPaginationTypeRequestOffset$inboundSchema
  ),
  request_page: z.lazy(() =>
    RestAuthenticationHmacRestPaginationTypeRequestPage$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationHmacPaginationUnion$Outbound =
  | RestAuthenticationHmacRestPaginationTypeNone$Outbound
  | RestAuthenticationHmacRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationHmacRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationHmacRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationHmacRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationHmacPaginationUnion$outboundSchema: z.ZodType<
  RestAuthenticationHmacPaginationUnion$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmacPaginationUnion
> = z.union([
  z.lazy(() => RestAuthenticationHmacRestPaginationTypeNone$outboundSchema),
  z.lazy(() =>
    RestAuthenticationHmacRestPaginationTypeResponseBody$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationHmacRestPaginationTypeResponseHeader$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationHmacRestPaginationTypeRequestOffset$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationHmacRestPaginationTypeRequestPage$outboundSchema
  ),
]);

export function restAuthenticationHmacPaginationUnionToJSON(
  restAuthenticationHmacPaginationUnion: RestAuthenticationHmacPaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationHmacPaginationUnion$outboundSchema.parse(
      restAuthenticationHmacPaginationUnion,
    ),
  );
}
export function restAuthenticationHmacPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmacPaginationUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacPaginationUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(restAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue),
  );
}
export function restAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(restAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse),
  );
}
export function restAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationHmacRestRetryRulesTypeBackoff$Outbound =
  | RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationHmacRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationHmacRestRetryRulesTypeBackoffToJSON(
  restAuthenticationHmacRestRetryRulesTypeBackoff:
    RestAuthenticationHmacRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestRetryRulesTypeBackoff$outboundSchema.parse(
      restAuthenticationHmacRestRetryRulesTypeBackoff,
    ),
  );
}
export function restAuthenticationHmacRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestRetryRulesTypeBackoff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationHmacRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue:
    RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(restAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue),
  );
}
export function restAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse:
    RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(restAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse),
  );
}
export function restAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationHmacRestRetryRulesTypeStatic$Outbound =
  | RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationHmacRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationHmacRestRetryRulesTypeStaticToJSON(
  restAuthenticationHmacRestRetryRulesTypeStatic:
    RestAuthenticationHmacRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestRetryRulesTypeStatic$outboundSchema.parse(
      restAuthenticationHmacRestRetryRulesTypeStatic,
    ),
  );
}
export function restAuthenticationHmacRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationHmacRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationHmacRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationHmacRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationHmacRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationHmacRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationHmacRestRetryRulesTypeNoneToJSON(
  restAuthenticationHmacRestRetryRulesTypeNone:
    RestAuthenticationHmacRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRestRetryRulesTypeNone$outboundSchema.parse(
      restAuthenticationHmacRestRetryRulesTypeNone,
    ),
  );
}
export function restAuthenticationHmacRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationHmacRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationHmacRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationHmacRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationHmacRestRetryRulesTypeNone$inboundSchema
  ),
  static: smartUnion([
    z.lazy(() =>
      RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  backoff: smartUnion([
    z.lazy(() =>
      RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
});
/** @internal */
export type RestAuthenticationHmacRetryRules$Outbound =
  | RestAuthenticationHmacRestRetryRulesTypeNone$Outbound
  | (
    | RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
      & { type: "static" }
  )
  | (
    | RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestAuthenticationHmacRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationHmacRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmacRetryRules
> = z.union([
  z.lazy(() => RestAuthenticationHmacRestRetryRulesTypeNone$outboundSchema),
  smartUnion([
    z.lazy(() =>
      RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  smartUnion([
    z.lazy(() =>
      RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
]);

export function restAuthenticationHmacRetryRulesToJSON(
  restAuthenticationHmacRetryRules: RestAuthenticationHmacRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRetryRules$outboundSchema.parse(
      restAuthenticationHmacRetryRules,
    ),
  );
}
export function restAuthenticationHmacRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmacRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationHmacRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacStateTracking$inboundSchema: z.ZodType<
  RestAuthenticationHmacStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: types.optional(types.boolean()),
});
/** @internal */
export type RestAuthenticationHmacStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationHmacStateTracking$outboundSchema: z.ZodType<
  RestAuthenticationHmacStateTracking$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmacStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restAuthenticationHmacStateTrackingToJSON(
  restAuthenticationHmacStateTracking: RestAuthenticationHmacStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationHmacStateTracking$outboundSchema.parse(
      restAuthenticationHmacStateTracking,
    ),
  );
}
export function restAuthenticationHmacStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmacStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacScheduling$inboundSchema: z.ZodType<
  RestAuthenticationHmacScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestAuthenticationHmacStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationHmacScheduling$Outbound = {
  stateTracking?: RestAuthenticationHmacStateTracking$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationHmacScheduling$outboundSchema: z.ZodType<
  RestAuthenticationHmacScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmacScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationHmacStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationHmacSchedulingToJSON(
  restAuthenticationHmacScheduling: RestAuthenticationHmacScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationHmacScheduling$outboundSchema.parse(
      restAuthenticationHmacScheduling,
    ),
  );
}
export function restAuthenticationHmacSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmacScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationHmacScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmac$inboundSchema: z.ZodType<
  RestAuthenticationHmac,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("hmac"),
  hmacFunctionId: types.string(),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectMethod: RestAuthenticationHmacCollectMethod$inboundSchema,
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationHmacRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationHmacRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationHmacRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationHmacRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationHmacRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationHmacRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestAuthenticationHmacScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationHmac$Outbound = {
  authentication: "hmac";
  hmacFunctionId: string;
  discovery?:
    | (
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationHmacRestPaginationTypeNone$Outbound
    | RestAuthenticationHmacRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationHmacRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationHmacRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationHmacRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationHmacRestRetryRulesTypeNone$Outbound
    | (
      | RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?: RestAuthenticationHmacScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationHmac$outboundSchema: z.ZodType<
  RestAuthenticationHmac$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmac
> = z.object({
  authentication: z.literal("hmac"),
  hmacFunctionId: z.string(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationHmacCollectMethod$outboundSchema,
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() => RestAuthenticationHmacRestPaginationTypeNone$outboundSchema),
    z.lazy(() =>
      RestAuthenticationHmacRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationHmacRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() => RestAuthenticationHmacRestRetryRulesTypeNone$outboundSchema),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]).optional(),
  __scheduling: z.lazy(() => RestAuthenticationHmacScheduling$outboundSchema)
    .optional(),
});

export function restAuthenticationHmacToJSON(
  restAuthenticationHmac: RestAuthenticationHmac,
): string {
  return JSON.stringify(
    RestAuthenticationHmac$outboundSchema.parse(restAuthenticationHmac),
  );
}
export function restAuthenticationHmacFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmac, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationHmac$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmac' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$Outbound =
  {
    discoverType: "none";
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$outboundSchema
      .parse(restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$Outbound =
  {
    discoverType: "list";
    itemList: Array<string>;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$outboundSchema
      .parse(restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$Outbound =
  {
    discoverType: "json";
    manualDiscoverResult: string;
    discoverDataField?: string | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$outboundSchema
      .parse(restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp$outboundSchema
      .parse(restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp),
  );
}
export function restAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretDiscovery$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretDiscovery,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretDiscovery$Outbound =
  | (
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationGoogleOauthSecretDiscovery$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretDiscovery$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretDiscovery
  > = z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]);

export function restAuthenticationGoogleOauthSecretDiscoveryToJSON(
  restAuthenticationGoogleOauthSecretDiscovery:
    RestAuthenticationGoogleOauthSecretDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretDiscovery$outboundSchema.parse(
      restAuthenticationGoogleOauthSecretDiscovery,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretDiscovery,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretDiscovery$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretCollectMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretCollectMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RestAuthenticationGoogleOauthSecretCollectMethod);
/** @internal */
export const RestAuthenticationGoogleOauthSecretCollectMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretCollectMethod
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthSecretCollectMethod,
  );

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$Outbound =
  {
    type: "request_page";
    pageField: string;
    page?: number | undefined;
    sizeField: string;
    size: number;
    totalPageField?: string | undefined;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationGoogleOauthSecretRestPaginationTypeRequestPageToJSON(
  restAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage:
    RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$outboundSchema
      .parse(restAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage),
  );
}
export function restAuthenticationGoogleOauthSecretRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$Outbound =
  {
    type: "request_offset";
    offsetField: string;
    offset?: number | undefined;
    limitField: string;
    limit: number;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset:
    RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink:
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$Outbound =
  {
    type: "response_header";
    attribute: Array<string>;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader:
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$Outbound =
  {
    type: "response_body";
    attribute: Array<string>;
    maxPages: number;
    lastPageExpr?: string | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestPaginationTypeResponseBodyToJSON(
  restAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody:
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$outboundSchema
      .parse(restAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody),
  );
}
export function restAuthenticationGoogleOauthSecretRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$Outbound =
  {
    type: "none";
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationGoogleOauthSecretRestPaginationTypeNoneToJSON(
  restAuthenticationGoogleOauthSecretRestPaginationTypeNone:
    RestAuthenticationGoogleOauthSecretRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$outboundSchema
      .parse(restAuthenticationGoogleOauthSecretRestPaginationTypeNone),
  );
}
export function restAuthenticationGoogleOauthSecretRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretPaginationUnion$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretPaginationUnion,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretPaginationUnion$Outbound =
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$Outbound
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationGoogleOauthSecretPaginationUnion$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretPaginationUnion$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretPaginationUnion
  > = z.union([
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$outboundSchema
    ),
  ]);

export function restAuthenticationGoogleOauthSecretPaginationUnionToJSON(
  restAuthenticationGoogleOauthSecretPaginationUnion:
    RestAuthenticationGoogleOauthSecretPaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretPaginationUnion$outboundSchema.parse(
      restAuthenticationGoogleOauthSecretPaginationUnion,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretPaginationUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretPaginationUnion$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff$Outbound =
  | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffToJSON(
  restAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff:
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff$outboundSchema
      .parse(restAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff),
  );
}
export function restAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue:
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse:
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic$Outbound =
  | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticToJSON(
  restAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic:
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic$outboundSchema
      .parse(restAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic),
  );
}
export function restAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$Outbound =
  {
    type: "none";
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    enableHeader?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationGoogleOauthSecretRestRetryRulesTypeNoneToJSON(
  restAuthenticationGoogleOauthSecretRestRetryRulesTypeNone:
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$outboundSchema
      .parse(restAuthenticationGoogleOauthSecretRestRetryRulesTypeNone),
  );
}
export function restAuthenticationGoogleOauthSecretRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRetryRules$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRetryRules,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRetryRules$Outbound =
  | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$Outbound
  | (
    | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
      & { type: "static" }
  )
  | (
    | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestAuthenticationGoogleOauthSecretRetryRules$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRetryRules$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRetryRules
  > = z.union([
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$outboundSchema
    ),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]);

export function restAuthenticationGoogleOauthSecretRetryRulesToJSON(
  restAuthenticationGoogleOauthSecretRetryRules:
    RestAuthenticationGoogleOauthSecretRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRetryRules$outboundSchema.parse(
      restAuthenticationGoogleOauthSecretRetryRules,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretStateTracking$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretStateTracking,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enabled: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthSecretStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthSecretStateTrackingToJSON(
  restAuthenticationGoogleOauthSecretStateTracking:
    RestAuthenticationGoogleOauthSecretStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretStateTracking$outboundSchema.parse(
      restAuthenticationGoogleOauthSecretStateTracking,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretScheduling$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretScheduling,
    z.ZodTypeDef,
    unknown
  > = z.object({
    stateTracking: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretStateTracking$inboundSchema
      ),
    ),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretScheduling$Outbound = {
  stateTracking?:
    | RestAuthenticationGoogleOauthSecretStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthSecretScheduling$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretScheduling$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretScheduling
  > = z.object({
    stateTracking: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretStateTracking$outboundSchema
    ).optional(),
  });

export function restAuthenticationGoogleOauthSecretSchedulingToJSON(
  restAuthenticationGoogleOauthSecretScheduling:
    RestAuthenticationGoogleOauthSecretScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretScheduling$outboundSchema.parse(
      restAuthenticationGoogleOauthSecretScheduling,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecret$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("google_oauthSecret"),
  scopes: z.array(types.string()),
  textSecret: types.string(),
  subject: types.string(),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectMethod: RestAuthenticationGoogleOauthSecretCollectMethod$inboundSchema,
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestAuthenticationGoogleOauthSecretScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationGoogleOauthSecret$Outbound = {
  authentication: "google_oauthSecret";
  scopes: Array<string>;
  textSecret: string;
  subject: string;
  discovery?:
    | (
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$Outbound
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$Outbound
    | (
      | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?:
    | RestAuthenticationGoogleOauthSecretScheduling$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthSecret$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthSecret$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauthSecret
> = z.object({
  authentication: z.literal("google_oauthSecret"),
  scopes: z.array(z.string()),
  textSecret: z.string(),
  subject: z.string(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectMethod:
    RestAuthenticationGoogleOauthSecretCollectMethod$outboundSchema,
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() =>
      RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone$outboundSchema
    ),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationGoogleOauthSecretScheduling$outboundSchema
  ).optional(),
});

export function restAuthenticationGoogleOauthSecretToJSON(
  restAuthenticationGoogleOauthSecret: RestAuthenticationGoogleOauthSecret,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecret$outboundSchema.parse(
      restAuthenticationGoogleOauthSecret,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationGoogleOauthSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecret' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$Outbound =
  {
    discoverType: "none";
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$outboundSchema
      .parse(restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$Outbound =
  {
    discoverType: "list";
    itemList: Array<string>;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$outboundSchema
      .parse(restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$Outbound =
  {
    discoverType: "json";
    manualDiscoverResult: string;
    discoverDataField?: string | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$outboundSchema
      .parse(restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp$outboundSchema
      .parse(restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp),
  );
}
export function restAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationGoogleOauthDiscovery$Outbound =
  | (
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationGoogleOauthDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauthDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restAuthenticationGoogleOauthDiscoveryToJSON(
  restAuthenticationGoogleOauthDiscovery:
    RestAuthenticationGoogleOauthDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthDiscovery$outboundSchema.parse(
      restAuthenticationGoogleOauthDiscovery,
    ),
  );
}
export function restAuthenticationGoogleOauthDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationGoogleOauthDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthCollectMethod$inboundSchema:
  z.ZodType<RestAuthenticationGoogleOauthCollectMethod, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(RestAuthenticationGoogleOauthCollectMethod);
/** @internal */
export const RestAuthenticationGoogleOauthCollectMethod$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationGoogleOauthCollectMethod> =
    openEnums.outboundSchema(RestAuthenticationGoogleOauthCollectMethod);

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$Outbound =
  {
    type: "request_page";
    pageField: string;
    page?: number | undefined;
    sizeField: string;
    size: number;
    totalPageField?: string | undefined;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationGoogleOauthRestPaginationTypeRequestPageToJSON(
  restAuthenticationGoogleOauthRestPaginationTypeRequestPage:
    RestAuthenticationGoogleOauthRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$outboundSchema
      .parse(restAuthenticationGoogleOauthRestPaginationTypeRequestPage),
  );
}
export function restAuthenticationGoogleOauthRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$Outbound =
  {
    type: "request_offset";
    offsetField: string;
    offset?: number | undefined;
    limitField: string;
    limit: number;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationGoogleOauthRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationGoogleOauthRestPaginationTypeRequestOffset:
    RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$outboundSchema
      .parse(restAuthenticationGoogleOauthRestPaginationTypeRequestOffset),
  );
}
export function restAuthenticationGoogleOauthRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink:
    RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink),
  );
}
export function restAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$Outbound =
  {
    type: "response_header";
    attribute: Array<string>;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationGoogleOauthRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationGoogleOauthRestPaginationTypeResponseHeader:
    RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$outboundSchema
      .parse(restAuthenticationGoogleOauthRestPaginationTypeResponseHeader),
  );
}
export function restAuthenticationGoogleOauthRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$Outbound =
  {
    type: "response_body";
    attribute: Array<string>;
    maxPages: number;
    lastPageExpr?: string | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationGoogleOauthRestPaginationTypeResponseBodyToJSON(
  restAuthenticationGoogleOauthRestPaginationTypeResponseBody:
    RestAuthenticationGoogleOauthRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$outboundSchema
      .parse(restAuthenticationGoogleOauthRestPaginationTypeResponseBody),
  );
}
export function restAuthenticationGoogleOauthRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestAuthenticationGoogleOauthRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationGoogleOauthRestPaginationTypeNoneToJSON(
  restAuthenticationGoogleOauthRestPaginationTypeNone:
    RestAuthenticationGoogleOauthRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestPaginationTypeNone$outboundSchema.parse(
      restAuthenticationGoogleOauthRestPaginationTypeNone,
    ),
  );
}
export function restAuthenticationGoogleOauthRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthPaginationUnion$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthPaginationUnion,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationGoogleOauthPaginationUnion$Outbound =
  | RestAuthenticationGoogleOauthRestPaginationTypeNone$Outbound
  | RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationGoogleOauthPaginationUnion$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthPaginationUnion$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthPaginationUnion
  > = z.union([
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$outboundSchema
    ),
  ]);

export function restAuthenticationGoogleOauthPaginationUnionToJSON(
  restAuthenticationGoogleOauthPaginationUnion:
    RestAuthenticationGoogleOauthPaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthPaginationUnion$outboundSchema.parse(
      restAuthenticationGoogleOauthPaginationUnion,
    ),
  );
}
export function restAuthenticationGoogleOauthPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthPaginationUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthPaginationUnion$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$Outbound =
  | RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationGoogleOauthRestRetryRulesTypeBackoffToJSON(
  restAuthenticationGoogleOauthRestRetryRulesTypeBackoff:
    RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$outboundSchema.parse(
      restAuthenticationGoogleOauthRestRetryRulesTypeBackoff,
    ),
  );
}
export function restAuthenticationGoogleOauthRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue:
    RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse:
    RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$Outbound =
  | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationGoogleOauthRestRetryRulesTypeStaticToJSON(
  restAuthenticationGoogleOauthRestRetryRulesTypeStatic:
    RestAuthenticationGoogleOauthRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$outboundSchema.parse(
      restAuthenticationGoogleOauthRestRetryRulesTypeStatic,
    ),
  );
}
export function restAuthenticationGoogleOauthRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationGoogleOauthRestRetryRulesTypeNoneToJSON(
  restAuthenticationGoogleOauthRestRetryRulesTypeNone:
    RestAuthenticationGoogleOauthRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestRetryRulesTypeNone$outboundSchema.parse(
      restAuthenticationGoogleOauthRestRetryRulesTypeNone,
    ),
  );
}
export function restAuthenticationGoogleOauthRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationGoogleOauthRestRetryRulesTypeNone$inboundSchema
  ),
  static: smartUnion([
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  backoff: smartUnion([
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
});
/** @internal */
export type RestAuthenticationGoogleOauthRetryRules$Outbound =
  | RestAuthenticationGoogleOauthRestRetryRulesTypeNone$Outbound
  | (
    | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
      & { type: "static" }
  )
  | (
    | RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestAuthenticationGoogleOauthRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauthRetryRules
> = z.union([
  z.lazy(() =>
    RestAuthenticationGoogleOauthRestRetryRulesTypeNone$outboundSchema
  ),
  smartUnion([
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  smartUnion([
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
]);

export function restAuthenticationGoogleOauthRetryRulesToJSON(
  restAuthenticationGoogleOauthRetryRules:
    RestAuthenticationGoogleOauthRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRetryRules$outboundSchema.parse(
      restAuthenticationGoogleOauthRetryRules,
    ),
  );
}
export function restAuthenticationGoogleOauthRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthStateTracking$inboundSchema:
  z.ZodType<RestAuthenticationGoogleOauthStateTracking, z.ZodTypeDef, unknown> =
    z.object({
      enabled: types.optional(types.boolean()),
    });
/** @internal */
export type RestAuthenticationGoogleOauthStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthStateTrackingToJSON(
  restAuthenticationGoogleOauthStateTracking:
    RestAuthenticationGoogleOauthStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthStateTracking$outboundSchema.parse(
      restAuthenticationGoogleOauthStateTracking,
    ),
  );
}
export function restAuthenticationGoogleOauthStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthScheduling$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestAuthenticationGoogleOauthStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationGoogleOauthScheduling$Outbound = {
  stateTracking?:
    | RestAuthenticationGoogleOauthStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthScheduling$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauthScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationGoogleOauthStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationGoogleOauthSchedulingToJSON(
  restAuthenticationGoogleOauthScheduling:
    RestAuthenticationGoogleOauthScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthScheduling$outboundSchema.parse(
      restAuthenticationGoogleOauthScheduling,
    ),
  );
}
export function restAuthenticationGoogleOauthSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauth$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauth,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("google_oauth"),
  scopes: z.array(types.string()),
  serviceAccountCredentials: types.string(),
  subject: types.string(),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectMethod: RestAuthenticationGoogleOauthCollectMethod$inboundSchema,
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestAuthenticationGoogleOauthScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationGoogleOauth$Outbound = {
  authentication: "google_oauth";
  scopes: Array<string>;
  serviceAccountCredentials: string;
  subject: string;
  discovery?:
    | (
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationGoogleOauthRestPaginationTypeNone$Outbound
    | RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationGoogleOauthRestRetryRulesTypeNone$Outbound
    | (
      | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?: RestAuthenticationGoogleOauthScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauth$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauth$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauth
> = z.object({
  authentication: z.literal("google_oauth"),
  scopes: z.array(z.string()),
  serviceAccountCredentials: z.string(),
  subject: z.string(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationGoogleOauthCollectMethod$outboundSchema,
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeNone$outboundSchema
    ),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationGoogleOauthScheduling$outboundSchema
  ).optional(),
});

export function restAuthenticationGoogleOauthToJSON(
  restAuthenticationGoogleOauth: RestAuthenticationGoogleOauth,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauth$outboundSchema.parse(
      restAuthenticationGoogleOauth,
    ),
  );
}
export function restAuthenticationGoogleOauthFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationGoogleOauth, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationGoogleOauth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauth' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$Outbound =
  {
    discoverType: "none";
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$outboundSchema
      .parse(restAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$Outbound =
  {
    discoverType: "list";
    itemList: Array<string>;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeList:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$outboundSchema
      .parse(restAuthenticationOauthSecretRestDiscoveryDiscoverTypeList),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$Outbound =
  {
    discoverType: "json";
    manualDiscoverResult: string;
    discoverDataField?: string | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$outboundSchema
      .parse(restAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp$outboundSchema
      .parse(restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecretDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationOauthSecretDiscovery$Outbound =
  | (
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationOauthSecretDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationOauthSecretDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthSecretDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restAuthenticationOauthSecretDiscoveryToJSON(
  restAuthenticationOauthSecretDiscovery:
    RestAuthenticationOauthSecretDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretDiscovery$outboundSchema.parse(
      restAuthenticationOauthSecretDiscovery,
    ),
  );
}
export function restAuthenticationOauthSecretDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthSecretDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretCollectMethod$inboundSchema:
  z.ZodType<RestAuthenticationOauthSecretCollectMethod, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(RestAuthenticationOauthSecretCollectMethod);
/** @internal */
export const RestAuthenticationOauthSecretCollectMethod$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationOauthSecretCollectMethod> =
    openEnums.outboundSchema(RestAuthenticationOauthSecretCollectMethod);

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestPaginationTypeRequestPage$Outbound =
  {
    type: "request_page";
    pageField: string;
    page?: number | undefined;
    sizeField: string;
    size: number;
    totalPageField?: string | undefined;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationOauthSecretRestPaginationTypeRequestPageToJSON(
  restAuthenticationOauthSecretRestPaginationTypeRequestPage:
    RestAuthenticationOauthSecretRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestPaginationTypeRequestPage$outboundSchema
      .parse(restAuthenticationOauthSecretRestPaginationTypeRequestPage),
  );
}
export function restAuthenticationOauthSecretRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestPage$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$Outbound =
  {
    type: "request_offset";
    offsetField: string;
    offset?: number | undefined;
    limitField: string;
    limit: number;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationOauthSecretRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationOauthSecretRestPaginationTypeRequestOffset:
    RestAuthenticationOauthSecretRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$outboundSchema
      .parse(restAuthenticationOauthSecretRestPaginationTypeRequestOffset),
  );
}
export function restAuthenticationOauthSecretRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationOauthSecretRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink:
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink),
  );
}
export function restAuthenticationOauthSecretRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$Outbound =
  {
    type: "response_header";
    attribute: Array<string>;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationOauthSecretRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationOauthSecretRestPaginationTypeResponseHeader:
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$outboundSchema
      .parse(restAuthenticationOauthSecretRestPaginationTypeResponseHeader),
  );
}
export function restAuthenticationOauthSecretRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestPaginationTypeResponseBody$Outbound =
  {
    type: "response_body";
    attribute: Array<string>;
    maxPages: number;
    lastPageExpr?: string | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationOauthSecretRestPaginationTypeResponseBodyToJSON(
  restAuthenticationOauthSecretRestPaginationTypeResponseBody:
    RestAuthenticationOauthSecretRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestPaginationTypeResponseBody$outboundSchema
      .parse(restAuthenticationOauthSecretRestPaginationTypeResponseBody),
  );
}
export function restAuthenticationOauthSecretRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationOauthSecretRestPaginationTypeNoneToJSON(
  restAuthenticationOauthSecretRestPaginationTypeNone:
    RestAuthenticationOauthSecretRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestPaginationTypeNone$outboundSchema.parse(
      restAuthenticationOauthSecretRestPaginationTypeNone,
    ),
  );
}
export function restAuthenticationOauthSecretRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretPaginationUnion$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretPaginationUnion,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestPage$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationOauthSecretPaginationUnion$Outbound =
  | RestAuthenticationOauthSecretRestPaginationTypeNone$Outbound
  | RestAuthenticationOauthSecretRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationOauthSecretRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationOauthSecretPaginationUnion$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretPaginationUnion$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretPaginationUnion
  > = z.union([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestPage$outboundSchema
    ),
  ]);

export function restAuthenticationOauthSecretPaginationUnionToJSON(
  restAuthenticationOauthSecretPaginationUnion:
    RestAuthenticationOauthSecretPaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretPaginationUnion$outboundSchema.parse(
      restAuthenticationOauthSecretPaginationUnion,
    ),
  );
}
export function restAuthenticationOauthSecretPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretPaginationUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretPaginationUnion$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$Outbound =
  | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationOauthSecretRestRetryRulesTypeBackoffToJSON(
  restAuthenticationOauthSecretRestRetryRulesTypeBackoff:
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$outboundSchema.parse(
      restAuthenticationOauthSecretRestRetryRulesTypeBackoff,
    ),
  );
}
export function restAuthenticationOauthSecretRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue:
    RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse:
    RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationOauthSecretRestRetryRulesTypeStatic$Outbound =
  | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationOauthSecretRestRetryRulesTypeStaticToJSON(
  restAuthenticationOauthSecretRestRetryRulesTypeStatic:
    RestAuthenticationOauthSecretRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestRetryRulesTypeStatic$outboundSchema.parse(
      restAuthenticationOauthSecretRestRetryRulesTypeStatic,
    ),
  );
}
export function restAuthenticationOauthSecretRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationOauthSecretRestRetryRulesTypeNoneToJSON(
  restAuthenticationOauthSecretRestRetryRulesTypeNone:
    RestAuthenticationOauthSecretRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestRetryRulesTypeNone$outboundSchema.parse(
      restAuthenticationOauthSecretRestRetryRulesTypeNone,
    ),
  );
}
export function restAuthenticationOauthSecretRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecretRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationOauthSecretRestRetryRulesTypeNone$inboundSchema
  ),
  static: smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  backoff: smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
});
/** @internal */
export type RestAuthenticationOauthSecretRetryRules$Outbound =
  | RestAuthenticationOauthSecretRestRetryRulesTypeNone$Outbound
  | (
    | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
      & { type: "static" }
  )
  | (
    | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestAuthenticationOauthSecretRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationOauthSecretRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthSecretRetryRules
> = z.union([
  z.lazy(() =>
    RestAuthenticationOauthSecretRestRetryRulesTypeNone$outboundSchema
  ),
  smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
]);

export function restAuthenticationOauthSecretRetryRulesToJSON(
  restAuthenticationOauthSecretRetryRules:
    RestAuthenticationOauthSecretRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRetryRules$outboundSchema.parse(
      restAuthenticationOauthSecretRetryRules,
    ),
  );
}
export function restAuthenticationOauthSecretRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretStateTracking$inboundSchema:
  z.ZodType<RestAuthenticationOauthSecretStateTracking, z.ZodTypeDef, unknown> =
    z.object({
      enabled: types.optional(types.boolean()),
    });
/** @internal */
export type RestAuthenticationOauthSecretStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationOauthSecretStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretStateTrackingToJSON(
  restAuthenticationOauthSecretStateTracking:
    RestAuthenticationOauthSecretStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretStateTracking$outboundSchema.parse(
      restAuthenticationOauthSecretStateTracking,
    ),
  );
}
export function restAuthenticationOauthSecretStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretScheduling$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecretScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestAuthenticationOauthSecretStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationOauthSecretScheduling$Outbound = {
  stateTracking?:
    | RestAuthenticationOauthSecretStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationOauthSecretScheduling$outboundSchema: z.ZodType<
  RestAuthenticationOauthSecretScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthSecretScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationOauthSecretStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationOauthSecretSchedulingToJSON(
  restAuthenticationOauthSecretScheduling:
    RestAuthenticationOauthSecretScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretScheduling$outboundSchema.parse(
      restAuthenticationOauthSecretScheduling,
    ),
  );
}
export function restAuthenticationOauthSecretSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecret$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("oauthSecret"),
  loginUrl: types.string(),
  tokenRespAttribute: types.optional(types.string()),
  authHeaderKey: types.optional(types.string()),
  authHeaderExpr: types.string(),
  clientSecretParamName: types.string(),
  textSecret: types.string(),
  authRequestParams: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  authRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectMethod: RestAuthenticationOauthSecretCollectMethod$inboundSchema,
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestAuthenticationOauthSecretScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationOauthSecret$Outbound = {
  authentication: "oauthSecret";
  loginUrl: string;
  tokenRespAttribute?: string | undefined;
  authHeaderKey?: string | undefined;
  authHeaderExpr: string;
  clientSecretParamName: string;
  textSecret: string;
  authRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationOauthSecretRestPaginationTypeNone$Outbound
    | RestAuthenticationOauthSecretRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationOauthSecretRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationOauthSecretRestRetryRulesTypeNone$Outbound
    | (
      | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?: RestAuthenticationOauthSecretScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationOauthSecret$outboundSchema: z.ZodType<
  RestAuthenticationOauthSecret$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthSecret
> = z.object({
  authentication: z.literal("oauthSecret"),
  loginUrl: z.string(),
  tokenRespAttribute: z.string().optional(),
  authHeaderKey: z.string().optional(),
  authHeaderExpr: z.string(),
  clientSecretParamName: z.string(),
  textSecret: z.string(),
  authRequestParams: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  authRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationOauthSecretCollectMethod$outboundSchema,
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeNone$outboundSchema
    ),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationOauthSecretScheduling$outboundSchema
  ).optional(),
});

export function restAuthenticationOauthSecretToJSON(
  restAuthenticationOauthSecret: RestAuthenticationOauthSecret,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecret$outboundSchema.parse(
      restAuthenticationOauthSecret,
    ),
  );
}
export function restAuthenticationOauthSecretFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauthSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecret' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$Outbound = {
  discoverType: "none";
};

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeNone:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$outboundSchema.parse(
      restAuthenticationOauthRestDiscoveryDiscoverTypeNone,
    ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeList$Outbound = {
  discoverType: "list";
  itemList: Array<string>;
};

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeList:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeList$outboundSchema.parse(
      restAuthenticationOauthRestDiscoveryDiscoverTypeList,
    ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeList$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$Outbound = {
  discoverType: "json";
  manualDiscoverResult: string;
  discoverDataField?: string | undefined;
};

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeJson:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$outboundSchema.parse(
      restAuthenticationOauthRestDiscoveryDiscoverTypeJson,
    ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp$outboundSchema.parse(
      restAuthenticationOauthRestDiscoveryDiscoverTypeHttp,
    ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationOauthDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestAuthenticationOauthRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationOauthDiscovery$Outbound =
  | (
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationOauthDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationOauthDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationOauthRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restAuthenticationOauthDiscoveryToJSON(
  restAuthenticationOauthDiscovery: RestAuthenticationOauthDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationOauthDiscovery$outboundSchema.parse(
      restAuthenticationOauthDiscovery,
    ),
  );
}
export function restAuthenticationOauthDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauthDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthCollectMethod$inboundSchema: z.ZodType<
  RestAuthenticationOauthCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationOauthCollectMethod);
/** @internal */
export const RestAuthenticationOauthCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationOauthCollectMethod
> = openEnums.outboundSchema(RestAuthenticationOauthCollectMethod);

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationOauthRestPaginationTypeRequestPage$Outbound = {
  type: "request_page";
  pageField: string;
  page?: number | undefined;
  sizeField: string;
  size: number;
  totalPageField?: string | undefined;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationOauthRestPaginationTypeRequestPageToJSON(
  restAuthenticationOauthRestPaginationTypeRequestPage:
    RestAuthenticationOauthRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestPaginationTypeRequestPage$outboundSchema.parse(
      restAuthenticationOauthRestPaginationTypeRequestPage,
    ),
  );
}
export function restAuthenticationOauthRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestPaginationTypeRequestPage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationOauthRestPaginationTypeRequestOffset$Outbound = {
  type: "request_offset";
  offsetField: string;
  offset?: number | undefined;
  limitField: string;
  limit: number;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationOauthRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationOauthRestPaginationTypeRequestOffset:
    RestAuthenticationOauthRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestPaginationTypeRequestOffset$outboundSchema.parse(
      restAuthenticationOauthRestPaginationTypeRequestOffset,
    ),
  );
}
export function restAuthenticationOauthRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationOauthRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationOauthRestPaginationTypeResponseHeaderLink:
    RestAuthenticationOauthRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restAuthenticationOauthRestPaginationTypeResponseHeaderLink),
  );
}
export function restAuthenticationOauthRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationOauthRestPaginationTypeResponseHeader$Outbound = {
  type: "response_header";
  attribute: Array<string>;
  maxPages: number;
};

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationOauthRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationOauthRestPaginationTypeResponseHeader:
    RestAuthenticationOauthRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestPaginationTypeResponseHeader$outboundSchema
      .parse(restAuthenticationOauthRestPaginationTypeResponseHeader),
  );
}
export function restAuthenticationOauthRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationOauthRestPaginationTypeResponseBody$Outbound = {
  type: "response_body";
  attribute: Array<string>;
  maxPages: number;
  lastPageExpr?: string | undefined;
};

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationOauthRestPaginationTypeResponseBodyToJSON(
  restAuthenticationOauthRestPaginationTypeResponseBody:
    RestAuthenticationOauthRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestPaginationTypeResponseBody$outboundSchema.parse(
      restAuthenticationOauthRestPaginationTypeResponseBody,
    ),
  );
}
export function restAuthenticationOauthRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestPaginationTypeResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationOauthRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationOauthRestPaginationTypeNoneToJSON(
  restAuthenticationOauthRestPaginationTypeNone:
    RestAuthenticationOauthRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestPaginationTypeNone$outboundSchema.parse(
      restAuthenticationOauthRestPaginationTypeNone,
    ),
  );
}
export function restAuthenticationOauthRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthPaginationUnion$inboundSchema: z.ZodType<
  RestAuthenticationOauthPaginationUnion,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeNone$inboundSchema
  ),
  response_body: z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeResponseBody$inboundSchema
  ),
  response_header: z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeResponseHeader$inboundSchema
  ),
  response_header_link: z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$inboundSchema
  ),
  request_offset: z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeRequestOffset$inboundSchema
  ),
  request_page: z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeRequestPage$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationOauthPaginationUnion$Outbound =
  | RestAuthenticationOauthRestPaginationTypeNone$Outbound
  | RestAuthenticationOauthRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationOauthRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationOauthRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationOauthRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationOauthPaginationUnion$outboundSchema: z.ZodType<
  RestAuthenticationOauthPaginationUnion$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthPaginationUnion
> = z.union([
  z.lazy(() => RestAuthenticationOauthRestPaginationTypeNone$outboundSchema),
  z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeResponseBody$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeResponseHeader$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeRequestOffset$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeRequestPage$outboundSchema
  ),
]);

export function restAuthenticationOauthPaginationUnionToJSON(
  restAuthenticationOauthPaginationUnion:
    RestAuthenticationOauthPaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationOauthPaginationUnion$outboundSchema.parse(
      restAuthenticationOauthPaginationUnion,
    ),
  );
}
export function restAuthenticationOauthPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthPaginationUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthPaginationUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(restAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue),
  );
}
export function restAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(restAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse),
  );
}
export function restAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationOauthRestRetryRulesTypeBackoff$Outbound =
  | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationOauthRestRetryRulesTypeBackoffToJSON(
  restAuthenticationOauthRestRetryRulesTypeBackoff:
    RestAuthenticationOauthRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestRetryRulesTypeBackoff$outboundSchema.parse(
      restAuthenticationOauthRestRetryRulesTypeBackoff,
    ),
  );
}
export function restAuthenticationOauthRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestRetryRulesTypeBackoff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue:
    RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(restAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue),
  );
}
export function restAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse:
    RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(restAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse),
  );
}
export function restAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationOauthRestRetryRulesTypeStatic$Outbound =
  | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationOauthRestRetryRulesTypeStaticToJSON(
  restAuthenticationOauthRestRetryRulesTypeStatic:
    RestAuthenticationOauthRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestRetryRulesTypeStatic$outboundSchema.parse(
      restAuthenticationOauthRestRetryRulesTypeStatic,
    ),
  );
}
export function restAuthenticationOauthRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationOauthRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationOauthRestRetryRulesTypeNoneToJSON(
  restAuthenticationOauthRestRetryRulesTypeNone:
    RestAuthenticationOauthRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestRetryRulesTypeNone$outboundSchema.parse(
      restAuthenticationOauthRestRetryRulesTypeNone,
    ),
  );
}
export function restAuthenticationOauthRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationOauthRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationOauthRestRetryRulesTypeNone$inboundSchema
  ),
  static: smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  backoff: smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
});
/** @internal */
export type RestAuthenticationOauthRetryRules$Outbound =
  | RestAuthenticationOauthRestRetryRulesTypeNone$Outbound
  | (
    | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
      & { type: "static" }
  )
  | (
    | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestAuthenticationOauthRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationOauthRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthRetryRules
> = z.union([
  z.lazy(() => RestAuthenticationOauthRestRetryRulesTypeNone$outboundSchema),
  smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
]);

export function restAuthenticationOauthRetryRulesToJSON(
  restAuthenticationOauthRetryRules: RestAuthenticationOauthRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRetryRules$outboundSchema.parse(
      restAuthenticationOauthRetryRules,
    ),
  );
}
export function restAuthenticationOauthRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauthRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthStateTracking$inboundSchema: z.ZodType<
  RestAuthenticationOauthStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: types.optional(types.boolean()),
});
/** @internal */
export type RestAuthenticationOauthStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationOauthStateTracking$outboundSchema: z.ZodType<
  RestAuthenticationOauthStateTracking$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restAuthenticationOauthStateTrackingToJSON(
  restAuthenticationOauthStateTracking: RestAuthenticationOauthStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationOauthStateTracking$outboundSchema.parse(
      restAuthenticationOauthStateTracking,
    ),
  );
}
export function restAuthenticationOauthStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthScheduling$inboundSchema: z.ZodType<
  RestAuthenticationOauthScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestAuthenticationOauthStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationOauthScheduling$Outbound = {
  stateTracking?: RestAuthenticationOauthStateTracking$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationOauthScheduling$outboundSchema: z.ZodType<
  RestAuthenticationOauthScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationOauthStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationOauthSchedulingToJSON(
  restAuthenticationOauthScheduling: RestAuthenticationOauthScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationOauthScheduling$outboundSchema.parse(
      restAuthenticationOauthScheduling,
    ),
  );
}
export function restAuthenticationOauthSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauthScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauth$inboundSchema: z.ZodType<
  RestAuthenticationOauth,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("oauth"),
  loginUrl: types.string(),
  tokenRespAttribute: types.optional(types.string()),
  authHeaderKey: types.optional(types.string()),
  authHeaderExpr: types.string(),
  clientSecretParamName: types.string(),
  clientSecretParamValue: types.string(),
  authRequestParams: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  authRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectMethod: RestAuthenticationOauthCollectMethod$inboundSchema,
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestAuthenticationOauthScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationOauth$Outbound = {
  authentication: "oauth";
  loginUrl: string;
  tokenRespAttribute?: string | undefined;
  authHeaderKey?: string | undefined;
  authHeaderExpr: string;
  clientSecretParamName: string;
  clientSecretParamValue: string;
  authRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationOauthRestPaginationTypeNone$Outbound
    | RestAuthenticationOauthRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationOauthRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationOauthRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationOauthRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationOauthRestRetryRulesTypeNone$Outbound
    | (
      | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?: RestAuthenticationOauthScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationOauth$outboundSchema: z.ZodType<
  RestAuthenticationOauth$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauth
> = z.object({
  authentication: z.literal("oauth"),
  loginUrl: z.string(),
  tokenRespAttribute: z.string().optional(),
  authHeaderKey: z.string().optional(),
  authHeaderExpr: z.string(),
  clientSecretParamName: z.string(),
  clientSecretParamValue: z.string(),
  authRequestParams: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  authRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationOauthCollectMethod$outboundSchema,
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() => RestAuthenticationOauthRestPaginationTypeNone$outboundSchema),
    z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() => RestAuthenticationOauthRestRetryRulesTypeNone$outboundSchema),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]).optional(),
  __scheduling: z.lazy(() => RestAuthenticationOauthScheduling$outboundSchema)
    .optional(),
});

export function restAuthenticationOauthToJSON(
  restAuthenticationOauth: RestAuthenticationOauth,
): string {
  return JSON.stringify(
    RestAuthenticationOauth$outboundSchema.parse(restAuthenticationOauth),
  );
}
export function restAuthenticationOauthFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauth, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauth' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$Outbound =
  {
    discoverType: "none";
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$Outbound =
  {
    discoverType: "list";
    itemList: Array<string>;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$Outbound =
  {
    discoverType: "json";
    manualDiscoverResult: string;
    discoverDataField?: string | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$Outbound =
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery
  > = z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoveryToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$outboundSchema
      .parse(restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$Outbound =
  {
    type: "request_page";
    pageField: string;
    page?: number | undefined;
    sizeField: string;
    size: number;
    totalPageField?: string | undefined;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPageToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$Outbound =
  {
    type: "request_offset";
    offsetField: string;
    offset?: number | undefined;
    limitField: string;
    limit: number;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$Outbound =
  {
    type: "response_header";
    attribute: Array<string>;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$Outbound =
  {
    type: "response_body";
    attribute: Array<string>;
    maxPages: number;
    lastPageExpr?: string | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBodyToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$Outbound =
  {
    type: "none";
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNoneToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion$Outbound =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$outboundSchema
    ),
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnionToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$Outbound =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$Outbound =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$Outbound =
  {
    type: "none";
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    enableHeader?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNoneToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules$Outbound =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$Outbound
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
      & { type: "static" }
  )
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$outboundSchema
    ),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRulesToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules$outboundSchema
      .parse(restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enabled: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$Outbound =
  {
    enabled?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTrackingToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling,
    z.ZodTypeDef,
    unknown
  > = z.object({
    stateTracking: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$inboundSchema
      ),
    ),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$Outbound =
  {
    stateTracking?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$Outbound
      | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling
  > = z.object({
    stateTracking: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$outboundSchema
    ).optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueSchedulingToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$outboundSchema
      .parse(restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    getAuthTokenFromHeader: types.optional(types.boolean()),
    authentication:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication$inboundSchema,
    loginUrl: types.string(),
    credentialsSecret: types.string(),
    loginBody: types.string(),
    authHeaderKey: types.optional(types.string()),
    authHeaderExpr: types.string(),
    authRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discovery: types.optional(discriminatedUnion("discoverType", {
      http: discriminatedUnion("discoverMethod", {
        get: z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        ),
        post: z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        ),
        post_with_body: z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        ),
        other: z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        ),
      }).and(z.object({ discoverType: z.literal("http") })),
      json: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$inboundSchema
      ),
      list: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$inboundSchema
      ),
      none: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$inboundSchema
      ),
    })),
    collectUrl: types.string(),
    collectMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod$inboundSchema,
    collectRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(discriminatedUnion("type", {
      none: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$inboundSchema
      ),
      response_body: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$inboundSchema
      ),
      response_header: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$inboundSchema
      ),
      response_header_link: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$inboundSchema
      ),
      request_offset: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$inboundSchema
      ),
      request_page: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$inboundSchema
      ),
    })),
    timeout: types.optional(types.number()),
    useRoundRobinDns: types.optional(types.boolean()),
    disableTimeFilter: types.optional(types.boolean()),
    decodeUrl: types.optional(types.boolean()),
    rejectUnauthorized: types.optional(types.boolean()),
    captureHeaders: types.optional(types.boolean()),
    stopOnEmptyResults: types.optional(types.boolean()),
    safeHeaders: types.optional(z.array(types.string())),
    retryRules: types.optional(discriminatedUnion("type", {
      none: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$inboundSchema
      ),
      static: smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        ),
      ]).and(z.object({ type: z.literal("static") })),
      backoff: smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        ),
      ]).and(z.object({ type: z.literal("backoff") })),
    })),
    __scheduling: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$inboundSchema
      ),
    ),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$Outbound = {
  getAuthTokenFromHeader?: boolean | undefined;
  authentication: string;
  loginUrl: string;
  credentialsSecret: string;
  loginBody: string;
  authHeaderKey?: string | undefined;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$Outbound
    | (
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue
  > = z.object({
    getAuthTokenFromHeader: z.boolean().optional(),
    authentication:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication$outboundSchema,
    loginUrl: z.string(),
    credentialsSecret: z.string(),
    loginBody: z.string(),
    authHeaderKey: z.string().optional(),
    authHeaderExpr: z.string(),
    authRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discovery: z.union([
      z.union([
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
        ),
      ]).and(z.object({ discoverType: z.literal("http") })),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$outboundSchema
      ),
    ]).optional(),
    collectUrl: z.string(),
    collectMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod$outboundSchema,
    collectRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.union([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$outboundSchema
      ),
    ]).optional(),
    timeout: z.number().optional(),
    useRoundRobinDns: z.boolean().optional(),
    disableTimeFilter: z.boolean().optional(),
    decodeUrl: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    stopOnEmptyResults: z.boolean().optional(),
    safeHeaders: z.array(z.string()).optional(),
    retryRules: z.union([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$outboundSchema
      ),
      smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
        ),
      ]).and(z.object({ type: z.literal("static") })),
      smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
        ),
      ]).and(z.object({ type: z.literal("backoff") })),
    ]).optional(),
    __scheduling: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$outboundSchema
    ).optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrue:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$outboundSchema
      .parse(restAuthenticationLoginSecretGetAuthTokenFromHeaderTrue),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$Outbound =
  {
    discoverType: "none";
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$Outbound =
  {
    discoverType: "list";
    itemList: Array<string>;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$Outbound =
  {
    discoverType: "json";
    manualDiscoverResult: string;
    discoverDataField?: string | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery$Outbound =
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery
  > = z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoveryToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery$outboundSchema
      .parse(restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$Outbound =
  {
    type: "request_page";
    pageField: string;
    page?: number | undefined;
    sizeField: string;
    size: number;
    totalPageField?: string | undefined;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPageToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$Outbound =
  {
    type: "request_offset";
    offsetField: string;
    offset?: number | undefined;
    limitField: string;
    limit: number;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$Outbound =
  {
    type: "response_header";
    attribute: Array<string>;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$Outbound =
  {
    type: "response_body";
    attribute: Array<string>;
    maxPages: number;
    lastPageExpr?: string | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBodyToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$Outbound =
  {
    type: "none";
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNoneToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion$Outbound =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$outboundSchema
    ),
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnionToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff$Outbound =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic$Outbound =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$Outbound =
  {
    type: "none";
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    enableHeader?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNoneToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules$Outbound =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$Outbound
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
      & { type: "static" }
  )
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$outboundSchema
    ),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRulesToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enabled: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$Outbound =
  {
    enabled?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTrackingToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling,
    z.ZodTypeDef,
    unknown
  > = z.object({
    stateTracking: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$inboundSchema
      ),
    ),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$Outbound =
  {
    stateTracking?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$Outbound
      | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling
  > = z.object({
    stateTracking: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$outboundSchema
    ).optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseSchedulingToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    getAuthTokenFromHeader: types.optional(types.boolean()),
    tokenRespAttribute: types.optional(types.string()),
    authentication:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication$inboundSchema,
    loginUrl: types.string(),
    credentialsSecret: types.string(),
    loginBody: types.string(),
    authHeaderKey: types.optional(types.string()),
    authHeaderExpr: types.string(),
    authRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discovery: types.optional(discriminatedUnion("discoverType", {
      http: discriminatedUnion("discoverMethod", {
        get: z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        ),
        post: z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        ),
        post_with_body: z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        ),
        other: z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        ),
      }).and(z.object({ discoverType: z.literal("http") })),
      json: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$inboundSchema
      ),
      list: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$inboundSchema
      ),
      none: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$inboundSchema
      ),
    })),
    collectUrl: types.string(),
    collectMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod$inboundSchema,
    collectRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(discriminatedUnion("type", {
      none: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$inboundSchema
      ),
      response_body: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$inboundSchema
      ),
      response_header: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$inboundSchema
      ),
      response_header_link: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$inboundSchema
      ),
      request_offset: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$inboundSchema
      ),
      request_page: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$inboundSchema
      ),
    })),
    timeout: types.optional(types.number()),
    useRoundRobinDns: types.optional(types.boolean()),
    disableTimeFilter: types.optional(types.boolean()),
    decodeUrl: types.optional(types.boolean()),
    rejectUnauthorized: types.optional(types.boolean()),
    captureHeaders: types.optional(types.boolean()),
    stopOnEmptyResults: types.optional(types.boolean()),
    safeHeaders: types.optional(z.array(types.string())),
    retryRules: types.optional(discriminatedUnion("type", {
      none: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$inboundSchema
      ),
      static: smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        ),
      ]).and(z.object({ type: z.literal("static") })),
      backoff: smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        ),
      ]).and(z.object({ type: z.literal("backoff") })),
    })),
    __scheduling: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$inboundSchema
      ),
    ),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$Outbound =
  {
    getAuthTokenFromHeader?: boolean | undefined;
    tokenRespAttribute?: string | undefined;
    authentication: string;
    loginUrl: string;
    credentialsSecret: string;
    loginBody: string;
    authHeaderKey?: string | undefined;
    authHeaderExpr: string;
    authRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discovery?:
      | (
        | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
        | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
        | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
        | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
          & { discoverType: "http" }
      )
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$Outbound
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$Outbound
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$Outbound
      | undefined;
    collectUrl: string;
    collectMethod: string;
    collectRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$Outbound
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$Outbound
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$Outbound
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$Outbound
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$Outbound
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$Outbound
      | undefined;
    timeout?: number | undefined;
    useRoundRobinDns?: boolean | undefined;
    disableTimeFilter?: boolean | undefined;
    decodeUrl?: boolean | undefined;
    rejectUnauthorized?: boolean | undefined;
    captureHeaders?: boolean | undefined;
    stopOnEmptyResults?: boolean | undefined;
    safeHeaders?: Array<string> | undefined;
    retryRules?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$Outbound
      | (
        | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
        | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
          & { type: "static" }
      )
      | (
        | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
        | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
          & { type: "backoff" }
      )
      | undefined;
    __scheduling?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$Outbound
      | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse
  > = z.object({
    getAuthTokenFromHeader: z.boolean().optional(),
    tokenRespAttribute: z.string().optional(),
    authentication:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication$outboundSchema,
    loginUrl: z.string(),
    credentialsSecret: z.string(),
    loginBody: z.string(),
    authHeaderKey: z.string().optional(),
    authHeaderExpr: z.string(),
    authRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discovery: z.union([
      z.union([
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
        ),
      ]).and(z.object({ discoverType: z.literal("http") })),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$outboundSchema
      ),
    ]).optional(),
    collectUrl: z.string(),
    collectMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod$outboundSchema,
    collectRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.union([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$outboundSchema
      ),
    ]).optional(),
    timeout: z.number().optional(),
    useRoundRobinDns: z.boolean().optional(),
    disableTimeFilter: z.boolean().optional(),
    decodeUrl: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    stopOnEmptyResults: z.boolean().optional(),
    safeHeaders: z.array(z.string()).optional(),
    retryRules: z.union([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$outboundSchema
      ),
      smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
        ),
      ]).and(z.object({ type: z.literal("static") })),
      smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
        ),
      ]).and(z.object({ type: z.literal("backoff") })),
    ]).optional(),
    __scheduling: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$outboundSchema
    ).optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalse:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$outboundSchema
      .parse(restAuthenticationLoginSecretGetAuthTokenFromHeaderFalse),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecret$inboundSchema: z.ZodType<
  RestAuthenticationLoginSecret,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() =>
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$inboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$inboundSchema
  ),
]);
/** @internal */
export type RestAuthenticationLoginSecret$Outbound =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationLoginSecret$outboundSchema: z.ZodType<
  RestAuthenticationLoginSecret$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLoginSecret
> = smartUnion([
  z.lazy(() =>
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$outboundSchema
  ),
]);

export function restAuthenticationLoginSecretToJSON(
  restAuthenticationLoginSecret: RestAuthenticationLoginSecret,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecret$outboundSchema.parse(
      restAuthenticationLoginSecret,
    ),
  );
}
export function restAuthenticationLoginSecretFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationLoginSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationLoginSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecret' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$Outbound =
  {
    discoverType: "none";
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$Outbound =
  {
    discoverType: "list";
    itemList: Array<string>;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$Outbound =
  {
    discoverType: "json";
    manualDiscoverResult: string;
    discoverDataField?: string | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery$Outbound =
  | (
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery
  > = z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]);

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoveryToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$Outbound =
  {
    type: "request_page";
    pageField: string;
    page?: number | undefined;
    sizeField: string;
    size: number;
    totalPageField?: string | undefined;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPageToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$Outbound =
  {
    type: "request_offset";
    offsetField: string;
    offset?: number | undefined;
    limitField: string;
    limit: number;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$Outbound =
  {
    type: "response_header";
    attribute: Array<string>;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$Outbound =
  {
    type: "response_body";
    attribute: Array<string>;
    maxPages: number;
    lastPageExpr?: string | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBodyToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$Outbound =
  {
    type: "none";
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNoneToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion$Outbound =
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$outboundSchema
    ),
  ]);

export function restAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnionToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion:
    RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$Outbound =
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$Outbound =
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$Outbound =
  {
    type: "none";
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    enableHeader?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNoneToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules$Outbound =
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$Outbound
  | (
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
      & { type: "static" }
  )
  | (
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$outboundSchema
    ),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]);

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRulesToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enabled: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$Outbound =
  {
    enabled?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueStateTrackingToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling,
    z.ZodTypeDef,
    unknown
  > = z.object({
    stateTracking: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$inboundSchema
      ),
    ),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$Outbound =
  {
    stateTracking?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$Outbound
      | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling
  > = z.object({
    stateTracking: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$outboundSchema
    ).optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueSchedulingToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    getAuthTokenFromHeader: types.optional(types.boolean()),
    authentication:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication$inboundSchema,
    loginUrl: types.string(),
    username: types.string(),
    password: types.string(),
    loginBody: types.string(),
    authHeaderKey: types.optional(types.string()),
    authHeaderExpr: types.string(),
    authRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discovery: types.optional(discriminatedUnion("discoverType", {
      http: discriminatedUnion("discoverMethod", {
        get: z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        ),
        post: z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        ),
        post_with_body: z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        ),
        other: z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        ),
      }).and(z.object({ discoverType: z.literal("http") })),
      json: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$inboundSchema
      ),
      list: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$inboundSchema
      ),
      none: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$inboundSchema
      ),
    })),
    collectUrl: types.string(),
    collectMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod$inboundSchema,
    collectRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(discriminatedUnion("type", {
      none: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$inboundSchema
      ),
      response_body: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$inboundSchema
      ),
      response_header: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$inboundSchema
      ),
      response_header_link: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$inboundSchema
      ),
      request_offset: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$inboundSchema
      ),
      request_page: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$inboundSchema
      ),
    })),
    timeout: types.optional(types.number()),
    useRoundRobinDns: types.optional(types.boolean()),
    disableTimeFilter: types.optional(types.boolean()),
    decodeUrl: types.optional(types.boolean()),
    rejectUnauthorized: types.optional(types.boolean()),
    captureHeaders: types.optional(types.boolean()),
    stopOnEmptyResults: types.optional(types.boolean()),
    safeHeaders: types.optional(z.array(types.string())),
    retryRules: types.optional(discriminatedUnion("type", {
      none: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$inboundSchema
      ),
      static: smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        ),
      ]).and(z.object({ type: z.literal("static") })),
      backoff: smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        ),
      ]).and(z.object({ type: z.literal("backoff") })),
    })),
    __scheduling: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$inboundSchema
      ),
    ),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrue$Outbound = {
  getAuthTokenFromHeader?: boolean | undefined;
  authentication: string;
  loginUrl: string;
  username: string;
  password: string;
  loginBody: string;
  authHeaderKey?: string | undefined;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$Outbound
    | (
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrue
  > = z.object({
    getAuthTokenFromHeader: z.boolean().optional(),
    authentication:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication$outboundSchema,
    loginUrl: z.string(),
    username: z.string(),
    password: z.string(),
    loginBody: z.string(),
    authHeaderKey: z.string().optional(),
    authHeaderExpr: z.string(),
    authRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discovery: z.union([
      z.union([
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
        ),
      ]).and(z.object({ discoverType: z.literal("http") })),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$outboundSchema
      ),
    ]).optional(),
    collectUrl: z.string(),
    collectMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod$outboundSchema,
    collectRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.union([
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$outboundSchema
      ),
    ]).optional(),
    timeout: z.number().optional(),
    useRoundRobinDns: z.boolean().optional(),
    disableTimeFilter: z.boolean().optional(),
    decodeUrl: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    stopOnEmptyResults: z.boolean().optional(),
    safeHeaders: z.array(z.string()).optional(),
    retryRules: z.union([
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$outboundSchema
      ),
      smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
        ),
      ]).and(z.object({ type: z.literal("static") })),
      smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
        ),
      ]).and(z.object({ type: z.literal("backoff") })),
    ]).optional(),
    __scheduling: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$outboundSchema
    ).optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrue:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrue$outboundSchema.parse(
      restAuthenticationLoginGetAuthTokenFromHeaderTrue,
    ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrue$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$Outbound =
  {
    discoverType: "none";
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$Outbound =
  {
    discoverType: "list";
    itemList: Array<string>;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$Outbound =
  {
    discoverType: "json";
    manualDiscoverResult: string;
    discoverDataField?: string | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery$Outbound =
  | (
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery
  > = z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]);

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoveryToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$Outbound =
  {
    type: "request_page";
    pageField: string;
    page?: number | undefined;
    sizeField: string;
    size: number;
    totalPageField?: string | undefined;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPageToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$Outbound =
  {
    type: "request_offset";
    offsetField: string;
    offset?: number | undefined;
    limitField: string;
    limit: number;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$Outbound =
  {
    type: "response_header";
    attribute: Array<string>;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$Outbound =
  {
    type: "response_body";
    attribute: Array<string>;
    maxPages: number;
    lastPageExpr?: string | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBodyToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone$Outbound =
  {
    type: "none";
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNoneToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnion$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnion,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnion$Outbound =
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnion$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnion$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnion
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$outboundSchema
    ),
  ]);

export function restAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnionToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnion:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnion$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnion),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnion$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff$Outbound =
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic$Outbound =
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$Outbound =
  {
    type: "none";
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    enableHeader?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNoneToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules$Outbound =
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$Outbound
  | (
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
      & { type: "static" }
  )
  | (
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$outboundSchema
    ),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]);

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRulesToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enabled: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking$Outbound =
  {
    enabled?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseStateTrackingToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling,
    z.ZodTypeDef,
    unknown
  > = z.object({
    stateTracking: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking$inboundSchema
      ),
    ),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling$Outbound =
  {
    stateTracking?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking$Outbound
      | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling
  > = z.object({
    stateTracking: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking$outboundSchema
    ).optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseSchedulingToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    getAuthTokenFromHeader: types.optional(types.boolean()),
    tokenRespAttribute: types.optional(types.string()),
    authentication:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication$inboundSchema,
    loginUrl: types.string(),
    username: types.string(),
    password: types.string(),
    loginBody: types.string(),
    authHeaderKey: types.optional(types.string()),
    authHeaderExpr: types.string(),
    authRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discovery: types.optional(discriminatedUnion("discoverType", {
      http: discriminatedUnion("discoverMethod", {
        get: z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        ),
        post: z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        ),
        post_with_body: z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        ),
        other: z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        ),
      }).and(z.object({ discoverType: z.literal("http") })),
      json: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$inboundSchema
      ),
      list: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$inboundSchema
      ),
      none: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$inboundSchema
      ),
    })),
    collectUrl: types.string(),
    collectMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod$inboundSchema,
    collectRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(discriminatedUnion("type", {
      none: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone$inboundSchema
      ),
      response_body: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$inboundSchema
      ),
      response_header: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$inboundSchema
      ),
      response_header_link: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$inboundSchema
      ),
      request_offset: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$inboundSchema
      ),
      request_page: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$inboundSchema
      ),
    })),
    timeout: types.optional(types.number()),
    useRoundRobinDns: types.optional(types.boolean()),
    disableTimeFilter: types.optional(types.boolean()),
    decodeUrl: types.optional(types.boolean()),
    rejectUnauthorized: types.optional(types.boolean()),
    captureHeaders: types.optional(types.boolean()),
    stopOnEmptyResults: types.optional(types.boolean()),
    safeHeaders: types.optional(z.array(types.string())),
    retryRules: types.optional(discriminatedUnion("type", {
      none: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$inboundSchema
      ),
      static: smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        ),
      ]).and(z.object({ type: z.literal("static") })),
      backoff: smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        ),
      ]).and(z.object({ type: z.literal("backoff") })),
    })),
    __scheduling: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling$inboundSchema
      ),
    ),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalse$Outbound = {
  getAuthTokenFromHeader?: boolean | undefined;
  tokenRespAttribute?: string | undefined;
  authentication: string;
  loginUrl: string;
  username: string;
  password: string;
  loginBody: string;
  authHeaderKey?: string | undefined;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$Outbound
    | (
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalse
  > = z.object({
    getAuthTokenFromHeader: z.boolean().optional(),
    tokenRespAttribute: z.string().optional(),
    authentication:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication$outboundSchema,
    loginUrl: z.string(),
    username: z.string(),
    password: z.string(),
    loginBody: z.string(),
    authHeaderKey: z.string().optional(),
    authHeaderExpr: z.string(),
    authRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discovery: z.union([
      z.union([
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
        ),
      ]).and(z.object({ discoverType: z.literal("http") })),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$outboundSchema
      ),
    ]).optional(),
    collectUrl: z.string(),
    collectMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod$outboundSchema,
    collectRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.union([
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$outboundSchema
      ),
    ]).optional(),
    timeout: z.number().optional(),
    useRoundRobinDns: z.boolean().optional(),
    disableTimeFilter: z.boolean().optional(),
    decodeUrl: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    stopOnEmptyResults: z.boolean().optional(),
    safeHeaders: z.array(z.string()).optional(),
    retryRules: z.union([
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$outboundSchema
      ),
      smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
        ),
      ]).and(z.object({ type: z.literal("static") })),
      smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
        ),
      ]).and(z.object({ type: z.literal("backoff") })),
    ]).optional(),
    __scheduling: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling$outboundSchema
    ).optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalse:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalse$outboundSchema.parse(
      restAuthenticationLoginGetAuthTokenFromHeaderFalse,
    ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLogin$inboundSchema: z.ZodType<
  RestAuthenticationLogin,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() =>
    RestAuthenticationLoginGetAuthTokenFromHeaderFalse$inboundSchema
  ),
  z.lazy(() => RestAuthenticationLoginGetAuthTokenFromHeaderTrue$inboundSchema),
]);
/** @internal */
export type RestAuthenticationLogin$Outbound =
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalse$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationLogin$outboundSchema: z.ZodType<
  RestAuthenticationLogin$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLogin
> = smartUnion([
  z.lazy(() =>
    RestAuthenticationLoginGetAuthTokenFromHeaderFalse$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationLoginGetAuthTokenFromHeaderTrue$outboundSchema
  ),
]);

export function restAuthenticationLoginToJSON(
  restAuthenticationLogin: RestAuthenticationLogin,
): string {
  return JSON.stringify(
    RestAuthenticationLogin$outboundSchema.parse(restAuthenticationLogin),
  );
}
export function restAuthenticationLoginFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationLogin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationLogin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLogin' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$Outbound =
  {
    discoverType: "none";
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$outboundSchema
      .parse(restAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$Outbound =
  {
    discoverType: "list";
    itemList: Array<string>;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeList:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$outboundSchema
      .parse(restAuthenticationBasicSecretRestDiscoveryDiscoverTypeList),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$Outbound =
  {
    discoverType: "json";
    manualDiscoverResult: string;
    discoverDataField?: string | undefined;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$outboundSchema
      .parse(restAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp$outboundSchema
      .parse(restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationBasicSecretDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationBasicSecretDiscovery$Outbound =
  | (
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationBasicSecretDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationBasicSecretDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicSecretDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restAuthenticationBasicSecretDiscoveryToJSON(
  restAuthenticationBasicSecretDiscovery:
    RestAuthenticationBasicSecretDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretDiscovery$outboundSchema.parse(
      restAuthenticationBasicSecretDiscovery,
    ),
  );
}
export function restAuthenticationBasicSecretDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicSecretDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretCollectMethod$inboundSchema:
  z.ZodType<RestAuthenticationBasicSecretCollectMethod, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(RestAuthenticationBasicSecretCollectMethod);
/** @internal */
export const RestAuthenticationBasicSecretCollectMethod$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationBasicSecretCollectMethod> =
    openEnums.outboundSchema(RestAuthenticationBasicSecretCollectMethod);

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestPaginationTypeRequestPage$Outbound =
  {
    type: "request_page";
    pageField: string;
    page?: number | undefined;
    sizeField: string;
    size: number;
    totalPageField?: string | undefined;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationBasicSecretRestPaginationTypeRequestPageToJSON(
  restAuthenticationBasicSecretRestPaginationTypeRequestPage:
    RestAuthenticationBasicSecretRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestPaginationTypeRequestPage$outboundSchema
      .parse(restAuthenticationBasicSecretRestPaginationTypeRequestPage),
  );
}
export function restAuthenticationBasicSecretRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestPaginationTypeRequestPage$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$Outbound =
  {
    type: "request_offset";
    offsetField: string;
    offset?: number | undefined;
    limitField: string;
    limit: number;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationBasicSecretRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationBasicSecretRestPaginationTypeRequestOffset:
    RestAuthenticationBasicSecretRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$outboundSchema
      .parse(restAuthenticationBasicSecretRestPaginationTypeRequestOffset),
  );
}
export function restAuthenticationBasicSecretRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationBasicSecretRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink:
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink),
  );
}
export function restAuthenticationBasicSecretRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$Outbound =
  {
    type: "response_header";
    attribute: Array<string>;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationBasicSecretRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationBasicSecretRestPaginationTypeResponseHeader:
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$outboundSchema
      .parse(restAuthenticationBasicSecretRestPaginationTypeResponseHeader),
  );
}
export function restAuthenticationBasicSecretRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestPaginationTypeResponseBody$Outbound =
  {
    type: "response_body";
    attribute: Array<string>;
    maxPages: number;
    lastPageExpr?: string | undefined;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationBasicSecretRestPaginationTypeResponseBodyToJSON(
  restAuthenticationBasicSecretRestPaginationTypeResponseBody:
    RestAuthenticationBasicSecretRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestPaginationTypeResponseBody$outboundSchema
      .parse(restAuthenticationBasicSecretRestPaginationTypeResponseBody),
  );
}
export function restAuthenticationBasicSecretRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationBasicSecretRestPaginationTypeNoneToJSON(
  restAuthenticationBasicSecretRestPaginationTypeNone:
    RestAuthenticationBasicSecretRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestPaginationTypeNone$outboundSchema.parse(
      restAuthenticationBasicSecretRestPaginationTypeNone,
    ),
  );
}
export function restAuthenticationBasicSecretRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicSecretRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretPaginationUnion$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretPaginationUnion,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeRequestPage$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationBasicSecretPaginationUnion$Outbound =
  | RestAuthenticationBasicSecretRestPaginationTypeNone$Outbound
  | RestAuthenticationBasicSecretRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationBasicSecretRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationBasicSecretPaginationUnion$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretPaginationUnion$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretPaginationUnion
  > = z.union([
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeRequestPage$outboundSchema
    ),
  ]);

export function restAuthenticationBasicSecretPaginationUnionToJSON(
  restAuthenticationBasicSecretPaginationUnion:
    RestAuthenticationBasicSecretPaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretPaginationUnion$outboundSchema.parse(
      restAuthenticationBasicSecretPaginationUnion,
    ),
  );
}
export function restAuthenticationBasicSecretPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretPaginationUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretPaginationUnion$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicSecretPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationBasicSecretRestRetryRulesTypeBackoff$Outbound =
  | RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationBasicSecretRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationBasicSecretRestRetryRulesTypeBackoffToJSON(
  restAuthenticationBasicSecretRestRetryRulesTypeBackoff:
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoff$outboundSchema.parse(
      restAuthenticationBasicSecretRestRetryRulesTypeBackoff,
    ),
  );
}
export function restAuthenticationBasicSecretRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestRetryRulesTypeBackoff$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue:
    RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse:
    RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationBasicSecretRestRetryRulesTypeStatic$Outbound =
  | RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationBasicSecretRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationBasicSecretRestRetryRulesTypeStaticToJSON(
  restAuthenticationBasicSecretRestRetryRulesTypeStatic:
    RestAuthenticationBasicSecretRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestRetryRulesTypeStatic$outboundSchema.parse(
      restAuthenticationBasicSecretRestRetryRulesTypeStatic,
    ),
  );
}
export function restAuthenticationBasicSecretRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicSecretRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationBasicSecretRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationBasicSecretRestRetryRulesTypeNoneToJSON(
  restAuthenticationBasicSecretRestRetryRulesTypeNone:
    RestAuthenticationBasicSecretRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestRetryRulesTypeNone$outboundSchema.parse(
      restAuthenticationBasicSecretRestRetryRulesTypeNone,
    ),
  );
}
export function restAuthenticationBasicSecretRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicSecretRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationBasicSecretRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationBasicSecretRestRetryRulesTypeNone$inboundSchema
  ),
  static: smartUnion([
    z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  backoff: smartUnion([
    z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
});
/** @internal */
export type RestAuthenticationBasicSecretRetryRules$Outbound =
  | RestAuthenticationBasicSecretRestRetryRulesTypeNone$Outbound
  | (
    | RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
      & { type: "static" }
  )
  | (
    | RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestAuthenticationBasicSecretRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationBasicSecretRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicSecretRetryRules
> = z.union([
  z.lazy(() =>
    RestAuthenticationBasicSecretRestRetryRulesTypeNone$outboundSchema
  ),
  smartUnion([
    z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  smartUnion([
    z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
]);

export function restAuthenticationBasicSecretRetryRulesToJSON(
  restAuthenticationBasicSecretRetryRules:
    RestAuthenticationBasicSecretRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRetryRules$outboundSchema.parse(
      restAuthenticationBasicSecretRetryRules,
    ),
  );
}
export function restAuthenticationBasicSecretRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicSecretRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretStateTracking$inboundSchema:
  z.ZodType<RestAuthenticationBasicSecretStateTracking, z.ZodTypeDef, unknown> =
    z.object({
      enabled: types.optional(types.boolean()),
    });
/** @internal */
export type RestAuthenticationBasicSecretStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationBasicSecretStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationBasicSecretStateTrackingToJSON(
  restAuthenticationBasicSecretStateTracking:
    RestAuthenticationBasicSecretStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretStateTracking$outboundSchema.parse(
      restAuthenticationBasicSecretStateTracking,
    ),
  );
}
export function restAuthenticationBasicSecretStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicSecretStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretScheduling$inboundSchema: z.ZodType<
  RestAuthenticationBasicSecretScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestAuthenticationBasicSecretStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationBasicSecretScheduling$Outbound = {
  stateTracking?:
    | RestAuthenticationBasicSecretStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationBasicSecretScheduling$outboundSchema: z.ZodType<
  RestAuthenticationBasicSecretScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicSecretScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationBasicSecretStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationBasicSecretSchedulingToJSON(
  restAuthenticationBasicSecretScheduling:
    RestAuthenticationBasicSecretScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretScheduling$outboundSchema.parse(
      restAuthenticationBasicSecretScheduling,
    ),
  );
}
export function restAuthenticationBasicSecretSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicSecretScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecret$inboundSchema: z.ZodType<
  RestAuthenticationBasicSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("basicSecret"),
  credentialsSecret: types.string(),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectMethod: RestAuthenticationBasicSecretCollectMethod$inboundSchema,
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestAuthenticationBasicSecretScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationBasicSecret$Outbound = {
  authentication: "basicSecret";
  credentialsSecret: string;
  discovery?:
    | (
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationBasicSecretRestPaginationTypeNone$Outbound
    | RestAuthenticationBasicSecretRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationBasicSecretRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationBasicSecretRestRetryRulesTypeNone$Outbound
    | (
      | RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?: RestAuthenticationBasicSecretScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationBasicSecret$outboundSchema: z.ZodType<
  RestAuthenticationBasicSecret$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicSecret
> = z.object({
  authentication: z.literal("basicSecret"),
  credentialsSecret: z.string(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationBasicSecretCollectMethod$outboundSchema,
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeNone$outboundSchema
    ),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationBasicSecretScheduling$outboundSchema
  ).optional(),
});

export function restAuthenticationBasicSecretToJSON(
  restAuthenticationBasicSecret: RestAuthenticationBasicSecret,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecret$outboundSchema.parse(
      restAuthenticationBasicSecret,
    ),
  );
}
export function restAuthenticationBasicSecretFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationBasicSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecret' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$Outbound = {
  discoverType: "none";
};

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeNone:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$outboundSchema.parse(
      restAuthenticationBasicRestDiscoveryDiscoverTypeNone,
    ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeList$Outbound = {
  discoverType: "list";
  itemList: Array<string>;
};

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeList:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeList$outboundSchema.parse(
      restAuthenticationBasicRestDiscoveryDiscoverTypeList,
    ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeList$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$Outbound = {
  discoverType: "json";
  manualDiscoverResult: string;
  discoverDataField?: string | undefined;
};

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeJson:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$outboundSchema.parse(
      restAuthenticationBasicRestDiscoveryDiscoverTypeJson,
    ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp$outboundSchema.parse(
      restAuthenticationBasicRestDiscoveryDiscoverTypeHttp,
    ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationBasicDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestAuthenticationBasicRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationBasicDiscovery$Outbound =
  | (
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationBasicDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationBasicDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationBasicRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restAuthenticationBasicDiscoveryToJSON(
  restAuthenticationBasicDiscovery: RestAuthenticationBasicDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationBasicDiscovery$outboundSchema.parse(
      restAuthenticationBasicDiscovery,
    ),
  );
}
export function restAuthenticationBasicDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationBasicDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicCollectMethod$inboundSchema: z.ZodType<
  RestAuthenticationBasicCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationBasicCollectMethod);
/** @internal */
export const RestAuthenticationBasicCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationBasicCollectMethod
> = openEnums.outboundSchema(RestAuthenticationBasicCollectMethod);

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationBasicRestPaginationTypeRequestPage$Outbound = {
  type: "request_page";
  pageField: string;
  page?: number | undefined;
  sizeField: string;
  size: number;
  totalPageField?: string | undefined;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationBasicRestPaginationTypeRequestPageToJSON(
  restAuthenticationBasicRestPaginationTypeRequestPage:
    RestAuthenticationBasicRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestPaginationTypeRequestPage$outboundSchema.parse(
      restAuthenticationBasicRestPaginationTypeRequestPage,
    ),
  );
}
export function restAuthenticationBasicRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestPaginationTypeRequestPage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationBasicRestPaginationTypeRequestOffset$Outbound = {
  type: "request_offset";
  offsetField: string;
  offset?: number | undefined;
  limitField: string;
  limit: number;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationBasicRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationBasicRestPaginationTypeRequestOffset:
    RestAuthenticationBasicRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestPaginationTypeRequestOffset$outboundSchema.parse(
      restAuthenticationBasicRestPaginationTypeRequestOffset,
    ),
  );
}
export function restAuthenticationBasicRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationBasicRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationBasicRestPaginationTypeResponseHeaderLink:
    RestAuthenticationBasicRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restAuthenticationBasicRestPaginationTypeResponseHeaderLink),
  );
}
export function restAuthenticationBasicRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationBasicRestPaginationTypeResponseHeader$Outbound = {
  type: "response_header";
  attribute: Array<string>;
  maxPages: number;
};

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationBasicRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationBasicRestPaginationTypeResponseHeader:
    RestAuthenticationBasicRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestPaginationTypeResponseHeader$outboundSchema
      .parse(restAuthenticationBasicRestPaginationTypeResponseHeader),
  );
}
export function restAuthenticationBasicRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationBasicRestPaginationTypeResponseBody$Outbound = {
  type: "response_body";
  attribute: Array<string>;
  maxPages: number;
  lastPageExpr?: string | undefined;
};

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationBasicRestPaginationTypeResponseBodyToJSON(
  restAuthenticationBasicRestPaginationTypeResponseBody:
    RestAuthenticationBasicRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestPaginationTypeResponseBody$outboundSchema.parse(
      restAuthenticationBasicRestPaginationTypeResponseBody,
    ),
  );
}
export function restAuthenticationBasicRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestPaginationTypeResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationBasicRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationBasicRestPaginationTypeNoneToJSON(
  restAuthenticationBasicRestPaginationTypeNone:
    RestAuthenticationBasicRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestPaginationTypeNone$outboundSchema.parse(
      restAuthenticationBasicRestPaginationTypeNone,
    ),
  );
}
export function restAuthenticationBasicRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicPaginationUnion$inboundSchema: z.ZodType<
  RestAuthenticationBasicPaginationUnion,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationBasicRestPaginationTypeNone$inboundSchema
  ),
  response_body: z.lazy(() =>
    RestAuthenticationBasicRestPaginationTypeResponseBody$inboundSchema
  ),
  response_header: z.lazy(() =>
    RestAuthenticationBasicRestPaginationTypeResponseHeader$inboundSchema
  ),
  response_header_link: z.lazy(() =>
    RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$inboundSchema
  ),
  request_offset: z.lazy(() =>
    RestAuthenticationBasicRestPaginationTypeRequestOffset$inboundSchema
  ),
  request_page: z.lazy(() =>
    RestAuthenticationBasicRestPaginationTypeRequestPage$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationBasicPaginationUnion$Outbound =
  | RestAuthenticationBasicRestPaginationTypeNone$Outbound
  | RestAuthenticationBasicRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationBasicRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationBasicRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationBasicRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationBasicPaginationUnion$outboundSchema: z.ZodType<
  RestAuthenticationBasicPaginationUnion$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicPaginationUnion
> = z.union([
  z.lazy(() => RestAuthenticationBasicRestPaginationTypeNone$outboundSchema),
  z.lazy(() =>
    RestAuthenticationBasicRestPaginationTypeResponseBody$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationBasicRestPaginationTypeResponseHeader$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationBasicRestPaginationTypeRequestOffset$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationBasicRestPaginationTypeRequestPage$outboundSchema
  ),
]);

export function restAuthenticationBasicPaginationUnionToJSON(
  restAuthenticationBasicPaginationUnion:
    RestAuthenticationBasicPaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationBasicPaginationUnion$outboundSchema.parse(
      restAuthenticationBasicPaginationUnion,
    ),
  );
}
export function restAuthenticationBasicPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicPaginationUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicPaginationUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(restAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue),
  );
}
export function restAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(restAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse),
  );
}
export function restAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationBasicRestRetryRulesTypeBackoff$Outbound =
  | RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationBasicRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationBasicRestRetryRulesTypeBackoffToJSON(
  restAuthenticationBasicRestRetryRulesTypeBackoff:
    RestAuthenticationBasicRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestRetryRulesTypeBackoff$outboundSchema.parse(
      restAuthenticationBasicRestRetryRulesTypeBackoff,
    ),
  );
}
export function restAuthenticationBasicRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestRetryRulesTypeBackoff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue:
    RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(restAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue),
  );
}
export function restAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse:
    RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(restAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse),
  );
}
export function restAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationBasicRestRetryRulesTypeStatic$Outbound =
  | RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationBasicRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationBasicRestRetryRulesTypeStaticToJSON(
  restAuthenticationBasicRestRetryRulesTypeStatic:
    RestAuthenticationBasicRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestRetryRulesTypeStatic$outboundSchema.parse(
      restAuthenticationBasicRestRetryRulesTypeStatic,
    ),
  );
}
export function restAuthenticationBasicRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationBasicRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationBasicRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationBasicRestRetryRulesTypeNoneToJSON(
  restAuthenticationBasicRestRetryRulesTypeNone:
    RestAuthenticationBasicRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestRetryRulesTypeNone$outboundSchema.parse(
      restAuthenticationBasicRestRetryRulesTypeNone,
    ),
  );
}
export function restAuthenticationBasicRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationBasicRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationBasicRestRetryRulesTypeNone$inboundSchema
  ),
  static: smartUnion([
    z.lazy(() =>
      RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  backoff: smartUnion([
    z.lazy(() =>
      RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
});
/** @internal */
export type RestAuthenticationBasicRetryRules$Outbound =
  | RestAuthenticationBasicRestRetryRulesTypeNone$Outbound
  | (
    | RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
      & { type: "static" }
  )
  | (
    | RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestAuthenticationBasicRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationBasicRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicRetryRules
> = z.union([
  z.lazy(() => RestAuthenticationBasicRestRetryRulesTypeNone$outboundSchema),
  smartUnion([
    z.lazy(() =>
      RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  smartUnion([
    z.lazy(() =>
      RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
]);

export function restAuthenticationBasicRetryRulesToJSON(
  restAuthenticationBasicRetryRules: RestAuthenticationBasicRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRetryRules$outboundSchema.parse(
      restAuthenticationBasicRetryRules,
    ),
  );
}
export function restAuthenticationBasicRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationBasicRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicStateTracking$inboundSchema: z.ZodType<
  RestAuthenticationBasicStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: types.optional(types.boolean()),
});
/** @internal */
export type RestAuthenticationBasicStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationBasicStateTracking$outboundSchema: z.ZodType<
  RestAuthenticationBasicStateTracking$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restAuthenticationBasicStateTrackingToJSON(
  restAuthenticationBasicStateTracking: RestAuthenticationBasicStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationBasicStateTracking$outboundSchema.parse(
      restAuthenticationBasicStateTracking,
    ),
  );
}
export function restAuthenticationBasicStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicScheduling$inboundSchema: z.ZodType<
  RestAuthenticationBasicScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestAuthenticationBasicStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationBasicScheduling$Outbound = {
  stateTracking?: RestAuthenticationBasicStateTracking$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationBasicScheduling$outboundSchema: z.ZodType<
  RestAuthenticationBasicScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationBasicStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationBasicSchedulingToJSON(
  restAuthenticationBasicScheduling: RestAuthenticationBasicScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationBasicScheduling$outboundSchema.parse(
      restAuthenticationBasicScheduling,
    ),
  );
}
export function restAuthenticationBasicSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationBasicScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasic$inboundSchema: z.ZodType<
  RestAuthenticationBasic,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("basic"),
  username: types.string(),
  password: types.string(),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectMethod: RestAuthenticationBasicCollectMethod$inboundSchema,
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationBasicRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationBasicRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationBasicRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationBasicRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationBasicRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationBasicRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestAuthenticationBasicScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationBasic$Outbound = {
  authentication: "basic";
  username: string;
  password: string;
  discovery?:
    | (
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationBasicRestPaginationTypeNone$Outbound
    | RestAuthenticationBasicRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationBasicRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationBasicRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationBasicRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationBasicRestRetryRulesTypeNone$Outbound
    | (
      | RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?: RestAuthenticationBasicScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationBasic$outboundSchema: z.ZodType<
  RestAuthenticationBasic$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasic
> = z.object({
  authentication: z.literal("basic"),
  username: z.string(),
  password: z.string(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationBasicCollectMethod$outboundSchema,
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() => RestAuthenticationBasicRestPaginationTypeNone$outboundSchema),
    z.lazy(() =>
      RestAuthenticationBasicRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() => RestAuthenticationBasicRestRetryRulesTypeNone$outboundSchema),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationBasicRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationBasicRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]).optional(),
  __scheduling: z.lazy(() => RestAuthenticationBasicScheduling$outboundSchema)
    .optional(),
});

export function restAuthenticationBasicToJSON(
  restAuthenticationBasic: RestAuthenticationBasic,
): string {
  return JSON.stringify(
    RestAuthenticationBasic$outboundSchema.parse(restAuthenticationBasic),
  );
}
export function restAuthenticationBasicFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationBasic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$Outbound = {
  discoverType: "none";
};

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeNone:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$outboundSchema.parse(
      restAuthenticationNoneRestDiscoveryDiscoverTypeNone,
    ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeList$Outbound = {
  discoverType: "list";
  itemList: Array<string>;
};

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeList:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeList$outboundSchema.parse(
      restAuthenticationNoneRestDiscoveryDiscoverTypeList,
    ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeList$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$Outbound = {
  discoverType: "json";
  manualDiscoverResult: string;
  discoverDataField?: string | undefined;
};

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeJson:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$outboundSchema.parse(
      restAuthenticationNoneRestDiscoveryDiscoverTypeJson,
    ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp$outboundSchema.parse(
      restAuthenticationNoneRestDiscoveryDiscoverTypeHttp,
    ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationNoneDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestAuthenticationNoneRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationNoneDiscovery$Outbound =
  | (
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationNoneDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationNoneDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNoneDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationNoneRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restAuthenticationNoneDiscoveryToJSON(
  restAuthenticationNoneDiscovery: RestAuthenticationNoneDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationNoneDiscovery$outboundSchema.parse(
      restAuthenticationNoneDiscovery,
    ),
  );
}
export function restAuthenticationNoneDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNoneDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationNoneDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneCollectMethod$inboundSchema: z.ZodType<
  RestAuthenticationNoneCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationNoneCollectMethod);
/** @internal */
export const RestAuthenticationNoneCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationNoneCollectMethod
> = openEnums.outboundSchema(RestAuthenticationNoneCollectMethod);

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationNoneRestPaginationTypeRequestPage$Outbound = {
  type: "request_page";
  pageField: string;
  page?: number | undefined;
  sizeField: string;
  size: number;
  totalPageField?: string | undefined;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationNoneRestPaginationTypeRequestPageToJSON(
  restAuthenticationNoneRestPaginationTypeRequestPage:
    RestAuthenticationNoneRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestPaginationTypeRequestPage$outboundSchema.parse(
      restAuthenticationNoneRestPaginationTypeRequestPage,
    ),
  );
}
export function restAuthenticationNoneRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestPaginationTypeRequestPage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationNoneRestPaginationTypeRequestOffset$Outbound = {
  type: "request_offset";
  offsetField: string;
  offset?: number | undefined;
  limitField: string;
  limit: number;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationNoneRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationNoneRestPaginationTypeRequestOffset:
    RestAuthenticationNoneRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestPaginationTypeRequestOffset$outboundSchema.parse(
      restAuthenticationNoneRestPaginationTypeRequestOffset,
    ),
  );
}
export function restAuthenticationNoneRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestPaginationTypeRequestOffset$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationNoneRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationNoneRestPaginationTypeResponseHeaderLink:
    RestAuthenticationNoneRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restAuthenticationNoneRestPaginationTypeResponseHeaderLink),
  );
}
export function restAuthenticationNoneRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationNoneRestPaginationTypeResponseHeader$Outbound = {
  type: "response_header";
  attribute: Array<string>;
  maxPages: number;
};

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationNoneRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationNoneRestPaginationTypeResponseHeader:
    RestAuthenticationNoneRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestPaginationTypeResponseHeader$outboundSchema.parse(
      restAuthenticationNoneRestPaginationTypeResponseHeader,
    ),
  );
}
export function restAuthenticationNoneRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationNoneRestPaginationTypeResponseBody$Outbound = {
  type: "response_body";
  attribute: Array<string>;
  maxPages: number;
  lastPageExpr?: string | undefined;
};

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationNoneRestPaginationTypeResponseBodyToJSON(
  restAuthenticationNoneRestPaginationTypeResponseBody:
    RestAuthenticationNoneRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestPaginationTypeResponseBody$outboundSchema.parse(
      restAuthenticationNoneRestPaginationTypeResponseBody,
    ),
  );
}
export function restAuthenticationNoneRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestPaginationTypeResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationNoneRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationNoneRestPaginationTypeNoneToJSON(
  restAuthenticationNoneRestPaginationTypeNone:
    RestAuthenticationNoneRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestPaginationTypeNone$outboundSchema.parse(
      restAuthenticationNoneRestPaginationTypeNone,
    ),
  );
}
export function restAuthenticationNoneRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNonePaginationUnion$inboundSchema: z.ZodType<
  RestAuthenticationNonePaginationUnion,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeNone$inboundSchema
  ),
  response_body: z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeResponseBody$inboundSchema
  ),
  response_header: z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeResponseHeader$inboundSchema
  ),
  response_header_link: z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$inboundSchema
  ),
  request_offset: z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeRequestOffset$inboundSchema
  ),
  request_page: z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeRequestPage$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationNonePaginationUnion$Outbound =
  | RestAuthenticationNoneRestPaginationTypeNone$Outbound
  | RestAuthenticationNoneRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationNoneRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationNoneRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationNoneRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationNonePaginationUnion$outboundSchema: z.ZodType<
  RestAuthenticationNonePaginationUnion$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNonePaginationUnion
> = z.union([
  z.lazy(() => RestAuthenticationNoneRestPaginationTypeNone$outboundSchema),
  z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeResponseBody$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeResponseHeader$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeRequestOffset$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeRequestPage$outboundSchema
  ),
]);

export function restAuthenticationNonePaginationUnionToJSON(
  restAuthenticationNonePaginationUnion: RestAuthenticationNonePaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationNonePaginationUnion$outboundSchema.parse(
      restAuthenticationNonePaginationUnion,
    ),
  );
}
export function restAuthenticationNonePaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNonePaginationUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNonePaginationUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNonePaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(restAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue),
  );
}
export function restAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(restAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse),
  );
}
export function restAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationNoneRestRetryRulesTypeBackoff$Outbound =
  | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationNoneRestRetryRulesTypeBackoffToJSON(
  restAuthenticationNoneRestRetryRulesTypeBackoff:
    RestAuthenticationNoneRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestRetryRulesTypeBackoff$outboundSchema.parse(
      restAuthenticationNoneRestRetryRulesTypeBackoff,
    ),
  );
}
export function restAuthenticationNoneRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestRetryRulesTypeBackoff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue:
    RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(restAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue),
  );
}
export function restAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse:
    RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(restAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse),
  );
}
export function restAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationNoneRestRetryRulesTypeStatic$Outbound =
  | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationNoneRestRetryRulesTypeStaticToJSON(
  restAuthenticationNoneRestRetryRulesTypeStatic:
    RestAuthenticationNoneRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestRetryRulesTypeStatic$outboundSchema.parse(
      restAuthenticationNoneRestRetryRulesTypeStatic,
    ),
  );
}
export function restAuthenticationNoneRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationNoneRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationNoneRestRetryRulesTypeNoneToJSON(
  restAuthenticationNoneRestRetryRulesTypeNone:
    RestAuthenticationNoneRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestRetryRulesTypeNone$outboundSchema.parse(
      restAuthenticationNoneRestRetryRulesTypeNone,
    ),
  );
}
export function restAuthenticationNoneRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationNoneRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationNoneRestRetryRulesTypeNone$inboundSchema
  ),
  static: smartUnion([
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  backoff: smartUnion([
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
});
/** @internal */
export type RestAuthenticationNoneRetryRules$Outbound =
  | RestAuthenticationNoneRestRetryRulesTypeNone$Outbound
  | (
    | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
      & { type: "static" }
  )
  | (
    | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestAuthenticationNoneRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationNoneRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNoneRetryRules
> = z.union([
  z.lazy(() => RestAuthenticationNoneRestRetryRulesTypeNone$outboundSchema),
  smartUnion([
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  smartUnion([
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
]);

export function restAuthenticationNoneRetryRulesToJSON(
  restAuthenticationNoneRetryRules: RestAuthenticationNoneRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRetryRules$outboundSchema.parse(
      restAuthenticationNoneRetryRules,
    ),
  );
}
export function restAuthenticationNoneRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNoneRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationNoneRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneStateTracking$inboundSchema: z.ZodType<
  RestAuthenticationNoneStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: types.optional(types.boolean()),
});
/** @internal */
export type RestAuthenticationNoneStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationNoneStateTracking$outboundSchema: z.ZodType<
  RestAuthenticationNoneStateTracking$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNoneStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restAuthenticationNoneStateTrackingToJSON(
  restAuthenticationNoneStateTracking: RestAuthenticationNoneStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationNoneStateTracking$outboundSchema.parse(
      restAuthenticationNoneStateTracking,
    ),
  );
}
export function restAuthenticationNoneStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNoneStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneScheduling$inboundSchema: z.ZodType<
  RestAuthenticationNoneScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestAuthenticationNoneStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationNoneScheduling$Outbound = {
  stateTracking?: RestAuthenticationNoneStateTracking$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationNoneScheduling$outboundSchema: z.ZodType<
  RestAuthenticationNoneScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNoneScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationNoneStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationNoneSchedulingToJSON(
  restAuthenticationNoneScheduling: RestAuthenticationNoneScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationNoneScheduling$outboundSchema.parse(
      restAuthenticationNoneScheduling,
    ),
  );
}
export function restAuthenticationNoneSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNoneScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationNoneScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNone$inboundSchema: z.ZodType<
  RestAuthenticationNone,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("none"),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectMethod: RestAuthenticationNoneCollectMethod$inboundSchema,
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestAuthenticationNoneScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationNone$Outbound = {
  authentication: "none";
  discovery?:
    | (
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationNoneRestPaginationTypeNone$Outbound
    | RestAuthenticationNoneRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationNoneRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationNoneRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationNoneRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationNoneRestRetryRulesTypeNone$Outbound
    | (
      | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?: RestAuthenticationNoneScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationNone$outboundSchema: z.ZodType<
  RestAuthenticationNone$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNone
> = z.object({
  authentication: z.literal("none"),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationNoneCollectMethod$outboundSchema,
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() => RestAuthenticationNoneRestPaginationTypeNone$outboundSchema),
    z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() => RestAuthenticationNoneRestRetryRulesTypeNone$outboundSchema),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]).optional(),
  __scheduling: z.lazy(() => RestAuthenticationNoneScheduling$outboundSchema)
    .optional(),
});

export function restAuthenticationNoneToJSON(
  restAuthenticationNone: RestAuthenticationNone,
): string {
  return JSON.stringify(
    RestAuthenticationNone$outboundSchema.parse(restAuthenticationNone),
  );
}
export function restAuthenticationNoneFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNone, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationNone$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherCollectMethod$inboundSchema: z.ZodType<
  RestCollectMethodOtherCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodOtherCollectMethod);
/** @internal */
export const RestCollectMethodOtherCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodOtherCollectMethod
> = openEnums.outboundSchema(RestCollectMethodOtherCollectMethod);

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$Outbound = {
  discoverType: "none";
};

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeNoneToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeNone:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$outboundSchema.parse(
      restCollectMethodOtherRestDiscoveryDiscoverTypeNone,
    ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeList$Outbound = {
  discoverType: "list";
  itemList: Array<string>;
};

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeListToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeList:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeList$outboundSchema.parse(
      restCollectMethodOtherRestDiscoveryDiscoverTypeList,
    ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeList$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$Outbound = {
  discoverType: "json";
  manualDiscoverResult: string;
  discoverDataField?: string | undefined;
};

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeJsonToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeJson:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$outboundSchema.parse(
      restCollectMethodOtherRestDiscoveryDiscoverTypeJson,
    ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttp:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp$outboundSchema.parse(
      restCollectMethodOtherRestDiscoveryDiscoverTypeHttp,
    ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherDiscovery$inboundSchema: z.ZodType<
  RestCollectMethodOtherDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestCollectMethodOtherRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodOtherDiscovery$Outbound =
  | (
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$Outbound
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeList$Outbound
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestCollectMethodOtherDiscovery$outboundSchema: z.ZodType<
  RestCollectMethodOtherDiscovery$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodOtherRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restCollectMethodOtherDiscoveryToJSON(
  restCollectMethodOtherDiscovery: RestCollectMethodOtherDiscovery,
): string {
  return JSON.stringify(
    RestCollectMethodOtherDiscovery$outboundSchema.parse(
      restCollectMethodOtherDiscovery,
    ),
  );
}
export function restCollectMethodOtherDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodOtherDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherDiscovery' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodOtherRestPaginationTypeRequestPage$Outbound = {
  type: "request_page";
  pageField: string;
  page?: number | undefined;
  sizeField: string;
  size: number;
  totalPageField?: string | undefined;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodOtherRestPaginationTypeRequestPageToJSON(
  restCollectMethodOtherRestPaginationTypeRequestPage:
    RestCollectMethodOtherRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestPaginationTypeRequestPage$outboundSchema.parse(
      restCollectMethodOtherRestPaginationTypeRequestPage,
    ),
  );
}
export function restCollectMethodOtherRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestPaginationTypeRequestPage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodOtherRestPaginationTypeRequestOffset$Outbound = {
  type: "request_offset";
  offsetField: string;
  offset?: number | undefined;
  limitField: string;
  limit: number;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodOtherRestPaginationTypeRequestOffsetToJSON(
  restCollectMethodOtherRestPaginationTypeRequestOffset:
    RestCollectMethodOtherRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestPaginationTypeRequestOffset$outboundSchema.parse(
      restCollectMethodOtherRestPaginationTypeRequestOffset,
    ),
  );
}
export function restCollectMethodOtherRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestPaginationTypeRequestOffset$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restCollectMethodOtherRestPaginationTypeResponseHeaderLinkToJSON(
  restCollectMethodOtherRestPaginationTypeResponseHeaderLink:
    RestCollectMethodOtherRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restCollectMethodOtherRestPaginationTypeResponseHeaderLink),
  );
}
export function restCollectMethodOtherRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodOtherRestPaginationTypeResponseHeader$Outbound = {
  type: "response_header";
  attribute: Array<string>;
  maxPages: number;
};

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restCollectMethodOtherRestPaginationTypeResponseHeaderToJSON(
  restCollectMethodOtherRestPaginationTypeResponseHeader:
    RestCollectMethodOtherRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestPaginationTypeResponseHeader$outboundSchema.parse(
      restCollectMethodOtherRestPaginationTypeResponseHeader,
    ),
  );
}
export function restCollectMethodOtherRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodOtherRestPaginationTypeResponseBody$Outbound = {
  type: "response_body";
  attribute: Array<string>;
  maxPages: number;
  lastPageExpr?: string | undefined;
};

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restCollectMethodOtherRestPaginationTypeResponseBodyToJSON(
  restCollectMethodOtherRestPaginationTypeResponseBody:
    RestCollectMethodOtherRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestPaginationTypeResponseBody$outboundSchema.parse(
      restCollectMethodOtherRestPaginationTypeResponseBody,
    ),
  );
}
export function restCollectMethodOtherRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestPaginationTypeResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodOtherRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restCollectMethodOtherRestPaginationTypeNoneToJSON(
  restCollectMethodOtherRestPaginationTypeNone:
    RestCollectMethodOtherRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestPaginationTypeNone$outboundSchema.parse(
      restCollectMethodOtherRestPaginationTypeNone,
    ),
  );
}
export function restCollectMethodOtherRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherPaginationUnion$inboundSchema: z.ZodType<
  RestCollectMethodOtherPaginationUnion,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeNone$inboundSchema
  ),
  response_body: z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeResponseBody$inboundSchema
  ),
  response_header: z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeResponseHeader$inboundSchema
  ),
  response_header_link: z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$inboundSchema
  ),
  request_offset: z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeRequestOffset$inboundSchema
  ),
  request_page: z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeRequestPage$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodOtherPaginationUnion$Outbound =
  | RestCollectMethodOtherRestPaginationTypeNone$Outbound
  | RestCollectMethodOtherRestPaginationTypeResponseBody$Outbound
  | RestCollectMethodOtherRestPaginationTypeResponseHeader$Outbound
  | RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$Outbound
  | RestCollectMethodOtherRestPaginationTypeRequestOffset$Outbound
  | RestCollectMethodOtherRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestCollectMethodOtherPaginationUnion$outboundSchema: z.ZodType<
  RestCollectMethodOtherPaginationUnion$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherPaginationUnion
> = z.union([
  z.lazy(() => RestCollectMethodOtherRestPaginationTypeNone$outboundSchema),
  z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeResponseBody$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeResponseHeader$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeRequestOffset$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeRequestPage$outboundSchema
  ),
]);

export function restCollectMethodOtherPaginationUnionToJSON(
  restCollectMethodOtherPaginationUnion: RestCollectMethodOtherPaginationUnion,
): string {
  return JSON.stringify(
    RestCollectMethodOtherPaginationUnion$outboundSchema.parse(
      restCollectMethodOtherPaginationUnion,
    ),
  );
}
export function restCollectMethodOtherPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherPaginationUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherPaginationUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherAuthentication$inboundSchema: z.ZodType<
  RestCollectMethodOtherAuthentication,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodOtherAuthentication);
/** @internal */
export const RestCollectMethodOtherAuthentication$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodOtherAuthentication
> = openEnums.outboundSchema(RestCollectMethodOtherAuthentication);

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(restCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue),
  );
}
export function restCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(restCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse),
  );
}
export function restCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestCollectMethodOtherRestRetryRulesTypeBackoff$Outbound =
  | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restCollectMethodOtherRestRetryRulesTypeBackoffToJSON(
  restCollectMethodOtherRestRetryRulesTypeBackoff:
    RestCollectMethodOtherRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestRetryRulesTypeBackoff$outboundSchema.parse(
      restCollectMethodOtherRestRetryRulesTypeBackoff,
    ),
  );
}
export function restCollectMethodOtherRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestRetryRulesTypeBackoff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue:
    RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(restCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue),
  );
}
export function restCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse:
    RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(restCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse),
  );
}
export function restCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestCollectMethodOtherRestRetryRulesTypeStatic$Outbound =
  | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restCollectMethodOtherRestRetryRulesTypeStaticToJSON(
  restCollectMethodOtherRestRetryRulesTypeStatic:
    RestCollectMethodOtherRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestRetryRulesTypeStatic$outboundSchema.parse(
      restCollectMethodOtherRestRetryRulesTypeStatic,
    ),
  );
}
export function restCollectMethodOtherRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodOtherRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restCollectMethodOtherRestRetryRulesTypeNoneToJSON(
  restCollectMethodOtherRestRetryRulesTypeNone:
    RestCollectMethodOtherRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestRetryRulesTypeNone$outboundSchema.parse(
      restCollectMethodOtherRestRetryRulesTypeNone,
    ),
  );
}
export function restCollectMethodOtherRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRetryRules$inboundSchema: z.ZodType<
  RestCollectMethodOtherRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestCollectMethodOtherRestRetryRulesTypeNone$inboundSchema
  ),
  static: smartUnion([
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  backoff: smartUnion([
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
});
/** @internal */
export type RestCollectMethodOtherRetryRules$Outbound =
  | RestCollectMethodOtherRestRetryRulesTypeNone$Outbound
  | (
    | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
      & { type: "static" }
  )
  | (
    | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestCollectMethodOtherRetryRules$outboundSchema: z.ZodType<
  RestCollectMethodOtherRetryRules$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherRetryRules
> = z.union([
  z.lazy(() => RestCollectMethodOtherRestRetryRulesTypeNone$outboundSchema),
  smartUnion([
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  smartUnion([
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
]);

export function restCollectMethodOtherRetryRulesToJSON(
  restCollectMethodOtherRetryRules: RestCollectMethodOtherRetryRules,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRetryRules$outboundSchema.parse(
      restCollectMethodOtherRetryRules,
    ),
  );
}
export function restCollectMethodOtherRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodOtherRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRetryRules' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherStateTracking$inboundSchema: z.ZodType<
  RestCollectMethodOtherStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: types.optional(types.boolean()),
});
/** @internal */
export type RestCollectMethodOtherStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestCollectMethodOtherStateTracking$outboundSchema: z.ZodType<
  RestCollectMethodOtherStateTracking$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restCollectMethodOtherStateTrackingToJSON(
  restCollectMethodOtherStateTracking: RestCollectMethodOtherStateTracking,
): string {
  return JSON.stringify(
    RestCollectMethodOtherStateTracking$outboundSchema.parse(
      restCollectMethodOtherStateTracking,
    ),
  );
}
export function restCollectMethodOtherStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherStateTracking' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherScheduling$inboundSchema: z.ZodType<
  RestCollectMethodOtherScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestCollectMethodOtherStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestCollectMethodOtherScheduling$Outbound = {
  stateTracking?: RestCollectMethodOtherStateTracking$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodOtherScheduling$outboundSchema: z.ZodType<
  RestCollectMethodOtherScheduling$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestCollectMethodOtherStateTracking$outboundSchema
  ).optional(),
});

export function restCollectMethodOtherSchedulingToJSON(
  restCollectMethodOtherScheduling: RestCollectMethodOtherScheduling,
): string {
  return JSON.stringify(
    RestCollectMethodOtherScheduling$outboundSchema.parse(
      restCollectMethodOtherScheduling,
    ),
  );
}
export function restCollectMethodOtherSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodOtherScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherScheduling' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOther$inboundSchema: z.ZodType<
  RestCollectMethodOther,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: RestCollectMethodOtherCollectMethod$inboundSchema,
  collectVerb: types.string(),
  collectBody: types.optional(types.string()),
  collectRequestParams: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  authentication: RestCollectMethodOtherAuthentication$inboundSchema,
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestCollectMethodOtherScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestCollectMethodOther$Outbound = {
  collectMethod: string;
  collectVerb: string;
  collectBody?: string | undefined;
  collectRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?:
    | (
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$Outbound
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeList$Outbound
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestCollectMethodOtherRestPaginationTypeNone$Outbound
    | RestCollectMethodOtherRestPaginationTypeResponseBody$Outbound
    | RestCollectMethodOtherRestPaginationTypeResponseHeader$Outbound
    | RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$Outbound
    | RestCollectMethodOtherRestPaginationTypeRequestOffset$Outbound
    | RestCollectMethodOtherRestPaginationTypeRequestPage$Outbound
    | undefined;
  authentication: string;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestCollectMethodOtherRestRetryRulesTypeNone$Outbound
    | (
      | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?: RestCollectMethodOtherScheduling$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodOther$outboundSchema: z.ZodType<
  RestCollectMethodOther$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOther
> = z.object({
  collectMethod: RestCollectMethodOtherCollectMethod$outboundSchema,
  collectVerb: z.string(),
  collectBody: z.string().optional(),
  collectRequestParams: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() => RestCollectMethodOtherRestPaginationTypeNone$outboundSchema),
    z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  authentication: RestCollectMethodOtherAuthentication$outboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() => RestCollectMethodOtherRestRetryRulesTypeNone$outboundSchema),
    smartUnion([
      z.lazy(() =>
        RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]).optional(),
  __scheduling: z.lazy(() => RestCollectMethodOtherScheduling$outboundSchema)
    .optional(),
});

export function restCollectMethodOtherToJSON(
  restCollectMethodOther: RestCollectMethodOther,
): string {
  return JSON.stringify(
    RestCollectMethodOther$outboundSchema.parse(restCollectMethodOther),
  );
}
export function restCollectMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOther, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodOther$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOther' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyCollectMethod$inboundSchema:
  z.ZodType<RestCollectMethodPostWithBodyCollectMethod, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(RestCollectMethodPostWithBodyCollectMethod);
/** @internal */
export const RestCollectMethodPostWithBodyCollectMethod$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestCollectMethodPostWithBodyCollectMethod> =
    openEnums.outboundSchema(RestCollectMethodPostWithBodyCollectMethod);

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$Outbound =
  {
    discoverType: "none";
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNoneToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$outboundSchema
      .parse(restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$Outbound =
  {
    discoverType: "list";
    itemList: Array<string>;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeListToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$outboundSchema
      .parse(restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$Outbound =
  {
    discoverType: "json";
    manualDiscoverResult: string;
    discoverDataField?: string | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJsonToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$outboundSchema
      .parse(restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp$outboundSchema
      .parse(restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyDiscovery$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodPostWithBodyDiscovery$Outbound =
  | (
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$Outbound
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$Outbound
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestCollectMethodPostWithBodyDiscovery$outboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyDiscovery$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostWithBodyDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restCollectMethodPostWithBodyDiscoveryToJSON(
  restCollectMethodPostWithBodyDiscovery:
    RestCollectMethodPostWithBodyDiscovery,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyDiscovery$outboundSchema.parse(
      restCollectMethodPostWithBodyDiscovery,
    ),
  );
}
export function restCollectMethodPostWithBodyDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostWithBodyDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyDiscovery' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$Outbound =
  {
    type: "request_page";
    pageField: string;
    page?: number | undefined;
    sizeField: string;
    size: number;
    totalPageField?: string | undefined;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodPostWithBodyRestPaginationTypeRequestPageToJSON(
  restCollectMethodPostWithBodyRestPaginationTypeRequestPage:
    RestCollectMethodPostWithBodyRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$outboundSchema
      .parse(restCollectMethodPostWithBodyRestPaginationTypeRequestPage),
  );
}
export function restCollectMethodPostWithBodyRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$Outbound =
  {
    type: "request_offset";
    offsetField: string;
    offset?: number | undefined;
    limitField: string;
    limit: number;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodPostWithBodyRestPaginationTypeRequestOffsetToJSON(
  restCollectMethodPostWithBodyRestPaginationTypeRequestOffset:
    RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$outboundSchema
      .parse(restCollectMethodPostWithBodyRestPaginationTypeRequestOffset),
  );
}
export function restCollectMethodPostWithBodyRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLinkToJSON(
  restCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink:
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink),
  );
}
export function restCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$Outbound =
  {
    type: "response_header";
    attribute: Array<string>;
    maxPages: number;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restCollectMethodPostWithBodyRestPaginationTypeResponseHeaderToJSON(
  restCollectMethodPostWithBodyRestPaginationTypeResponseHeader:
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$outboundSchema
      .parse(restCollectMethodPostWithBodyRestPaginationTypeResponseHeader),
  );
}
export function restCollectMethodPostWithBodyRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$Outbound =
  {
    type: "response_body";
    attribute: Array<string>;
    maxPages: number;
    lastPageExpr?: string | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restCollectMethodPostWithBodyRestPaginationTypeResponseBodyToJSON(
  restCollectMethodPostWithBodyRestPaginationTypeResponseBody:
    RestCollectMethodPostWithBodyRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$outboundSchema
      .parse(restCollectMethodPostWithBodyRestPaginationTypeResponseBody),
  );
}
export function restCollectMethodPostWithBodyRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restCollectMethodPostWithBodyRestPaginationTypeNoneToJSON(
  restCollectMethodPostWithBodyRestPaginationTypeNone:
    RestCollectMethodPostWithBodyRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestPaginationTypeNone$outboundSchema.parse(
      restCollectMethodPostWithBodyRestPaginationTypeNone,
    ),
  );
}
export function restCollectMethodPostWithBodyRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyPaginationUnion$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyPaginationUnion,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$inboundSchema
    ),
  });
/** @internal */
export type RestCollectMethodPostWithBodyPaginationUnion$Outbound =
  | RestCollectMethodPostWithBodyRestPaginationTypeNone$Outbound
  | RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$Outbound
  | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$Outbound
  | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$Outbound
  | RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$Outbound
  | RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestCollectMethodPostWithBodyPaginationUnion$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyPaginationUnion$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyPaginationUnion
  > = z.union([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$outboundSchema
    ),
  ]);

export function restCollectMethodPostWithBodyPaginationUnionToJSON(
  restCollectMethodPostWithBodyPaginationUnion:
    RestCollectMethodPostWithBodyPaginationUnion,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyPaginationUnion$outboundSchema.parse(
      restCollectMethodPostWithBodyPaginationUnion,
    ),
  );
}
export function restCollectMethodPostWithBodyPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyPaginationUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyPaginationUnion$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyAuthentication$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyAuthentication,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RestCollectMethodPostWithBodyAuthentication);
/** @internal */
export const RestCollectMethodPostWithBodyAuthentication$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestCollectMethodPostWithBodyAuthentication> =
    openEnums.outboundSchema(RestCollectMethodPostWithBodyAuthentication);

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue,
      ),
  );
}
export function restCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse,
      ),
  );
}
export function restCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$Outbound =
  | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restCollectMethodPostWithBodyRestRetryRulesTypeBackoffToJSON(
  restCollectMethodPostWithBodyRestRetryRulesTypeBackoff:
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$outboundSchema.parse(
      restCollectMethodPostWithBodyRestRetryRulesTypeBackoff,
    ),
  );
}
export function restCollectMethodPostWithBodyRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue:
    RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue,
      ),
  );
}
export function restCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse:
    RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse,
      ),
  );
}
export function restCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$Outbound =
  | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restCollectMethodPostWithBodyRestRetryRulesTypeStaticToJSON(
  restCollectMethodPostWithBodyRestRetryRulesTypeStatic:
    RestCollectMethodPostWithBodyRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$outboundSchema.parse(
      restCollectMethodPostWithBodyRestRetryRulesTypeStatic,
    ),
  );
}
export function restCollectMethodPostWithBodyRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restCollectMethodPostWithBodyRestRetryRulesTypeNoneToJSON(
  restCollectMethodPostWithBodyRestRetryRulesTypeNone:
    RestCollectMethodPostWithBodyRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestRetryRulesTypeNone$outboundSchema.parse(
      restCollectMethodPostWithBodyRestRetryRulesTypeNone,
    ),
  );
}
export function restCollectMethodPostWithBodyRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRetryRules$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestCollectMethodPostWithBodyRestRetryRulesTypeNone$inboundSchema
  ),
  static: smartUnion([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  backoff: smartUnion([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
});
/** @internal */
export type RestCollectMethodPostWithBodyRetryRules$Outbound =
  | RestCollectMethodPostWithBodyRestRetryRulesTypeNone$Outbound
  | (
    | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
      & { type: "static" }
  )
  | (
    | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestCollectMethodPostWithBodyRetryRules$outboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyRetryRules$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostWithBodyRetryRules
> = z.union([
  z.lazy(() =>
    RestCollectMethodPostWithBodyRestRetryRulesTypeNone$outboundSchema
  ),
  smartUnion([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  smartUnion([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
]);

export function restCollectMethodPostWithBodyRetryRulesToJSON(
  restCollectMethodPostWithBodyRetryRules:
    RestCollectMethodPostWithBodyRetryRules,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRetryRules$outboundSchema.parse(
      restCollectMethodPostWithBodyRetryRules,
    ),
  );
}
export function restCollectMethodPostWithBodyRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyRetryRules' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyStateTracking$inboundSchema:
  z.ZodType<RestCollectMethodPostWithBodyStateTracking, z.ZodTypeDef, unknown> =
    z.object({
      enabled: types.optional(types.boolean()),
    });
/** @internal */
export type RestCollectMethodPostWithBodyStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestCollectMethodPostWithBodyStateTracking$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyStateTracking$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyStateTrackingToJSON(
  restCollectMethodPostWithBodyStateTracking:
    RestCollectMethodPostWithBodyStateTracking,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyStateTracking$outboundSchema.parse(
      restCollectMethodPostWithBodyStateTracking,
    ),
  );
}
export function restCollectMethodPostWithBodyStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyStateTracking' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyScheduling$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestCollectMethodPostWithBodyStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestCollectMethodPostWithBodyScheduling$Outbound = {
  stateTracking?:
    | RestCollectMethodPostWithBodyStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestCollectMethodPostWithBodyScheduling$outboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyScheduling$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostWithBodyScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestCollectMethodPostWithBodyStateTracking$outboundSchema
  ).optional(),
});

export function restCollectMethodPostWithBodySchedulingToJSON(
  restCollectMethodPostWithBodyScheduling:
    RestCollectMethodPostWithBodyScheduling,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyScheduling$outboundSchema.parse(
      restCollectMethodPostWithBodyScheduling,
    ),
  );
}
export function restCollectMethodPostWithBodySchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyScheduling' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBody$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: RestCollectMethodPostWithBodyCollectMethod$inboundSchema,
  collectBody: types.string(),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  authentication: RestCollectMethodPostWithBodyAuthentication$inboundSchema,
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestCollectMethodPostWithBodyScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestCollectMethodPostWithBody$Outbound = {
  collectMethod: string;
  collectBody: string;
  discovery?:
    | (
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$Outbound
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$Outbound
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestCollectMethodPostWithBodyRestPaginationTypeNone$Outbound
    | RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$Outbound
    | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$Outbound
    | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$Outbound
    | RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$Outbound
    | RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$Outbound
    | undefined;
  authentication: string;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestCollectMethodPostWithBodyRestRetryRulesTypeNone$Outbound
    | (
      | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?: RestCollectMethodPostWithBodyScheduling$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodPostWithBody$outboundSchema: z.ZodType<
  RestCollectMethodPostWithBody$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostWithBody
> = z.object({
  collectMethod: RestCollectMethodPostWithBodyCollectMethod$outboundSchema,
  collectBody: z.string(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  authentication: RestCollectMethodPostWithBodyAuthentication$outboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeNone$outboundSchema
    ),
    smartUnion([
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]).optional(),
  __scheduling: z.lazy(() =>
    RestCollectMethodPostWithBodyScheduling$outboundSchema
  ).optional(),
});

export function restCollectMethodPostWithBodyToJSON(
  restCollectMethodPostWithBody: RestCollectMethodPostWithBody,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBody$outboundSchema.parse(
      restCollectMethodPostWithBody,
    ),
  );
}
export function restCollectMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostWithBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPostWithBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostCollectMethod$inboundSchema: z.ZodType<
  RestCollectMethodPostCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodPostCollectMethod);
/** @internal */
export const RestCollectMethodPostCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodPostCollectMethod
> = openEnums.outboundSchema(RestCollectMethodPostCollectMethod);

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeNone$Outbound = {
  discoverType: "none";
};

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeNoneToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeNone:
    RestCollectMethodPostRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeNone$outboundSchema.parse(
      restCollectMethodPostRestDiscoveryDiscoverTypeNone,
    ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeList$Outbound = {
  discoverType: "list";
  itemList: Array<string>;
};

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeListToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeList:
    RestCollectMethodPostRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeList$outboundSchema.parse(
      restCollectMethodPostRestDiscoveryDiscoverTypeList,
    ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeList$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeJson$Outbound = {
  discoverType: "json";
  manualDiscoverResult: string;
  discoverDataField?: string | undefined;
};

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeJsonToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeJson:
    RestCollectMethodPostRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeJson$outboundSchema.parse(
      restCollectMethodPostRestDiscoveryDiscoverTypeJson,
    ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeJson$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttp:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttp$outboundSchema.parse(
      restCollectMethodPostRestDiscoveryDiscoverTypeHttp,
    ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttp$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostDiscovery$inboundSchema: z.ZodType<
  RestCollectMethodPostDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestCollectMethodPostRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestCollectMethodPostRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestCollectMethodPostRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodPostDiscovery$Outbound =
  | (
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestCollectMethodPostRestDiscoveryDiscoverTypeJson$Outbound
  | RestCollectMethodPostRestDiscoveryDiscoverTypeList$Outbound
  | RestCollectMethodPostRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestCollectMethodPostDiscovery$outboundSchema: z.ZodType<
  RestCollectMethodPostDiscovery$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestCollectMethodPostRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restCollectMethodPostDiscoveryToJSON(
  restCollectMethodPostDiscovery: RestCollectMethodPostDiscovery,
): string {
  return JSON.stringify(
    RestCollectMethodPostDiscovery$outboundSchema.parse(
      restCollectMethodPostDiscovery,
    ),
  );
}
export function restCollectMethodPostDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPostDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostDiscovery' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodPostRestPaginationTypeRequestPage$Outbound = {
  type: "request_page";
  pageField: string;
  page?: number | undefined;
  sizeField: string;
  size: number;
  totalPageField?: string | undefined;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestCollectMethodPostRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodPostRestPaginationTypeRequestPageToJSON(
  restCollectMethodPostRestPaginationTypeRequestPage:
    RestCollectMethodPostRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestPaginationTypeRequestPage$outboundSchema.parse(
      restCollectMethodPostRestPaginationTypeRequestPage,
    ),
  );
}
export function restCollectMethodPostRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestPaginationTypeRequestPage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodPostRestPaginationTypeRequestOffset$Outbound = {
  type: "request_offset";
  offsetField: string;
  offset?: number | undefined;
  limitField: string;
  limit: number;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestCollectMethodPostRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodPostRestPaginationTypeRequestOffsetToJSON(
  restCollectMethodPostRestPaginationTypeRequestOffset:
    RestCollectMethodPostRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestPaginationTypeRequestOffset$outboundSchema.parse(
      restCollectMethodPostRestPaginationTypeRequestOffset,
    ),
  );
}
export function restCollectMethodPostRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestPaginationTypeRequestOffset$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodPostRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestCollectMethodPostRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restCollectMethodPostRestPaginationTypeResponseHeaderLinkToJSON(
  restCollectMethodPostRestPaginationTypeResponseHeaderLink:
    RestCollectMethodPostRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restCollectMethodPostRestPaginationTypeResponseHeaderLink),
  );
}
export function restCollectMethodPostRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodPostRestPaginationTypeResponseHeader$Outbound = {
  type: "response_header";
  attribute: Array<string>;
  maxPages: number;
};

/** @internal */
export const RestCollectMethodPostRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restCollectMethodPostRestPaginationTypeResponseHeaderToJSON(
  restCollectMethodPostRestPaginationTypeResponseHeader:
    RestCollectMethodPostRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestPaginationTypeResponseHeader$outboundSchema.parse(
      restCollectMethodPostRestPaginationTypeResponseHeader,
    ),
  );
}
export function restCollectMethodPostRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestPaginationTypeResponseHeader$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodPostRestPaginationTypeResponseBody$Outbound = {
  type: "response_body";
  attribute: Array<string>;
  maxPages: number;
  lastPageExpr?: string | undefined;
};

/** @internal */
export const RestCollectMethodPostRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restCollectMethodPostRestPaginationTypeResponseBodyToJSON(
  restCollectMethodPostRestPaginationTypeResponseBody:
    RestCollectMethodPostRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestPaginationTypeResponseBody$outboundSchema.parse(
      restCollectMethodPostRestPaginationTypeResponseBody,
    ),
  );
}
export function restCollectMethodPostRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestPaginationTypeResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodPostRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestCollectMethodPostRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restCollectMethodPostRestPaginationTypeNoneToJSON(
  restCollectMethodPostRestPaginationTypeNone:
    RestCollectMethodPostRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestPaginationTypeNone$outboundSchema.parse(
      restCollectMethodPostRestPaginationTypeNone,
    ),
  );
}
export function restCollectMethodPostRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostPaginationUnion$inboundSchema: z.ZodType<
  RestCollectMethodPostPaginationUnion,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() => RestCollectMethodPostRestPaginationTypeNone$inboundSchema),
  response_body: z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeResponseBody$inboundSchema
  ),
  response_header: z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeResponseHeader$inboundSchema
  ),
  response_header_link: z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeResponseHeaderLink$inboundSchema
  ),
  request_offset: z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeRequestOffset$inboundSchema
  ),
  request_page: z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeRequestPage$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodPostPaginationUnion$Outbound =
  | RestCollectMethodPostRestPaginationTypeNone$Outbound
  | RestCollectMethodPostRestPaginationTypeResponseBody$Outbound
  | RestCollectMethodPostRestPaginationTypeResponseHeader$Outbound
  | RestCollectMethodPostRestPaginationTypeResponseHeaderLink$Outbound
  | RestCollectMethodPostRestPaginationTypeRequestOffset$Outbound
  | RestCollectMethodPostRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestCollectMethodPostPaginationUnion$outboundSchema: z.ZodType<
  RestCollectMethodPostPaginationUnion$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostPaginationUnion
> = z.union([
  z.lazy(() => RestCollectMethodPostRestPaginationTypeNone$outboundSchema),
  z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeResponseBody$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeResponseHeader$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeResponseHeaderLink$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeRequestOffset$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeRequestPage$outboundSchema
  ),
]);

export function restCollectMethodPostPaginationUnionToJSON(
  restCollectMethodPostPaginationUnion: RestCollectMethodPostPaginationUnion,
): string {
  return JSON.stringify(
    RestCollectMethodPostPaginationUnion$outboundSchema.parse(
      restCollectMethodPostPaginationUnion,
    ),
  );
}
export function restCollectMethodPostPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostPaginationUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostPaginationUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostAuthentication$inboundSchema: z.ZodType<
  RestCollectMethodPostAuthentication,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodPostAuthentication);
/** @internal */
export const RestCollectMethodPostAuthentication$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodPostAuthentication
> = openEnums.outboundSchema(RestCollectMethodPostAuthentication);

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(restCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue),
  );
}
export function restCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(restCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse),
  );
}
export function restCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestCollectMethodPostRestRetryRulesTypeBackoff$Outbound =
  | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restCollectMethodPostRestRetryRulesTypeBackoffToJSON(
  restCollectMethodPostRestRetryRulesTypeBackoff:
    RestCollectMethodPostRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestRetryRulesTypeBackoff$outboundSchema.parse(
      restCollectMethodPostRestRetryRulesTypeBackoff,
    ),
  );
}
export function restCollectMethodPostRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestRetryRulesTypeBackoff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue:
    RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(restCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue),
  );
}
export function restCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse:
    RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(restCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse),
  );
}
export function restCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestCollectMethodPostRestRetryRulesTypeStatic$Outbound =
  | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restCollectMethodPostRestRetryRulesTypeStaticToJSON(
  restCollectMethodPostRestRetryRulesTypeStatic:
    RestCollectMethodPostRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestRetryRulesTypeStatic$outboundSchema.parse(
      restCollectMethodPostRestRetryRulesTypeStatic,
    ),
  );
}
export function restCollectMethodPostRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodPostRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restCollectMethodPostRestRetryRulesTypeNoneToJSON(
  restCollectMethodPostRestRetryRulesTypeNone:
    RestCollectMethodPostRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestRetryRulesTypeNone$outboundSchema.parse(
      restCollectMethodPostRestRetryRulesTypeNone,
    ),
  );
}
export function restCollectMethodPostRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRetryRules$inboundSchema: z.ZodType<
  RestCollectMethodPostRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() => RestCollectMethodPostRestRetryRulesTypeNone$inboundSchema),
  static: smartUnion([
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  backoff: smartUnion([
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
});
/** @internal */
export type RestCollectMethodPostRetryRules$Outbound =
  | RestCollectMethodPostRestRetryRulesTypeNone$Outbound
  | (
    | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$Outbound & {
      type: "static";
    }
  )
  | (
    | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestCollectMethodPostRetryRules$outboundSchema: z.ZodType<
  RestCollectMethodPostRetryRules$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostRetryRules
> = z.union([
  z.lazy(() => RestCollectMethodPostRestRetryRulesTypeNone$outboundSchema),
  smartUnion([
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  smartUnion([
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
]);

export function restCollectMethodPostRetryRulesToJSON(
  restCollectMethodPostRetryRules: RestCollectMethodPostRetryRules,
): string {
  return JSON.stringify(
    RestCollectMethodPostRetryRules$outboundSchema.parse(
      restCollectMethodPostRetryRules,
    ),
  );
}
export function restCollectMethodPostRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPostRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRetryRules' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostStateTracking$inboundSchema: z.ZodType<
  RestCollectMethodPostStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: types.optional(types.boolean()),
});
/** @internal */
export type RestCollectMethodPostStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestCollectMethodPostStateTracking$outboundSchema: z.ZodType<
  RestCollectMethodPostStateTracking$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restCollectMethodPostStateTrackingToJSON(
  restCollectMethodPostStateTracking: RestCollectMethodPostStateTracking,
): string {
  return JSON.stringify(
    RestCollectMethodPostStateTracking$outboundSchema.parse(
      restCollectMethodPostStateTracking,
    ),
  );
}
export function restCollectMethodPostStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostStateTracking' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostScheduling$inboundSchema: z.ZodType<
  RestCollectMethodPostScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestCollectMethodPostStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestCollectMethodPostScheduling$Outbound = {
  stateTracking?: RestCollectMethodPostStateTracking$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodPostScheduling$outboundSchema: z.ZodType<
  RestCollectMethodPostScheduling$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostScheduling
> = z.object({
  stateTracking: z.lazy(() => RestCollectMethodPostStateTracking$outboundSchema)
    .optional(),
});

export function restCollectMethodPostSchedulingToJSON(
  restCollectMethodPostScheduling: RestCollectMethodPostScheduling,
): string {
  return JSON.stringify(
    RestCollectMethodPostScheduling$outboundSchema.parse(
      restCollectMethodPostScheduling,
    ),
  );
}
export function restCollectMethodPostSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPostScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostScheduling' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPost$inboundSchema: z.ZodType<
  RestCollectMethodPost,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: RestCollectMethodPostCollectMethod$inboundSchema,
  collectRequestParams: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  authentication: RestCollectMethodPostAuthentication$inboundSchema,
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestCollectMethodPostScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestCollectMethodPost$Outbound = {
  collectMethod: string;
  collectRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?:
    | (
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestCollectMethodPostRestDiscoveryDiscoverTypeJson$Outbound
    | RestCollectMethodPostRestDiscoveryDiscoverTypeList$Outbound
    | RestCollectMethodPostRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestCollectMethodPostRestPaginationTypeNone$Outbound
    | RestCollectMethodPostRestPaginationTypeResponseBody$Outbound
    | RestCollectMethodPostRestPaginationTypeResponseHeader$Outbound
    | RestCollectMethodPostRestPaginationTypeResponseHeaderLink$Outbound
    | RestCollectMethodPostRestPaginationTypeRequestOffset$Outbound
    | RestCollectMethodPostRestPaginationTypeRequestPage$Outbound
    | undefined;
  authentication: string;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestCollectMethodPostRestRetryRulesTypeNone$Outbound
    | (
      | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?: RestCollectMethodPostScheduling$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodPost$outboundSchema: z.ZodType<
  RestCollectMethodPost$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPost
> = z.object({
  collectMethod: RestCollectMethodPostCollectMethod$outboundSchema,
  collectRequestParams: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() => RestCollectMethodPostRestPaginationTypeNone$outboundSchema),
    z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  authentication: RestCollectMethodPostAuthentication$outboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() => RestCollectMethodPostRestRetryRulesTypeNone$outboundSchema),
    smartUnion([
      z.lazy(() =>
        RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]).optional(),
  __scheduling: z.lazy(() => RestCollectMethodPostScheduling$outboundSchema)
    .optional(),
});

export function restCollectMethodPostToJSON(
  restCollectMethodPost: RestCollectMethodPost,
): string {
  return JSON.stringify(
    RestCollectMethodPost$outboundSchema.parse(restCollectMethodPost),
  );
}
export function restCollectMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPost, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPost$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPost' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetCollectMethod$inboundSchema: z.ZodType<
  RestCollectMethodGetCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodGetCollectMethod);
/** @internal */
export const RestCollectMethodGetCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodGetCollectMethod
> = openEnums.outboundSchema(RestCollectMethodGetCollectMethod);

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeNone$Outbound = {
  discoverType: "none";
};

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeNoneToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeNone:
    RestCollectMethodGetRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeNone$outboundSchema.parse(
      restCollectMethodGetRestDiscoveryDiscoverTypeNone,
    ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeList$Outbound = {
  discoverType: "list";
  itemList: Array<string>;
};

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeListToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeList:
    RestCollectMethodGetRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeList$outboundSchema.parse(
      restCollectMethodGetRestDiscoveryDiscoverTypeList,
    ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeList$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeJson$Outbound = {
  discoverType: "json";
  manualDiscoverResult: string;
  discoverDataField?: string | undefined;
};

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeJsonToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeJson:
    RestCollectMethodGetRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeJson$outboundSchema.parse(
      restCollectMethodGetRestDiscoveryDiscoverTypeJson,
    ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeJson$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttp:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttp$outboundSchema.parse(
      restCollectMethodGetRestDiscoveryDiscoverTypeHttp,
    ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttp$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetDiscovery$inboundSchema: z.ZodType<
  RestCollectMethodGetDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestCollectMethodGetRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestCollectMethodGetRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestCollectMethodGetRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodGetDiscovery$Outbound =
  | (
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestCollectMethodGetRestDiscoveryDiscoverTypeJson$Outbound
  | RestCollectMethodGetRestDiscoveryDiscoverTypeList$Outbound
  | RestCollectMethodGetRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestCollectMethodGetDiscovery$outboundSchema: z.ZodType<
  RestCollectMethodGetDiscovery$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestCollectMethodGetRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodGetRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodGetRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restCollectMethodGetDiscoveryToJSON(
  restCollectMethodGetDiscovery: RestCollectMethodGetDiscovery,
): string {
  return JSON.stringify(
    RestCollectMethodGetDiscovery$outboundSchema.parse(
      restCollectMethodGetDiscovery,
    ),
  );
}
export function restCollectMethodGetDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGetDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetDiscovery' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodGetRestPaginationTypeRequestPage$Outbound = {
  type: "request_page";
  pageField: string;
  page?: number | undefined;
  sizeField: string;
  size: number;
  totalPageField?: string | undefined;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestCollectMethodGetRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodGetRestPaginationTypeRequestPageToJSON(
  restCollectMethodGetRestPaginationTypeRequestPage:
    RestCollectMethodGetRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestPaginationTypeRequestPage$outboundSchema.parse(
      restCollectMethodGetRestPaginationTypeRequestPage,
    ),
  );
}
export function restCollectMethodGetRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestPaginationTypeRequestPage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodGetRestPaginationTypeRequestOffset$Outbound = {
  type: "request_offset";
  offsetField: string;
  offset?: number | undefined;
  limitField: string;
  limit: number;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestCollectMethodGetRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodGetRestPaginationTypeRequestOffsetToJSON(
  restCollectMethodGetRestPaginationTypeRequestOffset:
    RestCollectMethodGetRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestPaginationTypeRequestOffset$outboundSchema.parse(
      restCollectMethodGetRestPaginationTypeRequestOffset,
    ),
  );
}
export function restCollectMethodGetRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestPaginationTypeRequestOffset$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodGetRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestCollectMethodGetRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restCollectMethodGetRestPaginationTypeResponseHeaderLinkToJSON(
  restCollectMethodGetRestPaginationTypeResponseHeaderLink:
    RestCollectMethodGetRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restCollectMethodGetRestPaginationTypeResponseHeaderLink),
  );
}
export function restCollectMethodGetRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodGetRestPaginationTypeResponseHeader$Outbound = {
  type: "response_header";
  attribute: Array<string>;
  maxPages: number;
};

/** @internal */
export const RestCollectMethodGetRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restCollectMethodGetRestPaginationTypeResponseHeaderToJSON(
  restCollectMethodGetRestPaginationTypeResponseHeader:
    RestCollectMethodGetRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestPaginationTypeResponseHeader$outboundSchema.parse(
      restCollectMethodGetRestPaginationTypeResponseHeader,
    ),
  );
}
export function restCollectMethodGetRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestPaginationTypeResponseHeader$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodGetRestPaginationTypeResponseBody$Outbound = {
  type: "response_body";
  attribute: Array<string>;
  maxPages: number;
  lastPageExpr?: string | undefined;
};

/** @internal */
export const RestCollectMethodGetRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restCollectMethodGetRestPaginationTypeResponseBodyToJSON(
  restCollectMethodGetRestPaginationTypeResponseBody:
    RestCollectMethodGetRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestPaginationTypeResponseBody$outboundSchema.parse(
      restCollectMethodGetRestPaginationTypeResponseBody,
    ),
  );
}
export function restCollectMethodGetRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestPaginationTypeResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestPaginationTypeNone$inboundSchema:
  z.ZodType<RestCollectMethodGetRestPaginationTypeNone, z.ZodTypeDef, unknown> =
    z.object({
      type: types.literal("none"),
    });
/** @internal */
export type RestCollectMethodGetRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestCollectMethodGetRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restCollectMethodGetRestPaginationTypeNoneToJSON(
  restCollectMethodGetRestPaginationTypeNone:
    RestCollectMethodGetRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestPaginationTypeNone$outboundSchema.parse(
      restCollectMethodGetRestPaginationTypeNone,
    ),
  );
}
export function restCollectMethodGetRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetPaginationUnion$inboundSchema: z.ZodType<
  RestCollectMethodGetPaginationUnion,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() => RestCollectMethodGetRestPaginationTypeNone$inboundSchema),
  response_body: z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeResponseBody$inboundSchema
  ),
  response_header: z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeResponseHeader$inboundSchema
  ),
  response_header_link: z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeResponseHeaderLink$inboundSchema
  ),
  request_offset: z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeRequestOffset$inboundSchema
  ),
  request_page: z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeRequestPage$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodGetPaginationUnion$Outbound =
  | RestCollectMethodGetRestPaginationTypeNone$Outbound
  | RestCollectMethodGetRestPaginationTypeResponseBody$Outbound
  | RestCollectMethodGetRestPaginationTypeResponseHeader$Outbound
  | RestCollectMethodGetRestPaginationTypeResponseHeaderLink$Outbound
  | RestCollectMethodGetRestPaginationTypeRequestOffset$Outbound
  | RestCollectMethodGetRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestCollectMethodGetPaginationUnion$outboundSchema: z.ZodType<
  RestCollectMethodGetPaginationUnion$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetPaginationUnion
> = z.union([
  z.lazy(() => RestCollectMethodGetRestPaginationTypeNone$outboundSchema),
  z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeResponseBody$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeResponseHeader$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeResponseHeaderLink$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeRequestOffset$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeRequestPage$outboundSchema
  ),
]);

export function restCollectMethodGetPaginationUnionToJSON(
  restCollectMethodGetPaginationUnion: RestCollectMethodGetPaginationUnion,
): string {
  return JSON.stringify(
    RestCollectMethodGetPaginationUnion$outboundSchema.parse(
      restCollectMethodGetPaginationUnion,
    ),
  );
}
export function restCollectMethodGetPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetPaginationUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetPaginationUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetAuthentication$inboundSchema: z.ZodType<
  RestCollectMethodGetAuthentication,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodGetAuthentication);
/** @internal */
export const RestCollectMethodGetAuthentication$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodGetAuthentication
> = openEnums.outboundSchema(RestCollectMethodGetAuthentication);

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(restCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue),
  );
}
export function restCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(restCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse),
  );
}
export function restCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestCollectMethodGetRestRetryRulesTypeBackoff$Outbound =
  | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restCollectMethodGetRestRetryRulesTypeBackoffToJSON(
  restCollectMethodGetRestRetryRulesTypeBackoff:
    RestCollectMethodGetRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestRetryRulesTypeBackoff$outboundSchema.parse(
      restCollectMethodGetRestRetryRulesTypeBackoff,
    ),
  );
}
export function restCollectMethodGetRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestRetryRulesTypeBackoff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: any | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.any().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue:
    RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(restCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue),
  );
}
export function restCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(z.any()),
    type: types.string(),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: any | undefined;
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.any().optional(),
    type: z.string(),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse:
    RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(restCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse),
  );
}
export function restCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestCollectMethodGetRestRetryRulesTypeStatic$Outbound =
  | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restCollectMethodGetRestRetryRulesTypeStaticToJSON(
  restCollectMethodGetRestRetryRulesTypeStatic:
    RestCollectMethodGetRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestRetryRulesTypeStatic$outboundSchema.parse(
      restCollectMethodGetRestRetryRulesTypeStatic,
    ),
  );
}
export function restCollectMethodGetRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<RestCollectMethodGetRestRetryRulesTypeNone, z.ZodTypeDef, unknown> =
    z.object({
      type: types.literal("none"),
      interval: types.optional(z.any()),
      limit: types.optional(z.any()),
      multiplier: types.optional(z.any()),
      maxIntervalMs: types.optional(z.any()),
      codes: types.optional(z.any()),
      enableHeader: types.optional(z.any()),
      retryConnectTimeout: types.optional(z.any()),
      retryConnectReset: types.optional(z.any()),
    });
/** @internal */
export type RestCollectMethodGetRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restCollectMethodGetRestRetryRulesTypeNoneToJSON(
  restCollectMethodGetRestRetryRulesTypeNone:
    RestCollectMethodGetRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestRetryRulesTypeNone$outboundSchema.parse(
      restCollectMethodGetRestRetryRulesTypeNone,
    ),
  );
}
export function restCollectMethodGetRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRetryRules$inboundSchema: z.ZodType<
  RestCollectMethodGetRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() => RestCollectMethodGetRestRetryRulesTypeNone$inboundSchema),
  static: smartUnion([
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  backoff: smartUnion([
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
});
/** @internal */
export type RestCollectMethodGetRetryRules$Outbound =
  | RestCollectMethodGetRestRetryRulesTypeNone$Outbound
  | (
    | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$Outbound & {
      type: "static";
    }
  )
  | (
    | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound & {
      type: "backoff";
    }
  );

/** @internal */
export const RestCollectMethodGetRetryRules$outboundSchema: z.ZodType<
  RestCollectMethodGetRetryRules$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetRetryRules
> = z.union([
  z.lazy(() => RestCollectMethodGetRestRetryRulesTypeNone$outboundSchema),
  smartUnion([
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  smartUnion([
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
]);

export function restCollectMethodGetRetryRulesToJSON(
  restCollectMethodGetRetryRules: RestCollectMethodGetRetryRules,
): string {
  return JSON.stringify(
    RestCollectMethodGetRetryRules$outboundSchema.parse(
      restCollectMethodGetRetryRules,
    ),
  );
}
export function restCollectMethodGetRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGetRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRetryRules' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetStateTracking$inboundSchema: z.ZodType<
  RestCollectMethodGetStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: types.optional(types.boolean()),
});
/** @internal */
export type RestCollectMethodGetStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestCollectMethodGetStateTracking$outboundSchema: z.ZodType<
  RestCollectMethodGetStateTracking$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restCollectMethodGetStateTrackingToJSON(
  restCollectMethodGetStateTracking: RestCollectMethodGetStateTracking,
): string {
  return JSON.stringify(
    RestCollectMethodGetStateTracking$outboundSchema.parse(
      restCollectMethodGetStateTracking,
    ),
  );
}
export function restCollectMethodGetStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGetStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetStateTracking' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetScheduling$inboundSchema: z.ZodType<
  RestCollectMethodGetScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestCollectMethodGetStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestCollectMethodGetScheduling$Outbound = {
  stateTracking?: RestCollectMethodGetStateTracking$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodGetScheduling$outboundSchema: z.ZodType<
  RestCollectMethodGetScheduling$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetScheduling
> = z.object({
  stateTracking: z.lazy(() => RestCollectMethodGetStateTracking$outboundSchema)
    .optional(),
});

export function restCollectMethodGetSchedulingToJSON(
  restCollectMethodGetScheduling: RestCollectMethodGetScheduling,
): string {
  return JSON.stringify(
    RestCollectMethodGetScheduling$outboundSchema.parse(
      restCollectMethodGetScheduling,
    ),
  );
}
export function restCollectMethodGetSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGetScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetScheduling' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGet$inboundSchema: z.ZodType<
  RestCollectMethodGet,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: RestCollectMethodGetCollectMethod$inboundSchema,
  collectRequestParams: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodGetRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestCollectMethodGetRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestCollectMethodGetRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestCollectMethodGetRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestCollectMethodGetRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestCollectMethodGetRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  authentication: RestCollectMethodGetAuthentication$inboundSchema,
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodGetRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestCollectMethodGetScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestCollectMethodGet$Outbound = {
  collectMethod: string;
  collectRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?:
    | (
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestCollectMethodGetRestDiscoveryDiscoverTypeJson$Outbound
    | RestCollectMethodGetRestDiscoveryDiscoverTypeList$Outbound
    | RestCollectMethodGetRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestCollectMethodGetRestPaginationTypeNone$Outbound
    | RestCollectMethodGetRestPaginationTypeResponseBody$Outbound
    | RestCollectMethodGetRestPaginationTypeResponseHeader$Outbound
    | RestCollectMethodGetRestPaginationTypeResponseHeaderLink$Outbound
    | RestCollectMethodGetRestPaginationTypeRequestOffset$Outbound
    | RestCollectMethodGetRestPaginationTypeRequestPage$Outbound
    | undefined;
  authentication: string;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestCollectMethodGetRestRetryRulesTypeNone$Outbound
    | (
      | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?: RestCollectMethodGetScheduling$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodGet$outboundSchema: z.ZodType<
  RestCollectMethodGet$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGet
> = z.object({
  collectMethod: RestCollectMethodGetCollectMethod$outboundSchema,
  collectRequestParams: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() => RestCollectMethodGetRestPaginationTypeNone$outboundSchema),
    z.lazy(() =>
      RestCollectMethodGetRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  authentication: RestCollectMethodGetAuthentication$outboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() => RestCollectMethodGetRestRetryRulesTypeNone$outboundSchema),
    smartUnion([
      z.lazy(() =>
        RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodGetRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodGetRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]).optional(),
  __scheduling: z.lazy(() => RestCollectMethodGetScheduling$outboundSchema)
    .optional(),
});

export function restCollectMethodGetToJSON(
  restCollectMethodGet: RestCollectMethodGet,
): string {
  return JSON.stringify(
    RestCollectMethodGet$outboundSchema.parse(restCollectMethodGet),
  );
}
export function restCollectMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGet, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGet$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGet' from JSON`,
  );
}

/** @internal */
export const RestCollectorConf$inboundSchema: z.ZodType<
  RestCollectorConf,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("authentication", {
  none: z.lazy(() => RestAuthenticationNone$inboundSchema),
  basic: z.lazy(() => RestAuthenticationBasic$inboundSchema),
  basicSecret: z.lazy(() => RestAuthenticationBasicSecret$inboundSchema),
  login: smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ authentication: z.literal("login") })),
  loginSecret: smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ authentication: z.literal("loginSecret") })),
  oauth: z.lazy(() => RestAuthenticationOauth$inboundSchema),
  oauthSecret: z.lazy(() => RestAuthenticationOauthSecret$inboundSchema),
  google_oauth: z.lazy(() => RestAuthenticationGoogleOauth$inboundSchema),
  google_oauthSecret: z.lazy(() =>
    RestAuthenticationGoogleOauthSecret$inboundSchema
  ),
  hmac: z.lazy(() => RestAuthenticationHmac$inboundSchema),
});
/** @internal */
export type RestCollectorConf$Outbound =
  | RestAuthenticationNone$Outbound
  | RestAuthenticationBasic$Outbound
  | RestAuthenticationBasicSecret$Outbound
  | (
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalse$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrue$Outbound & {
      authentication: "login";
    }
  )
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$Outbound & {
      authentication: "loginSecret";
    }
  )
  | RestAuthenticationOauth$Outbound
  | RestAuthenticationOauthSecret$Outbound
  | RestAuthenticationGoogleOauth$Outbound
  | RestAuthenticationGoogleOauthSecret$Outbound
  | RestAuthenticationHmac$Outbound;

/** @internal */
export const RestCollectorConf$outboundSchema: z.ZodType<
  RestCollectorConf$Outbound,
  z.ZodTypeDef,
  RestCollectorConf
> = z.union([
  z.lazy(() => RestAuthenticationNone$outboundSchema),
  z.lazy(() => RestAuthenticationBasic$outboundSchema),
  z.lazy(() => RestAuthenticationBasicSecret$outboundSchema),
  smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ authentication: z.literal("login") })),
  smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ authentication: z.literal("loginSecret") })),
  z.lazy(() => RestAuthenticationOauth$outboundSchema),
  z.lazy(() => RestAuthenticationOauthSecret$outboundSchema),
  z.lazy(() => RestAuthenticationGoogleOauth$outboundSchema),
  z.lazy(() => RestAuthenticationGoogleOauthSecret$outboundSchema),
  z.lazy(() => RestAuthenticationHmac$outboundSchema),
]);

export function restCollectorConfToJSON(
  restCollectorConf: RestCollectorConf,
): string {
  return JSON.stringify(
    RestCollectorConf$outboundSchema.parse(restCollectorConf),
  );
}
export function restCollectorConfFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectorConf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectorConf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectorConf' from JSON`,
  );
}
