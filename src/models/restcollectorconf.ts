/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeRestCollectMethodGetCollectRequestParams,
  ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound,
  ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
} from "./itemstyperestcollectmethodgetcollectrequestparams.js";
import {
  RetryTypeOptionsHealthCheckCollectorConfRetryRules,
  RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
} from "./retrytypeoptionshealthcheckcollectorconfretryrules.js";

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationHmacDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationHmacDiscoverType = OpenEnum<
  typeof RestAuthenticationHmacDiscoverType
>;

export type RestAuthenticationHmacDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestAuthenticationHmacDiscoverType;
};

export const RestAuthenticationHmacCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationHmacCollectMethod = OpenEnum<
  typeof RestAuthenticationHmacCollectMethod
>;

export const RestAuthenticationHmacPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestAuthenticationHmacPaginationEnum = OpenEnum<
  typeof RestAuthenticationHmacPaginationEnum
>;

export type RestAuthenticationHmacPagination = {
  type: RestAuthenticationHmacPaginationEnum;
};

export type RestAuthenticationHmacRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationHmacStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationHmacScheduling = {
  stateTracking?: RestAuthenticationHmacStateTracking | undefined;
};

export type RestAuthenticationHmac = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "hmac";
  /**
   * Select or create an HMAC Function to use with authentication
   */
  hmacFunctionId: string;
  discovery?: RestAuthenticationHmacDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationHmacCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestAuthenticationHmacPagination | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationHmacRetryRules | undefined;
  __scheduling?: RestAuthenticationHmacScheduling | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthSecretDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthSecretDiscoverType = OpenEnum<
  typeof RestAuthenticationGoogleOauthSecretDiscoverType
>;

export type RestAuthenticationGoogleOauthSecretDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestAuthenticationGoogleOauthSecretDiscoverType;
};

export const RestAuthenticationGoogleOauthSecretCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationGoogleOauthSecretCollectMethod = OpenEnum<
  typeof RestAuthenticationGoogleOauthSecretCollectMethod
>;

export const RestAuthenticationGoogleOauthSecretPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestAuthenticationGoogleOauthSecretPaginationEnum = OpenEnum<
  typeof RestAuthenticationGoogleOauthSecretPaginationEnum
>;

export type RestAuthenticationGoogleOauthSecretPagination = {
  type: RestAuthenticationGoogleOauthSecretPaginationEnum;
};

export type RestAuthenticationGoogleOauthSecretRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationGoogleOauthSecretStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationGoogleOauthSecretScheduling = {
  stateTracking?: RestAuthenticationGoogleOauthSecretStateTracking | undefined;
};

export type RestAuthenticationGoogleOauthSecret = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "google_oauthSecret";
  /**
   * Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information.
   */
  scopes: Array<string>;
  /**
   * Select or create a text secret that contains the Google service account credentials value
   */
  textSecret: string;
  /**
   * Email address of a user account with Super Admin permissions to the resources the collector will retrieve
   */
  subject: string;
  discovery?: RestAuthenticationGoogleOauthSecretDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationGoogleOauthSecretCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestAuthenticationGoogleOauthSecretPagination | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationGoogleOauthSecretRetryRules | undefined;
  __scheduling?: RestAuthenticationGoogleOauthSecretScheduling | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationGoogleOauthDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationGoogleOauthDiscoverType = OpenEnum<
  typeof RestAuthenticationGoogleOauthDiscoverType
>;

export type RestAuthenticationGoogleOauthDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestAuthenticationGoogleOauthDiscoverType;
};

export const RestAuthenticationGoogleOauthCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationGoogleOauthCollectMethod = OpenEnum<
  typeof RestAuthenticationGoogleOauthCollectMethod
>;

export const RestAuthenticationGoogleOauthPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestAuthenticationGoogleOauthPaginationEnum = OpenEnum<
  typeof RestAuthenticationGoogleOauthPaginationEnum
>;

export type RestAuthenticationGoogleOauthPagination = {
  type: RestAuthenticationGoogleOauthPaginationEnum;
};

export type RestAuthenticationGoogleOauthRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationGoogleOauthStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationGoogleOauthScheduling = {
  stateTracking?: RestAuthenticationGoogleOauthStateTracking | undefined;
};

export type RestAuthenticationGoogleOauth = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "google_oauth";
  /**
   * Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information.
   */
  scopes: Array<string>;
  /**
   * Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right.
   */
  serviceAccountCredentials: string;
  /**
   * Email address of a user account with Super Admin permissions to the resources the collector will retrieve
   */
  subject: string;
  discovery?: RestAuthenticationGoogleOauthDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationGoogleOauthCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestAuthenticationGoogleOauthPagination | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationGoogleOauthRetryRules | undefined;
  __scheduling?: RestAuthenticationGoogleOauthScheduling | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthSecretDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthSecretDiscoverType = OpenEnum<
  typeof RestAuthenticationOauthSecretDiscoverType
>;

export type RestAuthenticationOauthSecretDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestAuthenticationOauthSecretDiscoverType;
};

export const RestAuthenticationOauthSecretCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationOauthSecretCollectMethod = OpenEnum<
  typeof RestAuthenticationOauthSecretCollectMethod
>;

export const RestAuthenticationOauthSecretPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestAuthenticationOauthSecretPaginationEnum = OpenEnum<
  typeof RestAuthenticationOauthSecretPaginationEnum
>;

export type RestAuthenticationOauthSecretPagination = {
  type: RestAuthenticationOauthSecretPaginationEnum;
};

export type RestAuthenticationOauthSecretRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationOauthSecretStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationOauthSecretScheduling = {
  stateTracking?: RestAuthenticationOauthSecretStateTracking | undefined;
};

export type RestAuthenticationOauthSecret = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "oauthSecret";
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl: string;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName: string;
  /**
   * Select or create a text secret that contains the client secret's value
   */
  textSecret: string;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?: RestAuthenticationOauthSecretDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationOauthSecretCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestAuthenticationOauthSecretPagination | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationOauthSecretRetryRules | undefined;
  __scheduling?: RestAuthenticationOauthSecretScheduling | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthDiscoverType = OpenEnum<
  typeof RestAuthenticationOauthDiscoverType
>;

export type RestAuthenticationOauthDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestAuthenticationOauthDiscoverType;
};

export const RestAuthenticationOauthCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationOauthCollectMethod = OpenEnum<
  typeof RestAuthenticationOauthCollectMethod
>;

export const RestAuthenticationOauthPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestAuthenticationOauthPaginationEnum = OpenEnum<
  typeof RestAuthenticationOauthPaginationEnum
>;

export type RestAuthenticationOauthPagination = {
  type: RestAuthenticationOauthPaginationEnum;
};

export type RestAuthenticationOauthRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationOauthStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationOauthScheduling = {
  stateTracking?: RestAuthenticationOauthStateTracking | undefined;
};

export type RestAuthenticationOauth = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "oauth";
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl: string;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName: string;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters.
   */
  clientSecretParamValue: string;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?: RestAuthenticationOauthDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationOauthCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestAuthenticationOauthPagination | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationOauthRetryRules | undefined;
  __scheduling?: RestAuthenticationOauthScheduling | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication =
  {
    None: "none",
    Basic: "basic",
    BasicSecret: "basicSecret",
    Login: "login",
    LoginSecret: "loginSecret",
    Oauth: "oauth",
    OauthSecret: "oauthSecret",
    GoogleOauth: "google_oauth",
    GoogleOauthSecret: "google_oauthSecret",
    Hmac: "hmac",
  } as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication
  >;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoverType
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoverType;
};

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod
  >;

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationEnum =
  {
    /**
     * None
     */
    None: "none",
    /**
     * Response Body Attribute
     */
    ResponseBody: "response_body",
    /**
     * Response Header Attribute
     */
    ResponseHeader: "response_header",
    /**
     * RFC 5988 - Web Linking
     */
    ResponseHeaderLink: "response_header_link",
    /**
     * Offset/Limit
     */
    RequestOffset: "request_offset",
    /**
     * Page/Size
     */
    RequestPage: "request_page",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationEnum =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationEnum
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePagination =
  {
    type: RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationEnum;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules =
  {
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    enableHeader?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking =
  {
    /**
     * Track collection progress between consecutive scheduled executions
     */
    enabled?: boolean | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling =
  {
    stateTracking?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking
      | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue = {
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication;
  /**
   * URL to use for login API call. This call is expected to be a POST.
   */
  loginUrl: string;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret: string;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody: string;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePagination
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules
    | undefined;
  __scheduling?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling
    | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication =
  {
    None: "none",
    Basic: "basic",
    BasicSecret: "basicSecret",
    Login: "login",
    LoginSecret: "loginSecret",
    Oauth: "oauth",
    OauthSecret: "oauthSecret",
    GoogleOauth: "google_oauth",
    GoogleOauthSecret: "google_oauthSecret",
    Hmac: "hmac",
  } as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication
  >;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoverType
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoverType;
  };

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod
  >;

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationEnum =
  {
    /**
     * None
     */
    None: "none",
    /**
     * Response Body Attribute
     */
    ResponseBody: "response_body",
    /**
     * Response Header Attribute
     */
    ResponseHeader: "response_header",
    /**
     * RFC 5988 - Web Linking
     */
    ResponseHeaderLink: "response_header_link",
    /**
     * Offset/Limit
     */
    RequestOffset: "request_offset",
    /**
     * Page/Size
     */
    RequestPage: "request_page",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationEnum =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationEnum
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePagination =
  {
    type:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationEnum;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules =
  {
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    enableHeader?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking =
  {
    /**
     * Track collection progress between consecutive scheduled executions
     */
    enabled?: boolean | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling =
  {
    stateTracking?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking
      | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse = {
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication;
  /**
   * URL to use for login API call. This call is expected to be a POST.
   */
  loginUrl: string;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret: string;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody: string;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePagination
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules
    | undefined;
  __scheduling?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling
    | undefined;
};

export type RestAuthenticationLoginSecret =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue;

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication
  >;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoverType
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoverType;
};

export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod
  >;

export const RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationEnum =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationEnum
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTruePagination = {
  type: RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationEnum;
};

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling = {
  stateTracking?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking
    | undefined;
};

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrue = {
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication;
  /**
   * URL to use for login API call. This call is expected to be a POST.
   */
  loginUrl: string;
  username: string;
  password: string;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody: string;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression used to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderTruePagination
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules
    | undefined;
  __scheduling?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling
    | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication =
  {
    None: "none",
    Basic: "basic",
    BasicSecret: "basicSecret",
    Login: "login",
    LoginSecret: "loginSecret",
    Oauth: "oauth",
    OauthSecret: "oauthSecret",
    GoogleOauth: "google_oauth",
    GoogleOauthSecret: "google_oauthSecret",
    Hmac: "hmac",
  } as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication
  >;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoverType
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoverType;
};

export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod
  >;

export const RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationEnum =
  {
    /**
     * None
     */
    None: "none",
    /**
     * Response Body Attribute
     */
    ResponseBody: "response_body",
    /**
     * Response Header Attribute
     */
    ResponseHeader: "response_header",
    /**
     * RFC 5988 - Web Linking
     */
    ResponseHeaderLink: "response_header_link",
    /**
     * Offset/Limit
     */
    RequestOffset: "request_offset",
    /**
     * Page/Size
     */
    RequestPage: "request_page",
  } as const;
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationEnum =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationEnum
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalsePagination = {
  type: RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationEnum;
};

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling = {
  stateTracking?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking
    | undefined;
};

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalse = {
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication;
  /**
   * URL to use for login API call. This call is expected to be a POST.
   */
  loginUrl: string;
  username: string;
  password: string;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody: string;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression used to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalsePagination
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules
    | undefined;
  __scheduling?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling
    | undefined;
};

export type RestAuthenticationLogin =
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalse
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrue;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicSecretDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicSecretDiscoverType = OpenEnum<
  typeof RestAuthenticationBasicSecretDiscoverType
>;

export type RestAuthenticationBasicSecretDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestAuthenticationBasicSecretDiscoverType;
};

export const RestAuthenticationBasicSecretCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationBasicSecretCollectMethod = OpenEnum<
  typeof RestAuthenticationBasicSecretCollectMethod
>;

export const RestAuthenticationBasicSecretPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestAuthenticationBasicSecretPaginationEnum = OpenEnum<
  typeof RestAuthenticationBasicSecretPaginationEnum
>;

export type RestAuthenticationBasicSecretPagination = {
  type: RestAuthenticationBasicSecretPaginationEnum;
};

export type RestAuthenticationBasicSecretRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationBasicSecretStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationBasicSecretScheduling = {
  stateTracking?: RestAuthenticationBasicSecretStateTracking | undefined;
};

export type RestAuthenticationBasicSecret = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "basicSecret";
  /**
   * Select or create a stored secret that references your credentials
   */
  credentialsSecret: string;
  discovery?: RestAuthenticationBasicSecretDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationBasicSecretCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestAuthenticationBasicSecretPagination | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationBasicSecretRetryRules | undefined;
  __scheduling?: RestAuthenticationBasicSecretScheduling | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicDiscoverType = OpenEnum<
  typeof RestAuthenticationBasicDiscoverType
>;

export type RestAuthenticationBasicDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestAuthenticationBasicDiscoverType;
};

export const RestAuthenticationBasicCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationBasicCollectMethod = OpenEnum<
  typeof RestAuthenticationBasicCollectMethod
>;

export const RestAuthenticationBasicPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestAuthenticationBasicPaginationEnum = OpenEnum<
  typeof RestAuthenticationBasicPaginationEnum
>;

export type RestAuthenticationBasicPagination = {
  type: RestAuthenticationBasicPaginationEnum;
};

export type RestAuthenticationBasicRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationBasicStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationBasicScheduling = {
  stateTracking?: RestAuthenticationBasicStateTracking | undefined;
};

export type RestAuthenticationBasic = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "basic";
  username: string;
  password: string;
  discovery?: RestAuthenticationBasicDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationBasicCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestAuthenticationBasicPagination | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationBasicRetryRules | undefined;
  __scheduling?: RestAuthenticationBasicScheduling | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationNoneDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationNoneDiscoverType = OpenEnum<
  typeof RestAuthenticationNoneDiscoverType
>;

export type RestAuthenticationNoneDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestAuthenticationNoneDiscoverType;
};

export const RestAuthenticationNoneCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationNoneCollectMethod = OpenEnum<
  typeof RestAuthenticationNoneCollectMethod
>;

export const RestAuthenticationNonePaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestAuthenticationNonePaginationEnum = OpenEnum<
  typeof RestAuthenticationNonePaginationEnum
>;

export type RestAuthenticationNonePagination = {
  type: RestAuthenticationNonePaginationEnum;
};

export type RestAuthenticationNoneRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationNoneStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationNoneScheduling = {
  stateTracking?: RestAuthenticationNoneStateTracking | undefined;
};

export type RestAuthenticationNone = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "none";
  discovery?: RestAuthenticationNoneDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationNoneCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestAuthenticationNonePagination | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationNoneRetryRules | undefined;
  __scheduling?: RestAuthenticationNoneScheduling | undefined;
};

export const RestCollectMethodOtherCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestCollectMethodOtherCollectMethod = OpenEnum<
  typeof RestCollectMethodOtherCollectMethod
>;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodOtherDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodOtherDiscoverType = OpenEnum<
  typeof RestCollectMethodOtherDiscoverType
>;

export type RestCollectMethodOtherDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestCollectMethodOtherDiscoverType;
};

export const RestCollectMethodOtherPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestCollectMethodOtherPaginationEnum = OpenEnum<
  typeof RestCollectMethodOtherPaginationEnum
>;

export type RestCollectMethodOtherPagination = {
  type: RestCollectMethodOtherPaginationEnum;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const RestCollectMethodOtherAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type RestCollectMethodOtherAuthentication = OpenEnum<
  typeof RestCollectMethodOtherAuthentication
>;

export type RestCollectMethodOtherRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodOtherStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestCollectMethodOtherScheduling = {
  stateTracking?: RestCollectMethodOtherStateTracking | undefined;
};

export type RestCollectMethodOther = {
  collectMethod: RestCollectMethodOtherCollectMethod;
  collectVerb?: any | undefined;
  collectBody?: any | undefined;
  collectRequestParams?: any | undefined;
  discovery?: RestCollectMethodOtherDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestCollectMethodOtherPagination | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: RestCollectMethodOtherAuthentication;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestCollectMethodOtherRetryRules | undefined;
  __scheduling?: RestCollectMethodOtherScheduling | undefined;
};

export const RestCollectMethodPostWithBodyCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestCollectMethodPostWithBodyCollectMethod = OpenEnum<
  typeof RestCollectMethodPostWithBodyCollectMethod
>;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostWithBodyDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostWithBodyDiscoverType = OpenEnum<
  typeof RestCollectMethodPostWithBodyDiscoverType
>;

export type RestCollectMethodPostWithBodyDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestCollectMethodPostWithBodyDiscoverType;
};

export const RestCollectMethodPostWithBodyPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestCollectMethodPostWithBodyPaginationEnum = OpenEnum<
  typeof RestCollectMethodPostWithBodyPaginationEnum
>;

export type RestCollectMethodPostWithBodyPagination = {
  type: RestCollectMethodPostWithBodyPaginationEnum;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const RestCollectMethodPostWithBodyAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type RestCollectMethodPostWithBodyAuthentication = OpenEnum<
  typeof RestCollectMethodPostWithBodyAuthentication
>;

export type RestCollectMethodPostWithBodyRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodPostWithBodyStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestCollectMethodPostWithBodyScheduling = {
  stateTracking?: RestCollectMethodPostWithBodyStateTracking | undefined;
};

export type RestCollectMethodPostWithBody = {
  collectMethod: RestCollectMethodPostWithBodyCollectMethod;
  collectBody?: any | undefined;
  discovery?: RestCollectMethodPostWithBodyDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestCollectMethodPostWithBodyPagination | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: RestCollectMethodPostWithBodyAuthentication;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestCollectMethodPostWithBodyRetryRules | undefined;
  __scheduling?: RestCollectMethodPostWithBodyScheduling | undefined;
};

export const RestCollectMethodPostCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestCollectMethodPostCollectMethod = OpenEnum<
  typeof RestCollectMethodPostCollectMethod
>;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostDiscoverType = OpenEnum<
  typeof RestCollectMethodPostDiscoverType
>;

export type RestCollectMethodPostDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestCollectMethodPostDiscoverType;
};

export const RestCollectMethodPostPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestCollectMethodPostPaginationEnum = OpenEnum<
  typeof RestCollectMethodPostPaginationEnum
>;

export type RestCollectMethodPostPagination = {
  type: RestCollectMethodPostPaginationEnum;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const RestCollectMethodPostAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type RestCollectMethodPostAuthentication = OpenEnum<
  typeof RestCollectMethodPostAuthentication
>;

export type RestCollectMethodPostRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodPostStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestCollectMethodPostScheduling = {
  stateTracking?: RestCollectMethodPostStateTracking | undefined;
};

export type RestCollectMethodPost = {
  collectMethod: RestCollectMethodPostCollectMethod;
  collectRequestParams?: any | undefined;
  discovery?: RestCollectMethodPostDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectVerb?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestCollectMethodPostPagination | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: RestCollectMethodPostAuthentication;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestCollectMethodPostRetryRules | undefined;
  __scheduling?: RestCollectMethodPostScheduling | undefined;
};

export const RestCollectMethodGetCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestCollectMethodGetCollectMethod = OpenEnum<
  typeof RestCollectMethodGetCollectMethod
>;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodGetDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodGetDiscoverType = OpenEnum<
  typeof RestCollectMethodGetDiscoverType
>;

export type RestCollectMethodGetDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: RestCollectMethodGetDiscoverType;
};

export const RestCollectMethodGetPaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type RestCollectMethodGetPaginationEnum = OpenEnum<
  typeof RestCollectMethodGetPaginationEnum
>;

export type RestCollectMethodGetPagination = {
  type: RestCollectMethodGetPaginationEnum;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const RestCollectMethodGetAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type RestCollectMethodGetAuthentication = OpenEnum<
  typeof RestCollectMethodGetAuthentication
>;

export type RestCollectMethodGetRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodGetStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestCollectMethodGetScheduling = {
  stateTracking?: RestCollectMethodGetStateTracking | undefined;
};

export type RestCollectMethodGet = {
  collectMethod: RestCollectMethodGetCollectMethod;
  collectRequestParams?: any | undefined;
  discovery?: RestCollectMethodGetDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectVerb?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestCollectMethodGetPagination | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: RestCollectMethodGetAuthentication;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestCollectMethodGetRetryRules | undefined;
  __scheduling?: RestCollectMethodGetScheduling | undefined;
};

export type RestCollectorConf =
  | RestAuthenticationNone
  | RestAuthenticationBasic
  | RestAuthenticationBasicSecret
  | (
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalse
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrue & {
      authentication: "login";
    }
  )
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue & {
      authentication: "loginSecret";
    }
  )
  | RestAuthenticationOauth
  | RestAuthenticationOauthSecret
  | RestAuthenticationGoogleOauth
  | RestAuthenticationGoogleOauthSecret
  | RestAuthenticationHmac;

/** @internal */
export const RestAuthenticationHmacDiscoverType$inboundSchema: z.ZodType<
  RestAuthenticationHmacDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationHmacDiscoverType);
/** @internal */
export const RestAuthenticationHmacDiscoverType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationHmacDiscoverType
> = openEnums.outboundSchema(RestAuthenticationHmacDiscoverType);

/** @internal */
export const RestAuthenticationHmacDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationHmacDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestAuthenticationHmacDiscoverType$inboundSchema,
});
/** @internal */
export type RestAuthenticationHmacDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestAuthenticationHmacDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationHmacDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmacDiscovery
> = z.object({
  discoverType: RestAuthenticationHmacDiscoverType$outboundSchema,
});

export function restAuthenticationHmacDiscoveryToJSON(
  restAuthenticationHmacDiscovery: RestAuthenticationHmacDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationHmacDiscovery$outboundSchema.parse(
      restAuthenticationHmacDiscovery,
    ),
  );
}
export function restAuthenticationHmacDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmacDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationHmacDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacCollectMethod$inboundSchema: z.ZodType<
  RestAuthenticationHmacCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationHmacCollectMethod);
/** @internal */
export const RestAuthenticationHmacCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationHmacCollectMethod
> = openEnums.outboundSchema(RestAuthenticationHmacCollectMethod);

/** @internal */
export const RestAuthenticationHmacPaginationEnum$inboundSchema: z.ZodType<
  RestAuthenticationHmacPaginationEnum,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationHmacPaginationEnum);
/** @internal */
export const RestAuthenticationHmacPaginationEnum$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationHmacPaginationEnum
> = openEnums.outboundSchema(RestAuthenticationHmacPaginationEnum);

/** @internal */
export const RestAuthenticationHmacPagination$inboundSchema: z.ZodType<
  RestAuthenticationHmacPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestAuthenticationHmacPaginationEnum$inboundSchema,
});
/** @internal */
export type RestAuthenticationHmacPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestAuthenticationHmacPagination$outboundSchema: z.ZodType<
  RestAuthenticationHmacPagination$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmacPagination
> = z.object({
  type: RestAuthenticationHmacPaginationEnum$outboundSchema,
});

export function restAuthenticationHmacPaginationToJSON(
  restAuthenticationHmacPagination: RestAuthenticationHmacPagination,
): string {
  return JSON.stringify(
    RestAuthenticationHmacPagination$outboundSchema.parse(
      restAuthenticationHmacPagination,
    ),
  );
}
export function restAuthenticationHmacPaginationFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmacPagination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationHmacPagination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationHmacRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestAuthenticationHmacRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationHmacRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationHmacRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmacRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restAuthenticationHmacRetryRulesToJSON(
  restAuthenticationHmacRetryRules: RestAuthenticationHmacRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationHmacRetryRules$outboundSchema.parse(
      restAuthenticationHmacRetryRules,
    ),
  );
}
export function restAuthenticationHmacRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmacRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationHmacRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacStateTracking$inboundSchema: z.ZodType<
  RestAuthenticationHmacStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type RestAuthenticationHmacStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationHmacStateTracking$outboundSchema: z.ZodType<
  RestAuthenticationHmacStateTracking$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmacStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restAuthenticationHmacStateTrackingToJSON(
  restAuthenticationHmacStateTracking: RestAuthenticationHmacStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationHmacStateTracking$outboundSchema.parse(
      restAuthenticationHmacStateTracking,
    ),
  );
}
export function restAuthenticationHmacStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmacStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationHmacStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmacScheduling$inboundSchema: z.ZodType<
  RestAuthenticationHmacScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => RestAuthenticationHmacStateTracking$inboundSchema)
    .optional(),
});
/** @internal */
export type RestAuthenticationHmacScheduling$Outbound = {
  stateTracking?: RestAuthenticationHmacStateTracking$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationHmacScheduling$outboundSchema: z.ZodType<
  RestAuthenticationHmacScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmacScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationHmacStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationHmacSchedulingToJSON(
  restAuthenticationHmacScheduling: RestAuthenticationHmacScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationHmacScheduling$outboundSchema.parse(
      restAuthenticationHmacScheduling,
    ),
  );
}
export function restAuthenticationHmacSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmacScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationHmacScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmacScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationHmac$inboundSchema: z.ZodType<
  RestAuthenticationHmac,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("hmac"),
  hmacFunctionId: z.string(),
  discovery: z.lazy(() => RestAuthenticationHmacDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationHmacCollectMethod$inboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestAuthenticationHmacPagination$inboundSchema)
    .optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestAuthenticationHmacRetryRules$inboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestAuthenticationHmacScheduling$inboundSchema)
    .optional(),
});
/** @internal */
export type RestAuthenticationHmac$Outbound = {
  authentication: "hmac";
  hmacFunctionId: string;
  discovery?: RestAuthenticationHmacDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestAuthenticationHmacPagination$Outbound | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationHmacRetryRules$Outbound | undefined;
  __scheduling?: RestAuthenticationHmacScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationHmac$outboundSchema: z.ZodType<
  RestAuthenticationHmac$Outbound,
  z.ZodTypeDef,
  RestAuthenticationHmac
> = z.object({
  authentication: z.literal("hmac"),
  hmacFunctionId: z.string(),
  discovery: z.lazy(() => RestAuthenticationHmacDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationHmacCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestAuthenticationHmacPagination$outboundSchema)
    .optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestAuthenticationHmacRetryRules$outboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestAuthenticationHmacScheduling$outboundSchema)
    .optional(),
});

export function restAuthenticationHmacToJSON(
  restAuthenticationHmac: RestAuthenticationHmac,
): string {
  return JSON.stringify(
    RestAuthenticationHmac$outboundSchema.parse(restAuthenticationHmac),
  );
}
export function restAuthenticationHmacFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationHmac, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationHmac$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationHmac' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RestAuthenticationGoogleOauthSecretDiscoverType);
/** @internal */
export const RestAuthenticationGoogleOauthSecretDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretDiscoverType
  > = openEnums.outboundSchema(RestAuthenticationGoogleOauthSecretDiscoverType);

/** @internal */
export const RestAuthenticationGoogleOauthSecretDiscovery$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretDiscovery,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: RestAuthenticationGoogleOauthSecretDiscoverType$inboundSchema,
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestAuthenticationGoogleOauthSecretDiscovery$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretDiscovery$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretDiscovery
  > = z.object({
    discoverType:
      RestAuthenticationGoogleOauthSecretDiscoverType$outboundSchema,
  });

export function restAuthenticationGoogleOauthSecretDiscoveryToJSON(
  restAuthenticationGoogleOauthSecretDiscovery:
    RestAuthenticationGoogleOauthSecretDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretDiscovery$outboundSchema.parse(
      restAuthenticationGoogleOauthSecretDiscovery,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretDiscovery,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretDiscovery$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretCollectMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretCollectMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RestAuthenticationGoogleOauthSecretCollectMethod);
/** @internal */
export const RestAuthenticationGoogleOauthSecretCollectMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretCollectMethod
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthSecretCollectMethod,
  );

/** @internal */
export const RestAuthenticationGoogleOauthSecretPaginationEnum$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretPaginationEnum,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationGoogleOauthSecretPaginationEnum,
  );
/** @internal */
export const RestAuthenticationGoogleOauthSecretPaginationEnum$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretPaginationEnum
  > = openEnums.outboundSchema(
    RestAuthenticationGoogleOauthSecretPaginationEnum,
  );

/** @internal */
export const RestAuthenticationGoogleOauthSecretPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: RestAuthenticationGoogleOauthSecretPaginationEnum$inboundSchema,
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestAuthenticationGoogleOauthSecretPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretPagination
  > = z.object({
    type: RestAuthenticationGoogleOauthSecretPaginationEnum$outboundSchema,
  });

export function restAuthenticationGoogleOauthSecretPaginationToJSON(
  restAuthenticationGoogleOauthSecretPagination:
    RestAuthenticationGoogleOauthSecretPagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretPagination$outboundSchema.parse(
      restAuthenticationGoogleOauthSecretPagination,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretPagination$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretRetryRules$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRetryRules,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthSecretRetryRules$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretRetryRules$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretRetryRules
  > = z.object({
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationGoogleOauthSecretRetryRulesToJSON(
  restAuthenticationGoogleOauthSecretRetryRules:
    RestAuthenticationGoogleOauthSecretRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretRetryRules$outboundSchema.parse(
      restAuthenticationGoogleOauthSecretRetryRules,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretStateTracking$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretStateTracking,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enabled: z.boolean().optional(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthSecretStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthSecretStateTrackingToJSON(
  restAuthenticationGoogleOauthSecretStateTracking:
    RestAuthenticationGoogleOauthSecretStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretStateTracking$outboundSchema.parse(
      restAuthenticationGoogleOauthSecretStateTracking,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecretScheduling$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretScheduling,
    z.ZodTypeDef,
    unknown
  > = z.object({
    stateTracking: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretStateTracking$inboundSchema
    ).optional(),
  });
/** @internal */
export type RestAuthenticationGoogleOauthSecretScheduling$Outbound = {
  stateTracking?:
    | RestAuthenticationGoogleOauthSecretStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthSecretScheduling$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthSecretScheduling$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthSecretScheduling
  > = z.object({
    stateTracking: z.lazy(() =>
      RestAuthenticationGoogleOauthSecretStateTracking$outboundSchema
    ).optional(),
  });

export function restAuthenticationGoogleOauthSecretSchedulingToJSON(
  restAuthenticationGoogleOauthSecretScheduling:
    RestAuthenticationGoogleOauthSecretScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecretScheduling$outboundSchema.parse(
      restAuthenticationGoogleOauthSecretScheduling,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthSecretScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecretScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthSecretScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthSecret$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("google_oauthSecret"),
  scopes: z.array(z.string()),
  textSecret: z.string(),
  subject: z.string(),
  discovery: z.lazy(() =>
    RestAuthenticationGoogleOauthSecretDiscovery$inboundSchema
  ).optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationGoogleOauthSecretCollectMethod$inboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() =>
    RestAuthenticationGoogleOauthSecretPagination$inboundSchema
  ).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    RestAuthenticationGoogleOauthSecretRetryRules$inboundSchema
  ).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationGoogleOauthSecretScheduling$inboundSchema
  ).optional(),
});
/** @internal */
export type RestAuthenticationGoogleOauthSecret$Outbound = {
  authentication: "google_oauthSecret";
  scopes: Array<string>;
  textSecret: string;
  subject: string;
  discovery?: RestAuthenticationGoogleOauthSecretDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationGoogleOauthSecretPagination$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationGoogleOauthSecretRetryRules$Outbound
    | undefined;
  __scheduling?:
    | RestAuthenticationGoogleOauthSecretScheduling$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthSecret$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthSecret$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauthSecret
> = z.object({
  authentication: z.literal("google_oauthSecret"),
  scopes: z.array(z.string()),
  textSecret: z.string(),
  subject: z.string(),
  discovery: z.lazy(() =>
    RestAuthenticationGoogleOauthSecretDiscovery$outboundSchema
  ).optional(),
  collectUrl: z.string(),
  collectMethod:
    RestAuthenticationGoogleOauthSecretCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() =>
    RestAuthenticationGoogleOauthSecretPagination$outboundSchema
  ).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    RestAuthenticationGoogleOauthSecretRetryRules$outboundSchema
  ).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationGoogleOauthSecretScheduling$outboundSchema
  ).optional(),
});

export function restAuthenticationGoogleOauthSecretToJSON(
  restAuthenticationGoogleOauthSecret: RestAuthenticationGoogleOauthSecret,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthSecret$outboundSchema.parse(
      restAuthenticationGoogleOauthSecret,
    ),
  );
}
export function restAuthenticationGoogleOauthSecretFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationGoogleOauthSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthSecret' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthDiscoverType$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationGoogleOauthDiscoverType);
/** @internal */
export const RestAuthenticationGoogleOauthDiscoverType$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationGoogleOauthDiscoverType> =
    openEnums.outboundSchema(RestAuthenticationGoogleOauthDiscoverType);

/** @internal */
export const RestAuthenticationGoogleOauthDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestAuthenticationGoogleOauthDiscoverType$inboundSchema,
});
/** @internal */
export type RestAuthenticationGoogleOauthDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestAuthenticationGoogleOauthDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauthDiscovery
> = z.object({
  discoverType: RestAuthenticationGoogleOauthDiscoverType$outboundSchema,
});

export function restAuthenticationGoogleOauthDiscoveryToJSON(
  restAuthenticationGoogleOauthDiscovery:
    RestAuthenticationGoogleOauthDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthDiscovery$outboundSchema.parse(
      restAuthenticationGoogleOauthDiscovery,
    ),
  );
}
export function restAuthenticationGoogleOauthDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationGoogleOauthDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauthDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthCollectMethod$inboundSchema:
  z.ZodType<RestAuthenticationGoogleOauthCollectMethod, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(RestAuthenticationGoogleOauthCollectMethod);
/** @internal */
export const RestAuthenticationGoogleOauthCollectMethod$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationGoogleOauthCollectMethod> =
    openEnums.outboundSchema(RestAuthenticationGoogleOauthCollectMethod);

/** @internal */
export const RestAuthenticationGoogleOauthPaginationEnum$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthPaginationEnum,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RestAuthenticationGoogleOauthPaginationEnum);
/** @internal */
export const RestAuthenticationGoogleOauthPaginationEnum$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationGoogleOauthPaginationEnum> =
    openEnums.outboundSchema(RestAuthenticationGoogleOauthPaginationEnum);

/** @internal */
export const RestAuthenticationGoogleOauthPagination$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestAuthenticationGoogleOauthPaginationEnum$inboundSchema,
});
/** @internal */
export type RestAuthenticationGoogleOauthPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestAuthenticationGoogleOauthPagination$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthPagination$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauthPagination
> = z.object({
  type: RestAuthenticationGoogleOauthPaginationEnum$outboundSchema,
});

export function restAuthenticationGoogleOauthPaginationToJSON(
  restAuthenticationGoogleOauthPagination:
    RestAuthenticationGoogleOauthPagination,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthPagination$outboundSchema.parse(
      restAuthenticationGoogleOauthPagination,
    ),
  );
}
export function restAuthenticationGoogleOauthPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthPagination$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestAuthenticationGoogleOauthRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauthRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restAuthenticationGoogleOauthRetryRulesToJSON(
  restAuthenticationGoogleOauthRetryRules:
    RestAuthenticationGoogleOauthRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRetryRules$outboundSchema.parse(
      restAuthenticationGoogleOauthRetryRules,
    ),
  );
}
export function restAuthenticationGoogleOauthRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthStateTracking$inboundSchema:
  z.ZodType<RestAuthenticationGoogleOauthStateTracking, z.ZodTypeDef, unknown> =
    z.object({
      enabled: z.boolean().optional(),
    });
/** @internal */
export type RestAuthenticationGoogleOauthStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthStateTrackingToJSON(
  restAuthenticationGoogleOauthStateTracking:
    RestAuthenticationGoogleOauthStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthStateTracking$outboundSchema.parse(
      restAuthenticationGoogleOauthStateTracking,
    ),
  );
}
export function restAuthenticationGoogleOauthStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthScheduling$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationGoogleOauthStateTracking$inboundSchema
  ).optional(),
});
/** @internal */
export type RestAuthenticationGoogleOauthScheduling$Outbound = {
  stateTracking?:
    | RestAuthenticationGoogleOauthStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthScheduling$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauthScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationGoogleOauthStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationGoogleOauthSchedulingToJSON(
  restAuthenticationGoogleOauthScheduling:
    RestAuthenticationGoogleOauthScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthScheduling$outboundSchema.parse(
      restAuthenticationGoogleOauthScheduling,
    ),
  );
}
export function restAuthenticationGoogleOauthSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauth$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauth,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("google_oauth"),
  scopes: z.array(z.string()),
  serviceAccountCredentials: z.string(),
  subject: z.string(),
  discovery: z.lazy(() => RestAuthenticationGoogleOauthDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationGoogleOauthCollectMethod$inboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() =>
    RestAuthenticationGoogleOauthPagination$inboundSchema
  ).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    RestAuthenticationGoogleOauthRetryRules$inboundSchema
  ).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationGoogleOauthScheduling$inboundSchema
  ).optional(),
});
/** @internal */
export type RestAuthenticationGoogleOauth$Outbound = {
  authentication: "google_oauth";
  scopes: Array<string>;
  serviceAccountCredentials: string;
  subject: string;
  discovery?: RestAuthenticationGoogleOauthDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestAuthenticationGoogleOauthPagination$Outbound | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationGoogleOauthRetryRules$Outbound | undefined;
  __scheduling?: RestAuthenticationGoogleOauthScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauth$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauth$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauth
> = z.object({
  authentication: z.literal("google_oauth"),
  scopes: z.array(z.string()),
  serviceAccountCredentials: z.string(),
  subject: z.string(),
  discovery: z.lazy(() => RestAuthenticationGoogleOauthDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationGoogleOauthCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() =>
    RestAuthenticationGoogleOauthPagination$outboundSchema
  ).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    RestAuthenticationGoogleOauthRetryRules$outboundSchema
  ).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationGoogleOauthScheduling$outboundSchema
  ).optional(),
});

export function restAuthenticationGoogleOauthToJSON(
  restAuthenticationGoogleOauth: RestAuthenticationGoogleOauth,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauth$outboundSchema.parse(
      restAuthenticationGoogleOauth,
    ),
  );
}
export function restAuthenticationGoogleOauthFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationGoogleOauth, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationGoogleOauth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauth' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretDiscoverType$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecretDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationOauthSecretDiscoverType);
/** @internal */
export const RestAuthenticationOauthSecretDiscoverType$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationOauthSecretDiscoverType> =
    openEnums.outboundSchema(RestAuthenticationOauthSecretDiscoverType);

/** @internal */
export const RestAuthenticationOauthSecretDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecretDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestAuthenticationOauthSecretDiscoverType$inboundSchema,
});
/** @internal */
export type RestAuthenticationOauthSecretDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestAuthenticationOauthSecretDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationOauthSecretDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthSecretDiscovery
> = z.object({
  discoverType: RestAuthenticationOauthSecretDiscoverType$outboundSchema,
});

export function restAuthenticationOauthSecretDiscoveryToJSON(
  restAuthenticationOauthSecretDiscovery:
    RestAuthenticationOauthSecretDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretDiscovery$outboundSchema.parse(
      restAuthenticationOauthSecretDiscovery,
    ),
  );
}
export function restAuthenticationOauthSecretDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthSecretDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretCollectMethod$inboundSchema:
  z.ZodType<RestAuthenticationOauthSecretCollectMethod, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(RestAuthenticationOauthSecretCollectMethod);
/** @internal */
export const RestAuthenticationOauthSecretCollectMethod$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationOauthSecretCollectMethod> =
    openEnums.outboundSchema(RestAuthenticationOauthSecretCollectMethod);

/** @internal */
export const RestAuthenticationOauthSecretPaginationEnum$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretPaginationEnum,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RestAuthenticationOauthSecretPaginationEnum);
/** @internal */
export const RestAuthenticationOauthSecretPaginationEnum$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationOauthSecretPaginationEnum> =
    openEnums.outboundSchema(RestAuthenticationOauthSecretPaginationEnum);

/** @internal */
export const RestAuthenticationOauthSecretPagination$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecretPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestAuthenticationOauthSecretPaginationEnum$inboundSchema,
});
/** @internal */
export type RestAuthenticationOauthSecretPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestAuthenticationOauthSecretPagination$outboundSchema: z.ZodType<
  RestAuthenticationOauthSecretPagination$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthSecretPagination
> = z.object({
  type: RestAuthenticationOauthSecretPaginationEnum$outboundSchema,
});

export function restAuthenticationOauthSecretPaginationToJSON(
  restAuthenticationOauthSecretPagination:
    RestAuthenticationOauthSecretPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretPagination$outboundSchema.parse(
      restAuthenticationOauthSecretPagination,
    ),
  );
}
export function restAuthenticationOauthSecretPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretPagination$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecretRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestAuthenticationOauthSecretRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationOauthSecretRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationOauthSecretRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthSecretRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restAuthenticationOauthSecretRetryRulesToJSON(
  restAuthenticationOauthSecretRetryRules:
    RestAuthenticationOauthSecretRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRetryRules$outboundSchema.parse(
      restAuthenticationOauthSecretRetryRules,
    ),
  );
}
export function restAuthenticationOauthSecretRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretStateTracking$inboundSchema:
  z.ZodType<RestAuthenticationOauthSecretStateTracking, z.ZodTypeDef, unknown> =
    z.object({
      enabled: z.boolean().optional(),
    });
/** @internal */
export type RestAuthenticationOauthSecretStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationOauthSecretStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretStateTrackingToJSON(
  restAuthenticationOauthSecretStateTracking:
    RestAuthenticationOauthSecretStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretStateTracking$outboundSchema.parse(
      restAuthenticationOauthSecretStateTracking,
    ),
  );
}
export function restAuthenticationOauthSecretStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretScheduling$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecretScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationOauthSecretStateTracking$inboundSchema
  ).optional(),
});
/** @internal */
export type RestAuthenticationOauthSecretScheduling$Outbound = {
  stateTracking?:
    | RestAuthenticationOauthSecretStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationOauthSecretScheduling$outboundSchema: z.ZodType<
  RestAuthenticationOauthSecretScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthSecretScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationOauthSecretStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationOauthSecretSchedulingToJSON(
  restAuthenticationOauthSecretScheduling:
    RestAuthenticationOauthSecretScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretScheduling$outboundSchema.parse(
      restAuthenticationOauthSecretScheduling,
    ),
  );
}
export function restAuthenticationOauthSecretSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecret$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("oauthSecret"),
  loginUrl: z.string(),
  tokenRespAttribute: z.string().optional(),
  authHeaderKey: z.string().optional(),
  authHeaderExpr: z.string(),
  clientSecretParamName: z.string(),
  textSecret: z.string(),
  authRequestParams: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  authRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  discovery: z.lazy(() => RestAuthenticationOauthSecretDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationOauthSecretCollectMethod$inboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() =>
    RestAuthenticationOauthSecretPagination$inboundSchema
  ).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    RestAuthenticationOauthSecretRetryRules$inboundSchema
  ).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationOauthSecretScheduling$inboundSchema
  ).optional(),
});
/** @internal */
export type RestAuthenticationOauthSecret$Outbound = {
  authentication: "oauthSecret";
  loginUrl: string;
  tokenRespAttribute?: string | undefined;
  authHeaderKey?: string | undefined;
  authHeaderExpr: string;
  clientSecretParamName: string;
  textSecret: string;
  authRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?: RestAuthenticationOauthSecretDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestAuthenticationOauthSecretPagination$Outbound | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationOauthSecretRetryRules$Outbound | undefined;
  __scheduling?: RestAuthenticationOauthSecretScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationOauthSecret$outboundSchema: z.ZodType<
  RestAuthenticationOauthSecret$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthSecret
> = z.object({
  authentication: z.literal("oauthSecret"),
  loginUrl: z.string(),
  tokenRespAttribute: z.string().optional(),
  authHeaderKey: z.string().optional(),
  authHeaderExpr: z.string(),
  clientSecretParamName: z.string(),
  textSecret: z.string(),
  authRequestParams: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  authRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  discovery: z.lazy(() => RestAuthenticationOauthSecretDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationOauthSecretCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() =>
    RestAuthenticationOauthSecretPagination$outboundSchema
  ).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    RestAuthenticationOauthSecretRetryRules$outboundSchema
  ).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationOauthSecretScheduling$outboundSchema
  ).optional(),
});

export function restAuthenticationOauthSecretToJSON(
  restAuthenticationOauthSecret: RestAuthenticationOauthSecret,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecret$outboundSchema.parse(
      restAuthenticationOauthSecret,
    ),
  );
}
export function restAuthenticationOauthSecretFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauthSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecret' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthDiscoverType$inboundSchema: z.ZodType<
  RestAuthenticationOauthDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationOauthDiscoverType);
/** @internal */
export const RestAuthenticationOauthDiscoverType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationOauthDiscoverType
> = openEnums.outboundSchema(RestAuthenticationOauthDiscoverType);

/** @internal */
export const RestAuthenticationOauthDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationOauthDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestAuthenticationOauthDiscoverType$inboundSchema,
});
/** @internal */
export type RestAuthenticationOauthDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestAuthenticationOauthDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationOauthDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthDiscovery
> = z.object({
  discoverType: RestAuthenticationOauthDiscoverType$outboundSchema,
});

export function restAuthenticationOauthDiscoveryToJSON(
  restAuthenticationOauthDiscovery: RestAuthenticationOauthDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationOauthDiscovery$outboundSchema.parse(
      restAuthenticationOauthDiscovery,
    ),
  );
}
export function restAuthenticationOauthDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauthDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthCollectMethod$inboundSchema: z.ZodType<
  RestAuthenticationOauthCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationOauthCollectMethod);
/** @internal */
export const RestAuthenticationOauthCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationOauthCollectMethod
> = openEnums.outboundSchema(RestAuthenticationOauthCollectMethod);

/** @internal */
export const RestAuthenticationOauthPaginationEnum$inboundSchema: z.ZodType<
  RestAuthenticationOauthPaginationEnum,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationOauthPaginationEnum);
/** @internal */
export const RestAuthenticationOauthPaginationEnum$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationOauthPaginationEnum
> = openEnums.outboundSchema(RestAuthenticationOauthPaginationEnum);

/** @internal */
export const RestAuthenticationOauthPagination$inboundSchema: z.ZodType<
  RestAuthenticationOauthPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestAuthenticationOauthPaginationEnum$inboundSchema,
});
/** @internal */
export type RestAuthenticationOauthPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestAuthenticationOauthPagination$outboundSchema: z.ZodType<
  RestAuthenticationOauthPagination$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthPagination
> = z.object({
  type: RestAuthenticationOauthPaginationEnum$outboundSchema,
});

export function restAuthenticationOauthPaginationToJSON(
  restAuthenticationOauthPagination: RestAuthenticationOauthPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthPagination$outboundSchema.parse(
      restAuthenticationOauthPagination,
    ),
  );
}
export function restAuthenticationOauthPaginationFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthPagination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauthPagination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationOauthRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestAuthenticationOauthRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationOauthRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationOauthRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restAuthenticationOauthRetryRulesToJSON(
  restAuthenticationOauthRetryRules: RestAuthenticationOauthRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRetryRules$outboundSchema.parse(
      restAuthenticationOauthRetryRules,
    ),
  );
}
export function restAuthenticationOauthRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauthRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthStateTracking$inboundSchema: z.ZodType<
  RestAuthenticationOauthStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type RestAuthenticationOauthStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationOauthStateTracking$outboundSchema: z.ZodType<
  RestAuthenticationOauthStateTracking$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restAuthenticationOauthStateTrackingToJSON(
  restAuthenticationOauthStateTracking: RestAuthenticationOauthStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationOauthStateTracking$outboundSchema.parse(
      restAuthenticationOauthStateTracking,
    ),
  );
}
export function restAuthenticationOauthStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthScheduling$inboundSchema: z.ZodType<
  RestAuthenticationOauthScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationOauthStateTracking$inboundSchema
  ).optional(),
});
/** @internal */
export type RestAuthenticationOauthScheduling$Outbound = {
  stateTracking?: RestAuthenticationOauthStateTracking$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationOauthScheduling$outboundSchema: z.ZodType<
  RestAuthenticationOauthScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationOauthStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationOauthSchedulingToJSON(
  restAuthenticationOauthScheduling: RestAuthenticationOauthScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationOauthScheduling$outboundSchema.parse(
      restAuthenticationOauthScheduling,
    ),
  );
}
export function restAuthenticationOauthSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauthScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauth$inboundSchema: z.ZodType<
  RestAuthenticationOauth,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("oauth"),
  loginUrl: z.string(),
  tokenRespAttribute: z.string().optional(),
  authHeaderKey: z.string().optional(),
  authHeaderExpr: z.string(),
  clientSecretParamName: z.string(),
  clientSecretParamValue: z.string(),
  authRequestParams: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  authRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  discovery: z.lazy(() => RestAuthenticationOauthDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationOauthCollectMethod$inboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestAuthenticationOauthPagination$inboundSchema)
    .optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestAuthenticationOauthRetryRules$inboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestAuthenticationOauthScheduling$inboundSchema)
    .optional(),
});
/** @internal */
export type RestAuthenticationOauth$Outbound = {
  authentication: "oauth";
  loginUrl: string;
  tokenRespAttribute?: string | undefined;
  authHeaderKey?: string | undefined;
  authHeaderExpr: string;
  clientSecretParamName: string;
  clientSecretParamValue: string;
  authRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?: RestAuthenticationOauthDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestAuthenticationOauthPagination$Outbound | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationOauthRetryRules$Outbound | undefined;
  __scheduling?: RestAuthenticationOauthScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationOauth$outboundSchema: z.ZodType<
  RestAuthenticationOauth$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauth
> = z.object({
  authentication: z.literal("oauth"),
  loginUrl: z.string(),
  tokenRespAttribute: z.string().optional(),
  authHeaderKey: z.string().optional(),
  authHeaderExpr: z.string(),
  clientSecretParamName: z.string(),
  clientSecretParamValue: z.string(),
  authRequestParams: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  authRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  discovery: z.lazy(() => RestAuthenticationOauthDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationOauthCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestAuthenticationOauthPagination$outboundSchema)
    .optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestAuthenticationOauthRetryRules$outboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestAuthenticationOauthScheduling$outboundSchema)
    .optional(),
});

export function restAuthenticationOauthToJSON(
  restAuthenticationOauth: RestAuthenticationOauth,
): string {
  return JSON.stringify(
    RestAuthenticationOauth$outboundSchema.parse(restAuthenticationOauth),
  );
}
export function restAuthenticationOauthFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauth, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauth' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoverType$inboundSchema,
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$Outbound =
  {
    discoverType: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery
  > = z.object({
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoverType$outboundSchema,
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoveryToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$outboundSchema
      .parse(restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationEnum$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationEnum,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationEnum,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationEnum$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationEnum
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationEnum,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationEnum$inboundSchema,
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePagination
  > = z.object({
    type:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationEnum$outboundSchema,
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTruePagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePagination$outboundSchema
      .parse(restAuthenticationLoginSecretGetAuthTokenFromHeaderTruePagination),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules$Outbound =
  {
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    enableHeader?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules
  > = z.object({
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRulesToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules$outboundSchema
      .parse(restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enabled: z.boolean().optional(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$Outbound =
  {
    enabled?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTrackingToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling,
    z.ZodTypeDef,
    unknown
  > = z.object({
    stateTracking: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$inboundSchema
    ).optional(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$Outbound =
  {
    stateTracking?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$Outbound
      | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling
  > = z.object({
    stateTracking: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$outboundSchema
    ).optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueSchedulingToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$outboundSchema
      .parse(restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    getAuthTokenFromHeader: z.boolean().optional(),
    authentication:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication$inboundSchema,
    loginUrl: z.string(),
    credentialsSecret: z.string(),
    loginBody: z.string(),
    authHeaderKey: z.string().optional(),
    authHeaderExpr: z.string(),
    authRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
    ).optional(),
    discovery: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$inboundSchema
    ).optional(),
    collectUrl: z.string(),
    collectMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod$inboundSchema,
    collectVerb: z.any().optional(),
    collectRequestParams: z.any().optional(),
    collectBody: z.any().optional(),
    collectRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePagination$inboundSchema
    ).optional(),
    timeout: z.number().optional(),
    useRoundRobinDns: z.boolean().optional(),
    disableTimeFilter: z.boolean().optional(),
    decodeUrl: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    stopOnEmptyResults: z.boolean().optional(),
    safeHeaders: z.array(z.string()).optional(),
    retryRules: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules$inboundSchema
    ).optional(),
    __scheduling: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$inboundSchema
    ).optional(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$Outbound = {
  getAuthTokenFromHeader?: boolean | undefined;
  authentication: string;
  loginUrl: string;
  credentialsSecret: string;
  loginBody: string;
  authHeaderKey?: string | undefined;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePagination$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules$Outbound
    | undefined;
  __scheduling?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue
  > = z.object({
    getAuthTokenFromHeader: z.boolean().optional(),
    authentication:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication$outboundSchema,
    loginUrl: z.string(),
    credentialsSecret: z.string(),
    loginBody: z.string(),
    authHeaderKey: z.string().optional(),
    authHeaderExpr: z.string(),
    authRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discovery: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$outboundSchema
    ).optional(),
    collectUrl: z.string(),
    collectMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod$outboundSchema,
    collectVerb: z.any().optional(),
    collectRequestParams: z.any().optional(),
    collectBody: z.any().optional(),
    collectRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePagination$outboundSchema
    ).optional(),
    timeout: z.number().optional(),
    useRoundRobinDns: z.boolean().optional(),
    disableTimeFilter: z.boolean().optional(),
    decodeUrl: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    stopOnEmptyResults: z.boolean().optional(),
    safeHeaders: z.array(z.string()).optional(),
    retryRules: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules$outboundSchema
    ).optional(),
    __scheduling: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$outboundSchema
    ).optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrue:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$outboundSchema
      .parse(restAuthenticationLoginSecretGetAuthTokenFromHeaderTrue),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoverType$inboundSchema,
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery$Outbound =
  {
    discoverType: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery
  > = z.object({
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoverType$outboundSchema,
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoveryToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery$outboundSchema
      .parse(restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationEnum$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationEnum,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationEnum,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationEnum$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationEnum
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationEnum,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationEnum$inboundSchema,
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePagination
  > = z.object({
    type:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationEnum$outboundSchema,
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules$Outbound =
  {
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    enableHeader?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules
  > = z.object({
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRulesToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enabled: z.boolean().optional(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$Outbound =
  {
    enabled?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTrackingToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling,
    z.ZodTypeDef,
    unknown
  > = z.object({
    stateTracking: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$inboundSchema
    ).optional(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$Outbound =
  {
    stateTracking?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$Outbound
      | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling
  > = z.object({
    stateTracking: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$outboundSchema
    ).optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseSchedulingToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    getAuthTokenFromHeader: z.boolean().optional(),
    tokenRespAttribute: z.string().optional(),
    authentication:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication$inboundSchema,
    loginUrl: z.string(),
    credentialsSecret: z.string(),
    loginBody: z.string(),
    authHeaderKey: z.string().optional(),
    authHeaderExpr: z.string(),
    authRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
    ).optional(),
    discovery: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery$inboundSchema
    ).optional(),
    collectUrl: z.string(),
    collectMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod$inboundSchema,
    collectVerb: z.any().optional(),
    collectRequestParams: z.any().optional(),
    collectBody: z.any().optional(),
    collectRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePagination$inboundSchema
    ).optional(),
    timeout: z.number().optional(),
    useRoundRobinDns: z.boolean().optional(),
    disableTimeFilter: z.boolean().optional(),
    decodeUrl: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    stopOnEmptyResults: z.boolean().optional(),
    safeHeaders: z.array(z.string()).optional(),
    retryRules: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules$inboundSchema
    ).optional(),
    __scheduling: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$inboundSchema
    ).optional(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$Outbound =
  {
    getAuthTokenFromHeader?: boolean | undefined;
    tokenRespAttribute?: string | undefined;
    authentication: string;
    loginUrl: string;
    credentialsSecret: string;
    loginBody: string;
    authHeaderKey?: string | undefined;
    authHeaderExpr: string;
    authRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discovery?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery$Outbound
      | undefined;
    collectUrl: string;
    collectMethod: string;
    collectVerb?: any | undefined;
    collectRequestParams?: any | undefined;
    collectBody?: any | undefined;
    collectRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePagination$Outbound
      | undefined;
    timeout?: number | undefined;
    useRoundRobinDns?: boolean | undefined;
    disableTimeFilter?: boolean | undefined;
    decodeUrl?: boolean | undefined;
    rejectUnauthorized?: boolean | undefined;
    captureHeaders?: boolean | undefined;
    stopOnEmptyResults?: boolean | undefined;
    safeHeaders?: Array<string> | undefined;
    retryRules?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules$Outbound
      | undefined;
    __scheduling?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$Outbound
      | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse
  > = z.object({
    getAuthTokenFromHeader: z.boolean().optional(),
    tokenRespAttribute: z.string().optional(),
    authentication:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication$outboundSchema,
    loginUrl: z.string(),
    credentialsSecret: z.string(),
    loginBody: z.string(),
    authHeaderKey: z.string().optional(),
    authHeaderExpr: z.string(),
    authRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discovery: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery$outboundSchema
    ).optional(),
    collectUrl: z.string(),
    collectMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod$outboundSchema,
    collectVerb: z.any().optional(),
    collectRequestParams: z.any().optional(),
    collectBody: z.any().optional(),
    collectRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePagination$outboundSchema
    ).optional(),
    timeout: z.number().optional(),
    useRoundRobinDns: z.boolean().optional(),
    disableTimeFilter: z.boolean().optional(),
    decodeUrl: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    stopOnEmptyResults: z.boolean().optional(),
    safeHeaders: z.array(z.string()).optional(),
    retryRules: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules$outboundSchema
    ).optional(),
    __scheduling: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$outboundSchema
    ).optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalse:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$outboundSchema
      .parse(restAuthenticationLoginSecretGetAuthTokenFromHeaderFalse),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecret$inboundSchema: z.ZodType<
  RestAuthenticationLoginSecret,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() =>
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$inboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$inboundSchema
  ),
]);
/** @internal */
export type RestAuthenticationLoginSecret$Outbound =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationLoginSecret$outboundSchema: z.ZodType<
  RestAuthenticationLoginSecret$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLoginSecret
> = z.union([
  z.lazy(() =>
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$outboundSchema
  ),
]);

export function restAuthenticationLoginSecretToJSON(
  restAuthenticationLoginSecret: RestAuthenticationLoginSecret,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecret$outboundSchema.parse(
      restAuthenticationLoginSecret,
    ),
  );
}
export function restAuthenticationLoginSecretFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationLoginSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationLoginSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecret' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoverType$inboundSchema,
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery$Outbound =
  {
    discoverType: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery
  > = z.object({
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoverType$outboundSchema,
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoveryToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationEnum$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationEnum,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationEnum,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationEnum$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationEnum
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationEnum,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationEnum$inboundSchema,
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTruePagination
  > = z.object({
    type:
      RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationEnum$outboundSchema,
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTruePaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTruePagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTruePagination$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderTruePagination),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules$Outbound =
  {
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    enableHeader?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules
  > = z.object({
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRulesToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enabled: z.boolean().optional(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$Outbound =
  {
    enabled?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueStateTrackingToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling,
    z.ZodTypeDef,
    unknown
  > = z.object({
    stateTracking: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$inboundSchema
    ).optional(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$Outbound =
  {
    stateTracking?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$Outbound
      | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling
  > = z.object({
    stateTracking: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$outboundSchema
    ).optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueSchedulingToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    getAuthTokenFromHeader: z.boolean().optional(),
    authentication:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication$inboundSchema,
    loginUrl: z.string(),
    username: z.string(),
    password: z.string(),
    loginBody: z.string(),
    authHeaderKey: z.string().optional(),
    authHeaderExpr: z.string(),
    authRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
    ).optional(),
    discovery: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery$inboundSchema
    ).optional(),
    collectUrl: z.string(),
    collectMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod$inboundSchema,
    collectVerb: z.any().optional(),
    collectRequestParams: z.any().optional(),
    collectBody: z.any().optional(),
    collectRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTruePagination$inboundSchema
    ).optional(),
    timeout: z.number().optional(),
    useRoundRobinDns: z.boolean().optional(),
    disableTimeFilter: z.boolean().optional(),
    decodeUrl: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    stopOnEmptyResults: z.boolean().optional(),
    safeHeaders: z.array(z.string()).optional(),
    retryRules: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules$inboundSchema
    ).optional(),
    __scheduling: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$inboundSchema
    ).optional(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrue$Outbound = {
  getAuthTokenFromHeader?: boolean | undefined;
  authentication: string;
  loginUrl: string;
  username: string;
  password: string;
  loginBody: string;
  authHeaderKey?: string | undefined;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderTruePagination$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules$Outbound
    | undefined;
  __scheduling?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrue
  > = z.object({
    getAuthTokenFromHeader: z.boolean().optional(),
    authentication:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication$outboundSchema,
    loginUrl: z.string(),
    username: z.string(),
    password: z.string(),
    loginBody: z.string(),
    authHeaderKey: z.string().optional(),
    authHeaderExpr: z.string(),
    authRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discovery: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery$outboundSchema
    ).optional(),
    collectUrl: z.string(),
    collectMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod$outboundSchema,
    collectVerb: z.any().optional(),
    collectRequestParams: z.any().optional(),
    collectBody: z.any().optional(),
    collectRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTruePagination$outboundSchema
    ).optional(),
    timeout: z.number().optional(),
    useRoundRobinDns: z.boolean().optional(),
    disableTimeFilter: z.boolean().optional(),
    decodeUrl: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    stopOnEmptyResults: z.boolean().optional(),
    safeHeaders: z.array(z.string()).optional(),
    retryRules: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules$outboundSchema
    ).optional(),
    __scheduling: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$outboundSchema
    ).optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrue:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrue$outboundSchema.parse(
      restAuthenticationLoginGetAuthTokenFromHeaderTrue,
    ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrue$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoverType$inboundSchema,
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery$Outbound =
  {
    discoverType: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery
  > = z.object({
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoverType$outboundSchema,
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoveryToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationEnum$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationEnum,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationEnum,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationEnum$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationEnum
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationEnum,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationEnum$inboundSchema,
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalsePagination
  > = z.object({
    type:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationEnum$outboundSchema,
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalsePagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalsePagination$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderFalsePagination),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules$Outbound =
  {
    type: string;
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    maxIntervalMs?: any | undefined;
    codes?: any | undefined;
    enableHeader?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules
  > = z.object({
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRulesToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enabled: z.boolean().optional(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking$Outbound =
  {
    enabled?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseStateTrackingToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling,
    z.ZodTypeDef,
    unknown
  > = z.object({
    stateTracking: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking$inboundSchema
    ).optional(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling$Outbound =
  {
    stateTracking?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking$Outbound
      | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling
  > = z.object({
    stateTracking: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking$outboundSchema
    ).optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseSchedulingToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    getAuthTokenFromHeader: z.boolean().optional(),
    tokenRespAttribute: z.string().optional(),
    authentication:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication$inboundSchema,
    loginUrl: z.string(),
    username: z.string(),
    password: z.string(),
    loginBody: z.string(),
    authHeaderKey: z.string().optional(),
    authHeaderExpr: z.string(),
    authRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
    ).optional(),
    discovery: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery$inboundSchema
    ).optional(),
    collectUrl: z.string(),
    collectMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod$inboundSchema,
    collectVerb: z.any().optional(),
    collectRequestParams: z.any().optional(),
    collectBody: z.any().optional(),
    collectRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalsePagination$inboundSchema
    ).optional(),
    timeout: z.number().optional(),
    useRoundRobinDns: z.boolean().optional(),
    disableTimeFilter: z.boolean().optional(),
    decodeUrl: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    stopOnEmptyResults: z.boolean().optional(),
    safeHeaders: z.array(z.string()).optional(),
    retryRules: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules$inboundSchema
    ).optional(),
    __scheduling: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling$inboundSchema
    ).optional(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalse$Outbound = {
  getAuthTokenFromHeader?: boolean | undefined;
  tokenRespAttribute?: string | undefined;
  authentication: string;
  loginUrl: string;
  username: string;
  password: string;
  loginBody: string;
  authHeaderKey?: string | undefined;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalsePagination$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules$Outbound
    | undefined;
  __scheduling?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalse
  > = z.object({
    getAuthTokenFromHeader: z.boolean().optional(),
    tokenRespAttribute: z.string().optional(),
    authentication:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication$outboundSchema,
    loginUrl: z.string(),
    username: z.string(),
    password: z.string(),
    loginBody: z.string(),
    authHeaderKey: z.string().optional(),
    authHeaderExpr: z.string(),
    authRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discovery: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery$outboundSchema
    ).optional(),
    collectUrl: z.string(),
    collectMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod$outboundSchema,
    collectVerb: z.any().optional(),
    collectRequestParams: z.any().optional(),
    collectBody: z.any().optional(),
    collectRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalsePagination$outboundSchema
    ).optional(),
    timeout: z.number().optional(),
    useRoundRobinDns: z.boolean().optional(),
    disableTimeFilter: z.boolean().optional(),
    decodeUrl: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    stopOnEmptyResults: z.boolean().optional(),
    safeHeaders: z.array(z.string()).optional(),
    retryRules: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules$outboundSchema
    ).optional(),
    __scheduling: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling$outboundSchema
    ).optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalse:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalse$outboundSchema.parse(
      restAuthenticationLoginGetAuthTokenFromHeaderFalse,
    ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLogin$inboundSchema: z.ZodType<
  RestAuthenticationLogin,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() =>
    RestAuthenticationLoginGetAuthTokenFromHeaderFalse$inboundSchema
  ),
  z.lazy(() => RestAuthenticationLoginGetAuthTokenFromHeaderTrue$inboundSchema),
]);
/** @internal */
export type RestAuthenticationLogin$Outbound =
  | RestAuthenticationLoginGetAuthTokenFromHeaderFalse$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationLogin$outboundSchema: z.ZodType<
  RestAuthenticationLogin$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLogin
> = z.union([
  z.lazy(() =>
    RestAuthenticationLoginGetAuthTokenFromHeaderFalse$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationLoginGetAuthTokenFromHeaderTrue$outboundSchema
  ),
]);

export function restAuthenticationLoginToJSON(
  restAuthenticationLogin: RestAuthenticationLogin,
): string {
  return JSON.stringify(
    RestAuthenticationLogin$outboundSchema.parse(restAuthenticationLogin),
  );
}
export function restAuthenticationLoginFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationLogin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationLogin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLogin' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretDiscoverType$inboundSchema: z.ZodType<
  RestAuthenticationBasicSecretDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationBasicSecretDiscoverType);
/** @internal */
export const RestAuthenticationBasicSecretDiscoverType$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationBasicSecretDiscoverType> =
    openEnums.outboundSchema(RestAuthenticationBasicSecretDiscoverType);

/** @internal */
export const RestAuthenticationBasicSecretDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationBasicSecretDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestAuthenticationBasicSecretDiscoverType$inboundSchema,
});
/** @internal */
export type RestAuthenticationBasicSecretDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestAuthenticationBasicSecretDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationBasicSecretDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicSecretDiscovery
> = z.object({
  discoverType: RestAuthenticationBasicSecretDiscoverType$outboundSchema,
});

export function restAuthenticationBasicSecretDiscoveryToJSON(
  restAuthenticationBasicSecretDiscovery:
    RestAuthenticationBasicSecretDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretDiscovery$outboundSchema.parse(
      restAuthenticationBasicSecretDiscovery,
    ),
  );
}
export function restAuthenticationBasicSecretDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicSecretDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretCollectMethod$inboundSchema:
  z.ZodType<RestAuthenticationBasicSecretCollectMethod, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(RestAuthenticationBasicSecretCollectMethod);
/** @internal */
export const RestAuthenticationBasicSecretCollectMethod$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationBasicSecretCollectMethod> =
    openEnums.outboundSchema(RestAuthenticationBasicSecretCollectMethod);

/** @internal */
export const RestAuthenticationBasicSecretPaginationEnum$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretPaginationEnum,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RestAuthenticationBasicSecretPaginationEnum);
/** @internal */
export const RestAuthenticationBasicSecretPaginationEnum$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationBasicSecretPaginationEnum> =
    openEnums.outboundSchema(RestAuthenticationBasicSecretPaginationEnum);

/** @internal */
export const RestAuthenticationBasicSecretPagination$inboundSchema: z.ZodType<
  RestAuthenticationBasicSecretPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestAuthenticationBasicSecretPaginationEnum$inboundSchema,
});
/** @internal */
export type RestAuthenticationBasicSecretPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestAuthenticationBasicSecretPagination$outboundSchema: z.ZodType<
  RestAuthenticationBasicSecretPagination$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicSecretPagination
> = z.object({
  type: RestAuthenticationBasicSecretPaginationEnum$outboundSchema,
});

export function restAuthenticationBasicSecretPaginationToJSON(
  restAuthenticationBasicSecretPagination:
    RestAuthenticationBasicSecretPagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretPagination$outboundSchema.parse(
      restAuthenticationBasicSecretPagination,
    ),
  );
}
export function restAuthenticationBasicSecretPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretPagination$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicSecretPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationBasicSecretRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestAuthenticationBasicSecretRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationBasicSecretRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationBasicSecretRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicSecretRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restAuthenticationBasicSecretRetryRulesToJSON(
  restAuthenticationBasicSecretRetryRules:
    RestAuthenticationBasicSecretRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRetryRules$outboundSchema.parse(
      restAuthenticationBasicSecretRetryRules,
    ),
  );
}
export function restAuthenticationBasicSecretRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicSecretRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretStateTracking$inboundSchema:
  z.ZodType<RestAuthenticationBasicSecretStateTracking, z.ZodTypeDef, unknown> =
    z.object({
      enabled: z.boolean().optional(),
    });
/** @internal */
export type RestAuthenticationBasicSecretStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationBasicSecretStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationBasicSecretStateTrackingToJSON(
  restAuthenticationBasicSecretStateTracking:
    RestAuthenticationBasicSecretStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretStateTracking$outboundSchema.parse(
      restAuthenticationBasicSecretStateTracking,
    ),
  );
}
export function restAuthenticationBasicSecretStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicSecretStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretScheduling$inboundSchema: z.ZodType<
  RestAuthenticationBasicSecretScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationBasicSecretStateTracking$inboundSchema
  ).optional(),
});
/** @internal */
export type RestAuthenticationBasicSecretScheduling$Outbound = {
  stateTracking?:
    | RestAuthenticationBasicSecretStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationBasicSecretScheduling$outboundSchema: z.ZodType<
  RestAuthenticationBasicSecretScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicSecretScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationBasicSecretStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationBasicSecretSchedulingToJSON(
  restAuthenticationBasicSecretScheduling:
    RestAuthenticationBasicSecretScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretScheduling$outboundSchema.parse(
      restAuthenticationBasicSecretScheduling,
    ),
  );
}
export function restAuthenticationBasicSecretSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicSecretScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecret$inboundSchema: z.ZodType<
  RestAuthenticationBasicSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("basicSecret"),
  credentialsSecret: z.string(),
  discovery: z.lazy(() => RestAuthenticationBasicSecretDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationBasicSecretCollectMethod$inboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() =>
    RestAuthenticationBasicSecretPagination$inboundSchema
  ).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    RestAuthenticationBasicSecretRetryRules$inboundSchema
  ).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationBasicSecretScheduling$inboundSchema
  ).optional(),
});
/** @internal */
export type RestAuthenticationBasicSecret$Outbound = {
  authentication: "basicSecret";
  credentialsSecret: string;
  discovery?: RestAuthenticationBasicSecretDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestAuthenticationBasicSecretPagination$Outbound | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationBasicSecretRetryRules$Outbound | undefined;
  __scheduling?: RestAuthenticationBasicSecretScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationBasicSecret$outboundSchema: z.ZodType<
  RestAuthenticationBasicSecret$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicSecret
> = z.object({
  authentication: z.literal("basicSecret"),
  credentialsSecret: z.string(),
  discovery: z.lazy(() => RestAuthenticationBasicSecretDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationBasicSecretCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() =>
    RestAuthenticationBasicSecretPagination$outboundSchema
  ).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    RestAuthenticationBasicSecretRetryRules$outboundSchema
  ).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationBasicSecretScheduling$outboundSchema
  ).optional(),
});

export function restAuthenticationBasicSecretToJSON(
  restAuthenticationBasicSecret: RestAuthenticationBasicSecret,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecret$outboundSchema.parse(
      restAuthenticationBasicSecret,
    ),
  );
}
export function restAuthenticationBasicSecretFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationBasicSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecret' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicDiscoverType$inboundSchema: z.ZodType<
  RestAuthenticationBasicDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationBasicDiscoverType);
/** @internal */
export const RestAuthenticationBasicDiscoverType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationBasicDiscoverType
> = openEnums.outboundSchema(RestAuthenticationBasicDiscoverType);

/** @internal */
export const RestAuthenticationBasicDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationBasicDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestAuthenticationBasicDiscoverType$inboundSchema,
});
/** @internal */
export type RestAuthenticationBasicDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestAuthenticationBasicDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationBasicDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicDiscovery
> = z.object({
  discoverType: RestAuthenticationBasicDiscoverType$outboundSchema,
});

export function restAuthenticationBasicDiscoveryToJSON(
  restAuthenticationBasicDiscovery: RestAuthenticationBasicDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationBasicDiscovery$outboundSchema.parse(
      restAuthenticationBasicDiscovery,
    ),
  );
}
export function restAuthenticationBasicDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationBasicDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicCollectMethod$inboundSchema: z.ZodType<
  RestAuthenticationBasicCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationBasicCollectMethod);
/** @internal */
export const RestAuthenticationBasicCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationBasicCollectMethod
> = openEnums.outboundSchema(RestAuthenticationBasicCollectMethod);

/** @internal */
export const RestAuthenticationBasicPaginationEnum$inboundSchema: z.ZodType<
  RestAuthenticationBasicPaginationEnum,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationBasicPaginationEnum);
/** @internal */
export const RestAuthenticationBasicPaginationEnum$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationBasicPaginationEnum
> = openEnums.outboundSchema(RestAuthenticationBasicPaginationEnum);

/** @internal */
export const RestAuthenticationBasicPagination$inboundSchema: z.ZodType<
  RestAuthenticationBasicPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestAuthenticationBasicPaginationEnum$inboundSchema,
});
/** @internal */
export type RestAuthenticationBasicPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestAuthenticationBasicPagination$outboundSchema: z.ZodType<
  RestAuthenticationBasicPagination$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicPagination
> = z.object({
  type: RestAuthenticationBasicPaginationEnum$outboundSchema,
});

export function restAuthenticationBasicPaginationToJSON(
  restAuthenticationBasicPagination: RestAuthenticationBasicPagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicPagination$outboundSchema.parse(
      restAuthenticationBasicPagination,
    ),
  );
}
export function restAuthenticationBasicPaginationFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicPagination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationBasicPagination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationBasicRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestAuthenticationBasicRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationBasicRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationBasicRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restAuthenticationBasicRetryRulesToJSON(
  restAuthenticationBasicRetryRules: RestAuthenticationBasicRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRetryRules$outboundSchema.parse(
      restAuthenticationBasicRetryRules,
    ),
  );
}
export function restAuthenticationBasicRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationBasicRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicStateTracking$inboundSchema: z.ZodType<
  RestAuthenticationBasicStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type RestAuthenticationBasicStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationBasicStateTracking$outboundSchema: z.ZodType<
  RestAuthenticationBasicStateTracking$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restAuthenticationBasicStateTrackingToJSON(
  restAuthenticationBasicStateTracking: RestAuthenticationBasicStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationBasicStateTracking$outboundSchema.parse(
      restAuthenticationBasicStateTracking,
    ),
  );
}
export function restAuthenticationBasicStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicScheduling$inboundSchema: z.ZodType<
  RestAuthenticationBasicScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationBasicStateTracking$inboundSchema
  ).optional(),
});
/** @internal */
export type RestAuthenticationBasicScheduling$Outbound = {
  stateTracking?: RestAuthenticationBasicStateTracking$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationBasicScheduling$outboundSchema: z.ZodType<
  RestAuthenticationBasicScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationBasicStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationBasicSchedulingToJSON(
  restAuthenticationBasicScheduling: RestAuthenticationBasicScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationBasicScheduling$outboundSchema.parse(
      restAuthenticationBasicScheduling,
    ),
  );
}
export function restAuthenticationBasicSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationBasicScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasic$inboundSchema: z.ZodType<
  RestAuthenticationBasic,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("basic"),
  username: z.string(),
  password: z.string(),
  discovery: z.lazy(() => RestAuthenticationBasicDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationBasicCollectMethod$inboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestAuthenticationBasicPagination$inboundSchema)
    .optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestAuthenticationBasicRetryRules$inboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestAuthenticationBasicScheduling$inboundSchema)
    .optional(),
});
/** @internal */
export type RestAuthenticationBasic$Outbound = {
  authentication: "basic";
  username: string;
  password: string;
  discovery?: RestAuthenticationBasicDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestAuthenticationBasicPagination$Outbound | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationBasicRetryRules$Outbound | undefined;
  __scheduling?: RestAuthenticationBasicScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationBasic$outboundSchema: z.ZodType<
  RestAuthenticationBasic$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasic
> = z.object({
  authentication: z.literal("basic"),
  username: z.string(),
  password: z.string(),
  discovery: z.lazy(() => RestAuthenticationBasicDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationBasicCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestAuthenticationBasicPagination$outboundSchema)
    .optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestAuthenticationBasicRetryRules$outboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestAuthenticationBasicScheduling$outboundSchema)
    .optional(),
});

export function restAuthenticationBasicToJSON(
  restAuthenticationBasic: RestAuthenticationBasic,
): string {
  return JSON.stringify(
    RestAuthenticationBasic$outboundSchema.parse(restAuthenticationBasic),
  );
}
export function restAuthenticationBasicFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationBasic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneDiscoverType$inboundSchema: z.ZodType<
  RestAuthenticationNoneDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationNoneDiscoverType);
/** @internal */
export const RestAuthenticationNoneDiscoverType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationNoneDiscoverType
> = openEnums.outboundSchema(RestAuthenticationNoneDiscoverType);

/** @internal */
export const RestAuthenticationNoneDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationNoneDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestAuthenticationNoneDiscoverType$inboundSchema,
});
/** @internal */
export type RestAuthenticationNoneDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestAuthenticationNoneDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationNoneDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNoneDiscovery
> = z.object({
  discoverType: RestAuthenticationNoneDiscoverType$outboundSchema,
});

export function restAuthenticationNoneDiscoveryToJSON(
  restAuthenticationNoneDiscovery: RestAuthenticationNoneDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationNoneDiscovery$outboundSchema.parse(
      restAuthenticationNoneDiscovery,
    ),
  );
}
export function restAuthenticationNoneDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNoneDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationNoneDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneCollectMethod$inboundSchema: z.ZodType<
  RestAuthenticationNoneCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationNoneCollectMethod);
/** @internal */
export const RestAuthenticationNoneCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationNoneCollectMethod
> = openEnums.outboundSchema(RestAuthenticationNoneCollectMethod);

/** @internal */
export const RestAuthenticationNonePaginationEnum$inboundSchema: z.ZodType<
  RestAuthenticationNonePaginationEnum,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationNonePaginationEnum);
/** @internal */
export const RestAuthenticationNonePaginationEnum$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationNonePaginationEnum
> = openEnums.outboundSchema(RestAuthenticationNonePaginationEnum);

/** @internal */
export const RestAuthenticationNonePagination$inboundSchema: z.ZodType<
  RestAuthenticationNonePagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestAuthenticationNonePaginationEnum$inboundSchema,
});
/** @internal */
export type RestAuthenticationNonePagination$Outbound = {
  type: string;
};

/** @internal */
export const RestAuthenticationNonePagination$outboundSchema: z.ZodType<
  RestAuthenticationNonePagination$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNonePagination
> = z.object({
  type: RestAuthenticationNonePaginationEnum$outboundSchema,
});

export function restAuthenticationNonePaginationToJSON(
  restAuthenticationNonePagination: RestAuthenticationNonePagination,
): string {
  return JSON.stringify(
    RestAuthenticationNonePagination$outboundSchema.parse(
      restAuthenticationNonePagination,
    ),
  );
}
export function restAuthenticationNonePaginationFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNonePagination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationNonePagination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNonePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationNoneRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestAuthenticationNoneRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationNoneRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationNoneRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNoneRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restAuthenticationNoneRetryRulesToJSON(
  restAuthenticationNoneRetryRules: RestAuthenticationNoneRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRetryRules$outboundSchema.parse(
      restAuthenticationNoneRetryRules,
    ),
  );
}
export function restAuthenticationNoneRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNoneRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationNoneRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneStateTracking$inboundSchema: z.ZodType<
  RestAuthenticationNoneStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type RestAuthenticationNoneStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationNoneStateTracking$outboundSchema: z.ZodType<
  RestAuthenticationNoneStateTracking$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNoneStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restAuthenticationNoneStateTrackingToJSON(
  restAuthenticationNoneStateTracking: RestAuthenticationNoneStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationNoneStateTracking$outboundSchema.parse(
      restAuthenticationNoneStateTracking,
    ),
  );
}
export function restAuthenticationNoneStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNoneStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneScheduling$inboundSchema: z.ZodType<
  RestAuthenticationNoneScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => RestAuthenticationNoneStateTracking$inboundSchema)
    .optional(),
});
/** @internal */
export type RestAuthenticationNoneScheduling$Outbound = {
  stateTracking?: RestAuthenticationNoneStateTracking$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationNoneScheduling$outboundSchema: z.ZodType<
  RestAuthenticationNoneScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNoneScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationNoneStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationNoneSchedulingToJSON(
  restAuthenticationNoneScheduling: RestAuthenticationNoneScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationNoneScheduling$outboundSchema.parse(
      restAuthenticationNoneScheduling,
    ),
  );
}
export function restAuthenticationNoneSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNoneScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationNoneScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNone$inboundSchema: z.ZodType<
  RestAuthenticationNone,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: z.literal("none"),
  discovery: z.lazy(() => RestAuthenticationNoneDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationNoneCollectMethod$inboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestAuthenticationNonePagination$inboundSchema)
    .optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestAuthenticationNoneRetryRules$inboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestAuthenticationNoneScheduling$inboundSchema)
    .optional(),
});
/** @internal */
export type RestAuthenticationNone$Outbound = {
  authentication: "none";
  discovery?: RestAuthenticationNoneDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestAuthenticationNonePagination$Outbound | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestAuthenticationNoneRetryRules$Outbound | undefined;
  __scheduling?: RestAuthenticationNoneScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationNone$outboundSchema: z.ZodType<
  RestAuthenticationNone$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNone
> = z.object({
  authentication: z.literal("none"),
  discovery: z.lazy(() => RestAuthenticationNoneDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationNoneCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestAuthenticationNonePagination$outboundSchema)
    .optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestAuthenticationNoneRetryRules$outboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestAuthenticationNoneScheduling$outboundSchema)
    .optional(),
});

export function restAuthenticationNoneToJSON(
  restAuthenticationNone: RestAuthenticationNone,
): string {
  return JSON.stringify(
    RestAuthenticationNone$outboundSchema.parse(restAuthenticationNone),
  );
}
export function restAuthenticationNoneFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNone, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationNone$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherCollectMethod$inboundSchema: z.ZodType<
  RestCollectMethodOtherCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodOtherCollectMethod);
/** @internal */
export const RestCollectMethodOtherCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodOtherCollectMethod
> = openEnums.outboundSchema(RestCollectMethodOtherCollectMethod);

/** @internal */
export const RestCollectMethodOtherDiscoverType$inboundSchema: z.ZodType<
  RestCollectMethodOtherDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodOtherDiscoverType);
/** @internal */
export const RestCollectMethodOtherDiscoverType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodOtherDiscoverType
> = openEnums.outboundSchema(RestCollectMethodOtherDiscoverType);

/** @internal */
export const RestCollectMethodOtherDiscovery$inboundSchema: z.ZodType<
  RestCollectMethodOtherDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestCollectMethodOtherDiscoverType$inboundSchema,
});
/** @internal */
export type RestCollectMethodOtherDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestCollectMethodOtherDiscovery$outboundSchema: z.ZodType<
  RestCollectMethodOtherDiscovery$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherDiscovery
> = z.object({
  discoverType: RestCollectMethodOtherDiscoverType$outboundSchema,
});

export function restCollectMethodOtherDiscoveryToJSON(
  restCollectMethodOtherDiscovery: RestCollectMethodOtherDiscovery,
): string {
  return JSON.stringify(
    RestCollectMethodOtherDiscovery$outboundSchema.parse(
      restCollectMethodOtherDiscovery,
    ),
  );
}
export function restCollectMethodOtherDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodOtherDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherDiscovery' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherPaginationEnum$inboundSchema: z.ZodType<
  RestCollectMethodOtherPaginationEnum,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodOtherPaginationEnum);
/** @internal */
export const RestCollectMethodOtherPaginationEnum$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodOtherPaginationEnum
> = openEnums.outboundSchema(RestCollectMethodOtherPaginationEnum);

/** @internal */
export const RestCollectMethodOtherPagination$inboundSchema: z.ZodType<
  RestCollectMethodOtherPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestCollectMethodOtherPaginationEnum$inboundSchema,
});
/** @internal */
export type RestCollectMethodOtherPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestCollectMethodOtherPagination$outboundSchema: z.ZodType<
  RestCollectMethodOtherPagination$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherPagination
> = z.object({
  type: RestCollectMethodOtherPaginationEnum$outboundSchema,
});

export function restCollectMethodOtherPaginationToJSON(
  restCollectMethodOtherPagination: RestCollectMethodOtherPagination,
): string {
  return JSON.stringify(
    RestCollectMethodOtherPagination$outboundSchema.parse(
      restCollectMethodOtherPagination,
    ),
  );
}
export function restCollectMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherPagination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodOtherPagination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherAuthentication$inboundSchema: z.ZodType<
  RestCollectMethodOtherAuthentication,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodOtherAuthentication);
/** @internal */
export const RestCollectMethodOtherAuthentication$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodOtherAuthentication
> = openEnums.outboundSchema(RestCollectMethodOtherAuthentication);

/** @internal */
export const RestCollectMethodOtherRetryRules$inboundSchema: z.ZodType<
  RestCollectMethodOtherRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestCollectMethodOtherRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestCollectMethodOtherRetryRules$outboundSchema: z.ZodType<
  RestCollectMethodOtherRetryRules$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restCollectMethodOtherRetryRulesToJSON(
  restCollectMethodOtherRetryRules: RestCollectMethodOtherRetryRules,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRetryRules$outboundSchema.parse(
      restCollectMethodOtherRetryRules,
    ),
  );
}
export function restCollectMethodOtherRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodOtherRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRetryRules' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherStateTracking$inboundSchema: z.ZodType<
  RestCollectMethodOtherStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type RestCollectMethodOtherStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestCollectMethodOtherStateTracking$outboundSchema: z.ZodType<
  RestCollectMethodOtherStateTracking$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restCollectMethodOtherStateTrackingToJSON(
  restCollectMethodOtherStateTracking: RestCollectMethodOtherStateTracking,
): string {
  return JSON.stringify(
    RestCollectMethodOtherStateTracking$outboundSchema.parse(
      restCollectMethodOtherStateTracking,
    ),
  );
}
export function restCollectMethodOtherStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherStateTracking' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherScheduling$inboundSchema: z.ZodType<
  RestCollectMethodOtherScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => RestCollectMethodOtherStateTracking$inboundSchema)
    .optional(),
});
/** @internal */
export type RestCollectMethodOtherScheduling$Outbound = {
  stateTracking?: RestCollectMethodOtherStateTracking$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodOtherScheduling$outboundSchema: z.ZodType<
  RestCollectMethodOtherScheduling$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestCollectMethodOtherStateTracking$outboundSchema
  ).optional(),
});

export function restCollectMethodOtherSchedulingToJSON(
  restCollectMethodOtherScheduling: RestCollectMethodOtherScheduling,
): string {
  return JSON.stringify(
    RestCollectMethodOtherScheduling$outboundSchema.parse(
      restCollectMethodOtherScheduling,
    ),
  );
}
export function restCollectMethodOtherSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodOtherScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherScheduling' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOther$inboundSchema: z.ZodType<
  RestCollectMethodOther,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: RestCollectMethodOtherCollectMethod$inboundSchema,
  collectVerb: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestParams: z.any().optional(),
  discovery: z.lazy(() => RestCollectMethodOtherDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestCollectMethodOtherPagination$inboundSchema)
    .optional(),
  authentication: RestCollectMethodOtherAuthentication$inboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestCollectMethodOtherRetryRules$inboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestCollectMethodOtherScheduling$inboundSchema)
    .optional(),
});
/** @internal */
export type RestCollectMethodOther$Outbound = {
  collectMethod: string;
  collectVerb?: any | undefined;
  collectBody?: any | undefined;
  collectRequestParams?: any | undefined;
  discovery?: RestCollectMethodOtherDiscovery$Outbound | undefined;
  collectUrl: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestCollectMethodOtherPagination$Outbound | undefined;
  authentication: string;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestCollectMethodOtherRetryRules$Outbound | undefined;
  __scheduling?: RestCollectMethodOtherScheduling$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodOther$outboundSchema: z.ZodType<
  RestCollectMethodOther$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOther
> = z.object({
  collectMethod: RestCollectMethodOtherCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestParams: z.any().optional(),
  discovery: z.lazy(() => RestCollectMethodOtherDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestCollectMethodOtherPagination$outboundSchema)
    .optional(),
  authentication: RestCollectMethodOtherAuthentication$outboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestCollectMethodOtherRetryRules$outboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestCollectMethodOtherScheduling$outboundSchema)
    .optional(),
});

export function restCollectMethodOtherToJSON(
  restCollectMethodOther: RestCollectMethodOther,
): string {
  return JSON.stringify(
    RestCollectMethodOther$outboundSchema.parse(restCollectMethodOther),
  );
}
export function restCollectMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOther, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodOther$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOther' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyCollectMethod$inboundSchema:
  z.ZodType<RestCollectMethodPostWithBodyCollectMethod, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(RestCollectMethodPostWithBodyCollectMethod);
/** @internal */
export const RestCollectMethodPostWithBodyCollectMethod$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestCollectMethodPostWithBodyCollectMethod> =
    openEnums.outboundSchema(RestCollectMethodPostWithBodyCollectMethod);

/** @internal */
export const RestCollectMethodPostWithBodyDiscoverType$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodPostWithBodyDiscoverType);
/** @internal */
export const RestCollectMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestCollectMethodPostWithBodyDiscoverType> =
    openEnums.outboundSchema(RestCollectMethodPostWithBodyDiscoverType);

/** @internal */
export const RestCollectMethodPostWithBodyDiscovery$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestCollectMethodPostWithBodyDiscoverType$inboundSchema,
});
/** @internal */
export type RestCollectMethodPostWithBodyDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestCollectMethodPostWithBodyDiscovery$outboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyDiscovery$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostWithBodyDiscovery
> = z.object({
  discoverType: RestCollectMethodPostWithBodyDiscoverType$outboundSchema,
});

export function restCollectMethodPostWithBodyDiscoveryToJSON(
  restCollectMethodPostWithBodyDiscovery:
    RestCollectMethodPostWithBodyDiscovery,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyDiscovery$outboundSchema.parse(
      restCollectMethodPostWithBodyDiscovery,
    ),
  );
}
export function restCollectMethodPostWithBodyDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostWithBodyDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyDiscovery' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyPaginationEnum$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyPaginationEnum,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RestCollectMethodPostWithBodyPaginationEnum);
/** @internal */
export const RestCollectMethodPostWithBodyPaginationEnum$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestCollectMethodPostWithBodyPaginationEnum> =
    openEnums.outboundSchema(RestCollectMethodPostWithBodyPaginationEnum);

/** @internal */
export const RestCollectMethodPostWithBodyPagination$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestCollectMethodPostWithBodyPaginationEnum$inboundSchema,
});
/** @internal */
export type RestCollectMethodPostWithBodyPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestCollectMethodPostWithBodyPagination$outboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyPagination$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostWithBodyPagination
> = z.object({
  type: RestCollectMethodPostWithBodyPaginationEnum$outboundSchema,
});

export function restCollectMethodPostWithBodyPaginationToJSON(
  restCollectMethodPostWithBodyPagination:
    RestCollectMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyPagination$outboundSchema.parse(
      restCollectMethodPostWithBodyPagination,
    ),
  );
}
export function restCollectMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyPagination$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyAuthentication$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyAuthentication,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RestCollectMethodPostWithBodyAuthentication);
/** @internal */
export const RestCollectMethodPostWithBodyAuthentication$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestCollectMethodPostWithBodyAuthentication> =
    openEnums.outboundSchema(RestCollectMethodPostWithBodyAuthentication);

/** @internal */
export const RestCollectMethodPostWithBodyRetryRules$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestCollectMethodPostWithBodyRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestCollectMethodPostWithBodyRetryRules$outboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyRetryRules$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostWithBodyRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restCollectMethodPostWithBodyRetryRulesToJSON(
  restCollectMethodPostWithBodyRetryRules:
    RestCollectMethodPostWithBodyRetryRules,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRetryRules$outboundSchema.parse(
      restCollectMethodPostWithBodyRetryRules,
    ),
  );
}
export function restCollectMethodPostWithBodyRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyRetryRules' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyStateTracking$inboundSchema:
  z.ZodType<RestCollectMethodPostWithBodyStateTracking, z.ZodTypeDef, unknown> =
    z.object({
      enabled: z.boolean().optional(),
    });
/** @internal */
export type RestCollectMethodPostWithBodyStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestCollectMethodPostWithBodyStateTracking$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyStateTracking$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyStateTrackingToJSON(
  restCollectMethodPostWithBodyStateTracking:
    RestCollectMethodPostWithBodyStateTracking,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyStateTracking$outboundSchema.parse(
      restCollectMethodPostWithBodyStateTracking,
    ),
  );
}
export function restCollectMethodPostWithBodyStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyStateTracking' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyScheduling$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() =>
    RestCollectMethodPostWithBodyStateTracking$inboundSchema
  ).optional(),
});
/** @internal */
export type RestCollectMethodPostWithBodyScheduling$Outbound = {
  stateTracking?:
    | RestCollectMethodPostWithBodyStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestCollectMethodPostWithBodyScheduling$outboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyScheduling$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostWithBodyScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestCollectMethodPostWithBodyStateTracking$outboundSchema
  ).optional(),
});

export function restCollectMethodPostWithBodySchedulingToJSON(
  restCollectMethodPostWithBodyScheduling:
    RestCollectMethodPostWithBodyScheduling,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyScheduling$outboundSchema.parse(
      restCollectMethodPostWithBodyScheduling,
    ),
  );
}
export function restCollectMethodPostWithBodySchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyScheduling' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBody$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: RestCollectMethodPostWithBodyCollectMethod$inboundSchema,
  collectBody: z.any().optional(),
  discovery: z.lazy(() => RestCollectMethodPostWithBodyDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() =>
    RestCollectMethodPostWithBodyPagination$inboundSchema
  ).optional(),
  authentication: RestCollectMethodPostWithBodyAuthentication$inboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    RestCollectMethodPostWithBodyRetryRules$inboundSchema
  ).optional(),
  __scheduling: z.lazy(() =>
    RestCollectMethodPostWithBodyScheduling$inboundSchema
  ).optional(),
});
/** @internal */
export type RestCollectMethodPostWithBody$Outbound = {
  collectMethod: string;
  collectBody?: any | undefined;
  discovery?: RestCollectMethodPostWithBodyDiscovery$Outbound | undefined;
  collectUrl: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestCollectMethodPostWithBodyPagination$Outbound | undefined;
  authentication: string;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestCollectMethodPostWithBodyRetryRules$Outbound | undefined;
  __scheduling?: RestCollectMethodPostWithBodyScheduling$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodPostWithBody$outboundSchema: z.ZodType<
  RestCollectMethodPostWithBody$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostWithBody
> = z.object({
  collectMethod: RestCollectMethodPostWithBodyCollectMethod$outboundSchema,
  collectBody: z.any().optional(),
  discovery: z.lazy(() => RestCollectMethodPostWithBodyDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() =>
    RestCollectMethodPostWithBodyPagination$outboundSchema
  ).optional(),
  authentication: RestCollectMethodPostWithBodyAuthentication$outboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() =>
    RestCollectMethodPostWithBodyRetryRules$outboundSchema
  ).optional(),
  __scheduling: z.lazy(() =>
    RestCollectMethodPostWithBodyScheduling$outboundSchema
  ).optional(),
});

export function restCollectMethodPostWithBodyToJSON(
  restCollectMethodPostWithBody: RestCollectMethodPostWithBody,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBody$outboundSchema.parse(
      restCollectMethodPostWithBody,
    ),
  );
}
export function restCollectMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostWithBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPostWithBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostCollectMethod$inboundSchema: z.ZodType<
  RestCollectMethodPostCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodPostCollectMethod);
/** @internal */
export const RestCollectMethodPostCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodPostCollectMethod
> = openEnums.outboundSchema(RestCollectMethodPostCollectMethod);

/** @internal */
export const RestCollectMethodPostDiscoverType$inboundSchema: z.ZodType<
  RestCollectMethodPostDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodPostDiscoverType);
/** @internal */
export const RestCollectMethodPostDiscoverType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodPostDiscoverType
> = openEnums.outboundSchema(RestCollectMethodPostDiscoverType);

/** @internal */
export const RestCollectMethodPostDiscovery$inboundSchema: z.ZodType<
  RestCollectMethodPostDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestCollectMethodPostDiscoverType$inboundSchema,
});
/** @internal */
export type RestCollectMethodPostDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestCollectMethodPostDiscovery$outboundSchema: z.ZodType<
  RestCollectMethodPostDiscovery$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostDiscovery
> = z.object({
  discoverType: RestCollectMethodPostDiscoverType$outboundSchema,
});

export function restCollectMethodPostDiscoveryToJSON(
  restCollectMethodPostDiscovery: RestCollectMethodPostDiscovery,
): string {
  return JSON.stringify(
    RestCollectMethodPostDiscovery$outboundSchema.parse(
      restCollectMethodPostDiscovery,
    ),
  );
}
export function restCollectMethodPostDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPostDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostDiscovery' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostPaginationEnum$inboundSchema: z.ZodType<
  RestCollectMethodPostPaginationEnum,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodPostPaginationEnum);
/** @internal */
export const RestCollectMethodPostPaginationEnum$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodPostPaginationEnum
> = openEnums.outboundSchema(RestCollectMethodPostPaginationEnum);

/** @internal */
export const RestCollectMethodPostPagination$inboundSchema: z.ZodType<
  RestCollectMethodPostPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestCollectMethodPostPaginationEnum$inboundSchema,
});
/** @internal */
export type RestCollectMethodPostPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestCollectMethodPostPagination$outboundSchema: z.ZodType<
  RestCollectMethodPostPagination$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostPagination
> = z.object({
  type: RestCollectMethodPostPaginationEnum$outboundSchema,
});

export function restCollectMethodPostPaginationToJSON(
  restCollectMethodPostPagination: RestCollectMethodPostPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostPagination$outboundSchema.parse(
      restCollectMethodPostPagination,
    ),
  );
}
export function restCollectMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostPagination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPostPagination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostAuthentication$inboundSchema: z.ZodType<
  RestCollectMethodPostAuthentication,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodPostAuthentication);
/** @internal */
export const RestCollectMethodPostAuthentication$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodPostAuthentication
> = openEnums.outboundSchema(RestCollectMethodPostAuthentication);

/** @internal */
export const RestCollectMethodPostRetryRules$inboundSchema: z.ZodType<
  RestCollectMethodPostRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestCollectMethodPostRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestCollectMethodPostRetryRules$outboundSchema: z.ZodType<
  RestCollectMethodPostRetryRules$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restCollectMethodPostRetryRulesToJSON(
  restCollectMethodPostRetryRules: RestCollectMethodPostRetryRules,
): string {
  return JSON.stringify(
    RestCollectMethodPostRetryRules$outboundSchema.parse(
      restCollectMethodPostRetryRules,
    ),
  );
}
export function restCollectMethodPostRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPostRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRetryRules' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostStateTracking$inboundSchema: z.ZodType<
  RestCollectMethodPostStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type RestCollectMethodPostStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestCollectMethodPostStateTracking$outboundSchema: z.ZodType<
  RestCollectMethodPostStateTracking$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restCollectMethodPostStateTrackingToJSON(
  restCollectMethodPostStateTracking: RestCollectMethodPostStateTracking,
): string {
  return JSON.stringify(
    RestCollectMethodPostStateTracking$outboundSchema.parse(
      restCollectMethodPostStateTracking,
    ),
  );
}
export function restCollectMethodPostStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostStateTracking' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostScheduling$inboundSchema: z.ZodType<
  RestCollectMethodPostScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => RestCollectMethodPostStateTracking$inboundSchema)
    .optional(),
});
/** @internal */
export type RestCollectMethodPostScheduling$Outbound = {
  stateTracking?: RestCollectMethodPostStateTracking$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodPostScheduling$outboundSchema: z.ZodType<
  RestCollectMethodPostScheduling$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostScheduling
> = z.object({
  stateTracking: z.lazy(() => RestCollectMethodPostStateTracking$outboundSchema)
    .optional(),
});

export function restCollectMethodPostSchedulingToJSON(
  restCollectMethodPostScheduling: RestCollectMethodPostScheduling,
): string {
  return JSON.stringify(
    RestCollectMethodPostScheduling$outboundSchema.parse(
      restCollectMethodPostScheduling,
    ),
  );
}
export function restCollectMethodPostSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPostScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostScheduling' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPost$inboundSchema: z.ZodType<
  RestCollectMethodPost,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: RestCollectMethodPostCollectMethod$inboundSchema,
  collectRequestParams: z.any().optional(),
  discovery: z.lazy(() => RestCollectMethodPostDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectVerb: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestCollectMethodPostPagination$inboundSchema)
    .optional(),
  authentication: RestCollectMethodPostAuthentication$inboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestCollectMethodPostRetryRules$inboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestCollectMethodPostScheduling$inboundSchema)
    .optional(),
});
/** @internal */
export type RestCollectMethodPost$Outbound = {
  collectMethod: string;
  collectRequestParams?: any | undefined;
  discovery?: RestCollectMethodPostDiscovery$Outbound | undefined;
  collectUrl: string;
  collectVerb?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestCollectMethodPostPagination$Outbound | undefined;
  authentication: string;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestCollectMethodPostRetryRules$Outbound | undefined;
  __scheduling?: RestCollectMethodPostScheduling$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodPost$outboundSchema: z.ZodType<
  RestCollectMethodPost$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPost
> = z.object({
  collectMethod: RestCollectMethodPostCollectMethod$outboundSchema,
  collectRequestParams: z.any().optional(),
  discovery: z.lazy(() => RestCollectMethodPostDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectVerb: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestCollectMethodPostPagination$outboundSchema)
    .optional(),
  authentication: RestCollectMethodPostAuthentication$outboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestCollectMethodPostRetryRules$outboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestCollectMethodPostScheduling$outboundSchema)
    .optional(),
});

export function restCollectMethodPostToJSON(
  restCollectMethodPost: RestCollectMethodPost,
): string {
  return JSON.stringify(
    RestCollectMethodPost$outboundSchema.parse(restCollectMethodPost),
  );
}
export function restCollectMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPost, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPost$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPost' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetCollectMethod$inboundSchema: z.ZodType<
  RestCollectMethodGetCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodGetCollectMethod);
/** @internal */
export const RestCollectMethodGetCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodGetCollectMethod
> = openEnums.outboundSchema(RestCollectMethodGetCollectMethod);

/** @internal */
export const RestCollectMethodGetDiscoverType$inboundSchema: z.ZodType<
  RestCollectMethodGetDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodGetDiscoverType);
/** @internal */
export const RestCollectMethodGetDiscoverType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodGetDiscoverType
> = openEnums.outboundSchema(RestCollectMethodGetDiscoverType);

/** @internal */
export const RestCollectMethodGetDiscovery$inboundSchema: z.ZodType<
  RestCollectMethodGetDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestCollectMethodGetDiscoverType$inboundSchema,
});
/** @internal */
export type RestCollectMethodGetDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestCollectMethodGetDiscovery$outboundSchema: z.ZodType<
  RestCollectMethodGetDiscovery$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetDiscovery
> = z.object({
  discoverType: RestCollectMethodGetDiscoverType$outboundSchema,
});

export function restCollectMethodGetDiscoveryToJSON(
  restCollectMethodGetDiscovery: RestCollectMethodGetDiscovery,
): string {
  return JSON.stringify(
    RestCollectMethodGetDiscovery$outboundSchema.parse(
      restCollectMethodGetDiscovery,
    ),
  );
}
export function restCollectMethodGetDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGetDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetDiscovery' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetPaginationEnum$inboundSchema: z.ZodType<
  RestCollectMethodGetPaginationEnum,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodGetPaginationEnum);
/** @internal */
export const RestCollectMethodGetPaginationEnum$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodGetPaginationEnum
> = openEnums.outboundSchema(RestCollectMethodGetPaginationEnum);

/** @internal */
export const RestCollectMethodGetPagination$inboundSchema: z.ZodType<
  RestCollectMethodGetPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestCollectMethodGetPaginationEnum$inboundSchema,
});
/** @internal */
export type RestCollectMethodGetPagination$Outbound = {
  type: string;
};

/** @internal */
export const RestCollectMethodGetPagination$outboundSchema: z.ZodType<
  RestCollectMethodGetPagination$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetPagination
> = z.object({
  type: RestCollectMethodGetPaginationEnum$outboundSchema,
});

export function restCollectMethodGetPaginationToJSON(
  restCollectMethodGetPagination: RestCollectMethodGetPagination,
): string {
  return JSON.stringify(
    RestCollectMethodGetPagination$outboundSchema.parse(
      restCollectMethodGetPagination,
    ),
  );
}
export function restCollectMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetPagination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGetPagination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetAuthentication$inboundSchema: z.ZodType<
  RestCollectMethodGetAuthentication,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodGetAuthentication);
/** @internal */
export const RestCollectMethodGetAuthentication$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodGetAuthentication
> = openEnums.outboundSchema(RestCollectMethodGetAuthentication);

/** @internal */
export const RestCollectMethodGetRetryRules$inboundSchema: z.ZodType<
  RestCollectMethodGetRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$inboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestCollectMethodGetRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestCollectMethodGetRetryRules$outboundSchema: z.ZodType<
  RestCollectMethodGetRetryRules$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetRetryRules
> = z.object({
  type: RetryTypeOptionsHealthCheckCollectorConfRetryRules$outboundSchema,
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restCollectMethodGetRetryRulesToJSON(
  restCollectMethodGetRetryRules: RestCollectMethodGetRetryRules,
): string {
  return JSON.stringify(
    RestCollectMethodGetRetryRules$outboundSchema.parse(
      restCollectMethodGetRetryRules,
    ),
  );
}
export function restCollectMethodGetRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGetRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRetryRules' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetStateTracking$inboundSchema: z.ZodType<
  RestCollectMethodGetStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type RestCollectMethodGetStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestCollectMethodGetStateTracking$outboundSchema: z.ZodType<
  RestCollectMethodGetStateTracking$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restCollectMethodGetStateTrackingToJSON(
  restCollectMethodGetStateTracking: RestCollectMethodGetStateTracking,
): string {
  return JSON.stringify(
    RestCollectMethodGetStateTracking$outboundSchema.parse(
      restCollectMethodGetStateTracking,
    ),
  );
}
export function restCollectMethodGetStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGetStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetStateTracking' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetScheduling$inboundSchema: z.ZodType<
  RestCollectMethodGetScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => RestCollectMethodGetStateTracking$inboundSchema)
    .optional(),
});
/** @internal */
export type RestCollectMethodGetScheduling$Outbound = {
  stateTracking?: RestCollectMethodGetStateTracking$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodGetScheduling$outboundSchema: z.ZodType<
  RestCollectMethodGetScheduling$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetScheduling
> = z.object({
  stateTracking: z.lazy(() => RestCollectMethodGetStateTracking$outboundSchema)
    .optional(),
});

export function restCollectMethodGetSchedulingToJSON(
  restCollectMethodGetScheduling: RestCollectMethodGetScheduling,
): string {
  return JSON.stringify(
    RestCollectMethodGetScheduling$outboundSchema.parse(
      restCollectMethodGetScheduling,
    ),
  );
}
export function restCollectMethodGetSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGetScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetScheduling' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGet$inboundSchema: z.ZodType<
  RestCollectMethodGet,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: RestCollectMethodGetCollectMethod$inboundSchema,
  collectRequestParams: z.any().optional(),
  discovery: z.lazy(() => RestCollectMethodGetDiscovery$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectVerb: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestCollectMethodGetPagination$inboundSchema)
    .optional(),
  authentication: RestCollectMethodGetAuthentication$inboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestCollectMethodGetRetryRules$inboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestCollectMethodGetScheduling$inboundSchema)
    .optional(),
});
/** @internal */
export type RestCollectMethodGet$Outbound = {
  collectMethod: string;
  collectRequestParams?: any | undefined;
  discovery?: RestCollectMethodGetDiscovery$Outbound | undefined;
  collectUrl: string;
  collectVerb?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?: RestCollectMethodGetPagination$Outbound | undefined;
  authentication: string;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestCollectMethodGetRetryRules$Outbound | undefined;
  __scheduling?: RestCollectMethodGetScheduling$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodGet$outboundSchema: z.ZodType<
  RestCollectMethodGet$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGet
> = z.object({
  collectMethod: RestCollectMethodGetCollectMethod$outboundSchema,
  collectRequestParams: z.any().optional(),
  discovery: z.lazy(() => RestCollectMethodGetDiscovery$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectVerb: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.lazy(() => RestCollectMethodGetPagination$outboundSchema)
    .optional(),
  authentication: RestCollectMethodGetAuthentication$outboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestCollectMethodGetRetryRules$outboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestCollectMethodGetScheduling$outboundSchema)
    .optional(),
});

export function restCollectMethodGetToJSON(
  restCollectMethodGet: RestCollectMethodGet,
): string {
  return JSON.stringify(
    RestCollectMethodGet$outboundSchema.parse(restCollectMethodGet),
  );
}
export function restCollectMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGet, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGet$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGet' from JSON`,
  );
}

/** @internal */
export const RestCollectorConf$inboundSchema: z.ZodType<
  RestCollectorConf,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => RestAuthenticationNone$inboundSchema),
  z.lazy(() => RestAuthenticationBasic$inboundSchema),
  z.lazy(() => RestAuthenticationBasicSecret$inboundSchema),
  z.union([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ authentication: z.literal("login") })),
  z.union([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ authentication: z.literal("loginSecret") })),
  z.lazy(() => RestAuthenticationOauth$inboundSchema),
  z.lazy(() => RestAuthenticationOauthSecret$inboundSchema),
  z.lazy(() => RestAuthenticationGoogleOauth$inboundSchema),
  z.lazy(() => RestAuthenticationGoogleOauthSecret$inboundSchema),
  z.lazy(() => RestAuthenticationHmac$inboundSchema),
]);
/** @internal */
export type RestCollectorConf$Outbound =
  | RestAuthenticationNone$Outbound
  | RestAuthenticationBasic$Outbound
  | RestAuthenticationBasicSecret$Outbound
  | (
    | RestAuthenticationLoginGetAuthTokenFromHeaderFalse$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrue$Outbound & {
      authentication: "login";
    }
  )
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$Outbound & {
      authentication: "loginSecret";
    }
  )
  | RestAuthenticationOauth$Outbound
  | RestAuthenticationOauthSecret$Outbound
  | RestAuthenticationGoogleOauth$Outbound
  | RestAuthenticationGoogleOauthSecret$Outbound
  | RestAuthenticationHmac$Outbound;

/** @internal */
export const RestCollectorConf$outboundSchema: z.ZodType<
  RestCollectorConf$Outbound,
  z.ZodTypeDef,
  RestCollectorConf
> = z.union([
  z.lazy(() => RestAuthenticationNone$outboundSchema),
  z.lazy(() => RestAuthenticationBasic$outboundSchema),
  z.lazy(() => RestAuthenticationBasicSecret$outboundSchema),
  z.union([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ authentication: z.literal("login") })),
  z.union([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ authentication: z.literal("loginSecret") })),
  z.lazy(() => RestAuthenticationOauth$outboundSchema),
  z.lazy(() => RestAuthenticationOauthSecret$outboundSchema),
  z.lazy(() => RestAuthenticationGoogleOauth$outboundSchema),
  z.lazy(() => RestAuthenticationGoogleOauthSecret$outboundSchema),
  z.lazy(() => RestAuthenticationHmac$outboundSchema),
]);

export function restCollectorConfToJSON(
  restCollectorConf: RestCollectorConf,
): string {
  return JSON.stringify(
    RestCollectorConf$outboundSchema.parse(restCollectorConf),
  );
}
export function restCollectorConfFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectorConf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectorConf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectorConf' from JSON`,
  );
}
