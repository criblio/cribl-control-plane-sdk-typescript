/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectorConfDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectorConfDiscoverType = OpenEnum<
  typeof RestCollectorConfDiscoverType
>;

export type RestCollectorConfDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType?: RestCollectorConfDiscoverType | undefined;
};

export const CollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type CollectMethod = OpenEnum<typeof CollectMethod>;

export type RestCollectorConfCollectRequestHeader = {
  name: string;
  /**
   * JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants.
   */
  value: string;
};

export const PaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type PaginationEnum = OpenEnum<typeof PaginationEnum>;

export type Pagination = {
  type?: PaginationEnum | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const RestCollectorConfAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type RestCollectorConfAuthentication = OpenEnum<
  typeof RestCollectorConfAuthentication
>;

/**
 * Algorithm to use when performing HTTP retries
 */
export const RestCollectorConfRetryType = {
  /**
   * Disabled
   */
  None: "none",
  /**
   * Backoff
   */
  Backoff: "backoff",
  /**
   * Static
   */
  Static: "static",
} as const;
/**
 * Algorithm to use when performing HTTP retries
 */
export type RestCollectorConfRetryType = OpenEnum<
  typeof RestCollectorConfRetryType
>;

export type RestCollectorConfRetryRules = {
  /**
   * Algorithm to use when performing HTTP retries
   */
  type?: RestCollectorConfRetryType | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectorConfStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestCollectorConfScheduling = {
  stateTracking?: RestCollectorConfStateTracking | undefined;
};

export type RestCollectorConf = {
  discovery?: RestCollectorConfDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod?: CollectMethod | undefined;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<RestCollectorConfCollectRequestHeader>
    | undefined;
  pagination?: Pagination | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: RestCollectorConfAuthentication | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestCollectorConfRetryRules | undefined;
  scheduling?: RestCollectorConfScheduling | undefined;
};

/** @internal */
export const RestCollectorConfDiscoverType$inboundSchema: z.ZodType<
  RestCollectorConfDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectorConfDiscoverType);
/** @internal */
export const RestCollectorConfDiscoverType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectorConfDiscoverType
> = openEnums.outboundSchema(RestCollectorConfDiscoverType);

/** @internal */
export const RestCollectorConfDiscovery$inboundSchema: z.ZodType<
  RestCollectorConfDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: RestCollectorConfDiscoverType$inboundSchema.default("none"),
});
/** @internal */
export type RestCollectorConfDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const RestCollectorConfDiscovery$outboundSchema: z.ZodType<
  RestCollectorConfDiscovery$Outbound,
  z.ZodTypeDef,
  RestCollectorConfDiscovery
> = z.object({
  discoverType: RestCollectorConfDiscoverType$outboundSchema.default("none"),
});

export function restCollectorConfDiscoveryToJSON(
  restCollectorConfDiscovery: RestCollectorConfDiscovery,
): string {
  return JSON.stringify(
    RestCollectorConfDiscovery$outboundSchema.parse(restCollectorConfDiscovery),
  );
}
export function restCollectorConfDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectorConfDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectorConfDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectorConfDiscovery' from JSON`,
  );
}

/** @internal */
export const CollectMethod$inboundSchema: z.ZodType<
  CollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectMethod);
/** @internal */
export const CollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectMethod
> = openEnums.outboundSchema(CollectMethod);

/** @internal */
export const RestCollectorConfCollectRequestHeader$inboundSchema: z.ZodType<
  RestCollectorConfCollectRequestHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type RestCollectorConfCollectRequestHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const RestCollectorConfCollectRequestHeader$outboundSchema: z.ZodType<
  RestCollectorConfCollectRequestHeader$Outbound,
  z.ZodTypeDef,
  RestCollectorConfCollectRequestHeader
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function restCollectorConfCollectRequestHeaderToJSON(
  restCollectorConfCollectRequestHeader: RestCollectorConfCollectRequestHeader,
): string {
  return JSON.stringify(
    RestCollectorConfCollectRequestHeader$outboundSchema.parse(
      restCollectorConfCollectRequestHeader,
    ),
  );
}
export function restCollectorConfCollectRequestHeaderFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectorConfCollectRequestHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectorConfCollectRequestHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectorConfCollectRequestHeader' from JSON`,
  );
}

/** @internal */
export const PaginationEnum$inboundSchema: z.ZodType<
  PaginationEnum,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(PaginationEnum);
/** @internal */
export const PaginationEnum$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  PaginationEnum
> = openEnums.outboundSchema(PaginationEnum);

/** @internal */
export const Pagination$inboundSchema: z.ZodType<
  Pagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: PaginationEnum$inboundSchema.default("none"),
});
/** @internal */
export type Pagination$Outbound = {
  type: string;
};

/** @internal */
export const Pagination$outboundSchema: z.ZodType<
  Pagination$Outbound,
  z.ZodTypeDef,
  Pagination
> = z.object({
  type: PaginationEnum$outboundSchema.default("none"),
});

export function paginationToJSON(pagination: Pagination): string {
  return JSON.stringify(Pagination$outboundSchema.parse(pagination));
}
export function paginationFromJSON(
  jsonString: string,
): SafeParseResult<Pagination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Pagination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Pagination' from JSON`,
  );
}

/** @internal */
export const RestCollectorConfAuthentication$inboundSchema: z.ZodType<
  RestCollectorConfAuthentication,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectorConfAuthentication);
/** @internal */
export const RestCollectorConfAuthentication$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectorConfAuthentication
> = openEnums.outboundSchema(RestCollectorConfAuthentication);

/** @internal */
export const RestCollectorConfRetryType$inboundSchema: z.ZodType<
  RestCollectorConfRetryType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectorConfRetryType);
/** @internal */
export const RestCollectorConfRetryType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectorConfRetryType
> = openEnums.outboundSchema(RestCollectorConfRetryType);

/** @internal */
export const RestCollectorConfRetryRules$inboundSchema: z.ZodType<
  RestCollectorConfRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RestCollectorConfRetryType$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RestCollectorConfRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestCollectorConfRetryRules$outboundSchema: z.ZodType<
  RestCollectorConfRetryRules$Outbound,
  z.ZodTypeDef,
  RestCollectorConfRetryRules
> = z.object({
  type: RestCollectorConfRetryType$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function restCollectorConfRetryRulesToJSON(
  restCollectorConfRetryRules: RestCollectorConfRetryRules,
): string {
  return JSON.stringify(
    RestCollectorConfRetryRules$outboundSchema.parse(
      restCollectorConfRetryRules,
    ),
  );
}
export function restCollectorConfRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectorConfRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectorConfRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectorConfRetryRules' from JSON`,
  );
}

/** @internal */
export const RestCollectorConfStateTracking$inboundSchema: z.ZodType<
  RestCollectorConfStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type RestCollectorConfStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestCollectorConfStateTracking$outboundSchema: z.ZodType<
  RestCollectorConfStateTracking$Outbound,
  z.ZodTypeDef,
  RestCollectorConfStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restCollectorConfStateTrackingToJSON(
  restCollectorConfStateTracking: RestCollectorConfStateTracking,
): string {
  return JSON.stringify(
    RestCollectorConfStateTracking$outboundSchema.parse(
      restCollectorConfStateTracking,
    ),
  );
}
export function restCollectorConfStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectorConfStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectorConfStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectorConfStateTracking' from JSON`,
  );
}

/** @internal */
export const RestCollectorConfScheduling$inboundSchema: z.ZodType<
  RestCollectorConfScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => RestCollectorConfStateTracking$inboundSchema)
    .optional(),
});
/** @internal */
export type RestCollectorConfScheduling$Outbound = {
  stateTracking?: RestCollectorConfStateTracking$Outbound | undefined;
};

/** @internal */
export const RestCollectorConfScheduling$outboundSchema: z.ZodType<
  RestCollectorConfScheduling$Outbound,
  z.ZodTypeDef,
  RestCollectorConfScheduling
> = z.object({
  stateTracking: z.lazy(() => RestCollectorConfStateTracking$outboundSchema)
    .optional(),
});

export function restCollectorConfSchedulingToJSON(
  restCollectorConfScheduling: RestCollectorConfScheduling,
): string {
  return JSON.stringify(
    RestCollectorConfScheduling$outboundSchema.parse(
      restCollectorConfScheduling,
    ),
  );
}
export function restCollectorConfSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectorConfScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectorConfScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectorConfScheduling' from JSON`,
  );
}

/** @internal */
export const RestCollectorConf$inboundSchema: z.ZodType<
  RestCollectorConf,
  z.ZodTypeDef,
  unknown
> = z.object({
  discovery: z.lazy(() => RestCollectorConfDiscovery$inboundSchema).optional(),
  collectUrl: z.string(),
  collectMethod: CollectMethod$inboundSchema.default("get"),
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() => RestCollectorConfCollectRequestHeader$inboundSchema),
  ).optional(),
  pagination: z.lazy(() => Pagination$inboundSchema).optional(),
  authentication: RestCollectorConfAuthentication$inboundSchema.default("none"),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestCollectorConfRetryRules$inboundSchema)
    .optional(),
  __scheduling: z.lazy(() => RestCollectorConfScheduling$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "__scheduling": "scheduling",
  });
});
/** @internal */
export type RestCollectorConf$Outbound = {
  discovery?: RestCollectorConfDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<RestCollectorConfCollectRequestHeader$Outbound>
    | undefined;
  pagination?: Pagination$Outbound | undefined;
  authentication: string;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  decodeUrl: boolean;
  rejectUnauthorized: boolean;
  captureHeaders: boolean;
  stopOnEmptyResults: boolean;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RestCollectorConfRetryRules$Outbound | undefined;
  __scheduling?: RestCollectorConfScheduling$Outbound | undefined;
};

/** @internal */
export const RestCollectorConf$outboundSchema: z.ZodType<
  RestCollectorConf$Outbound,
  z.ZodTypeDef,
  RestCollectorConf
> = z.object({
  discovery: z.lazy(() => RestCollectorConfDiscovery$outboundSchema).optional(),
  collectUrl: z.string(),
  collectMethod: CollectMethod$outboundSchema.default("get"),
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() => RestCollectorConfCollectRequestHeader$outboundSchema),
  ).optional(),
  pagination: z.lazy(() => Pagination$outboundSchema).optional(),
  authentication: RestCollectorConfAuthentication$outboundSchema.default(
    "none",
  ),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => RestCollectorConfRetryRules$outboundSchema)
    .optional(),
  scheduling: z.lazy(() => RestCollectorConfScheduling$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    scheduling: "__scheduling",
  });
});

export function restCollectorConfToJSON(
  restCollectorConf: RestCollectorConf,
): string {
  return JSON.stringify(
    RestCollectorConf$outboundSchema.parse(restCollectorConf),
  );
}
export function restCollectorConfFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectorConf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectorConf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectorConf' from JSON`,
  );
}
