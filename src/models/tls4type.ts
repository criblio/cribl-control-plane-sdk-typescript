/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const Tls4TypeMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type Tls4TypeMinimumTLSVersion = OpenEnum<
  typeof Tls4TypeMinimumTLSVersion
>;

export const Tls4TypeMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type Tls4TypeMaximumTLSVersion = OpenEnum<
  typeof Tls4TypeMaximumTLSVersion
>;

export type Tls4Type = {
  disabled?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: Tls4TypeMinimumTLSVersion | undefined;
  maxVersion?: Tls4TypeMaximumTLSVersion | undefined;
};

/** @internal */
export const Tls4TypeMinimumTLSVersion$inboundSchema: z.ZodType<
  Tls4TypeMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(Tls4TypeMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const Tls4TypeMinimumTLSVersion$outboundSchema: z.ZodType<
  Tls4TypeMinimumTLSVersion,
  z.ZodTypeDef,
  Tls4TypeMinimumTLSVersion
> = z.union([
  z.nativeEnum(Tls4TypeMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const Tls4TypeMaximumTLSVersion$inboundSchema: z.ZodType<
  Tls4TypeMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(Tls4TypeMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const Tls4TypeMaximumTLSVersion$outboundSchema: z.ZodType<
  Tls4TypeMaximumTLSVersion,
  z.ZodTypeDef,
  Tls4TypeMaximumTLSVersion
> = z.union([
  z.nativeEnum(Tls4TypeMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const Tls4Type$inboundSchema: z.ZodType<
  Tls4Type,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: Tls4TypeMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: Tls4TypeMaximumTLSVersion$inboundSchema.optional(),
});
/** @internal */
export type Tls4Type$Outbound = {
  disabled: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const Tls4Type$outboundSchema: z.ZodType<
  Tls4Type$Outbound,
  z.ZodTypeDef,
  Tls4Type
> = z.object({
  disabled: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: Tls4TypeMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: Tls4TypeMaximumTLSVersion$outboundSchema.optional(),
});

export function tls4TypeToJSON(tls4Type: Tls4Type): string {
  return JSON.stringify(Tls4Type$outboundSchema.parse(tls4Type));
}
export function tls4TypeFromJSON(
  jsonString: string,
): SafeParseResult<Tls4Type, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Tls4Type$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Tls4Type' from JSON`,
  );
}
