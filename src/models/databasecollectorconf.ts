/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  HiddenDefaultBreakersOptionsDatabaseCollectorConf,
  HiddenDefaultBreakersOptionsDatabaseCollectorConf$inboundSchema,
  HiddenDefaultBreakersOptionsDatabaseCollectorConf$outboundSchema,
} from "./hiddendefaultbreakersoptionsdatabasecollectorconf.js";

export type DatabaseCollectorConfStateTracking = {
  /**
   * Enable tracking of collection progress between consecutive scheduled executions.
   */
  enabled?: boolean | undefined;
};

export type DatabaseCollectorConfScheduling = {
  stateTracking?: DatabaseCollectorConfStateTracking | undefined;
};

export type DatabaseCollectorConf = {
  /**
   * Select an existing Connection, or go to Knowledge > Database Connections to add one
   */
  connectionId: string;
  /**
   * An expression that resolves to the query string for selecting data from the database. Has access to the special ${earliest} and ${latest} variables, which will resolve to the Collector run's start and end time.
   */
  query: string;
  /**
   * Enforces a basic query validation that allows only a single 'select' statement. Disable for more complex queries or when using semicolons. Caution: Disabling query validation allows DDL and DML statements to be executed, which could be destructive to your database.
   */
  queryValidationEnabled?: boolean | undefined;
  defaultBreakers?:
    | HiddenDefaultBreakersOptionsDatabaseCollectorConf
    | undefined;
  __scheduling?: DatabaseCollectorConfScheduling | undefined;
};

/** @internal */
export const DatabaseCollectorConfStateTracking$inboundSchema: z.ZodType<
  DatabaseCollectorConfStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type DatabaseCollectorConfStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const DatabaseCollectorConfStateTracking$outboundSchema: z.ZodType<
  DatabaseCollectorConfStateTracking$Outbound,
  z.ZodTypeDef,
  DatabaseCollectorConfStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function databaseCollectorConfStateTrackingToJSON(
  databaseCollectorConfStateTracking: DatabaseCollectorConfStateTracking,
): string {
  return JSON.stringify(
    DatabaseCollectorConfStateTracking$outboundSchema.parse(
      databaseCollectorConfStateTracking,
    ),
  );
}
export function databaseCollectorConfStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<DatabaseCollectorConfStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DatabaseCollectorConfStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DatabaseCollectorConfStateTracking' from JSON`,
  );
}

/** @internal */
export const DatabaseCollectorConfScheduling$inboundSchema: z.ZodType<
  DatabaseCollectorConfScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => DatabaseCollectorConfStateTracking$inboundSchema)
    .optional(),
});
/** @internal */
export type DatabaseCollectorConfScheduling$Outbound = {
  stateTracking?: DatabaseCollectorConfStateTracking$Outbound | undefined;
};

/** @internal */
export const DatabaseCollectorConfScheduling$outboundSchema: z.ZodType<
  DatabaseCollectorConfScheduling$Outbound,
  z.ZodTypeDef,
  DatabaseCollectorConfScheduling
> = z.object({
  stateTracking: z.lazy(() => DatabaseCollectorConfStateTracking$outboundSchema)
    .optional(),
});

export function databaseCollectorConfSchedulingToJSON(
  databaseCollectorConfScheduling: DatabaseCollectorConfScheduling,
): string {
  return JSON.stringify(
    DatabaseCollectorConfScheduling$outboundSchema.parse(
      databaseCollectorConfScheduling,
    ),
  );
}
export function databaseCollectorConfSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<DatabaseCollectorConfScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DatabaseCollectorConfScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DatabaseCollectorConfScheduling' from JSON`,
  );
}

/** @internal */
export const DatabaseCollectorConf$inboundSchema: z.ZodType<
  DatabaseCollectorConf,
  z.ZodTypeDef,
  unknown
> = z.object({
  connectionId: z.string(),
  query: z.string(),
  queryValidationEnabled: z.boolean().default(true),
  defaultBreakers:
    HiddenDefaultBreakersOptionsDatabaseCollectorConf$inboundSchema.optional(),
  __scheduling: z.lazy(() => DatabaseCollectorConfScheduling$inboundSchema)
    .optional(),
});
/** @internal */
export type DatabaseCollectorConf$Outbound = {
  connectionId: string;
  query: string;
  queryValidationEnabled: boolean;
  defaultBreakers?: string | undefined;
  __scheduling?: DatabaseCollectorConfScheduling$Outbound | undefined;
};

/** @internal */
export const DatabaseCollectorConf$outboundSchema: z.ZodType<
  DatabaseCollectorConf$Outbound,
  z.ZodTypeDef,
  DatabaseCollectorConf
> = z.object({
  connectionId: z.string(),
  query: z.string(),
  queryValidationEnabled: z.boolean().default(true),
  defaultBreakers:
    HiddenDefaultBreakersOptionsDatabaseCollectorConf$outboundSchema.optional(),
  __scheduling: z.lazy(() => DatabaseCollectorConfScheduling$outboundSchema)
    .optional(),
});

export function databaseCollectorConfToJSON(
  databaseCollectorConf: DatabaseCollectorConf,
): string {
  return JSON.stringify(
    DatabaseCollectorConf$outboundSchema.parse(databaseCollectorConf),
  );
}
export function databaseCollectorConfFromJSON(
  jsonString: string,
): SafeParseResult<DatabaseCollectorConf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DatabaseCollectorConf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DatabaseCollectorConf' from JSON`,
  );
}
