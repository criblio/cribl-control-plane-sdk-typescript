/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as discriminatedUnionTypes from "../types/discriminatedUnion.js";
import { discriminatedUnion } from "../types/discriminatedUnion.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeRestCollectMethodGetCollectRequestParams,
  ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound,
  ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
} from "./itemstyperestcollectmethodgetcollectrequestparams.js";
import {
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeJson,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$inboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$Outbound,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$outboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeList,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeList$inboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeList$Outbound,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeList$outboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeNone,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$inboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$Outbound,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$outboundSchema,
} from "./restauthenticationnonerestdiscoverydiscovertypehttpenablediscovercodefalsepagination.js";

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * If 'Strict discover response parsing' parsing is enabled, provide the response format
     */
    discoverResponseFormat: string;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationNoneDiscovery =
  | (
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeJson
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeList
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationNoneCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationNoneCollectMethod = OpenEnum<
  typeof RestAuthenticationNoneCollectMethod
>;

export type RestAuthenticationNoneRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationNoneRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationNoneRestPaginationTypeResponseHeaderLink = {
  type: "response_header_link";
  /**
   * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
   */
  nextRelationAttribute: string;
  /**
   * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
   */
  curRelationAttribute?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationNoneRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationNoneRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestAuthenticationNoneRestPaginationTypeNone = {
  type: "none";
};

export type RestAuthenticationNonePaginationUnion =
  | RestAuthenticationNoneRestPaginationTypeNone
  | RestAuthenticationNoneRestPaginationTypeResponseBody
  | RestAuthenticationNoneRestPaginationTypeResponseHeader
  | RestAuthenticationNoneRestPaginationTypeResponseHeaderLink
  | RestAuthenticationNoneRestPaginationTypeRequestOffset
  | RestAuthenticationNoneRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue = {
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  /**
   * Time interval between a failed request and the first retry
   */
  interval?: number | undefined;
  /**
   * Maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
   */
  multiplier?: number | undefined;
  maxIntervalMs?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

export type RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse = {
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  /**
   * Time interval between a failed request and the first retry
   */
  interval?: number | undefined;
  /**
   * Maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
   */
  multiplier?: number | undefined;
  maxIntervalMs?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

export type RestAuthenticationNoneRestRetryRulesTypeBackoff =
  | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue = {
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  /**
   * Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * Maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

export type RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse = {
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  /**
   * Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * Maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

export type RestAuthenticationNoneRestRetryRulesTypeStatic =
  | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse
  | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestAuthenticationNoneRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
};

export type RestAuthenticationNoneRetryRules =
  | RestAuthenticationNoneRestRetryRulesTypeNone
  | (
    | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse
    | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue & {
      type: "static";
    }
  )
  | (
    | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue & {
      type: "backoff";
    }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationNoneStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationNoneScheduling = {
  stateTracking?: RestAuthenticationNoneStateTracking | undefined;
};

export type RestAuthenticationNone = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
   */
  authentication: "none";
  discovery?:
    | (
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeJson
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeList
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationNoneCollectMethod;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationNoneRestPaginationTypeNone
    | RestAuthenticationNoneRestPaginationTypeResponseBody
    | RestAuthenticationNoneRestPaginationTypeResponseHeader
    | RestAuthenticationNoneRestPaginationTypeResponseHeaderLink
    | RestAuthenticationNoneRestPaginationTypeRequestOffset
    | RestAuthenticationNoneRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationNoneRestRetryRulesTypeNone
    | (
      | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse
      | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue & {
        type: "static";
      }
    )
    | (
      | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue & {
        type: "backoff";
      }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestAuthenticationNoneScheduling | undefined;
};

export const RestCollectMethodOtherCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestCollectMethodOtherCollectMethod = OpenEnum<
  typeof RestCollectMethodOtherCollectMethod
>;

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    /**
     * Custom HTTP method to use for the Discover operation
     */
    discoverVerb: string;
    /**
     * Template for body to send with the discover request
     */
    discoverBody?: string | undefined;
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    /**
     * Template for POST body to send with the discover request. To reference global variables or functions, use template parameters: `{ myVar: ${C.vars.myVar}, secret: ${C.Secret('mySecret','text').value} }`
     */
    discoverBody: string;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * If 'Strict discover response parsing' parsing is enabled, provide the response format
     */
    discoverResponseFormat: string;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp =
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestCollectMethodOtherDiscovery =
  | (
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeJson
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeList
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export type RestCollectMethodOtherRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodOtherRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodOtherRestPaginationTypeResponseHeaderLink = {
  type: "response_header_link";
  /**
   * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
   */
  nextRelationAttribute: string;
  /**
   * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
   */
  curRelationAttribute?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestCollectMethodOtherRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestCollectMethodOtherRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestCollectMethodOtherRestPaginationTypeNone = {
  type: "none";
};

export type RestCollectMethodOtherPaginationUnion =
  | RestCollectMethodOtherRestPaginationTypeNone
  | RestCollectMethodOtherRestPaginationTypeResponseBody
  | RestCollectMethodOtherRestPaginationTypeResponseHeader
  | RestCollectMethodOtherRestPaginationTypeResponseHeaderLink
  | RestCollectMethodOtherRestPaginationTypeRequestOffset
  | RestCollectMethodOtherRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

/**
 * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
 */
export const RestCollectMethodOtherAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
 */
export type RestCollectMethodOtherAuthentication = OpenEnum<
  typeof RestCollectMethodOtherAuthentication
>;

export type RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue = {
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  /**
   * Time interval between a failed request and the first retry
   */
  interval?: number | undefined;
  /**
   * Maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
   */
  multiplier?: number | undefined;
  maxIntervalMs?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

export type RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse = {
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  /**
   * Time interval between a failed request and the first retry
   */
  interval?: number | undefined;
  /**
   * Maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
   */
  multiplier?: number | undefined;
  maxIntervalMs?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

export type RestCollectMethodOtherRestRetryRulesTypeBackoff =
  | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue = {
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  /**
   * Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * Maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

export type RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse = {
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  /**
   * Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * Maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

export type RestCollectMethodOtherRestRetryRulesTypeStatic =
  | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse
  | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestCollectMethodOtherRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
};

export type RestCollectMethodOtherRetryRules =
  | RestCollectMethodOtherRestRetryRulesTypeNone
  | (
    | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse
    | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue & {
      type: "static";
    }
  )
  | (
    | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue & {
      type: "backoff";
    }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestCollectMethodOtherStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestCollectMethodOtherScheduling = {
  stateTracking?: RestCollectMethodOtherStateTracking | undefined;
};

export type RestCollectMethodOther = {
  collectMethod: RestCollectMethodOtherCollectMethod;
  /**
   * Custom HTTP method to use for the Collect operation
   */
  collectVerb: string;
  /**
   * Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`
   */
  collectBody?: string | undefined;
  collectRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | (
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeJson
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeList
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestCollectMethodOtherRestPaginationTypeNone
    | RestCollectMethodOtherRestPaginationTypeResponseBody
    | RestCollectMethodOtherRestPaginationTypeResponseHeader
    | RestCollectMethodOtherRestPaginationTypeResponseHeaderLink
    | RestCollectMethodOtherRestPaginationTypeRequestOffset
    | RestCollectMethodOtherRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
   */
  authentication: RestCollectMethodOtherAuthentication;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestCollectMethodOtherRestRetryRulesTypeNone
    | (
      | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse
      | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue & {
        type: "static";
      }
    )
    | (
      | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue & {
        type: "backoff";
      }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestCollectMethodOtherScheduling | undefined;
};

export const RestCollectMethodPostWithBodyCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestCollectMethodPostWithBodyCollectMethod = OpenEnum<
  typeof RestCollectMethodPostWithBodyCollectMethod
>;

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    /**
     * Custom HTTP method to use for the Discover operation
     */
    discoverVerb: string;
    /**
     * Template for body to send with the discover request
     */
    discoverBody?: string | undefined;
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    /**
     * Template for POST body to send with the discover request. To reference global variables or functions, use template parameters: `{ myVar: ${C.vars.myVar}, secret: ${C.Secret('mySecret','text').value} }`
     */
    discoverBody: string;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * If 'Strict discover response parsing' parsing is enabled, provide the response format
     */
    discoverResponseFormat: string;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp =
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestCollectMethodPostWithBodyDiscovery =
  | (
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export type RestCollectMethodPostWithBodyRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink =
  {
    type: "response_header_link";
    /**
     * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
     */
    nextRelationAttribute: string;
    /**
     * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
     */
    curRelationAttribute?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestCollectMethodPostWithBodyRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestCollectMethodPostWithBodyRestPaginationTypeNone = {
  type: "none";
};

export type RestCollectMethodPostWithBodyPaginationUnion =
  | RestCollectMethodPostWithBodyRestPaginationTypeNone
  | RestCollectMethodPostWithBodyRestPaginationTypeResponseBody
  | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader
  | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink
  | RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset
  | RestCollectMethodPostWithBodyRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

/**
 * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
 */
export const RestCollectMethodPostWithBodyAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
 */
export type RestCollectMethodPostWithBodyAuthentication = OpenEnum<
  typeof RestCollectMethodPostWithBodyAuthentication
>;

export type RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue =
  {
    /**
     * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
     */
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    /**
     * Time interval between a failed request and the first retry
     */
    interval?: number | undefined;
    /**
     * Maximum number of times to retry a failed HTTP request
     */
    limit?: number | undefined;
    /**
     * Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
     */
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    /**
     * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
     */
    codes?: Array<number> | undefined;
    /**
     * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
     */
    retryConnectTimeout?: boolean | undefined;
    /**
     * Retry request when a connection reset (ECONNRESET) error occurs
     */
    retryConnectReset?: boolean | undefined;
  };

export type RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse =
  {
    /**
     * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
     */
    enableHeader?: boolean | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    /**
     * Time interval between a failed request and the first retry
     */
    interval?: number | undefined;
    /**
     * Maximum number of times to retry a failed HTTP request
     */
    limit?: number | undefined;
    /**
     * Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
     */
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    /**
     * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
     */
    codes?: Array<number> | undefined;
    /**
     * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
     */
    retryConnectTimeout?: boolean | undefined;
    /**
     * Retry request when a connection reset (ECONNRESET) error occurs
     */
    retryConnectReset?: boolean | undefined;
  };

export type RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff =
  | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue =
  {
    /**
     * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
     */
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    /**
     * Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
     */
    interval?: number | undefined;
    /**
     * Maximum number of times to retry a failed HTTP request
     */
    limit?: number | undefined;
    /**
     * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
     */
    codes?: Array<number> | undefined;
    /**
     * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
     */
    retryConnectTimeout?: boolean | undefined;
    /**
     * Retry request when a connection reset (ECONNRESET) error occurs
     */
    retryConnectReset?: boolean | undefined;
  };

export type RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse =
  {
    /**
     * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
     */
    enableHeader?: boolean | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    /**
     * Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
     */
    interval?: number | undefined;
    /**
     * Maximum number of times to retry a failed HTTP request
     */
    limit?: number | undefined;
    /**
     * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
     */
    codes?: Array<number> | undefined;
    /**
     * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
     */
    retryConnectTimeout?: boolean | undefined;
    /**
     * Retry request when a connection reset (ECONNRESET) error occurs
     */
    retryConnectReset?: boolean | undefined;
  };

export type RestCollectMethodPostWithBodyRestRetryRulesTypeStatic =
  | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse
  | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestCollectMethodPostWithBodyRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
};

export type RestCollectMethodPostWithBodyRetryRules =
  | RestCollectMethodPostWithBodyRestRetryRulesTypeNone
  | (
    | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse
    | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue & {
      type: "static";
    }
  )
  | (
    | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue & {
      type: "backoff";
    }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestCollectMethodPostWithBodyStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestCollectMethodPostWithBodyScheduling = {
  stateTracking?: RestCollectMethodPostWithBodyStateTracking | undefined;
};

export type RestCollectMethodPostWithBody = {
  collectMethod: RestCollectMethodPostWithBodyCollectMethod;
  /**
   * Template for POST body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template params: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`
   */
  collectBody: string;
  discovery?:
    | (
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestCollectMethodPostWithBodyRestPaginationTypeNone
    | RestCollectMethodPostWithBodyRestPaginationTypeResponseBody
    | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader
    | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink
    | RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset
    | RestCollectMethodPostWithBodyRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API keyâ€“based authentication by adding the appropriate Collect headers.
   */
  authentication: RestCollectMethodPostWithBodyAuthentication;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestCollectMethodPostWithBodyRestRetryRulesTypeNone
    | (
      | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse
      | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue
        & { type: "static" }
    )
    | (
      | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue
        & { type: "backoff" }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestCollectMethodPostWithBodyScheduling | undefined;
};

export const RestCollectMethodPostCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestCollectMethodPostCollectMethod = OpenEnum<
  typeof RestCollectMethodPostCollectMethod
>;

export type RestCollectMethodPostRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestCollectMethodPostRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestCollectMethodPostRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    /**
     * Custom HTTP method to use for the Discover operation
     */
    discoverVerb: string;
    /**
     * Template for body to send with the discover request
     */
    discoverBody?: string | undefined;
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    /**
     * Template for POST body to send with the discover request. To reference global variables or functions, use template parameters: `{ myVar: ${C.vars.myVar}, secret: ${C.Secret('mySecret','text').value} }`
     */
    discoverBody: string;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema,
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
        .optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.string(),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat: string;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.string(),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema,
    post:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema,
    post_with_body:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema,
    other:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema,
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp
  > = z.union([
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema,
  ]);

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp$outboundSchema.parse(
      restAuthenticationNoneRestDiscoveryDiscoverTypeHttp,
    ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationNoneDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema,
    post:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema,
    post_with_body:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema,
    other:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema,
  }).and(z.object({ discoverType: z.literal("http") })),
  json: RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$inboundSchema,
  list: RestAuthenticationNoneRestDiscoveryDiscoverTypeList$inboundSchema,
  none: RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$inboundSchema,
});
/** @internal */
export type RestAuthenticationNoneDiscovery$Outbound =
  | (
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationNoneDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationNoneDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNoneDiscovery
> = z.union([
  z.union([
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema,
  ]).and(z.object({ discoverType: z.literal("http") })),
  RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$outboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeList$outboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$outboundSchema,
]);

export function restAuthenticationNoneDiscoveryToJSON(
  restAuthenticationNoneDiscovery: RestAuthenticationNoneDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationNoneDiscovery$outboundSchema.parse(
      restAuthenticationNoneDiscovery,
    ),
  );
}
export function restAuthenticationNoneDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNoneDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationNoneDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneCollectMethod$inboundSchema: z.ZodType<
  RestAuthenticationNoneCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationNoneCollectMethod);
/** @internal */
export const RestAuthenticationNoneCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationNoneCollectMethod
> = openEnums.outboundSchema(RestAuthenticationNoneCollectMethod);

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationNoneRestPaginationTypeRequestPage$Outbound = {
  type: "request_page";
  pageField: string;
  page?: number | undefined;
  sizeField: string;
  size: number;
  totalPageField?: string | undefined;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationNoneRestPaginationTypeRequestPageToJSON(
  restAuthenticationNoneRestPaginationTypeRequestPage:
    RestAuthenticationNoneRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestPaginationTypeRequestPage$outboundSchema.parse(
      restAuthenticationNoneRestPaginationTypeRequestPage,
    ),
  );
}
export function restAuthenticationNoneRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestPaginationTypeRequestPage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationNoneRestPaginationTypeRequestOffset$Outbound = {
  type: "request_offset";
  offsetField: string;
  offset?: number | undefined;
  limitField: string;
  limit: number;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationNoneRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationNoneRestPaginationTypeRequestOffset:
    RestAuthenticationNoneRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestPaginationTypeRequestOffset$outboundSchema.parse(
      restAuthenticationNoneRestPaginationTypeRequestOffset,
    ),
  );
}
export function restAuthenticationNoneRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestPaginationTypeRequestOffset$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationNoneRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationNoneRestPaginationTypeResponseHeaderLink:
    RestAuthenticationNoneRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restAuthenticationNoneRestPaginationTypeResponseHeaderLink),
  );
}
export function restAuthenticationNoneRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationNoneRestPaginationTypeResponseHeader$Outbound = {
  type: "response_header";
  attribute: Array<string>;
  maxPages: number;
};

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationNoneRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationNoneRestPaginationTypeResponseHeader:
    RestAuthenticationNoneRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestPaginationTypeResponseHeader$outboundSchema.parse(
      restAuthenticationNoneRestPaginationTypeResponseHeader,
    ),
  );
}
export function restAuthenticationNoneRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationNoneRestPaginationTypeResponseBody$Outbound = {
  type: "response_body";
  attribute: Array<string>;
  maxPages: number;
  lastPageExpr?: string | undefined;
};

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationNoneRestPaginationTypeResponseBodyToJSON(
  restAuthenticationNoneRestPaginationTypeResponseBody:
    RestAuthenticationNoneRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestPaginationTypeResponseBody$outboundSchema.parse(
      restAuthenticationNoneRestPaginationTypeResponseBody,
    ),
  );
}
export function restAuthenticationNoneRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestPaginationTypeResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationNoneRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationNoneRestPaginationTypeNoneToJSON(
  restAuthenticationNoneRestPaginationTypeNone:
    RestAuthenticationNoneRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestPaginationTypeNone$outboundSchema.parse(
      restAuthenticationNoneRestPaginationTypeNone,
    ),
  );
}
export function restAuthenticationNoneRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNonePaginationUnion$inboundSchema: z.ZodType<
  RestAuthenticationNonePaginationUnion,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeNone$inboundSchema
  ),
  response_body: z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeResponseBody$inboundSchema
  ),
  response_header: z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeResponseHeader$inboundSchema
  ),
  response_header_link: z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$inboundSchema
  ),
  request_offset: z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeRequestOffset$inboundSchema
  ),
  request_page: z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeRequestPage$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationNonePaginationUnion$Outbound =
  | RestAuthenticationNoneRestPaginationTypeNone$Outbound
  | RestAuthenticationNoneRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationNoneRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationNoneRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationNoneRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationNonePaginationUnion$outboundSchema: z.ZodType<
  RestAuthenticationNonePaginationUnion$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNonePaginationUnion
> = z.union([
  z.lazy(() => RestAuthenticationNoneRestPaginationTypeNone$outboundSchema),
  z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeResponseBody$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeResponseHeader$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeRequestOffset$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeRequestPage$outboundSchema
  ),
]);

export function restAuthenticationNonePaginationUnionToJSON(
  restAuthenticationNonePaginationUnion: RestAuthenticationNonePaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationNonePaginationUnion$outboundSchema.parse(
      restAuthenticationNonePaginationUnion,
    ),
  );
}
export function restAuthenticationNonePaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNonePaginationUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNonePaginationUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNonePaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    multiplier: types.optional(types.number()),
    maxIntervalMs: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.boolean().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    multiplier: z.number().optional(),
    maxIntervalMs: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(restAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue),
  );
}
export function restAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    multiplier: types.optional(types.number()),
    maxIntervalMs: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: boolean | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.boolean().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    multiplier: z.number().optional(),
    maxIntervalMs: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(restAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse),
  );
}
export function restAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationNoneRestRetryRulesTypeBackoff$Outbound =
  | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationNoneRestRetryRulesTypeBackoffToJSON(
  restAuthenticationNoneRestRetryRulesTypeBackoff:
    RestAuthenticationNoneRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestRetryRulesTypeBackoff$outboundSchema.parse(
      restAuthenticationNoneRestRetryRulesTypeBackoff,
    ),
  );
}
export function restAuthenticationNoneRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestRetryRulesTypeBackoff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.boolean().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue:
    RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(restAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue),
  );
}
export function restAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: boolean | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.boolean().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse:
    RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(restAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse),
  );
}
export function restAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationNoneRestRetryRulesTypeStatic$Outbound =
  | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationNoneRestRetryRulesTypeStaticToJSON(
  restAuthenticationNoneRestRetryRulesTypeStatic:
    RestAuthenticationNoneRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestRetryRulesTypeStatic$outboundSchema.parse(
      restAuthenticationNoneRestRetryRulesTypeStatic,
    ),
  );
}
export function restAuthenticationNoneRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationNoneRestRetryRulesTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationNoneRestRetryRulesTypeNoneToJSON(
  restAuthenticationNoneRestRetryRulesTypeNone:
    RestAuthenticationNoneRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestRetryRulesTypeNone$outboundSchema.parse(
      restAuthenticationNoneRestRetryRulesTypeNone,
    ),
  );
}
export function restAuthenticationNoneRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationNoneRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationNoneRestRetryRulesTypeNone$inboundSchema
  ),
  static: smartUnion([
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  backoff: smartUnion([
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
});
/** @internal */
export type RestAuthenticationNoneRetryRules$Outbound =
  | RestAuthenticationNoneRestRetryRulesTypeNone$Outbound
  | (
    | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
      & { type: "static" }
  )
  | (
    | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestAuthenticationNoneRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationNoneRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNoneRetryRules
> = z.union([
  z.lazy(() => RestAuthenticationNoneRestRetryRulesTypeNone$outboundSchema),
  smartUnion([
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  smartUnion([
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
]);

export function restAuthenticationNoneRetryRulesToJSON(
  restAuthenticationNoneRetryRules: RestAuthenticationNoneRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRetryRules$outboundSchema.parse(
      restAuthenticationNoneRetryRules,
    ),
  );
}
export function restAuthenticationNoneRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNoneRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationNoneRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneStateTracking$inboundSchema: z.ZodType<
  RestAuthenticationNoneStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: types.optional(types.boolean()),
});
/** @internal */
export type RestAuthenticationNoneStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationNoneStateTracking$outboundSchema: z.ZodType<
  RestAuthenticationNoneStateTracking$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNoneStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restAuthenticationNoneStateTrackingToJSON(
  restAuthenticationNoneStateTracking: RestAuthenticationNoneStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationNoneStateTracking$outboundSchema.parse(
      restAuthenticationNoneStateTracking,
    ),
  );
}
export function restAuthenticationNoneStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNoneStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneScheduling$inboundSchema: z.ZodType<
  RestAuthenticationNoneScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestAuthenticationNoneStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationNoneScheduling$Outbound = {
  stateTracking?: RestAuthenticationNoneStateTracking$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationNoneScheduling$outboundSchema: z.ZodType<
  RestAuthenticationNoneScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNoneScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationNoneStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationNoneSchedulingToJSON(
  restAuthenticationNoneScheduling: RestAuthenticationNoneScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationNoneScheduling$outboundSchema.parse(
      restAuthenticationNoneScheduling,
    ),
  );
}
export function restAuthenticationNoneSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNoneScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationNoneScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNone$inboundSchema: z.ZodType<
  RestAuthenticationNone,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("none"),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get:
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema,
      post:
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema,
      post_with_body:
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema,
      other:
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema,
    }).and(z.object({ discoverType: z.literal("http") })),
    json: RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$inboundSchema,
    list: RestAuthenticationNoneRestDiscoveryDiscoverTypeList$inboundSchema,
    none: RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$inboundSchema,
  })),
  collectUrl: types.string(),
  collectMethod: RestAuthenticationNoneCollectMethod$inboundSchema,
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestAuthenticationNoneScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationNone$Outbound = {
  authentication: "none";
  discovery?:
    | (
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationNoneRestPaginationTypeNone$Outbound
    | RestAuthenticationNoneRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationNoneRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationNoneRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationNoneRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationNoneRestRetryRulesTypeNone$Outbound
    | (
      | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?: RestAuthenticationNoneScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationNone$outboundSchema: z.ZodType<
  RestAuthenticationNone$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNone
> = z.object({
  authentication: z.literal("none"),
  discovery: z.union([
    z.union([
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema,
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema,
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema,
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema,
    ]).and(z.object({ discoverType: z.literal("http") })),
    RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$outboundSchema,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeList$outboundSchema,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$outboundSchema,
  ]).optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationNoneCollectMethod$outboundSchema,
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() => RestAuthenticationNoneRestPaginationTypeNone$outboundSchema),
    z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() => RestAuthenticationNoneRestRetryRulesTypeNone$outboundSchema),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationNoneRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationNoneRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]).optional(),
  __scheduling: z.lazy(() => RestAuthenticationNoneScheduling$outboundSchema)
    .optional(),
});

export function restAuthenticationNoneToJSON(
  restAuthenticationNone: RestAuthenticationNone,
): string {
  return JSON.stringify(
    RestAuthenticationNone$outboundSchema.parse(restAuthenticationNone),
  );
}
export function restAuthenticationNoneFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNone, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationNone$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherCollectMethod$inboundSchema: z.ZodType<
  RestCollectMethodOtherCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodOtherCollectMethod);
/** @internal */
export const RestCollectMethodOtherCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodOtherCollectMethod
> = openEnums.outboundSchema(RestCollectMethodOtherCollectMethod);

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$Outbound = {
  discoverType: "none";
};

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeNoneToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeNone:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$outboundSchema.parse(
      restCollectMethodOtherRestDiscoveryDiscoverTypeNone,
    ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeList$Outbound = {
  discoverType: "list";
  itemList: Array<string>;
};

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeListToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeList:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeList$outboundSchema.parse(
      restCollectMethodOtherRestDiscoveryDiscoverTypeList,
    ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeList$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$Outbound = {
  discoverType: "json";
  manualDiscoverResult: string;
  discoverDataField?: string | undefined;
};

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeJsonToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeJson:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$outboundSchema.parse(
      restCollectMethodOtherRestDiscoveryDiscoverTypeJson,
    ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.string(),
    discoverBody: types.optional(types.string()),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb: string;
    discoverBody?: string | undefined;
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.string(),
    discoverBody: z.string().optional(),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.string(),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody: string;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.string(),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.string(),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat: string;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.string(),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttp:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp$outboundSchema.parse(
      restCollectMethodOtherRestDiscoveryDiscoverTypeHttp,
    ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherDiscovery$inboundSchema: z.ZodType<
  RestCollectMethodOtherDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestCollectMethodOtherRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodOtherDiscovery$Outbound =
  | (
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$Outbound
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeList$Outbound
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestCollectMethodOtherDiscovery$outboundSchema: z.ZodType<
  RestCollectMethodOtherDiscovery$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodOtherRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restCollectMethodOtherDiscoveryToJSON(
  restCollectMethodOtherDiscovery: RestCollectMethodOtherDiscovery,
): string {
  return JSON.stringify(
    RestCollectMethodOtherDiscovery$outboundSchema.parse(
      restCollectMethodOtherDiscovery,
    ),
  );
}
export function restCollectMethodOtherDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodOtherDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherDiscovery' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodOtherRestPaginationTypeRequestPage$Outbound = {
  type: "request_page";
  pageField: string;
  page?: number | undefined;
  sizeField: string;
  size: number;
  totalPageField?: string | undefined;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodOtherRestPaginationTypeRequestPageToJSON(
  restCollectMethodOtherRestPaginationTypeRequestPage:
    RestCollectMethodOtherRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestPaginationTypeRequestPage$outboundSchema.parse(
      restCollectMethodOtherRestPaginationTypeRequestPage,
    ),
  );
}
export function restCollectMethodOtherRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestPaginationTypeRequestPage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodOtherRestPaginationTypeRequestOffset$Outbound = {
  type: "request_offset";
  offsetField: string;
  offset?: number | undefined;
  limitField: string;
  limit: number;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodOtherRestPaginationTypeRequestOffsetToJSON(
  restCollectMethodOtherRestPaginationTypeRequestOffset:
    RestCollectMethodOtherRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestPaginationTypeRequestOffset$outboundSchema.parse(
      restCollectMethodOtherRestPaginationTypeRequestOffset,
    ),
  );
}
export function restCollectMethodOtherRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestPaginationTypeRequestOffset$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restCollectMethodOtherRestPaginationTypeResponseHeaderLinkToJSON(
  restCollectMethodOtherRestPaginationTypeResponseHeaderLink:
    RestCollectMethodOtherRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restCollectMethodOtherRestPaginationTypeResponseHeaderLink),
  );
}
export function restCollectMethodOtherRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodOtherRestPaginationTypeResponseHeader$Outbound = {
  type: "response_header";
  attribute: Array<string>;
  maxPages: number;
};

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restCollectMethodOtherRestPaginationTypeResponseHeaderToJSON(
  restCollectMethodOtherRestPaginationTypeResponseHeader:
    RestCollectMethodOtherRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestPaginationTypeResponseHeader$outboundSchema.parse(
      restCollectMethodOtherRestPaginationTypeResponseHeader,
    ),
  );
}
export function restCollectMethodOtherRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodOtherRestPaginationTypeResponseBody$Outbound = {
  type: "response_body";
  attribute: Array<string>;
  maxPages: number;
  lastPageExpr?: string | undefined;
};

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restCollectMethodOtherRestPaginationTypeResponseBodyToJSON(
  restCollectMethodOtherRestPaginationTypeResponseBody:
    RestCollectMethodOtherRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestPaginationTypeResponseBody$outboundSchema.parse(
      restCollectMethodOtherRestPaginationTypeResponseBody,
    ),
  );
}
export function restCollectMethodOtherRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestPaginationTypeResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodOtherRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restCollectMethodOtherRestPaginationTypeNoneToJSON(
  restCollectMethodOtherRestPaginationTypeNone:
    RestCollectMethodOtherRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestPaginationTypeNone$outboundSchema.parse(
      restCollectMethodOtherRestPaginationTypeNone,
    ),
  );
}
export function restCollectMethodOtherRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherPaginationUnion$inboundSchema: z.ZodType<
  RestCollectMethodOtherPaginationUnion,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeNone$inboundSchema
  ),
  response_body: z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeResponseBody$inboundSchema
  ),
  response_header: z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeResponseHeader$inboundSchema
  ),
  response_header_link: z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$inboundSchema
  ),
  request_offset: z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeRequestOffset$inboundSchema
  ),
  request_page: z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeRequestPage$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodOtherPaginationUnion$Outbound =
  | RestCollectMethodOtherRestPaginationTypeNone$Outbound
  | RestCollectMethodOtherRestPaginationTypeResponseBody$Outbound
  | RestCollectMethodOtherRestPaginationTypeResponseHeader$Outbound
  | RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$Outbound
  | RestCollectMethodOtherRestPaginationTypeRequestOffset$Outbound
  | RestCollectMethodOtherRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestCollectMethodOtherPaginationUnion$outboundSchema: z.ZodType<
  RestCollectMethodOtherPaginationUnion$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherPaginationUnion
> = z.union([
  z.lazy(() => RestCollectMethodOtherRestPaginationTypeNone$outboundSchema),
  z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeResponseBody$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeResponseHeader$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeRequestOffset$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeRequestPage$outboundSchema
  ),
]);

export function restCollectMethodOtherPaginationUnionToJSON(
  restCollectMethodOtherPaginationUnion: RestCollectMethodOtherPaginationUnion,
): string {
  return JSON.stringify(
    RestCollectMethodOtherPaginationUnion$outboundSchema.parse(
      restCollectMethodOtherPaginationUnion,
    ),
  );
}
export function restCollectMethodOtherPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherPaginationUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherPaginationUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherAuthentication$inboundSchema: z.ZodType<
  RestCollectMethodOtherAuthentication,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodOtherAuthentication);
/** @internal */
export const RestCollectMethodOtherAuthentication$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodOtherAuthentication
> = openEnums.outboundSchema(RestCollectMethodOtherAuthentication);

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    multiplier: types.optional(types.number()),
    maxIntervalMs: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.boolean().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    multiplier: z.number().optional(),
    maxIntervalMs: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(restCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue),
  );
}
export function restCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    multiplier: types.optional(types.number()),
    maxIntervalMs: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: boolean | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.boolean().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    multiplier: z.number().optional(),
    maxIntervalMs: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(restCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse),
  );
}
export function restCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestCollectMethodOtherRestRetryRulesTypeBackoff$Outbound =
  | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restCollectMethodOtherRestRetryRulesTypeBackoffToJSON(
  restCollectMethodOtherRestRetryRulesTypeBackoff:
    RestCollectMethodOtherRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestRetryRulesTypeBackoff$outboundSchema.parse(
      restCollectMethodOtherRestRetryRulesTypeBackoff,
    ),
  );
}
export function restCollectMethodOtherRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestRetryRulesTypeBackoff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.boolean().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue:
    RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(restCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue),
  );
}
export function restCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: boolean | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.boolean().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse:
    RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(restCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse),
  );
}
export function restCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestCollectMethodOtherRestRetryRulesTypeStatic$Outbound =
  | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restCollectMethodOtherRestRetryRulesTypeStaticToJSON(
  restCollectMethodOtherRestRetryRulesTypeStatic:
    RestCollectMethodOtherRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestRetryRulesTypeStatic$outboundSchema.parse(
      restCollectMethodOtherRestRetryRulesTypeStatic,
    ),
  );
}
export function restCollectMethodOtherRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodOtherRestRetryRulesTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restCollectMethodOtherRestRetryRulesTypeNoneToJSON(
  restCollectMethodOtherRestRetryRulesTypeNone:
    RestCollectMethodOtherRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestRetryRulesTypeNone$outboundSchema.parse(
      restCollectMethodOtherRestRetryRulesTypeNone,
    ),
  );
}
export function restCollectMethodOtherRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRetryRules$inboundSchema: z.ZodType<
  RestCollectMethodOtherRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestCollectMethodOtherRestRetryRulesTypeNone$inboundSchema
  ),
  static: smartUnion([
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  backoff: smartUnion([
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
});
/** @internal */
export type RestCollectMethodOtherRetryRules$Outbound =
  | RestCollectMethodOtherRestRetryRulesTypeNone$Outbound
  | (
    | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
      & { type: "static" }
  )
  | (
    | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestCollectMethodOtherRetryRules$outboundSchema: z.ZodType<
  RestCollectMethodOtherRetryRules$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherRetryRules
> = z.union([
  z.lazy(() => RestCollectMethodOtherRestRetryRulesTypeNone$outboundSchema),
  smartUnion([
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  smartUnion([
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
]);

export function restCollectMethodOtherRetryRulesToJSON(
  restCollectMethodOtherRetryRules: RestCollectMethodOtherRetryRules,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRetryRules$outboundSchema.parse(
      restCollectMethodOtherRetryRules,
    ),
  );
}
export function restCollectMethodOtherRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodOtherRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRetryRules' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherStateTracking$inboundSchema: z.ZodType<
  RestCollectMethodOtherStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: types.optional(types.boolean()),
});
/** @internal */
export type RestCollectMethodOtherStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestCollectMethodOtherStateTracking$outboundSchema: z.ZodType<
  RestCollectMethodOtherStateTracking$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restCollectMethodOtherStateTrackingToJSON(
  restCollectMethodOtherStateTracking: RestCollectMethodOtherStateTracking,
): string {
  return JSON.stringify(
    RestCollectMethodOtherStateTracking$outboundSchema.parse(
      restCollectMethodOtherStateTracking,
    ),
  );
}
export function restCollectMethodOtherStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherStateTracking' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherScheduling$inboundSchema: z.ZodType<
  RestCollectMethodOtherScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestCollectMethodOtherStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestCollectMethodOtherScheduling$Outbound = {
  stateTracking?: RestCollectMethodOtherStateTracking$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodOtherScheduling$outboundSchema: z.ZodType<
  RestCollectMethodOtherScheduling$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestCollectMethodOtherStateTracking$outboundSchema
  ).optional(),
});

export function restCollectMethodOtherSchedulingToJSON(
  restCollectMethodOtherScheduling: RestCollectMethodOtherScheduling,
): string {
  return JSON.stringify(
    RestCollectMethodOtherScheduling$outboundSchema.parse(
      restCollectMethodOtherScheduling,
    ),
  );
}
export function restCollectMethodOtherSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodOtherScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherScheduling' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOther$inboundSchema: z.ZodType<
  RestCollectMethodOther,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: RestCollectMethodOtherCollectMethod$inboundSchema,
  collectVerb: types.string(),
  collectBody: types.optional(types.string()),
  collectRequestParams: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  authentication: RestCollectMethodOtherAuthentication$inboundSchema,
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestCollectMethodOtherScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestCollectMethodOther$Outbound = {
  collectMethod: string;
  collectVerb: string;
  collectBody?: string | undefined;
  collectRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?:
    | (
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$Outbound
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeList$Outbound
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestCollectMethodOtherRestPaginationTypeNone$Outbound
    | RestCollectMethodOtherRestPaginationTypeResponseBody$Outbound
    | RestCollectMethodOtherRestPaginationTypeResponseHeader$Outbound
    | RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$Outbound
    | RestCollectMethodOtherRestPaginationTypeRequestOffset$Outbound
    | RestCollectMethodOtherRestPaginationTypeRequestPage$Outbound
    | undefined;
  authentication: string;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestCollectMethodOtherRestRetryRulesTypeNone$Outbound
    | (
      | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?: RestCollectMethodOtherScheduling$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodOther$outboundSchema: z.ZodType<
  RestCollectMethodOther$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOther
> = z.object({
  collectMethod: RestCollectMethodOtherCollectMethod$outboundSchema,
  collectVerb: z.string(),
  collectBody: z.string().optional(),
  collectRequestParams: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() => RestCollectMethodOtherRestPaginationTypeNone$outboundSchema),
    z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  authentication: RestCollectMethodOtherAuthentication$outboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() => RestCollectMethodOtherRestRetryRulesTypeNone$outboundSchema),
    smartUnion([
      z.lazy(() =>
        RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodOtherRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodOtherRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]).optional(),
  __scheduling: z.lazy(() => RestCollectMethodOtherScheduling$outboundSchema)
    .optional(),
});

export function restCollectMethodOtherToJSON(
  restCollectMethodOther: RestCollectMethodOther,
): string {
  return JSON.stringify(
    RestCollectMethodOther$outboundSchema.parse(restCollectMethodOther),
  );
}
export function restCollectMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOther, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodOther$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOther' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyCollectMethod$inboundSchema:
  z.ZodType<RestCollectMethodPostWithBodyCollectMethod, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(RestCollectMethodPostWithBodyCollectMethod);
/** @internal */
export const RestCollectMethodPostWithBodyCollectMethod$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestCollectMethodPostWithBodyCollectMethod> =
    openEnums.outboundSchema(RestCollectMethodPostWithBodyCollectMethod);

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$Outbound =
  {
    discoverType: "none";
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNoneToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$outboundSchema
      .parse(restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$Outbound =
  {
    discoverType: "list";
    itemList: Array<string>;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeListToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$outboundSchema
      .parse(restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$Outbound =
  {
    discoverType: "json";
    manualDiscoverResult: string;
    discoverDataField?: string | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJsonToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$outboundSchema
      .parse(restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.string(),
    discoverBody: types.optional(types.string()),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb: string;
    discoverBody?: string | undefined;
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.string(),
    discoverBody: z.string().optional(),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.string(),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody: string;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.string(),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.string(),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat: string;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.string(),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp$outboundSchema
      .parse(restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyDiscovery$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodPostWithBodyDiscovery$Outbound =
  | (
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$Outbound
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$Outbound
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestCollectMethodPostWithBodyDiscovery$outboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyDiscovery$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostWithBodyDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restCollectMethodPostWithBodyDiscoveryToJSON(
  restCollectMethodPostWithBodyDiscovery:
    RestCollectMethodPostWithBodyDiscovery,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyDiscovery$outboundSchema.parse(
      restCollectMethodPostWithBodyDiscovery,
    ),
  );
}
export function restCollectMethodPostWithBodyDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostWithBodyDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyDiscovery' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$Outbound =
  {
    type: "request_page";
    pageField: string;
    page?: number | undefined;
    sizeField: string;
    size: number;
    totalPageField?: string | undefined;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodPostWithBodyRestPaginationTypeRequestPageToJSON(
  restCollectMethodPostWithBodyRestPaginationTypeRequestPage:
    RestCollectMethodPostWithBodyRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$outboundSchema
      .parse(restCollectMethodPostWithBodyRestPaginationTypeRequestPage),
  );
}
export function restCollectMethodPostWithBodyRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$Outbound =
  {
    type: "request_offset";
    offsetField: string;
    offset?: number | undefined;
    limitField: string;
    limit: number;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodPostWithBodyRestPaginationTypeRequestOffsetToJSON(
  restCollectMethodPostWithBodyRestPaginationTypeRequestOffset:
    RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$outboundSchema
      .parse(restCollectMethodPostWithBodyRestPaginationTypeRequestOffset),
  );
}
export function restCollectMethodPostWithBodyRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLinkToJSON(
  restCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink:
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink),
  );
}
export function restCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$Outbound =
  {
    type: "response_header";
    attribute: Array<string>;
    maxPages: number;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restCollectMethodPostWithBodyRestPaginationTypeResponseHeaderToJSON(
  restCollectMethodPostWithBodyRestPaginationTypeResponseHeader:
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$outboundSchema
      .parse(restCollectMethodPostWithBodyRestPaginationTypeResponseHeader),
  );
}
export function restCollectMethodPostWithBodyRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$Outbound =
  {
    type: "response_body";
    attribute: Array<string>;
    maxPages: number;
    lastPageExpr?: string | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restCollectMethodPostWithBodyRestPaginationTypeResponseBodyToJSON(
  restCollectMethodPostWithBodyRestPaginationTypeResponseBody:
    RestCollectMethodPostWithBodyRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$outboundSchema
      .parse(restCollectMethodPostWithBodyRestPaginationTypeResponseBody),
  );
}
export function restCollectMethodPostWithBodyRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restCollectMethodPostWithBodyRestPaginationTypeNoneToJSON(
  restCollectMethodPostWithBodyRestPaginationTypeNone:
    RestCollectMethodPostWithBodyRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestPaginationTypeNone$outboundSchema.parse(
      restCollectMethodPostWithBodyRestPaginationTypeNone,
    ),
  );
}
export function restCollectMethodPostWithBodyRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyPaginationUnion$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyPaginationUnion,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$inboundSchema
    ),
  });
/** @internal */
export type RestCollectMethodPostWithBodyPaginationUnion$Outbound =
  | RestCollectMethodPostWithBodyRestPaginationTypeNone$Outbound
  | RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$Outbound
  | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$Outbound
  | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$Outbound
  | RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$Outbound
  | RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestCollectMethodPostWithBodyPaginationUnion$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyPaginationUnion$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyPaginationUnion
  > = z.union([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$outboundSchema
    ),
  ]);

export function restCollectMethodPostWithBodyPaginationUnionToJSON(
  restCollectMethodPostWithBodyPaginationUnion:
    RestCollectMethodPostWithBodyPaginationUnion,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyPaginationUnion$outboundSchema.parse(
      restCollectMethodPostWithBodyPaginationUnion,
    ),
  );
}
export function restCollectMethodPostWithBodyPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyPaginationUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyPaginationUnion$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyAuthentication$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyAuthentication,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RestCollectMethodPostWithBodyAuthentication);
/** @internal */
export const RestCollectMethodPostWithBodyAuthentication$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestCollectMethodPostWithBodyAuthentication> =
    openEnums.outboundSchema(RestCollectMethodPostWithBodyAuthentication);

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    multiplier: types.optional(types.number()),
    maxIntervalMs: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.boolean().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    multiplier: z.number().optional(),
    maxIntervalMs: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue,
      ),
  );
}
export function restCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    multiplier: types.optional(types.number()),
    maxIntervalMs: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: boolean | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.boolean().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    multiplier: z.number().optional(),
    maxIntervalMs: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse,
      ),
  );
}
export function restCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$Outbound =
  | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restCollectMethodPostWithBodyRestRetryRulesTypeBackoffToJSON(
  restCollectMethodPostWithBodyRestRetryRulesTypeBackoff:
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$outboundSchema.parse(
      restCollectMethodPostWithBodyRestRetryRulesTypeBackoff,
    ),
  );
}
export function restCollectMethodPostWithBodyRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.boolean().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue:
    RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue,
      ),
  );
}
export function restCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: boolean | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.boolean().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse:
    RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse,
      ),
  );
}
export function restCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$Outbound =
  | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restCollectMethodPostWithBodyRestRetryRulesTypeStaticToJSON(
  restCollectMethodPostWithBodyRestRetryRulesTypeStatic:
    RestCollectMethodPostWithBodyRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$outboundSchema.parse(
      restCollectMethodPostWithBodyRestRetryRulesTypeStatic,
    ),
  );
}
export function restCollectMethodPostWithBodyRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestRetryRulesTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restCollectMethodPostWithBodyRestRetryRulesTypeNoneToJSON(
  restCollectMethodPostWithBodyRestRetryRulesTypeNone:
    RestCollectMethodPostWithBodyRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestRetryRulesTypeNone$outboundSchema.parse(
      restCollectMethodPostWithBodyRestRetryRulesTypeNone,
    ),
  );
}
export function restCollectMethodPostWithBodyRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRetryRules$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestCollectMethodPostWithBodyRestRetryRulesTypeNone$inboundSchema
  ),
  static: smartUnion([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  backoff: smartUnion([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
});
/** @internal */
export type RestCollectMethodPostWithBodyRetryRules$Outbound =
  | RestCollectMethodPostWithBodyRestRetryRulesTypeNone$Outbound
  | (
    | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
      & { type: "static" }
  )
  | (
    | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestCollectMethodPostWithBodyRetryRules$outboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyRetryRules$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostWithBodyRetryRules
> = z.union([
  z.lazy(() =>
    RestCollectMethodPostWithBodyRestRetryRulesTypeNone$outboundSchema
  ),
  smartUnion([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  smartUnion([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
]);

export function restCollectMethodPostWithBodyRetryRulesToJSON(
  restCollectMethodPostWithBodyRetryRules:
    RestCollectMethodPostWithBodyRetryRules,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRetryRules$outboundSchema.parse(
      restCollectMethodPostWithBodyRetryRules,
    ),
  );
}
export function restCollectMethodPostWithBodyRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyRetryRules' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyStateTracking$inboundSchema:
  z.ZodType<RestCollectMethodPostWithBodyStateTracking, z.ZodTypeDef, unknown> =
    z.object({
      enabled: types.optional(types.boolean()),
    });
/** @internal */
export type RestCollectMethodPostWithBodyStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestCollectMethodPostWithBodyStateTracking$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyStateTracking$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyStateTrackingToJSON(
  restCollectMethodPostWithBodyStateTracking:
    RestCollectMethodPostWithBodyStateTracking,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyStateTracking$outboundSchema.parse(
      restCollectMethodPostWithBodyStateTracking,
    ),
  );
}
export function restCollectMethodPostWithBodyStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyStateTracking' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyScheduling$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestCollectMethodPostWithBodyStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestCollectMethodPostWithBodyScheduling$Outbound = {
  stateTracking?:
    | RestCollectMethodPostWithBodyStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestCollectMethodPostWithBodyScheduling$outboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyScheduling$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostWithBodyScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestCollectMethodPostWithBodyStateTracking$outboundSchema
  ).optional(),
});

export function restCollectMethodPostWithBodySchedulingToJSON(
  restCollectMethodPostWithBodyScheduling:
    RestCollectMethodPostWithBodyScheduling,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyScheduling$outboundSchema.parse(
      restCollectMethodPostWithBodyScheduling,
    ),
  );
}
export function restCollectMethodPostWithBodySchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyScheduling' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBody$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: RestCollectMethodPostWithBodyCollectMethod$inboundSchema,
  collectBody: types.string(),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  authentication: RestCollectMethodPostWithBodyAuthentication$inboundSchema,
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestCollectMethodPostWithBodyScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestCollectMethodPostWithBody$Outbound = {
  collectMethod: string;
  collectBody: string;
  discovery?:
    | (
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$Outbound
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$Outbound
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestCollectMethodPostWithBodyRestPaginationTypeNone$Outbound
    | RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$Outbound
    | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$Outbound
    | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$Outbound
    | RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$Outbound
    | RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$Outbound
    | undefined;
  authentication: string;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestCollectMethodPostWithBodyRestRetryRulesTypeNone$Outbound
    | (
      | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?: RestCollectMethodPostWithBodyScheduling$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodPostWithBody$outboundSchema: z.ZodType<
  RestCollectMethodPostWithBody$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostWithBody
> = z.object({
  collectMethod: RestCollectMethodPostWithBodyCollectMethod$outboundSchema,
  collectBody: z.string(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  authentication: RestCollectMethodPostWithBodyAuthentication$outboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeNone$outboundSchema
    ),
    smartUnion([
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]).optional(),
  __scheduling: z.lazy(() =>
    RestCollectMethodPostWithBodyScheduling$outboundSchema
  ).optional(),
});

export function restCollectMethodPostWithBodyToJSON(
  restCollectMethodPostWithBody: RestCollectMethodPostWithBody,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBody$outboundSchema.parse(
      restCollectMethodPostWithBody,
    ),
  );
}
export function restCollectMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostWithBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPostWithBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostCollectMethod$inboundSchema: z.ZodType<
  RestCollectMethodPostCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodPostCollectMethod);
/** @internal */
export const RestCollectMethodPostCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodPostCollectMethod
> = openEnums.outboundSchema(RestCollectMethodPostCollectMethod);

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeNone$Outbound = {
  discoverType: "none";
};

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeNoneToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeNone:
    RestCollectMethodPostRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeNone$outboundSchema.parse(
      restCollectMethodPostRestDiscoveryDiscoverTypeNone,
    ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeList$Outbound = {
  discoverType: "list";
  itemList: Array<string>;
};

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeListToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeList:
    RestCollectMethodPostRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeList$outboundSchema.parse(
      restCollectMethodPostRestDiscoveryDiscoverTypeList,
    ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeList$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeJson$Outbound = {
  discoverType: "json";
  manualDiscoverResult: string;
  discoverDataField?: string | undefined;
};

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeJsonToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeJson:
    RestCollectMethodPostRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeJson$outboundSchema.parse(
      restCollectMethodPostRestDiscoveryDiscoverTypeJson,
    ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeJson$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.string(),
    discoverBody: types.optional(types.string()),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb: string;
    discoverBody?: string | undefined;
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.string(),
    discoverBody: z.string().optional(),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.string(),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody: string;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.string(),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
