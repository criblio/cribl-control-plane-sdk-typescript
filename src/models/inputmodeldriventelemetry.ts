/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  ConnectionsType,
  ConnectionsType$inboundSchema,
  ConnectionsType$Outbound,
  ConnectionsType$outboundSchema,
} from "./connectionstype.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  Metadata1Type,
  Metadata1Type$inboundSchema,
  Metadata1Type$Outbound,
  Metadata1Type$outboundSchema,
} from "./metadata1type.js";
import {
  PqType,
  PqType$inboundSchema,
  PqType$Outbound,
  PqType$outboundSchema,
} from "./pqtype.js";
import {
  Tls2Type,
  Tls2Type$inboundSchema,
  Tls2Type$Outbound,
  Tls2Type$outboundSchema,
} from "./tls2type.js";

export const InputModelDrivenTelemetryType4 = {
  ModelDrivenTelemetry: "model_driven_telemetry",
} as const;
export type InputModelDrivenTelemetryType4 = ClosedEnum<
  typeof InputModelDrivenTelemetryType4
>;

export type InputModelDrivenTelemetryModelDrivenTelemetry4 = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputModelDrivenTelemetryType4;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq: PqType;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port?: number | undefined;
  tls?: Tls2Type | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * Time in milliseconds to allow the server to shutdown gracefully before forcing shutdown. Defaults to 5000.
   */
  shutdownTimeoutMs?: number | undefined;
  description?: string | undefined;
};

export const InputModelDrivenTelemetryType3 = {
  ModelDrivenTelemetry: "model_driven_telemetry",
} as const;
export type InputModelDrivenTelemetryType3 = ClosedEnum<
  typeof InputModelDrivenTelemetryType3
>;

export type InputModelDrivenTelemetryModelDrivenTelemetry3 = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputModelDrivenTelemetryType3;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port?: number | undefined;
  tls?: Tls2Type | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * Time in milliseconds to allow the server to shutdown gracefully before forcing shutdown. Defaults to 5000.
   */
  shutdownTimeoutMs?: number | undefined;
  description?: string | undefined;
};

export const InputModelDrivenTelemetryType2 = {
  ModelDrivenTelemetry: "model_driven_telemetry",
} as const;
export type InputModelDrivenTelemetryType2 = ClosedEnum<
  typeof InputModelDrivenTelemetryType2
>;

export type InputModelDrivenTelemetryModelDrivenTelemetry2 = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputModelDrivenTelemetryType2;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections: Array<ConnectionsType>;
  pq?: PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port?: number | undefined;
  tls?: Tls2Type | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * Time in milliseconds to allow the server to shutdown gracefully before forcing shutdown. Defaults to 5000.
   */
  shutdownTimeoutMs?: number | undefined;
  description?: string | undefined;
};

export const InputModelDrivenTelemetryType1 = {
  ModelDrivenTelemetry: "model_driven_telemetry",
} as const;
export type InputModelDrivenTelemetryType1 = ClosedEnum<
  typeof InputModelDrivenTelemetryType1
>;

export type InputModelDrivenTelemetryModelDrivenTelemetry1 = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputModelDrivenTelemetryType1;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port?: number | undefined;
  tls?: Tls2Type | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * Time in milliseconds to allow the server to shutdown gracefully before forcing shutdown. Defaults to 5000.
   */
  shutdownTimeoutMs?: number | undefined;
  description?: string | undefined;
};

export type InputModelDrivenTelemetry =
  | InputModelDrivenTelemetryModelDrivenTelemetry2
  | InputModelDrivenTelemetryModelDrivenTelemetry4
  | InputModelDrivenTelemetryModelDrivenTelemetry1
  | InputModelDrivenTelemetryModelDrivenTelemetry3;

/** @internal */
export const InputModelDrivenTelemetryType4$inboundSchema: z.ZodNativeEnum<
  typeof InputModelDrivenTelemetryType4
> = z.nativeEnum(InputModelDrivenTelemetryType4);
/** @internal */
export const InputModelDrivenTelemetryType4$outboundSchema: z.ZodNativeEnum<
  typeof InputModelDrivenTelemetryType4
> = InputModelDrivenTelemetryType4$inboundSchema;

/** @internal */
export const InputModelDrivenTelemetryModelDrivenTelemetry4$inboundSchema:
  z.ZodType<
    InputModelDrivenTelemetryModelDrivenTelemetry4,
    z.ZodTypeDef,
    unknown
  > = z.object({
    pqEnabled: z.boolean().default(false),
    id: z.string().optional(),
    type: InputModelDrivenTelemetryType4$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ConnectionsType$inboundSchema).optional(),
    pq: PqType$inboundSchema,
    host: z.string().default("0.0.0.0"),
    port: z.number().default(57000),
    tls: Tls2Type$inboundSchema.optional(),
    metadata: z.array(Metadata1Type$inboundSchema).optional(),
    maxActiveCxn: z.number().default(1000),
    shutdownTimeoutMs: z.number().default(5000),
    description: z.string().optional(),
  });
/** @internal */
export type InputModelDrivenTelemetryModelDrivenTelemetry4$Outbound = {
  pqEnabled: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq: PqType$Outbound;
  host: string;
  port: number;
  tls?: Tls2Type$Outbound | undefined;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  maxActiveCxn: number;
  shutdownTimeoutMs: number;
  description?: string | undefined;
};

/** @internal */
export const InputModelDrivenTelemetryModelDrivenTelemetry4$outboundSchema:
  z.ZodType<
    InputModelDrivenTelemetryModelDrivenTelemetry4$Outbound,
    z.ZodTypeDef,
    InputModelDrivenTelemetryModelDrivenTelemetry4
  > = z.object({
    pqEnabled: z.boolean().default(false),
    id: z.string().optional(),
    type: InputModelDrivenTelemetryType4$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ConnectionsType$outboundSchema).optional(),
    pq: PqType$outboundSchema,
    host: z.string().default("0.0.0.0"),
    port: z.number().default(57000),
    tls: Tls2Type$outboundSchema.optional(),
    metadata: z.array(Metadata1Type$outboundSchema).optional(),
    maxActiveCxn: z.number().default(1000),
    shutdownTimeoutMs: z.number().default(5000),
    description: z.string().optional(),
  });

export function inputModelDrivenTelemetryModelDrivenTelemetry4ToJSON(
  inputModelDrivenTelemetryModelDrivenTelemetry4:
    InputModelDrivenTelemetryModelDrivenTelemetry4,
): string {
  return JSON.stringify(
    InputModelDrivenTelemetryModelDrivenTelemetry4$outboundSchema.parse(
      inputModelDrivenTelemetryModelDrivenTelemetry4,
    ),
  );
}
export function inputModelDrivenTelemetryModelDrivenTelemetry4FromJSON(
  jsonString: string,
): SafeParseResult<
  InputModelDrivenTelemetryModelDrivenTelemetry4,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputModelDrivenTelemetryModelDrivenTelemetry4$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputModelDrivenTelemetryModelDrivenTelemetry4' from JSON`,
  );
}

/** @internal */
export const InputModelDrivenTelemetryType3$inboundSchema: z.ZodNativeEnum<
  typeof InputModelDrivenTelemetryType3
> = z.nativeEnum(InputModelDrivenTelemetryType3);
/** @internal */
export const InputModelDrivenTelemetryType3$outboundSchema: z.ZodNativeEnum<
  typeof InputModelDrivenTelemetryType3
> = InputModelDrivenTelemetryType3$inboundSchema;

/** @internal */
export const InputModelDrivenTelemetryModelDrivenTelemetry3$inboundSchema:
  z.ZodType<
    InputModelDrivenTelemetryModelDrivenTelemetry3,
    z.ZodTypeDef,
    unknown
  > = z.object({
    pqEnabled: z.boolean().default(false),
    id: z.string().optional(),
    type: InputModelDrivenTelemetryType3$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ConnectionsType$inboundSchema).optional(),
    pq: PqType$inboundSchema.optional(),
    host: z.string().default("0.0.0.0"),
    port: z.number().default(57000),
    tls: Tls2Type$inboundSchema.optional(),
    metadata: z.array(Metadata1Type$inboundSchema).optional(),
    maxActiveCxn: z.number().default(1000),
    shutdownTimeoutMs: z.number().default(5000),
    description: z.string().optional(),
  });
/** @internal */
export type InputModelDrivenTelemetryModelDrivenTelemetry3$Outbound = {
  pqEnabled: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: Tls2Type$Outbound | undefined;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  maxActiveCxn: number;
  shutdownTimeoutMs: number;
  description?: string | undefined;
};

/** @internal */
export const InputModelDrivenTelemetryModelDrivenTelemetry3$outboundSchema:
  z.ZodType<
    InputModelDrivenTelemetryModelDrivenTelemetry3$Outbound,
    z.ZodTypeDef,
    InputModelDrivenTelemetryModelDrivenTelemetry3
  > = z.object({
    pqEnabled: z.boolean().default(false),
    id: z.string().optional(),
    type: InputModelDrivenTelemetryType3$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ConnectionsType$outboundSchema).optional(),
    pq: PqType$outboundSchema.optional(),
    host: z.string().default("0.0.0.0"),
    port: z.number().default(57000),
    tls: Tls2Type$outboundSchema.optional(),
    metadata: z.array(Metadata1Type$outboundSchema).optional(),
    maxActiveCxn: z.number().default(1000),
    shutdownTimeoutMs: z.number().default(5000),
    description: z.string().optional(),
  });

export function inputModelDrivenTelemetryModelDrivenTelemetry3ToJSON(
  inputModelDrivenTelemetryModelDrivenTelemetry3:
    InputModelDrivenTelemetryModelDrivenTelemetry3,
): string {
  return JSON.stringify(
    InputModelDrivenTelemetryModelDrivenTelemetry3$outboundSchema.parse(
      inputModelDrivenTelemetryModelDrivenTelemetry3,
    ),
  );
}
export function inputModelDrivenTelemetryModelDrivenTelemetry3FromJSON(
  jsonString: string,
): SafeParseResult<
  InputModelDrivenTelemetryModelDrivenTelemetry3,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputModelDrivenTelemetryModelDrivenTelemetry3$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputModelDrivenTelemetryModelDrivenTelemetry3' from JSON`,
  );
}

/** @internal */
export const InputModelDrivenTelemetryType2$inboundSchema: z.ZodNativeEnum<
  typeof InputModelDrivenTelemetryType2
> = z.nativeEnum(InputModelDrivenTelemetryType2);
/** @internal */
export const InputModelDrivenTelemetryType2$outboundSchema: z.ZodNativeEnum<
  typeof InputModelDrivenTelemetryType2
> = InputModelDrivenTelemetryType2$inboundSchema;

/** @internal */
export const InputModelDrivenTelemetryModelDrivenTelemetry2$inboundSchema:
  z.ZodType<
    InputModelDrivenTelemetryModelDrivenTelemetry2,
    z.ZodTypeDef,
    unknown
  > = z.object({
    sendToRoutes: z.boolean().default(true),
    id: z.string().optional(),
    type: InputModelDrivenTelemetryType2$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ConnectionsType$inboundSchema),
    pq: PqType$inboundSchema.optional(),
    host: z.string().default("0.0.0.0"),
    port: z.number().default(57000),
    tls: Tls2Type$inboundSchema.optional(),
    metadata: z.array(Metadata1Type$inboundSchema).optional(),
    maxActiveCxn: z.number().default(1000),
    shutdownTimeoutMs: z.number().default(5000),
    description: z.string().optional(),
  });
/** @internal */
export type InputModelDrivenTelemetryModelDrivenTelemetry2$Outbound = {
  sendToRoutes: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections: Array<ConnectionsType$Outbound>;
  pq?: PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: Tls2Type$Outbound | undefined;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  maxActiveCxn: number;
  shutdownTimeoutMs: number;
  description?: string | undefined;
};

/** @internal */
export const InputModelDrivenTelemetryModelDrivenTelemetry2$outboundSchema:
  z.ZodType<
    InputModelDrivenTelemetryModelDrivenTelemetry2$Outbound,
    z.ZodTypeDef,
    InputModelDrivenTelemetryModelDrivenTelemetry2
  > = z.object({
    sendToRoutes: z.boolean().default(true),
    id: z.string().optional(),
    type: InputModelDrivenTelemetryType2$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ConnectionsType$outboundSchema),
    pq: PqType$outboundSchema.optional(),
    host: z.string().default("0.0.0.0"),
    port: z.number().default(57000),
    tls: Tls2Type$outboundSchema.optional(),
    metadata: z.array(Metadata1Type$outboundSchema).optional(),
    maxActiveCxn: z.number().default(1000),
    shutdownTimeoutMs: z.number().default(5000),
    description: z.string().optional(),
  });

export function inputModelDrivenTelemetryModelDrivenTelemetry2ToJSON(
  inputModelDrivenTelemetryModelDrivenTelemetry2:
    InputModelDrivenTelemetryModelDrivenTelemetry2,
): string {
  return JSON.stringify(
    InputModelDrivenTelemetryModelDrivenTelemetry2$outboundSchema.parse(
      inputModelDrivenTelemetryModelDrivenTelemetry2,
    ),
  );
}
export function inputModelDrivenTelemetryModelDrivenTelemetry2FromJSON(
  jsonString: string,
): SafeParseResult<
  InputModelDrivenTelemetryModelDrivenTelemetry2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputModelDrivenTelemetryModelDrivenTelemetry2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputModelDrivenTelemetryModelDrivenTelemetry2' from JSON`,
  );
}

/** @internal */
export const InputModelDrivenTelemetryType1$inboundSchema: z.ZodNativeEnum<
  typeof InputModelDrivenTelemetryType1
> = z.nativeEnum(InputModelDrivenTelemetryType1);
/** @internal */
export const InputModelDrivenTelemetryType1$outboundSchema: z.ZodNativeEnum<
  typeof InputModelDrivenTelemetryType1
> = InputModelDrivenTelemetryType1$inboundSchema;

/** @internal */
export const InputModelDrivenTelemetryModelDrivenTelemetry1$inboundSchema:
  z.ZodType<
    InputModelDrivenTelemetryModelDrivenTelemetry1,
    z.ZodTypeDef,
    unknown
  > = z.object({
    sendToRoutes: z.boolean().default(true),
    id: z.string().optional(),
    type: InputModelDrivenTelemetryType1$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ConnectionsType$inboundSchema).optional(),
    pq: PqType$inboundSchema.optional(),
    host: z.string().default("0.0.0.0"),
    port: z.number().default(57000),
    tls: Tls2Type$inboundSchema.optional(),
    metadata: z.array(Metadata1Type$inboundSchema).optional(),
    maxActiveCxn: z.number().default(1000),
    shutdownTimeoutMs: z.number().default(5000),
    description: z.string().optional(),
  });
/** @internal */
export type InputModelDrivenTelemetryModelDrivenTelemetry1$Outbound = {
  sendToRoutes: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: Tls2Type$Outbound | undefined;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  maxActiveCxn: number;
  shutdownTimeoutMs: number;
  description?: string | undefined;
};

/** @internal */
export const InputModelDrivenTelemetryModelDrivenTelemetry1$outboundSchema:
  z.ZodType<
    InputModelDrivenTelemetryModelDrivenTelemetry1$Outbound,
    z.ZodTypeDef,
    InputModelDrivenTelemetryModelDrivenTelemetry1
  > = z.object({
    sendToRoutes: z.boolean().default(true),
    id: z.string().optional(),
    type: InputModelDrivenTelemetryType1$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ConnectionsType$outboundSchema).optional(),
    pq: PqType$outboundSchema.optional(),
    host: z.string().default("0.0.0.0"),
    port: z.number().default(57000),
    tls: Tls2Type$outboundSchema.optional(),
    metadata: z.array(Metadata1Type$outboundSchema).optional(),
    maxActiveCxn: z.number().default(1000),
    shutdownTimeoutMs: z.number().default(5000),
    description: z.string().optional(),
  });

export function inputModelDrivenTelemetryModelDrivenTelemetry1ToJSON(
  inputModelDrivenTelemetryModelDrivenTelemetry1:
    InputModelDrivenTelemetryModelDrivenTelemetry1,
): string {
  return JSON.stringify(
    InputModelDrivenTelemetryModelDrivenTelemetry1$outboundSchema.parse(
      inputModelDrivenTelemetryModelDrivenTelemetry1,
    ),
  );
}
export function inputModelDrivenTelemetryModelDrivenTelemetry1FromJSON(
  jsonString: string,
): SafeParseResult<
  InputModelDrivenTelemetryModelDrivenTelemetry1,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputModelDrivenTelemetryModelDrivenTelemetry1$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputModelDrivenTelemetryModelDrivenTelemetry1' from JSON`,
  );
}

/** @internal */
export const InputModelDrivenTelemetry$inboundSchema: z.ZodType<
  InputModelDrivenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => InputModelDrivenTelemetryModelDrivenTelemetry2$inboundSchema),
  z.lazy(() => InputModelDrivenTelemetryModelDrivenTelemetry4$inboundSchema),
  z.lazy(() => InputModelDrivenTelemetryModelDrivenTelemetry1$inboundSchema),
  z.lazy(() => InputModelDrivenTelemetryModelDrivenTelemetry3$inboundSchema),
]);
/** @internal */
export type InputModelDrivenTelemetry$Outbound =
  | InputModelDrivenTelemetryModelDrivenTelemetry2$Outbound
  | InputModelDrivenTelemetryModelDrivenTelemetry4$Outbound
  | InputModelDrivenTelemetryModelDrivenTelemetry1$Outbound
  | InputModelDrivenTelemetryModelDrivenTelemetry3$Outbound;

/** @internal */
export const InputModelDrivenTelemetry$outboundSchema: z.ZodType<
  InputModelDrivenTelemetry$Outbound,
  z.ZodTypeDef,
  InputModelDrivenTelemetry
> = z.union([
  z.lazy(() => InputModelDrivenTelemetryModelDrivenTelemetry2$outboundSchema),
  z.lazy(() => InputModelDrivenTelemetryModelDrivenTelemetry4$outboundSchema),
  z.lazy(() => InputModelDrivenTelemetryModelDrivenTelemetry1$outboundSchema),
  z.lazy(() => InputModelDrivenTelemetryModelDrivenTelemetry3$outboundSchema),
]);

export function inputModelDrivenTelemetryToJSON(
  inputModelDrivenTelemetry: InputModelDrivenTelemetry,
): string {
  return JSON.stringify(
    InputModelDrivenTelemetry$outboundSchema.parse(inputModelDrivenTelemetry),
  );
}
export function inputModelDrivenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<InputModelDrivenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputModelDrivenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputModelDrivenTelemetry' from JSON`,
  );
}
