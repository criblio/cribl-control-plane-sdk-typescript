/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

/**
 * The algorithm to use when performing HTTP retries
 */
export const RetryType = {
  /**
   * Disabled
   */
  None: "none",
  /**
   * Backoff
   */
  Backoff: "backoff",
  /**
   * Static
   */
  Static: "static",
} as const;
/**
 * The algorithm to use when performing HTTP retries
 */
export type RetryType = OpenEnum<typeof RetryType>;

export type RetryRulesType = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryType | undefined;
  /**
   * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * The maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
   */
  multiplier?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

/** @internal */
export const RetryType$inboundSchema: z.ZodType<
  RetryType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RetryType),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const RetryType$outboundSchema: z.ZodType<
  RetryType,
  z.ZodTypeDef,
  RetryType
> = z.union([
  z.nativeEnum(RetryType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const RetryRulesType$inboundSchema: z.ZodType<
  RetryRulesType,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryType$inboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});
/** @internal */
export type RetryRulesType$Outbound = {
  type: string;
  interval: number;
  limit: number;
  multiplier: number;
  codes?: Array<number> | undefined;
  enableHeader: boolean;
  retryConnectTimeout: boolean;
  retryConnectReset: boolean;
};

/** @internal */
export const RetryRulesType$outboundSchema: z.ZodType<
  RetryRulesType$Outbound,
  z.ZodTypeDef,
  RetryRulesType
> = z.object({
  type: RetryType$outboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

export function retryRulesTypeToJSON(retryRulesType: RetryRulesType): string {
  return JSON.stringify(RetryRulesType$outboundSchema.parse(retryRulesType));
}
export function retryRulesTypeFromJSON(
  jsonString: string,
): SafeParseResult<RetryRulesType, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetryRulesType$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetryRulesType' from JSON`,
  );
}
