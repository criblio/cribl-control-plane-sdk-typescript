/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export type RetryRulesType = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  /**
   * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * The maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
   */
  multiplier?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

/** @internal */
export const RetryRulesType$inboundSchema: z.ZodType<
  RetryRulesType,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.string(),
  interval: z.number().optional(),
  limit: z.number().optional(),
  multiplier: z.number().optional(),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().optional(),
  retryConnectTimeout: z.boolean().optional(),
  retryConnectReset: z.boolean().optional(),
});
/** @internal */
export type RetryRulesType$Outbound = {
  type: string;
  interval?: number | undefined;
  limit?: number | undefined;
  multiplier?: number | undefined;
  codes?: Array<number> | undefined;
  enableHeader?: boolean | undefined;
  retryConnectTimeout?: boolean | undefined;
  retryConnectReset?: boolean | undefined;
};

/** @internal */
export const RetryRulesType$outboundSchema: z.ZodType<
  RetryRulesType$Outbound,
  z.ZodTypeDef,
  RetryRulesType
> = z.object({
  type: z.string(),
  interval: z.number().optional(),
  limit: z.number().optional(),
  multiplier: z.number().optional(),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().optional(),
  retryConnectTimeout: z.boolean().optional(),
  retryConnectReset: z.boolean().optional(),
});

export function retryRulesTypeToJSON(retryRulesType: RetryRulesType): string {
  return JSON.stringify(RetryRulesType$outboundSchema.parse(retryRulesType));
}
export function retryRulesTypeFromJSON(
  jsonString: string,
): SafeParseResult<RetryRulesType, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetryRulesType$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetryRulesType' from JSON`,
  );
}
