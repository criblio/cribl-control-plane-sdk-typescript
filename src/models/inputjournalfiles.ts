/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeConnections,
  ItemsTypeConnections$inboundSchema,
  ItemsTypeConnections$Outbound,
  ItemsTypeConnections$outboundSchema,
} from "./itemstypeconnections.js";
import {
  ItemsTypeNotificationMetadata,
  ItemsTypeNotificationMetadata$inboundSchema,
  ItemsTypeNotificationMetadata$Outbound,
  ItemsTypeNotificationMetadata$outboundSchema,
} from "./itemstypenotificationmetadata.js";
import {
  PqType,
  PqType$inboundSchema,
  PqType$Outbound,
  PqType$outboundSchema,
} from "./pqtype.js";

export const InputJournalFilesPqEnabledTrueWithPqConstraintType = {
  JournalFiles: "journal_files",
} as const;
export type InputJournalFilesPqEnabledTrueWithPqConstraintType = ClosedEnum<
  typeof InputJournalFilesPqEnabledTrueWithPqConstraintType
>;

export type PqEnabledTrueWithPqConstraintRule = {
  /**
   * JavaScript expression applied to Journal objects. Return 'true' to include it.
   */
  filter: string;
  /**
   * Optional description of this rule's purpose
   */
  description?: string | undefined;
};

export type InputJournalFilesPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  pq?: PqType | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputJournalFilesPqEnabledTrueWithPqConstraintType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnections> | undefined;
  /**
   * Directory path to search for journals. Environment variables will be resolved, e.g. $CRIBL_EDGE_FS_ROOT/var/log/journal/$MACHINE_ID.
   */
  path: string;
  /**
   * Time, in seconds, between scanning for journals.
   */
  interval?: number | undefined;
  /**
   * The full path of discovered journals are matched against this wildcard list.
   */
  journals: Array<string>;
  /**
   * Add rules to decide which journal objects to allow. Events are generated if no rules are given or if all the rules' expressions evaluate to true.
   */
  rules?: Array<PqEnabledTrueWithPqConstraintRule> | undefined;
  /**
   * Skip log messages that are not part of the current boot session.
   */
  currentBoot?: boolean | undefined;
  /**
   * The maximum log message age, in duration form (e.g,: 60s, 4h, 3d, 1w).  Default of no value will apply no max age filters.
   */
  maxAgeDur?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export const InputJournalFilesPqEnabledFalseWithPqConstraintType = {
  JournalFiles: "journal_files",
} as const;
export type InputJournalFilesPqEnabledFalseWithPqConstraintType = ClosedEnum<
  typeof InputJournalFilesPqEnabledFalseWithPqConstraintType
>;

export type PqEnabledFalseWithPqConstraintRule = {
  /**
   * JavaScript expression applied to Journal objects. Return 'true' to include it.
   */
  filter: string;
  /**
   * Optional description of this rule's purpose
   */
  description?: string | undefined;
};

export type InputJournalFilesPqEnabledFalseWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  pq?: PqType | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputJournalFilesPqEnabledFalseWithPqConstraintType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnections> | undefined;
  /**
   * Directory path to search for journals. Environment variables will be resolved, e.g. $CRIBL_EDGE_FS_ROOT/var/log/journal/$MACHINE_ID.
   */
  path: string;
  /**
   * Time, in seconds, between scanning for journals.
   */
  interval?: number | undefined;
  /**
   * The full path of discovered journals are matched against this wildcard list.
   */
  journals: Array<string>;
  /**
   * Add rules to decide which journal objects to allow. Events are generated if no rules are given or if all the rules' expressions evaluate to true.
   */
  rules?: Array<PqEnabledFalseWithPqConstraintRule> | undefined;
  /**
   * Skip log messages that are not part of the current boot session.
   */
  currentBoot?: boolean | undefined;
  /**
   * The maximum log message age, in duration form (e.g,: 60s, 4h, 3d, 1w).  Default of no value will apply no max age filters.
   */
  maxAgeDur?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export const InputJournalFilesSendToRoutesFalseWithConnectionsConstraintType = {
  JournalFiles: "journal_files",
} as const;
export type InputJournalFilesSendToRoutesFalseWithConnectionsConstraintType =
  ClosedEnum<
    typeof InputJournalFilesSendToRoutesFalseWithConnectionsConstraintType
  >;

export type SendToRoutesFalseWithConnectionsConstraintRule = {
  /**
   * JavaScript expression applied to Journal objects. Return 'true' to include it.
   */
  filter: string;
  /**
   * Optional description of this rule's purpose
   */
  description?: string | undefined;
};

export type InputJournalFilesSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnections> | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputJournalFilesSendToRoutesFalseWithConnectionsConstraintType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: PqType | undefined;
  /**
   * Directory path to search for journals. Environment variables will be resolved, e.g. $CRIBL_EDGE_FS_ROOT/var/log/journal/$MACHINE_ID.
   */
  path: string;
  /**
   * Time, in seconds, between scanning for journals.
   */
  interval?: number | undefined;
  /**
   * The full path of discovered journals are matched against this wildcard list.
   */
  journals: Array<string>;
  /**
   * Add rules to decide which journal objects to allow. Events are generated if no rules are given or if all the rules' expressions evaluate to true.
   */
  rules?: Array<SendToRoutesFalseWithConnectionsConstraintRule> | undefined;
  /**
   * Skip log messages that are not part of the current boot session.
   */
  currentBoot?: boolean | undefined;
  /**
   * The maximum log message age, in duration form (e.g,: 60s, 4h, 3d, 1w).  Default of no value will apply no max age filters.
   */
  maxAgeDur?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export const InputJournalFilesSendToRoutesTrueWithConnectionsConstraintType = {
  JournalFiles: "journal_files",
} as const;
export type InputJournalFilesSendToRoutesTrueWithConnectionsConstraintType =
  ClosedEnum<
    typeof InputJournalFilesSendToRoutesTrueWithConnectionsConstraintType
  >;

export type SendToRoutesTrueWithConnectionsConstraintRule = {
  /**
   * JavaScript expression applied to Journal objects. Return 'true' to include it.
   */
  filter: string;
  /**
   * Optional description of this rule's purpose
   */
  description?: string | undefined;
};

export type InputJournalFilesSendToRoutesTrueWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnections> | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputJournalFilesSendToRoutesTrueWithConnectionsConstraintType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: PqType | undefined;
  /**
   * Directory path to search for journals. Environment variables will be resolved, e.g. $CRIBL_EDGE_FS_ROOT/var/log/journal/$MACHINE_ID.
   */
  path: string;
  /**
   * Time, in seconds, between scanning for journals.
   */
  interval?: number | undefined;
  /**
   * The full path of discovered journals are matched against this wildcard list.
   */
  journals: Array<string>;
  /**
   * Add rules to decide which journal objects to allow. Events are generated if no rules are given or if all the rules' expressions evaluate to true.
   */
  rules?: Array<SendToRoutesTrueWithConnectionsConstraintRule> | undefined;
  /**
   * Skip log messages that are not part of the current boot session.
   */
  currentBoot?: boolean | undefined;
  /**
   * The maximum log message age, in duration form (e.g,: 60s, 4h, 3d, 1w).  Default of no value will apply no max age filters.
   */
  maxAgeDur?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputJournalFiles =
  | InputJournalFilesSendToRoutesTrueWithConnectionsConstraint
  | InputJournalFilesSendToRoutesFalseWithConnectionsConstraint
  | InputJournalFilesPqEnabledFalseWithPqConstraint
  | InputJournalFilesPqEnabledTrueWithPqConstraint;

/** @internal */
export const InputJournalFilesPqEnabledTrueWithPqConstraintType$inboundSchema:
  z.ZodNativeEnum<typeof InputJournalFilesPqEnabledTrueWithPqConstraintType> = z
    .nativeEnum(InputJournalFilesPqEnabledTrueWithPqConstraintType);
/** @internal */
export const InputJournalFilesPqEnabledTrueWithPqConstraintType$outboundSchema:
  z.ZodNativeEnum<typeof InputJournalFilesPqEnabledTrueWithPqConstraintType> =
    InputJournalFilesPqEnabledTrueWithPqConstraintType$inboundSchema;

/** @internal */
export const PqEnabledTrueWithPqConstraintRule$inboundSchema: z.ZodType<
  PqEnabledTrueWithPqConstraintRule,
  z.ZodTypeDef,
  unknown
> = z.object({
  filter: z.string(),
  description: z.string().optional(),
});
/** @internal */
export type PqEnabledTrueWithPqConstraintRule$Outbound = {
  filter: string;
  description?: string | undefined;
};

/** @internal */
export const PqEnabledTrueWithPqConstraintRule$outboundSchema: z.ZodType<
  PqEnabledTrueWithPqConstraintRule$Outbound,
  z.ZodTypeDef,
  PqEnabledTrueWithPqConstraintRule
> = z.object({
  filter: z.string(),
  description: z.string().optional(),
});

export function pqEnabledTrueWithPqConstraintRuleToJSON(
  pqEnabledTrueWithPqConstraintRule: PqEnabledTrueWithPqConstraintRule,
): string {
  return JSON.stringify(
    PqEnabledTrueWithPqConstraintRule$outboundSchema.parse(
      pqEnabledTrueWithPqConstraintRule,
    ),
  );
}
export function pqEnabledTrueWithPqConstraintRuleFromJSON(
  jsonString: string,
): SafeParseResult<PqEnabledTrueWithPqConstraintRule, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqEnabledTrueWithPqConstraintRule$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqEnabledTrueWithPqConstraintRule' from JSON`,
  );
}

/** @internal */
export const InputJournalFilesPqEnabledTrueWithPqConstraint$inboundSchema:
  z.ZodType<
    InputJournalFilesPqEnabledTrueWithPqConstraint,
    z.ZodTypeDef,
    unknown
  > = z.object({
    pqEnabled: z.boolean().default(false),
    pq: PqType$inboundSchema.optional(),
    id: z.string().optional(),
    type: InputJournalFilesPqEnabledTrueWithPqConstraintType$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnections$inboundSchema).optional(),
    path: z.string(),
    interval: z.number().default(10),
    journals: z.array(z.string()),
    rules: z.array(
      z.lazy(() => PqEnabledTrueWithPqConstraintRule$inboundSchema),
    ).optional(),
    currentBoot: z.boolean().default(false),
    maxAgeDur: z.string().optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
    description: z.string().optional(),
  });
/** @internal */
export type InputJournalFilesPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: PqType$Outbound | undefined;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ItemsTypeConnections$Outbound> | undefined;
  path: string;
  interval: number;
  journals: Array<string>;
  rules?: Array<PqEnabledTrueWithPqConstraintRule$Outbound> | undefined;
  currentBoot: boolean;
  maxAgeDur?: string | undefined;
  metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputJournalFilesPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputJournalFilesPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputJournalFilesPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean().default(false),
    pq: PqType$outboundSchema.optional(),
    id: z.string().optional(),
    type: InputJournalFilesPqEnabledTrueWithPqConstraintType$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnections$outboundSchema).optional(),
    path: z.string(),
    interval: z.number().default(10),
    journals: z.array(z.string()),
    rules: z.array(
      z.lazy(() => PqEnabledTrueWithPqConstraintRule$outboundSchema),
    ).optional(),
    currentBoot: z.boolean().default(false),
    maxAgeDur: z.string().optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
    description: z.string().optional(),
  });

export function inputJournalFilesPqEnabledTrueWithPqConstraintToJSON(
  inputJournalFilesPqEnabledTrueWithPqConstraint:
    InputJournalFilesPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputJournalFilesPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputJournalFilesPqEnabledTrueWithPqConstraint,
    ),
  );
}
export function inputJournalFilesPqEnabledTrueWithPqConstraintFromJSON(
  jsonString: string,
): SafeParseResult<
  InputJournalFilesPqEnabledTrueWithPqConstraint,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputJournalFilesPqEnabledTrueWithPqConstraint$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputJournalFilesPqEnabledTrueWithPqConstraint' from JSON`,
  );
}

/** @internal */
export const InputJournalFilesPqEnabledFalseWithPqConstraintType$inboundSchema:
  z.ZodNativeEnum<typeof InputJournalFilesPqEnabledFalseWithPqConstraintType> =
    z.nativeEnum(InputJournalFilesPqEnabledFalseWithPqConstraintType);
/** @internal */
export const InputJournalFilesPqEnabledFalseWithPqConstraintType$outboundSchema:
  z.ZodNativeEnum<typeof InputJournalFilesPqEnabledFalseWithPqConstraintType> =
    InputJournalFilesPqEnabledFalseWithPqConstraintType$inboundSchema;

/** @internal */
export const PqEnabledFalseWithPqConstraintRule$inboundSchema: z.ZodType<
  PqEnabledFalseWithPqConstraintRule,
  z.ZodTypeDef,
  unknown
> = z.object({
  filter: z.string(),
  description: z.string().optional(),
});
/** @internal */
export type PqEnabledFalseWithPqConstraintRule$Outbound = {
  filter: string;
  description?: string | undefined;
};

/** @internal */
export const PqEnabledFalseWithPqConstraintRule$outboundSchema: z.ZodType<
  PqEnabledFalseWithPqConstraintRule$Outbound,
  z.ZodTypeDef,
  PqEnabledFalseWithPqConstraintRule
> = z.object({
  filter: z.string(),
  description: z.string().optional(),
});

export function pqEnabledFalseWithPqConstraintRuleToJSON(
  pqEnabledFalseWithPqConstraintRule: PqEnabledFalseWithPqConstraintRule,
): string {
  return JSON.stringify(
    PqEnabledFalseWithPqConstraintRule$outboundSchema.parse(
      pqEnabledFalseWithPqConstraintRule,
    ),
  );
}
export function pqEnabledFalseWithPqConstraintRuleFromJSON(
  jsonString: string,
): SafeParseResult<PqEnabledFalseWithPqConstraintRule, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      PqEnabledFalseWithPqConstraintRule$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqEnabledFalseWithPqConstraintRule' from JSON`,
  );
}

/** @internal */
export const InputJournalFilesPqEnabledFalseWithPqConstraint$inboundSchema:
  z.ZodType<
    InputJournalFilesPqEnabledFalseWithPqConstraint,
    z.ZodTypeDef,
    unknown
  > = z.object({
    pqEnabled: z.boolean().default(false),
    pq: PqType$inboundSchema.optional(),
    id: z.string().optional(),
    type: InputJournalFilesPqEnabledFalseWithPqConstraintType$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnections$inboundSchema).optional(),
    path: z.string(),
    interval: z.number().default(10),
    journals: z.array(z.string()),
    rules: z.array(
      z.lazy(() => PqEnabledFalseWithPqConstraintRule$inboundSchema),
    ).optional(),
    currentBoot: z.boolean().default(false),
    maxAgeDur: z.string().optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
    description: z.string().optional(),
  });
/** @internal */
export type InputJournalFilesPqEnabledFalseWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: PqType$Outbound | undefined;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ItemsTypeConnections$Outbound> | undefined;
  path: string;
  interval: number;
  journals: Array<string>;
  rules?: Array<PqEnabledFalseWithPqConstraintRule$Outbound> | undefined;
  currentBoot: boolean;
  maxAgeDur?: string | undefined;
  metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputJournalFilesPqEnabledFalseWithPqConstraint$outboundSchema:
  z.ZodType<
    InputJournalFilesPqEnabledFalseWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputJournalFilesPqEnabledFalseWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean().default(false),
    pq: PqType$outboundSchema.optional(),
    id: z.string().optional(),
    type: InputJournalFilesPqEnabledFalseWithPqConstraintType$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnections$outboundSchema).optional(),
    path: z.string(),
    interval: z.number().default(10),
    journals: z.array(z.string()),
    rules: z.array(
      z.lazy(() => PqEnabledFalseWithPqConstraintRule$outboundSchema),
    ).optional(),
    currentBoot: z.boolean().default(false),
    maxAgeDur: z.string().optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
    description: z.string().optional(),
  });

export function inputJournalFilesPqEnabledFalseWithPqConstraintToJSON(
  inputJournalFilesPqEnabledFalseWithPqConstraint:
    InputJournalFilesPqEnabledFalseWithPqConstraint,
): string {
  return JSON.stringify(
    InputJournalFilesPqEnabledFalseWithPqConstraint$outboundSchema.parse(
      inputJournalFilesPqEnabledFalseWithPqConstraint,
    ),
  );
}
export function inputJournalFilesPqEnabledFalseWithPqConstraintFromJSON(
  jsonString: string,
): SafeParseResult<
  InputJournalFilesPqEnabledFalseWithPqConstraint,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputJournalFilesPqEnabledFalseWithPqConstraint$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputJournalFilesPqEnabledFalseWithPqConstraint' from JSON`,
  );
}

/** @internal */
export const InputJournalFilesSendToRoutesFalseWithConnectionsConstraintType$inboundSchema:
  z.ZodNativeEnum<
    typeof InputJournalFilesSendToRoutesFalseWithConnectionsConstraintType
  > = z.nativeEnum(
    InputJournalFilesSendToRoutesFalseWithConnectionsConstraintType,
  );
/** @internal */
export const InputJournalFilesSendToRoutesFalseWithConnectionsConstraintType$outboundSchema:
  z.ZodNativeEnum<
    typeof InputJournalFilesSendToRoutesFalseWithConnectionsConstraintType
  > =
    InputJournalFilesSendToRoutesFalseWithConnectionsConstraintType$inboundSchema;

/** @internal */
export const SendToRoutesFalseWithConnectionsConstraintRule$inboundSchema:
  z.ZodType<
    SendToRoutesFalseWithConnectionsConstraintRule,
    z.ZodTypeDef,
    unknown
  > = z.object({
    filter: z.string(),
    description: z.string().optional(),
  });
/** @internal */
export type SendToRoutesFalseWithConnectionsConstraintRule$Outbound = {
  filter: string;
  description?: string | undefined;
};

/** @internal */
export const SendToRoutesFalseWithConnectionsConstraintRule$outboundSchema:
  z.ZodType<
    SendToRoutesFalseWithConnectionsConstraintRule$Outbound,
    z.ZodTypeDef,
    SendToRoutesFalseWithConnectionsConstraintRule
  > = z.object({
    filter: z.string(),
    description: z.string().optional(),
  });

export function sendToRoutesFalseWithConnectionsConstraintRuleToJSON(
  sendToRoutesFalseWithConnectionsConstraintRule:
    SendToRoutesFalseWithConnectionsConstraintRule,
): string {
  return JSON.stringify(
    SendToRoutesFalseWithConnectionsConstraintRule$outboundSchema.parse(
      sendToRoutesFalseWithConnectionsConstraintRule,
    ),
  );
}
export function sendToRoutesFalseWithConnectionsConstraintRuleFromJSON(
  jsonString: string,
): SafeParseResult<
  SendToRoutesFalseWithConnectionsConstraintRule,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SendToRoutesFalseWithConnectionsConstraintRule$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SendToRoutesFalseWithConnectionsConstraintRule' from JSON`,
  );
}

/** @internal */
export const InputJournalFilesSendToRoutesFalseWithConnectionsConstraint$inboundSchema:
  z.ZodType<
    InputJournalFilesSendToRoutesFalseWithConnectionsConstraint,
    z.ZodTypeDef,
    unknown
  > = z.object({
    sendToRoutes: z.boolean().default(true),
    connections: z.array(ItemsTypeConnections$inboundSchema).optional(),
    id: z.string().optional(),
    type:
      InputJournalFilesSendToRoutesFalseWithConnectionsConstraintType$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    pq: PqType$inboundSchema.optional(),
    path: z.string(),
    interval: z.number().default(10),
    journals: z.array(z.string()),
    rules: z.array(
      z.lazy(() =>
        SendToRoutesFalseWithConnectionsConstraintRule$inboundSchema
      ),
    ).optional(),
    currentBoot: z.boolean().default(false),
    maxAgeDur: z.string().optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
    description: z.string().optional(),
  });
/** @internal */
export type InputJournalFilesSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?: Array<ItemsTypeConnections$Outbound> | undefined;
    id?: string | undefined;
    type: string;
    disabled: boolean;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled: boolean;
    streamtags?: Array<string> | undefined;
    pq?: PqType$Outbound | undefined;
    path: string;
    interval: number;
    journals: Array<string>;
    rules?:
      | Array<SendToRoutesFalseWithConnectionsConstraintRule$Outbound>
      | undefined;
    currentBoot: boolean;
    maxAgeDur?: string | undefined;
    metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
    description?: string | undefined;
  };

/** @internal */
export const InputJournalFilesSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputJournalFilesSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputJournalFilesSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean().default(true),
    connections: z.array(ItemsTypeConnections$outboundSchema).optional(),
    id: z.string().optional(),
    type:
      InputJournalFilesSendToRoutesFalseWithConnectionsConstraintType$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    pq: PqType$outboundSchema.optional(),
    path: z.string(),
    interval: z.number().default(10),
    journals: z.array(z.string()),
    rules: z.array(
      z.lazy(() =>
        SendToRoutesFalseWithConnectionsConstraintRule$outboundSchema
      ),
    ).optional(),
    currentBoot: z.boolean().default(false),
    maxAgeDur: z.string().optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
    description: z.string().optional(),
  });

export function inputJournalFilesSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputJournalFilesSendToRoutesFalseWithConnectionsConstraint:
    InputJournalFilesSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputJournalFilesSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputJournalFilesSendToRoutesFalseWithConnectionsConstraint),
  );
}
export function inputJournalFilesSendToRoutesFalseWithConnectionsConstraintFromJSON(
  jsonString: string,
): SafeParseResult<
  InputJournalFilesSendToRoutesFalseWithConnectionsConstraint,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputJournalFilesSendToRoutesFalseWithConnectionsConstraint$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'InputJournalFilesSendToRoutesFalseWithConnectionsConstraint' from JSON`,
  );
}

/** @internal */
export const InputJournalFilesSendToRoutesTrueWithConnectionsConstraintType$inboundSchema:
  z.ZodNativeEnum<
    typeof InputJournalFilesSendToRoutesTrueWithConnectionsConstraintType
  > = z.nativeEnum(
    InputJournalFilesSendToRoutesTrueWithConnectionsConstraintType,
  );
/** @internal */
export const InputJournalFilesSendToRoutesTrueWithConnectionsConstraintType$outboundSchema:
  z.ZodNativeEnum<
    typeof InputJournalFilesSendToRoutesTrueWithConnectionsConstraintType
  > =
    InputJournalFilesSendToRoutesTrueWithConnectionsConstraintType$inboundSchema;

/** @internal */
export const SendToRoutesTrueWithConnectionsConstraintRule$inboundSchema:
  z.ZodType<
    SendToRoutesTrueWithConnectionsConstraintRule,
    z.ZodTypeDef,
    unknown
  > = z.object({
    filter: z.string(),
    description: z.string().optional(),
  });
/** @internal */
export type SendToRoutesTrueWithConnectionsConstraintRule$Outbound = {
  filter: string;
  description?: string | undefined;
};

/** @internal */
export const SendToRoutesTrueWithConnectionsConstraintRule$outboundSchema:
  z.ZodType<
    SendToRoutesTrueWithConnectionsConstraintRule$Outbound,
    z.ZodTypeDef,
    SendToRoutesTrueWithConnectionsConstraintRule
  > = z.object({
    filter: z.string(),
    description: z.string().optional(),
  });

export function sendToRoutesTrueWithConnectionsConstraintRuleToJSON(
  sendToRoutesTrueWithConnectionsConstraintRule:
    SendToRoutesTrueWithConnectionsConstraintRule,
): string {
  return JSON.stringify(
    SendToRoutesTrueWithConnectionsConstraintRule$outboundSchema.parse(
      sendToRoutesTrueWithConnectionsConstraintRule,
    ),
  );
}
export function sendToRoutesTrueWithConnectionsConstraintRuleFromJSON(
  jsonString: string,
): SafeParseResult<
  SendToRoutesTrueWithConnectionsConstraintRule,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SendToRoutesTrueWithConnectionsConstraintRule$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SendToRoutesTrueWithConnectionsConstraintRule' from JSON`,
  );
}

/** @internal */
export const InputJournalFilesSendToRoutesTrueWithConnectionsConstraint$inboundSchema:
  z.ZodType<
    InputJournalFilesSendToRoutesTrueWithConnectionsConstraint,
    z.ZodTypeDef,
    unknown
  > = z.object({
    sendToRoutes: z.boolean().default(true),
    connections: z.array(ItemsTypeConnections$inboundSchema).optional(),
    id: z.string().optional(),
    type:
      InputJournalFilesSendToRoutesTrueWithConnectionsConstraintType$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    pq: PqType$inboundSchema.optional(),
    path: z.string(),
    interval: z.number().default(10),
    journals: z.array(z.string()),
    rules: z.array(
      z.lazy(() => SendToRoutesTrueWithConnectionsConstraintRule$inboundSchema),
    ).optional(),
    currentBoot: z.boolean().default(false),
    maxAgeDur: z.string().optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
    description: z.string().optional(),
  });
/** @internal */
export type InputJournalFilesSendToRoutesTrueWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?: Array<ItemsTypeConnections$Outbound> | undefined;
    id?: string | undefined;
    type: string;
    disabled: boolean;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled: boolean;
    streamtags?: Array<string> | undefined;
    pq?: PqType$Outbound | undefined;
    path: string;
    interval: number;
    journals: Array<string>;
    rules?:
      | Array<SendToRoutesTrueWithConnectionsConstraintRule$Outbound>
      | undefined;
    currentBoot: boolean;
    maxAgeDur?: string | undefined;
    metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
    description?: string | undefined;
  };

/** @internal */
export const InputJournalFilesSendToRoutesTrueWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputJournalFilesSendToRoutesTrueWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputJournalFilesSendToRoutesTrueWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean().default(true),
    connections: z.array(ItemsTypeConnections$outboundSchema).optional(),
    id: z.string().optional(),
    type:
      InputJournalFilesSendToRoutesTrueWithConnectionsConstraintType$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    pq: PqType$outboundSchema.optional(),
    path: z.string(),
    interval: z.number().default(10),
    journals: z.array(z.string()),
    rules: z.array(
      z.lazy(() =>
        SendToRoutesTrueWithConnectionsConstraintRule$outboundSchema
      ),
    ).optional(),
    currentBoot: z.boolean().default(false),
    maxAgeDur: z.string().optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
    description: z.string().optional(),
  });

export function inputJournalFilesSendToRoutesTrueWithConnectionsConstraintToJSON(
  inputJournalFilesSendToRoutesTrueWithConnectionsConstraint:
    InputJournalFilesSendToRoutesTrueWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputJournalFilesSendToRoutesTrueWithConnectionsConstraint$outboundSchema
      .parse(inputJournalFilesSendToRoutesTrueWithConnectionsConstraint),
  );
}
export function inputJournalFilesSendToRoutesTrueWithConnectionsConstraintFromJSON(
  jsonString: string,
): SafeParseResult<
  InputJournalFilesSendToRoutesTrueWithConnectionsConstraint,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputJournalFilesSendToRoutesTrueWithConnectionsConstraint$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'InputJournalFilesSendToRoutesTrueWithConnectionsConstraint' from JSON`,
  );
}

/** @internal */
export const InputJournalFiles$inboundSchema: z.ZodType<
  InputJournalFiles,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() =>
    InputJournalFilesSendToRoutesTrueWithConnectionsConstraint$inboundSchema
  ),
  z.lazy(() =>
    InputJournalFilesSendToRoutesFalseWithConnectionsConstraint$inboundSchema
  ),
  z.lazy(() => InputJournalFilesPqEnabledFalseWithPqConstraint$inboundSchema),
  z.lazy(() => InputJournalFilesPqEnabledTrueWithPqConstraint$inboundSchema),
]);
/** @internal */
export type InputJournalFiles$Outbound =
  | InputJournalFilesSendToRoutesTrueWithConnectionsConstraint$Outbound
  | InputJournalFilesSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputJournalFilesPqEnabledFalseWithPqConstraint$Outbound
  | InputJournalFilesPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputJournalFiles$outboundSchema: z.ZodType<
  InputJournalFiles$Outbound,
  z.ZodTypeDef,
  InputJournalFiles
> = z.union([
  z.lazy(() =>
    InputJournalFilesSendToRoutesTrueWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() =>
    InputJournalFilesSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputJournalFilesPqEnabledFalseWithPqConstraint$outboundSchema),
  z.lazy(() => InputJournalFilesPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputJournalFilesToJSON(
  inputJournalFiles: InputJournalFiles,
): string {
  return JSON.stringify(
    InputJournalFiles$outboundSchema.parse(inputJournalFiles),
  );
}
export function inputJournalFilesFromJSON(
  jsonString: string,
): SafeParseResult<InputJournalFiles, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputJournalFiles$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputJournalFiles' from JSON`,
  );
}
