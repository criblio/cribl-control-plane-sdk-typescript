/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  MaximumTlsVersionOptionsKafkaSchemaRegistryTls,
  MaximumTlsVersionOptionsKafkaSchemaRegistryTls$inboundSchema,
  MaximumTlsVersionOptionsKafkaSchemaRegistryTls$outboundSchema,
} from "./maximumtlsversionoptionskafkaschemaregistrytls.js";
import {
  MinimumTlsVersionOptionsKafkaSchemaRegistryTls,
  MinimumTlsVersionOptionsKafkaSchemaRegistryTls$inboundSchema,
  MinimumTlsVersionOptionsKafkaSchemaRegistryTls$outboundSchema,
} from "./minimumtlsversionoptionskafkaschemaregistrytls.js";

export type TlsSettingsServerSideType = {
  disabled?: boolean | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Regex matching allowable common names in peer certificates' subject attribute
   */
  commonNameRegex?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  minVersion?: MinimumTlsVersionOptionsKafkaSchemaRegistryTls | undefined;
  maxVersion?: MaximumTlsVersionOptionsKafkaSchemaRegistryTls | undefined;
};

/** @internal */
export const TlsSettingsServerSideType$inboundSchema: z.ZodType<
  TlsSettingsServerSideType,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().optional(),
  requestCert: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  commonNameRegex: z.string().optional(),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  minVersion: MinimumTlsVersionOptionsKafkaSchemaRegistryTls$inboundSchema
    .optional(),
  maxVersion: MaximumTlsVersionOptionsKafkaSchemaRegistryTls$inboundSchema
    .optional(),
});
/** @internal */
export type TlsSettingsServerSideType$Outbound = {
  disabled?: boolean | undefined;
  requestCert?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  commonNameRegex?: string | undefined;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TlsSettingsServerSideType$outboundSchema: z.ZodType<
  TlsSettingsServerSideType$Outbound,
  z.ZodTypeDef,
  TlsSettingsServerSideType
> = z.object({
  disabled: z.boolean().optional(),
  requestCert: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  commonNameRegex: z.string().optional(),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  minVersion: MinimumTlsVersionOptionsKafkaSchemaRegistryTls$outboundSchema
    .optional(),
  maxVersion: MaximumTlsVersionOptionsKafkaSchemaRegistryTls$outboundSchema
    .optional(),
});

export function tlsSettingsServerSideTypeToJSON(
  tlsSettingsServerSideType: TlsSettingsServerSideType,
): string {
  return JSON.stringify(
    TlsSettingsServerSideType$outboundSchema.parse(tlsSettingsServerSideType),
  );
}
export function tlsSettingsServerSideTypeFromJSON(
  jsonString: string,
): SafeParseResult<TlsSettingsServerSideType, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TlsSettingsServerSideType$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TlsSettingsServerSideType' from JSON`,
  );
}
