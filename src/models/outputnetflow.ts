/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export type OutputNetflowHost = {
  /**
   * Destination host
   */
  host: string;
  /**
   * Destination port, default is 2055
   */
  port: number;
};

export type OutputNetflow = {
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: "netflow";
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * One or more NetFlow Destinations to forward events to
   */
  hosts: Array<OutputNetflowHost>;
  /**
   * How often to resolve the destination hostname to an IP address. Ignored if all destinations are IP addresses. A value of 0 means every datagram sent will incur a DNS lookup.
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * Send NetFlow traffic using the original event's Source IP and port. To enable this, you must install the external `udp-sender` helper binary at `/usr/bin/udp-sender` on all Worker Nodes and grant it the `CAP_NET_RAW` capability.
   */
  enableIpSpoofing?: boolean | undefined;
  description?: string | undefined;
  /**
   * MTU in bytes. The actual maximum NetFlow payload size will be MTU minus IP and UDP headers (28 bytes for IPv4, 48 bytes for IPv6). For example, with the default MTU of 1500, the max payload is 1472 bytes for IPv4. Payloads exceeding this limit will be dropped.
   */
  maxRecordSize?: number | undefined;
};

/** @internal */
export const OutputNetflowHost$inboundSchema: z.ZodType<
  OutputNetflowHost,
  z.ZodTypeDef,
  unknown
> = z.object({
  host: z.string(),
  port: z.number(),
});
/** @internal */
export type OutputNetflowHost$Outbound = {
  host: string;
  port: number;
};

/** @internal */
export const OutputNetflowHost$outboundSchema: z.ZodType<
  OutputNetflowHost$Outbound,
  z.ZodTypeDef,
  OutputNetflowHost
> = z.object({
  host: z.string(),
  port: z.number(),
});

export function outputNetflowHostToJSON(
  outputNetflowHost: OutputNetflowHost,
): string {
  return JSON.stringify(
    OutputNetflowHost$outboundSchema.parse(outputNetflowHost),
  );
}
export function outputNetflowHostFromJSON(
  jsonString: string,
): SafeParseResult<OutputNetflowHost, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputNetflowHost$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputNetflowHost' from JSON`,
  );
}

/** @internal */
export const OutputNetflow$inboundSchema: z.ZodType<
  OutputNetflow,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  type: z.literal("netflow"),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  hosts: z.array(z.lazy(() => OutputNetflowHost$inboundSchema)),
  dnsResolvePeriodSec: z.number().optional(),
  enableIpSpoofing: z.boolean().optional(),
  description: z.string().optional(),
  maxRecordSize: z.number().optional(),
});
/** @internal */
export type OutputNetflow$Outbound = {
  id?: string | undefined;
  type: "netflow";
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  hosts: Array<OutputNetflowHost$Outbound>;
  dnsResolvePeriodSec?: number | undefined;
  enableIpSpoofing?: boolean | undefined;
  description?: string | undefined;
  maxRecordSize?: number | undefined;
};

/** @internal */
export const OutputNetflow$outboundSchema: z.ZodType<
  OutputNetflow$Outbound,
  z.ZodTypeDef,
  OutputNetflow
> = z.object({
  id: z.string().optional(),
  type: z.literal("netflow"),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  hosts: z.array(z.lazy(() => OutputNetflowHost$outboundSchema)),
  dnsResolvePeriodSec: z.number().optional(),
  enableIpSpoofing: z.boolean().optional(),
  description: z.string().optional(),
  maxRecordSize: z.number().optional(),
});

export function outputNetflowToJSON(outputNetflow: OutputNetflow): string {
  return JSON.stringify(OutputNetflow$outboundSchema.parse(outputNetflow));
}
export function outputNetflowFromJSON(
  jsonString: string,
): SafeParseResult<OutputNetflow, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputNetflow$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputNetflow' from JSON`,
  );
}
