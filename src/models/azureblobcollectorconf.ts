/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as discriminatedUnionTypes from "../types/discriminatedUnion.js";
import { discriminatedUnion } from "../types/discriminatedUnion.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import {
  CertificateTypeAzureBlobAuthTypeClientCert,
  CertificateTypeAzureBlobAuthTypeClientCert$inboundSchema,
  CertificateTypeAzureBlobAuthTypeClientCert$Outbound,
  CertificateTypeAzureBlobAuthTypeClientCert$outboundSchema,
} from "./certificatetypeazureblobauthtypeclientcert.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export type AzureBlobAuthTypeClientCertExtractor = {
  /**
   * A token from the template path, such as epoch
   */
  key: string;
  /**
   * A JavaScript expression that accesses a corresponding <token> through the value variable and evaluates the token to populate event fields. Example: {date: new Date(+value*1000)}
   */
  expression: string;
};

export type AzureBlobAuthTypeClientCert = {
  /**
   * Enter authentication data directly, or select a secret referencing your auth data
   */
  authType: "clientCert";
  /**
   * The name of your Azure storage account
   */
  storageAccountName: string;
  /**
   * The service principal's tenant ID
   */
  tenantId: string;
  /**
   * The service principal's client ID
   */
  clientId: string;
  certificate: CertificateTypeAzureBlobAuthTypeClientCert;
  /**
   * The Azure cloud to use. Defaults to Azure Public Cloud.
   */
  azureCloud?: string | undefined;
  /**
   * The endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net.
   */
  endpointSuffix?: string | undefined;
  /**
   * An optional predefined Destination that will be used to auto-populate Collector settings
   */
  outputName?: string | undefined;
  /**
   * Container to collect from. This value can be a constant, or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: myBucket-${C.vars.myVar}
   */
  containerName: string;
  /**
   * The directory from which to collect data. Templating is supported, such as myDir/${datacenter}/${host}/${app}/. Time-based tokens are supported, such as myOtherDir/${_time:%Y}/${_time:%m}/${_time:%d}/.
   */
  path?: string | undefined;
  /**
   * Extractors allow use of template tokens as context for expressions that enrich discovery results. For example, given a template /path/${epoch}, an extractor under key "epoch" with an expression {date: new Date(+value*1000)} will enrich discovery results with a human-readable "date" field.
   */
  extractors?: Array<AzureBlobAuthTypeClientCertExtractor> | undefined;
  /**
   * Recurse through subdirectories
   */
  recurse?: boolean | undefined;
  /**
   * Include Azure Blob metadata in collected events. In each event, metadata will be located at: __collectible.metadata.
   */
  includeMetadata?: boolean | undefined;
  /**
   * Include Azure Blob tags in collected events. In each event, tags will be located at: __collectible.tags. Disable this feature when using a Shared Access Signature Connection String, to prevent errors.
   */
  includeTags?: boolean | undefined;
  /**
   * Maximum number of metadata objects to batch before recording as results
   */
  maxBatchSize?: number | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will abort if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
};

export type AzureBlobAuthTypeClientSecretExtractor = {
  /**
   * A token from the template path, such as epoch
   */
  key: string;
  /**
   * A JavaScript expression that accesses a corresponding <token> through the value variable and evaluates the token to populate event fields. Example: {date: new Date(+value*1000)}
   */
  expression: string;
};

export type AzureBlobAuthTypeClientSecret = {
  /**
   * Enter authentication data directly, or select a secret referencing your auth data
   */
  authType: "clientSecret";
  /**
   * The name of your Azure storage account
   */
  storageAccountName: string;
  /**
   * The service principal's tenant ID
   */
  tenantId: string;
  /**
   * The service principal's client ID
   */
  clientId: string;
  /**
   * Text secret containing the client secret
   */
  clientTextSecret: string;
  /**
   * The endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net.
   */
  endpointSuffix?: string | undefined;
  /**
   * The Azure cloud to use. Defaults to Azure Public Cloud.
   */
  azureCloud?: string | undefined;
  /**
   * An optional predefined Destination that will be used to auto-populate Collector settings
   */
  outputName?: string | undefined;
  /**
   * Container to collect from. This value can be a constant, or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: myBucket-${C.vars.myVar}
   */
  containerName: string;
  /**
   * The directory from which to collect data. Templating is supported, such as myDir/${datacenter}/${host}/${app}/. Time-based tokens are supported, such as myOtherDir/${_time:%Y}/${_time:%m}/${_time:%d}/.
   */
  path?: string | undefined;
  /**
   * Extractors allow use of template tokens as context for expressions that enrich discovery results. For example, given a template /path/${epoch}, an extractor under key "epoch" with an expression {date: new Date(+value*1000)} will enrich discovery results with a human-readable "date" field.
   */
  extractors?: Array<AzureBlobAuthTypeClientSecretExtractor> | undefined;
  /**
   * Recurse through subdirectories
   */
  recurse?: boolean | undefined;
  /**
   * Include Azure Blob metadata in collected events. In each event, metadata will be located at: __collectible.metadata.
   */
  includeMetadata?: boolean | undefined;
  /**
   * Include Azure Blob tags in collected events. In each event, tags will be located at: __collectible.tags. Disable this feature when using a Shared Access Signature Connection String, to prevent errors.
   */
  includeTags?: boolean | undefined;
  /**
   * Maximum number of metadata objects to batch before recording as results
   */
  maxBatchSize?: number | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will abort if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
};

export type AzureBlobAuthTypeSecretExtractor = {
  /**
   * A token from the template path, such as epoch
   */
  key: string;
  /**
   * A JavaScript expression that accesses a corresponding <token> through the value variable and evaluates the token to populate event fields. Example: {date: new Date(+value*1000)}
   */
  expression: string;
};

export type AzureBlobAuthTypeSecret = {
  /**
   * Enter authentication data directly, or select a secret referencing your auth data
   */
  authType: "secret";
  /**
   * Text secret
   */
  textSecret: string;
  /**
   * An optional predefined Destination that will be used to auto-populate Collector settings
   */
  outputName?: string | undefined;
  /**
   * Container to collect from. This value can be a constant, or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: myBucket-${C.vars.myVar}
   */
  containerName: string;
  /**
   * The directory from which to collect data. Templating is supported, such as myDir/${datacenter}/${host}/${app}/. Time-based tokens are supported, such as myOtherDir/${_time:%Y}/${_time:%m}/${_time:%d}/.
   */
  path?: string | undefined;
  /**
   * Extractors allow use of template tokens as context for expressions that enrich discovery results. For example, given a template /path/${epoch}, an extractor under key "epoch" with an expression {date: new Date(+value*1000)} will enrich discovery results with a human-readable "date" field.
   */
  extractors?: Array<AzureBlobAuthTypeSecretExtractor> | undefined;
  /**
   * Recurse through subdirectories
   */
  recurse?: boolean | undefined;
  /**
   * Include Azure Blob metadata in collected events. In each event, metadata will be located at: __collectible.metadata.
   */
  includeMetadata?: boolean | undefined;
  /**
   * Include Azure Blob tags in collected events. In each event, tags will be located at: __collectible.tags. Disable this feature when using a Shared Access Signature Connection String, to prevent errors.
   */
  includeTags?: boolean | undefined;
  /**
   * Maximum number of metadata objects to batch before recording as results
   */
  maxBatchSize?: number | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will abort if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
};

export type AzureBlobAuthTypeManualExtractor = {
  /**
   * A token from the template path, such as epoch
   */
  key: string;
  /**
   * A JavaScript expression that accesses a corresponding <token> through the value variable and evaluates the token to populate event fields. Example: {date: new Date(+value*1000)}
   */
  expression: string;
};

export type AzureBlobAuthTypeManual = {
  /**
   * Enter authentication data directly, or select a secret referencing your auth data
   */
  authType: "manual";
  /**
   * Enter your Azure storage account Connection String. If left blank, Cribl Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING.
   */
  connectionString: string;
  /**
   * An optional predefined Destination that will be used to auto-populate Collector settings
   */
  outputName?: string | undefined;
  /**
   * Container to collect from. This value can be a constant, or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: myBucket-${C.vars.myVar}
   */
  containerName: string;
  /**
   * The directory from which to collect data. Templating is supported, such as myDir/${datacenter}/${host}/${app}/. Time-based tokens are supported, such as myOtherDir/${_time:%Y}/${_time:%m}/${_time:%d}/.
   */
  path?: string | undefined;
  /**
   * Extractors allow use of template tokens as context for expressions that enrich discovery results. For example, given a template /path/${epoch}, an extractor under key "epoch" with an expression {date: new Date(+value*1000)} will enrich discovery results with a human-readable "date" field.
   */
  extractors?: Array<AzureBlobAuthTypeManualExtractor> | undefined;
  /**
   * Recurse through subdirectories
   */
  recurse?: boolean | undefined;
  /**
   * Include Azure Blob metadata in collected events. In each event, metadata will be located at: __collectible.metadata.
   */
  includeMetadata?: boolean | undefined;
  /**
   * Include Azure Blob tags in collected events. In each event, tags will be located at: __collectible.tags. Disable this feature when using a Shared Access Signature Connection String, to prevent errors.
   */
  includeTags?: boolean | undefined;
  /**
   * Maximum number of metadata objects to batch before recording as results
   */
  maxBatchSize?: number | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will abort if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
};

export type AzureBlobCollectorConf =
  | AzureBlobAuthTypeManual
  | AzureBlobAuthTypeSecret
  | AzureBlobAuthTypeClientSecret
  | AzureBlobAuthTypeClientCert
  | discriminatedUnionTypes.Unknown<"authType">;

/** @internal */
export const AzureBlobAuthTypeClientCertExtractor$inboundSchema: z.ZodType<
  AzureBlobAuthTypeClientCertExtractor,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: types.string(),
  expression: types.string(),
});
/** @internal */
export type AzureBlobAuthTypeClientCertExtractor$Outbound = {
  key: string;
  expression: string;
};

/** @internal */
export const AzureBlobAuthTypeClientCertExtractor$outboundSchema: z.ZodType<
  AzureBlobAuthTypeClientCertExtractor$Outbound,
  z.ZodTypeDef,
  AzureBlobAuthTypeClientCertExtractor
> = z.object({
  key: z.string(),
  expression: z.string(),
});

export function azureBlobAuthTypeClientCertExtractorToJSON(
  azureBlobAuthTypeClientCertExtractor: AzureBlobAuthTypeClientCertExtractor,
): string {
  return JSON.stringify(
    AzureBlobAuthTypeClientCertExtractor$outboundSchema.parse(
      azureBlobAuthTypeClientCertExtractor,
    ),
  );
}
export function azureBlobAuthTypeClientCertExtractorFromJSON(
  jsonString: string,
): SafeParseResult<AzureBlobAuthTypeClientCertExtractor, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AzureBlobAuthTypeClientCertExtractor$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AzureBlobAuthTypeClientCertExtractor' from JSON`,
  );
}

/** @internal */
export const AzureBlobAuthTypeClientCert$inboundSchema: z.ZodType<
  AzureBlobAuthTypeClientCert,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: types.literal("clientCert"),
  storageAccountName: types.string(),
  tenantId: types.string(),
  clientId: types.string(),
  certificate: CertificateTypeAzureBlobAuthTypeClientCert$inboundSchema,
  azureCloud: types.optional(types.string()),
  endpointSuffix: types.optional(types.string()),
  outputName: types.optional(types.string()),
  containerName: types.string(),
  path: types.optional(types.string()),
  extractors: types.optional(
    z.array(z.lazy(() => AzureBlobAuthTypeClientCertExtractor$inboundSchema)),
  ),
  recurse: types.optional(types.boolean()),
  includeMetadata: types.optional(types.boolean()),
  includeTags: types.optional(types.boolean()),
  maxBatchSize: types.optional(types.number()),
  parquetChunkSizeMB: types.optional(types.number()),
  parquetChunkDownloadTimeout: types.optional(types.number()),
});
/** @internal */
export type AzureBlobAuthTypeClientCert$Outbound = {
  authType: "clientCert";
  storageAccountName: string;
  tenantId: string;
  clientId: string;
  certificate: CertificateTypeAzureBlobAuthTypeClientCert$Outbound;
  azureCloud?: string | undefined;
  endpointSuffix?: string | undefined;
  outputName?: string | undefined;
  containerName: string;
  path?: string | undefined;
  extractors?: Array<AzureBlobAuthTypeClientCertExtractor$Outbound> | undefined;
  recurse?: boolean | undefined;
  includeMetadata?: boolean | undefined;
  includeTags?: boolean | undefined;
  maxBatchSize?: number | undefined;
  parquetChunkSizeMB?: number | undefined;
  parquetChunkDownloadTimeout?: number | undefined;
};

/** @internal */
export const AzureBlobAuthTypeClientCert$outboundSchema: z.ZodType<
  AzureBlobAuthTypeClientCert$Outbound,
  z.ZodTypeDef,
  AzureBlobAuthTypeClientCert
> = z.object({
  authType: z.literal("clientCert"),
  storageAccountName: z.string(),
  tenantId: z.string(),
  clientId: z.string(),
  certificate: CertificateTypeAzureBlobAuthTypeClientCert$outboundSchema,
  azureCloud: z.string().optional(),
  endpointSuffix: z.string().optional(),
  outputName: z.string().optional(),
  containerName: z.string(),
  path: z.string().optional(),
  extractors: z.array(
    z.lazy(() => AzureBlobAuthTypeClientCertExtractor$outboundSchema),
  ).optional(),
  recurse: z.boolean().optional(),
  includeMetadata: z.boolean().optional(),
  includeTags: z.boolean().optional(),
  maxBatchSize: z.number().optional(),
  parquetChunkSizeMB: z.number().optional(),
  parquetChunkDownloadTimeout: z.number().optional(),
});

export function azureBlobAuthTypeClientCertToJSON(
  azureBlobAuthTypeClientCert: AzureBlobAuthTypeClientCert,
): string {
  return JSON.stringify(
    AzureBlobAuthTypeClientCert$outboundSchema.parse(
      azureBlobAuthTypeClientCert,
    ),
  );
}
export function azureBlobAuthTypeClientCertFromJSON(
  jsonString: string,
): SafeParseResult<AzureBlobAuthTypeClientCert, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AzureBlobAuthTypeClientCert$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AzureBlobAuthTypeClientCert' from JSON`,
  );
}

/** @internal */
export const AzureBlobAuthTypeClientSecretExtractor$inboundSchema: z.ZodType<
  AzureBlobAuthTypeClientSecretExtractor,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: types.string(),
  expression: types.string(),
});
/** @internal */
export type AzureBlobAuthTypeClientSecretExtractor$Outbound = {
  key: string;
  expression: string;
};

/** @internal */
export const AzureBlobAuthTypeClientSecretExtractor$outboundSchema: z.ZodType<
  AzureBlobAuthTypeClientSecretExtractor$Outbound,
  z.ZodTypeDef,
  AzureBlobAuthTypeClientSecretExtractor
> = z.object({
  key: z.string(),
  expression: z.string(),
});

export function azureBlobAuthTypeClientSecretExtractorToJSON(
  azureBlobAuthTypeClientSecretExtractor:
    AzureBlobAuthTypeClientSecretExtractor,
): string {
  return JSON.stringify(
    AzureBlobAuthTypeClientSecretExtractor$outboundSchema.parse(
      azureBlobAuthTypeClientSecretExtractor,
    ),
  );
}
export function azureBlobAuthTypeClientSecretExtractorFromJSON(
  jsonString: string,
): SafeParseResult<AzureBlobAuthTypeClientSecretExtractor, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AzureBlobAuthTypeClientSecretExtractor$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AzureBlobAuthTypeClientSecretExtractor' from JSON`,
  );
}

/** @internal */
export const AzureBlobAuthTypeClientSecret$inboundSchema: z.ZodType<
  AzureBlobAuthTypeClientSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: types.literal("clientSecret"),
  storageAccountName: types.string(),
  tenantId: types.string(),
  clientId: types.string(),
  clientTextSecret: types.string(),
  endpointSuffix: types.optional(types.string()),
  azureCloud: types.optional(types.string()),
  outputName: types.optional(types.string()),
  containerName: types.string(),
  path: types.optional(types.string()),
  extractors: types.optional(
    z.array(z.lazy(() => AzureBlobAuthTypeClientSecretExtractor$inboundSchema)),
  ),
  recurse: types.optional(types.boolean()),
  includeMetadata: types.optional(types.boolean()),
  includeTags: types.optional(types.boolean()),
  maxBatchSize: types.optional(types.number()),
  parquetChunkSizeMB: types.optional(types.number()),
  parquetChunkDownloadTimeout: types.optional(types.number()),
});
/** @internal */
export type AzureBlobAuthTypeClientSecret$Outbound = {
  authType: "clientSecret";
  storageAccountName: string;
  tenantId: string;
  clientId: string;
  clientTextSecret: string;
  endpointSuffix?: string | undefined;
  azureCloud?: string | undefined;
  outputName?: string | undefined;
  containerName: string;
  path?: string | undefined;
  extractors?:
    | Array<AzureBlobAuthTypeClientSecretExtractor$Outbound>
    | undefined;
  recurse?: boolean | undefined;
  includeMetadata?: boolean | undefined;
  includeTags?: boolean | undefined;
  maxBatchSize?: number | undefined;
  parquetChunkSizeMB?: number | undefined;
  parquetChunkDownloadTimeout?: number | undefined;
};

/** @internal */
export const AzureBlobAuthTypeClientSecret$outboundSchema: z.ZodType<
  AzureBlobAuthTypeClientSecret$Outbound,
  z.ZodTypeDef,
  AzureBlobAuthTypeClientSecret
> = z.object({
  authType: z.literal("clientSecret"),
  storageAccountName: z.string(),
  tenantId: z.string(),
  clientId: z.string(),
  clientTextSecret: z.string(),
  endpointSuffix: z.string().optional(),
  azureCloud: z.string().optional(),
  outputName: z.string().optional(),
  containerName: z.string(),
  path: z.string().optional(),
  extractors: z.array(
    z.lazy(() => AzureBlobAuthTypeClientSecretExtractor$outboundSchema),
  ).optional(),
  recurse: z.boolean().optional(),
  includeMetadata: z.boolean().optional(),
  includeTags: z.boolean().optional(),
  maxBatchSize: z.number().optional(),
  parquetChunkSizeMB: z.number().optional(),
  parquetChunkDownloadTimeout: z.number().optional(),
});

export function azureBlobAuthTypeClientSecretToJSON(
  azureBlobAuthTypeClientSecret: AzureBlobAuthTypeClientSecret,
): string {
  return JSON.stringify(
    AzureBlobAuthTypeClientSecret$outboundSchema.parse(
      azureBlobAuthTypeClientSecret,
    ),
  );
}
export function azureBlobAuthTypeClientSecretFromJSON(
  jsonString: string,
): SafeParseResult<AzureBlobAuthTypeClientSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AzureBlobAuthTypeClientSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AzureBlobAuthTypeClientSecret' from JSON`,
  );
}

/** @internal */
export const AzureBlobAuthTypeSecretExtractor$inboundSchema: z.ZodType<
  AzureBlobAuthTypeSecretExtractor,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: types.string(),
  expression: types.string(),
});
/** @internal */
export type AzureBlobAuthTypeSecretExtractor$Outbound = {
  key: string;
  expression: string;
};

/** @internal */
export const AzureBlobAuthTypeSecretExtractor$outboundSchema: z.ZodType<
  AzureBlobAuthTypeSecretExtractor$Outbound,
  z.ZodTypeDef,
  AzureBlobAuthTypeSecretExtractor
> = z.object({
  key: z.string(),
  expression: z.string(),
});

export function azureBlobAuthTypeSecretExtractorToJSON(
  azureBlobAuthTypeSecretExtractor: AzureBlobAuthTypeSecretExtractor,
): string {
  return JSON.stringify(
    AzureBlobAuthTypeSecretExtractor$outboundSchema.parse(
      azureBlobAuthTypeSecretExtractor,
    ),
  );
}
export function azureBlobAuthTypeSecretExtractorFromJSON(
  jsonString: string,
): SafeParseResult<AzureBlobAuthTypeSecretExtractor, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AzureBlobAuthTypeSecretExtractor$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AzureBlobAuthTypeSecretExtractor' from JSON`,
  );
}

/** @internal */
export const AzureBlobAuthTypeSecret$inboundSchema: z.ZodType<
  AzureBlobAuthTypeSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: types.literal("secret"),
  textSecret: types.string(),
  outputName: types.optional(types.string()),
  containerName: types.string(),
  path: types.optional(types.string()),
  extractors: types.optional(
    z.array(z.lazy(() => AzureBlobAuthTypeSecretExtractor$inboundSchema)),
  ),
  recurse: types.optional(types.boolean()),
  includeMetadata: types.optional(types.boolean()),
  includeTags: types.optional(types.boolean()),
  maxBatchSize: types.optional(types.number()),
  parquetChunkSizeMB: types.optional(types.number()),
  parquetChunkDownloadTimeout: types.optional(types.number()),
});
/** @internal */
export type AzureBlobAuthTypeSecret$Outbound = {
  authType: "secret";
  textSecret: string;
  outputName?: string | undefined;
  containerName: string;
  path?: string | undefined;
  extractors?: Array<AzureBlobAuthTypeSecretExtractor$Outbound> | undefined;
  recurse?: boolean | undefined;
  includeMetadata?: boolean | undefined;
  includeTags?: boolean | undefined;
  maxBatchSize?: number | undefined;
  parquetChunkSizeMB?: number | undefined;
  parquetChunkDownloadTimeout?: number | undefined;
};

/** @internal */
export const AzureBlobAuthTypeSecret$outboundSchema: z.ZodType<
  AzureBlobAuthTypeSecret$Outbound,
  z.ZodTypeDef,
  AzureBlobAuthTypeSecret
> = z.object({
  authType: z.literal("secret"),
  textSecret: z.string(),
  outputName: z.string().optional(),
  containerName: z.string(),
  path: z.string().optional(),
  extractors: z.array(
    z.lazy(() => AzureBlobAuthTypeSecretExtractor$outboundSchema),
  ).optional(),
  recurse: z.boolean().optional(),
  includeMetadata: z.boolean().optional(),
  includeTags: z.boolean().optional(),
  maxBatchSize: z.number().optional(),
  parquetChunkSizeMB: z.number().optional(),
  parquetChunkDownloadTimeout: z.number().optional(),
});

export function azureBlobAuthTypeSecretToJSON(
  azureBlobAuthTypeSecret: AzureBlobAuthTypeSecret,
): string {
  return JSON.stringify(
    AzureBlobAuthTypeSecret$outboundSchema.parse(azureBlobAuthTypeSecret),
  );
}
export function azureBlobAuthTypeSecretFromJSON(
  jsonString: string,
): SafeParseResult<AzureBlobAuthTypeSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AzureBlobAuthTypeSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AzureBlobAuthTypeSecret' from JSON`,
  );
}

/** @internal */
export const AzureBlobAuthTypeManualExtractor$inboundSchema: z.ZodType<
  AzureBlobAuthTypeManualExtractor,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: types.string(),
  expression: types.string(),
});
/** @internal */
export type AzureBlobAuthTypeManualExtractor$Outbound = {
  key: string;
  expression: string;
};

/** @internal */
export const AzureBlobAuthTypeManualExtractor$outboundSchema: z.ZodType<
  AzureBlobAuthTypeManualExtractor$Outbound,
  z.ZodTypeDef,
  AzureBlobAuthTypeManualExtractor
> = z.object({
  key: z.string(),
  expression: z.string(),
});

export function azureBlobAuthTypeManualExtractorToJSON(
  azureBlobAuthTypeManualExtractor: AzureBlobAuthTypeManualExtractor,
): string {
  return JSON.stringify(
    AzureBlobAuthTypeManualExtractor$outboundSchema.parse(
      azureBlobAuthTypeManualExtractor,
    ),
  );
}
export function azureBlobAuthTypeManualExtractorFromJSON(
  jsonString: string,
): SafeParseResult<AzureBlobAuthTypeManualExtractor, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AzureBlobAuthTypeManualExtractor$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AzureBlobAuthTypeManualExtractor' from JSON`,
  );
}

/** @internal */
export const AzureBlobAuthTypeManual$inboundSchema: z.ZodType<
  AzureBlobAuthTypeManual,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: types.literal("manual"),
  connectionString: types.string(),
  outputName: types.optional(types.string()),
  containerName: types.string(),
  path: types.optional(types.string()),
  extractors: types.optional(
    z.array(z.lazy(() => AzureBlobAuthTypeManualExtractor$inboundSchema)),
  ),
  recurse: types.optional(types.boolean()),
  includeMetadata: types.optional(types.boolean()),
  includeTags: types.optional(types.boolean()),
  maxBatchSize: types.optional(types.number()),
  parquetChunkSizeMB: types.optional(types.number()),
  parquetChunkDownloadTimeout: types.optional(types.number()),
});
/** @internal */
export type AzureBlobAuthTypeManual$Outbound = {
  authType: "manual";
  connectionString: string;
  outputName?: string | undefined;
  containerName: string;
  path?: string | undefined;
  extractors?: Array<AzureBlobAuthTypeManualExtractor$Outbound> | undefined;
  recurse?: boolean | undefined;
  includeMetadata?: boolean | undefined;
  includeTags?: boolean | undefined;
  maxBatchSize?: number | undefined;
  parquetChunkSizeMB?: number | undefined;
  parquetChunkDownloadTimeout?: number | undefined;
};

/** @internal */
export const AzureBlobAuthTypeManual$outboundSchema: z.ZodType<
  AzureBlobAuthTypeManual$Outbound,
  z.ZodTypeDef,
  AzureBlobAuthTypeManual
> = z.object({
  authType: z.literal("manual"),
  connectionString: z.string(),
  outputName: z.string().optional(),
  containerName: z.string(),
  path: z.string().optional(),
  extractors: z.array(
    z.lazy(() => AzureBlobAuthTypeManualExtractor$outboundSchema),
  ).optional(),
  recurse: z.boolean().optional(),
  includeMetadata: z.boolean().optional(),
  includeTags: z.boolean().optional(),
  maxBatchSize: z.number().optional(),
  parquetChunkSizeMB: z.number().optional(),
  parquetChunkDownloadTimeout: z.number().optional(),
});

export function azureBlobAuthTypeManualToJSON(
  azureBlobAuthTypeManual: AzureBlobAuthTypeManual,
): string {
  return JSON.stringify(
    AzureBlobAuthTypeManual$outboundSchema.parse(azureBlobAuthTypeManual),
  );
}
export function azureBlobAuthTypeManualFromJSON(
  jsonString: string,
): SafeParseResult<AzureBlobAuthTypeManual, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AzureBlobAuthTypeManual$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AzureBlobAuthTypeManual' from JSON`,
  );
}

/** @internal */
export const AzureBlobCollectorConf$inboundSchema: z.ZodType<
  AzureBlobCollectorConf,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("authType", {
  manual: z.lazy(() => AzureBlobAuthTypeManual$inboundSchema),
  secret: z.lazy(() => AzureBlobAuthTypeSecret$inboundSchema),
  clientSecret: z.lazy(() => AzureBlobAuthTypeClientSecret$inboundSchema),
  clientCert: z.lazy(() => AzureBlobAuthTypeClientCert$inboundSchema),
});
/** @internal */
export type AzureBlobCollectorConf$Outbound =
  | AzureBlobAuthTypeManual$Outbound
  | AzureBlobAuthTypeSecret$Outbound
  | AzureBlobAuthTypeClientSecret$Outbound
  | AzureBlobAuthTypeClientCert$Outbound;

/** @internal */
export const AzureBlobCollectorConf$outboundSchema: z.ZodType<
  AzureBlobCollectorConf$Outbound,
  z.ZodTypeDef,
  AzureBlobCollectorConf
> = z.union([
  z.lazy(() => AzureBlobAuthTypeManual$outboundSchema),
  z.lazy(() => AzureBlobAuthTypeSecret$outboundSchema),
  z.lazy(() => AzureBlobAuthTypeClientSecret$outboundSchema),
  z.lazy(() => AzureBlobAuthTypeClientCert$outboundSchema),
]);

export function azureBlobCollectorConfToJSON(
  azureBlobCollectorConf: AzureBlobCollectorConf,
): string {
  return JSON.stringify(
    AzureBlobCollectorConf$outboundSchema.parse(azureBlobCollectorConf),
  );
}
export function azureBlobCollectorConfFromJSON(
  jsonString: string,
): SafeParseResult<AzureBlobCollectorConf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AzureBlobCollectorConf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AzureBlobCollectorConf' from JSON`,
  );
}
