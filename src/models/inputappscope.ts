/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  AuthType2Options,
  AuthType2Options$inboundSchema,
  AuthType2Options$outboundSchema,
} from "./authtype2options.js";
import {
  ConnectionsType,
  ConnectionsType$inboundSchema,
  ConnectionsType$Outbound,
  ConnectionsType$outboundSchema,
} from "./connectionstype.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  Metadata1Type,
  Metadata1Type$inboundSchema,
  Metadata1Type$Outbound,
  Metadata1Type$outboundSchema,
} from "./metadata1type.js";
import {
  Persistence1Type,
  Persistence1Type$inboundSchema,
  Persistence1Type$Outbound,
  Persistence1Type$outboundSchema,
} from "./persistence1type.js";
import {
  PqType,
  PqType$inboundSchema,
  PqType$Outbound,
  PqType$outboundSchema,
} from "./pqtype.js";
import {
  Tls2Type,
  Tls2Type$inboundSchema,
  Tls2Type$Outbound,
  Tls2Type$outboundSchema,
} from "./tls2type.js";

export const InputAppscopeType8 = {
  Appscope: "appscope",
} as const;
export type InputAppscopeType8 = ClosedEnum<typeof InputAppscopeType8>;

export type Allow8 = {
  /**
   * Specify the name of a process or family of processes.
   */
  procname: string;
  /**
   * Specify a string to substring-match against process command-line.
   */
  arg?: string | undefined;
  /**
   * Choose a config to apply to processes that match the process name and/or argument.
   */
  config: string;
};

export type InputAppscopeFilter8 = {
  /**
   * Specify processes that AppScope should be loaded into, and the config to use.
   */
  allow?: Array<Allow8> | undefined;
  /**
   * To override the UNIX domain socket or address/port specified in General Settings (while leaving Authentication settings as is), enter a URL.
   */
  transportURL?: string | undefined;
};

export type InputAppscopeAppscope8 = {
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthType2Options | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputAppscopeType8;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port.
   */
  enableUnixPath?: boolean | undefined;
  filter?: InputAppscopeFilter8 | undefined;
  persistence?: Persistence1Type | undefined;
  description?: string | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port?: number | undefined;
  tls?: Tls2Type | undefined;
  /**
   * Path to the UNIX domain socket to listen on.
   */
  unixSocketPath?: string | undefined;
  /**
   * Permissions to set for socket e.g., 777. If empty, falls back to the runtime user's default permissions.
   */
  unixSocketPerms?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret: string;
};

export const InputAppscopeType7 = {
  Appscope: "appscope",
} as const;
export type InputAppscopeType7 = ClosedEnum<typeof InputAppscopeType7>;

export type Allow7 = {
  /**
   * Specify the name of a process or family of processes.
   */
  procname: string;
  /**
   * Specify a string to substring-match against process command-line.
   */
  arg?: string | undefined;
  /**
   * Choose a config to apply to processes that match the process name and/or argument.
   */
  config: string;
};

export type InputAppscopeFilter7 = {
  /**
   * Specify processes that AppScope should be loaded into, and the config to use.
   */
  allow?: Array<Allow7> | undefined;
  /**
   * To override the UNIX domain socket or address/port specified in General Settings (while leaving Authentication settings as is), enter a URL.
   */
  transportURL?: string | undefined;
};

export type InputAppscopeAppscope7 = {
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthType2Options | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputAppscopeType7;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port.
   */
  enableUnixPath?: boolean | undefined;
  filter?: InputAppscopeFilter7 | undefined;
  persistence?: Persistence1Type | undefined;
  description?: string | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port?: number | undefined;
  tls?: Tls2Type | undefined;
  /**
   * Path to the UNIX domain socket to listen on.
   */
  unixSocketPath?: string | undefined;
  /**
   * Permissions to set for socket e.g., 777. If empty, falls back to the runtime user's default permissions.
   */
  unixSocketPerms?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const InputAppscopeType6 = {
  Appscope: "appscope",
} as const;
export type InputAppscopeType6 = ClosedEnum<typeof InputAppscopeType6>;

export type Allow6 = {
  /**
   * Specify the name of a process or family of processes.
   */
  procname: string;
  /**
   * Specify a string to substring-match against process command-line.
   */
  arg?: string | undefined;
  /**
   * Choose a config to apply to processes that match the process name and/or argument.
   */
  config: string;
};

export type InputAppscopeFilter6 = {
  /**
   * Specify processes that AppScope should be loaded into, and the config to use.
   */
  allow?: Array<Allow6> | undefined;
  /**
   * To override the UNIX domain socket or address/port specified in General Settings (while leaving Authentication settings as is), enter a URL.
   */
  transportURL?: string | undefined;
};

export type InputAppscopeAppscope6 = {
  /**
   * Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port.
   */
  enableUnixPath?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputAppscopeType6;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  filter?: InputAppscopeFilter6 | undefined;
  persistence?: Persistence1Type | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthType2Options | undefined;
  description?: string | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port?: number | undefined;
  tls?: Tls2Type | undefined;
  /**
   * Path to the UNIX domain socket to listen on.
   */
  unixSocketPath?: string | undefined;
  /**
   * Permissions to set for socket e.g., 777. If empty, falls back to the runtime user's default permissions.
   */
  unixSocketPerms: string;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const InputAppscopeType5 = {
  Appscope: "appscope",
} as const;
export type InputAppscopeType5 = ClosedEnum<typeof InputAppscopeType5>;

export type Allow5 = {
  /**
   * Specify the name of a process or family of processes.
   */
  procname: string;
  /**
   * Specify a string to substring-match against process command-line.
   */
  arg?: string | undefined;
  /**
   * Choose a config to apply to processes that match the process name and/or argument.
   */
  config: string;
};

export type InputAppscopeFilter5 = {
  /**
   * Specify processes that AppScope should be loaded into, and the config to use.
   */
  allow?: Array<Allow5> | undefined;
  /**
   * To override the UNIX domain socket or address/port specified in General Settings (while leaving Authentication settings as is), enter a URL.
   */
  transportURL?: string | undefined;
};

export type InputAppscopeAppscope5 = {
  /**
   * Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port.
   */
  enableUnixPath?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputAppscopeType5;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  filter?: InputAppscopeFilter5 | undefined;
  persistence?: Persistence1Type | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthType2Options | undefined;
  description?: string | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls: Tls2Type;
  /**
   * Path to the UNIX domain socket to listen on.
   */
  unixSocketPath?: string | undefined;
  /**
   * Permissions to set for socket e.g., 777. If empty, falls back to the runtime user's default permissions.
   */
  unixSocketPerms?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const InputAppscopeType4 = {
  Appscope: "appscope",
} as const;
export type InputAppscopeType4 = ClosedEnum<typeof InputAppscopeType4>;

export type Allow4 = {
  /**
   * Specify the name of a process or family of processes.
   */
  procname: string;
  /**
   * Specify a string to substring-match against process command-line.
   */
  arg?: string | undefined;
  /**
   * Choose a config to apply to processes that match the process name and/or argument.
   */
  config: string;
};

export type InputAppscopeFilter4 = {
  /**
   * Specify processes that AppScope should be loaded into, and the config to use.
   */
  allow?: Array<Allow4> | undefined;
  /**
   * To override the UNIX domain socket or address/port specified in General Settings (while leaving Authentication settings as is), enter a URL.
   */
  transportURL?: string | undefined;
};

export type InputAppscopeAppscope4 = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputAppscopeType4;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq: PqType;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port.
   */
  enableUnixPath?: boolean | undefined;
  filter?: InputAppscopeFilter4 | undefined;
  persistence?: Persistence1Type | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthType2Options | undefined;
  description?: string | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port?: number | undefined;
  tls?: Tls2Type | undefined;
  /**
   * Path to the UNIX domain socket to listen on.
   */
  unixSocketPath?: string | undefined;
  /**
   * Permissions to set for socket e.g., 777. If empty, falls back to the runtime user's default permissions.
   */
  unixSocketPerms?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const InputAppscopeType3 = {
  Appscope: "appscope",
} as const;
export type InputAppscopeType3 = ClosedEnum<typeof InputAppscopeType3>;

export type Allow3 = {
  /**
   * Specify the name of a process or family of processes.
   */
  procname: string;
  /**
   * Specify a string to substring-match against process command-line.
   */
  arg?: string | undefined;
  /**
   * Choose a config to apply to processes that match the process name and/or argument.
   */
  config: string;
};

export type InputAppscopeFilter3 = {
  /**
   * Specify processes that AppScope should be loaded into, and the config to use.
   */
  allow?: Array<Allow3> | undefined;
  /**
   * To override the UNIX domain socket or address/port specified in General Settings (while leaving Authentication settings as is), enter a URL.
   */
  transportURL?: string | undefined;
};

export type InputAppscopeAppscope3 = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputAppscopeType3;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port.
   */
  enableUnixPath?: boolean | undefined;
  filter?: InputAppscopeFilter3 | undefined;
  persistence?: Persistence1Type | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthType2Options | undefined;
  description?: string | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port?: number | undefined;
  tls?: Tls2Type | undefined;
  /**
   * Path to the UNIX domain socket to listen on.
   */
  unixSocketPath?: string | undefined;
  /**
   * Permissions to set for socket e.g., 777. If empty, falls back to the runtime user's default permissions.
   */
  unixSocketPerms?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const InputAppscopeType2 = {
  Appscope: "appscope",
} as const;
export type InputAppscopeType2 = ClosedEnum<typeof InputAppscopeType2>;

export type Allow2 = {
  /**
   * Specify the name of a process or family of processes.
   */
  procname: string;
  /**
   * Specify a string to substring-match against process command-line.
   */
  arg?: string | undefined;
  /**
   * Choose a config to apply to processes that match the process name and/or argument.
   */
  config: string;
};

export type InputAppscopeFilter2 = {
  /**
   * Specify processes that AppScope should be loaded into, and the config to use.
   */
  allow?: Array<Allow2> | undefined;
  /**
   * To override the UNIX domain socket or address/port specified in General Settings (while leaving Authentication settings as is), enter a URL.
   */
  transportURL?: string | undefined;
};

export type InputAppscopeAppscope2 = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputAppscopeType2;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections: Array<ConnectionsType>;
  pq?: PqType | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port.
   */
  enableUnixPath?: boolean | undefined;
  filter?: InputAppscopeFilter2 | undefined;
  persistence?: Persistence1Type | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthType2Options | undefined;
  description?: string | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port?: number | undefined;
  tls?: Tls2Type | undefined;
  /**
   * Path to the UNIX domain socket to listen on.
   */
  unixSocketPath?: string | undefined;
  /**
   * Permissions to set for socket e.g., 777. If empty, falls back to the runtime user's default permissions.
   */
  unixSocketPerms?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const InputAppscopeType1 = {
  Appscope: "appscope",
} as const;
export type InputAppscopeType1 = ClosedEnum<typeof InputAppscopeType1>;

export type Allow1 = {
  /**
   * Specify the name of a process or family of processes.
   */
  procname: string;
  /**
   * Specify a string to substring-match against process command-line.
   */
  arg?: string | undefined;
  /**
   * Choose a config to apply to processes that match the process name and/or argument.
   */
  config: string;
};

export type InputAppscopeFilter1 = {
  /**
   * Specify processes that AppScope should be loaded into, and the config to use.
   */
  allow?: Array<Allow1> | undefined;
  /**
   * To override the UNIX domain socket or address/port specified in General Settings (while leaving Authentication settings as is), enter a URL.
   */
  transportURL?: string | undefined;
};

export type InputAppscopeAppscope1 = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputAppscopeType1;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port.
   */
  enableUnixPath?: boolean | undefined;
  filter?: InputAppscopeFilter1 | undefined;
  persistence?: Persistence1Type | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthType2Options | undefined;
  description?: string | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port?: number | undefined;
  tls?: Tls2Type | undefined;
  /**
   * Path to the UNIX domain socket to listen on.
   */
  unixSocketPath?: string | undefined;
  /**
   * Permissions to set for socket e.g., 777. If empty, falls back to the runtime user's default permissions.
   */
  unixSocketPerms?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputAppscope =
  | InputAppscopeAppscope5
  | InputAppscopeAppscope2
  | InputAppscopeAppscope4
  | InputAppscopeAppscope6
  | InputAppscopeAppscope8
  | InputAppscopeAppscope1
  | InputAppscopeAppscope3
  | InputAppscopeAppscope7;

/** @internal */
export const InputAppscopeType8$inboundSchema: z.ZodNativeEnum<
  typeof InputAppscopeType8
> = z.nativeEnum(InputAppscopeType8);
/** @internal */
export const InputAppscopeType8$outboundSchema: z.ZodNativeEnum<
  typeof InputAppscopeType8
> = InputAppscopeType8$inboundSchema;

/** @internal */
export const Allow8$inboundSchema: z.ZodType<Allow8, z.ZodTypeDef, unknown> = z
  .object({
    procname: z.string(),
    arg: z.string().optional(),
    config: z.string(),
  });
/** @internal */
export type Allow8$Outbound = {
  procname: string;
  arg?: string | undefined;
  config: string;
};

/** @internal */
export const Allow8$outboundSchema: z.ZodType<
  Allow8$Outbound,
  z.ZodTypeDef,
  Allow8
> = z.object({
  procname: z.string(),
  arg: z.string().optional(),
  config: z.string(),
});

export function allow8ToJSON(allow8: Allow8): string {
  return JSON.stringify(Allow8$outboundSchema.parse(allow8));
}
export function allow8FromJSON(
  jsonString: string,
): SafeParseResult<Allow8, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Allow8$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Allow8' from JSON`,
  );
}

/** @internal */
export const InputAppscopeFilter8$inboundSchema: z.ZodType<
  InputAppscopeFilter8,
  z.ZodTypeDef,
  unknown
> = z.object({
  allow: z.array(z.lazy(() => Allow8$inboundSchema)).optional(),
  transportURL: z.string().optional(),
});
/** @internal */
export type InputAppscopeFilter8$Outbound = {
  allow?: Array<Allow8$Outbound> | undefined;
  transportURL?: string | undefined;
};

/** @internal */
export const InputAppscopeFilter8$outboundSchema: z.ZodType<
  InputAppscopeFilter8$Outbound,
  z.ZodTypeDef,
  InputAppscopeFilter8
> = z.object({
  allow: z.array(z.lazy(() => Allow8$outboundSchema)).optional(),
  transportURL: z.string().optional(),
});

export function inputAppscopeFilter8ToJSON(
  inputAppscopeFilter8: InputAppscopeFilter8,
): string {
  return JSON.stringify(
    InputAppscopeFilter8$outboundSchema.parse(inputAppscopeFilter8),
  );
}
export function inputAppscopeFilter8FromJSON(
  jsonString: string,
): SafeParseResult<InputAppscopeFilter8, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAppscopeFilter8$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAppscopeFilter8' from JSON`,
  );
}

/** @internal */
export const InputAppscopeAppscope8$inboundSchema: z.ZodType<
  InputAppscopeAppscope8,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthType2Options$inboundSchema.default("manual"),
  id: z.string().optional(),
  type: InputAppscopeType8$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableUnixPath: z.boolean().default(false),
  filter: z.lazy(() => InputAppscopeFilter8$inboundSchema).optional(),
  persistence: Persistence1Type$inboundSchema.optional(),
  description: z.string().optional(),
  host: z.string().optional(),
  port: z.number().optional(),
  tls: Tls2Type$inboundSchema.optional(),
  unixSocketPath: z.string().default("$CRIBL_HOME/state/appscope.sock"),
  unixSocketPerms: z.string().optional(),
  authToken: z.string().default(""),
  textSecret: z.string(),
});
/** @internal */
export type InputAppscopeAppscope8$Outbound = {
  authType: string;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  ipWhitelistRegex: string;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  enableProxyHeader: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  enableUnixPath: boolean;
  filter?: InputAppscopeFilter8$Outbound | undefined;
  persistence?: Persistence1Type$Outbound | undefined;
  description?: string | undefined;
  host?: string | undefined;
  port?: number | undefined;
  tls?: Tls2Type$Outbound | undefined;
  unixSocketPath: string;
  unixSocketPerms?: string | undefined;
  authToken: string;
  textSecret: string;
};

/** @internal */
export const InputAppscopeAppscope8$outboundSchema: z.ZodType<
  InputAppscopeAppscope8$Outbound,
  z.ZodTypeDef,
  InputAppscopeAppscope8
> = z.object({
  authType: AuthType2Options$outboundSchema.default("manual"),
  id: z.string().optional(),
  type: InputAppscopeType8$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableUnixPath: z.boolean().default(false),
  filter: z.lazy(() => InputAppscopeFilter8$outboundSchema).optional(),
  persistence: Persistence1Type$outboundSchema.optional(),
  description: z.string().optional(),
  host: z.string().optional(),
  port: z.number().optional(),
  tls: Tls2Type$outboundSchema.optional(),
  unixSocketPath: z.string().default("$CRIBL_HOME/state/appscope.sock"),
  unixSocketPerms: z.string().optional(),
  authToken: z.string().default(""),
  textSecret: z.string(),
});

export function inputAppscopeAppscope8ToJSON(
  inputAppscopeAppscope8: InputAppscopeAppscope8,
): string {
  return JSON.stringify(
    InputAppscopeAppscope8$outboundSchema.parse(inputAppscopeAppscope8),
  );
}
export function inputAppscopeAppscope8FromJSON(
  jsonString: string,
): SafeParseResult<InputAppscopeAppscope8, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAppscopeAppscope8$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAppscopeAppscope8' from JSON`,
  );
}

/** @internal */
export const InputAppscopeType7$inboundSchema: z.ZodNativeEnum<
  typeof InputAppscopeType7
> = z.nativeEnum(InputAppscopeType7);
/** @internal */
export const InputAppscopeType7$outboundSchema: z.ZodNativeEnum<
  typeof InputAppscopeType7
> = InputAppscopeType7$inboundSchema;

/** @internal */
export const Allow7$inboundSchema: z.ZodType<Allow7, z.ZodTypeDef, unknown> = z
  .object({
    procname: z.string(),
    arg: z.string().optional(),
    config: z.string(),
  });
/** @internal */
export type Allow7$Outbound = {
  procname: string;
  arg?: string | undefined;
  config: string;
};

/** @internal */
export const Allow7$outboundSchema: z.ZodType<
  Allow7$Outbound,
  z.ZodTypeDef,
  Allow7
> = z.object({
  procname: z.string(),
  arg: z.string().optional(),
  config: z.string(),
});

export function allow7ToJSON(allow7: Allow7): string {
  return JSON.stringify(Allow7$outboundSchema.parse(allow7));
}
export function allow7FromJSON(
  jsonString: string,
): SafeParseResult<Allow7, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Allow7$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Allow7' from JSON`,
  );
}

/** @internal */
export const InputAppscopeFilter7$inboundSchema: z.ZodType<
  InputAppscopeFilter7,
  z.ZodTypeDef,
  unknown
> = z.object({
  allow: z.array(z.lazy(() => Allow7$inboundSchema)).optional(),
  transportURL: z.string().optional(),
});
/** @internal */
export type InputAppscopeFilter7$Outbound = {
  allow?: Array<Allow7$Outbound> | undefined;
  transportURL?: string | undefined;
};

/** @internal */
export const InputAppscopeFilter7$outboundSchema: z.ZodType<
  InputAppscopeFilter7$Outbound,
  z.ZodTypeDef,
  InputAppscopeFilter7
> = z.object({
  allow: z.array(z.lazy(() => Allow7$outboundSchema)).optional(),
  transportURL: z.string().optional(),
});

export function inputAppscopeFilter7ToJSON(
  inputAppscopeFilter7: InputAppscopeFilter7,
): string {
  return JSON.stringify(
    InputAppscopeFilter7$outboundSchema.parse(inputAppscopeFilter7),
  );
}
export function inputAppscopeFilter7FromJSON(
  jsonString: string,
): SafeParseResult<InputAppscopeFilter7, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAppscopeFilter7$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAppscopeFilter7' from JSON`,
  );
}

/** @internal */
export const InputAppscopeAppscope7$inboundSchema: z.ZodType<
  InputAppscopeAppscope7,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthType2Options$inboundSchema.default("manual"),
  id: z.string().optional(),
  type: InputAppscopeType7$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableUnixPath: z.boolean().default(false),
  filter: z.lazy(() => InputAppscopeFilter7$inboundSchema).optional(),
  persistence: Persistence1Type$inboundSchema.optional(),
  description: z.string().optional(),
  host: z.string().optional(),
  port: z.number().optional(),
  tls: Tls2Type$inboundSchema.optional(),
  unixSocketPath: z.string().default("$CRIBL_HOME/state/appscope.sock"),
  unixSocketPerms: z.string().optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});
/** @internal */
export type InputAppscopeAppscope7$Outbound = {
  authType: string;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  ipWhitelistRegex: string;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  enableProxyHeader: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  enableUnixPath: boolean;
  filter?: InputAppscopeFilter7$Outbound | undefined;
  persistence?: Persistence1Type$Outbound | undefined;
  description?: string | undefined;
  host?: string | undefined;
  port?: number | undefined;
  tls?: Tls2Type$Outbound | undefined;
  unixSocketPath: string;
  unixSocketPerms?: string | undefined;
  authToken: string;
  textSecret?: string | undefined;
};

/** @internal */
export const InputAppscopeAppscope7$outboundSchema: z.ZodType<
  InputAppscopeAppscope7$Outbound,
  z.ZodTypeDef,
  InputAppscopeAppscope7
> = z.object({
  authType: AuthType2Options$outboundSchema.default("manual"),
  id: z.string().optional(),
  type: InputAppscopeType7$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableUnixPath: z.boolean().default(false),
  filter: z.lazy(() => InputAppscopeFilter7$outboundSchema).optional(),
  persistence: Persistence1Type$outboundSchema.optional(),
  description: z.string().optional(),
  host: z.string().optional(),
  port: z.number().optional(),
  tls: Tls2Type$outboundSchema.optional(),
  unixSocketPath: z.string().default("$CRIBL_HOME/state/appscope.sock"),
  unixSocketPerms: z.string().optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});

export function inputAppscopeAppscope7ToJSON(
  inputAppscopeAppscope7: InputAppscopeAppscope7,
): string {
  return JSON.stringify(
    InputAppscopeAppscope7$outboundSchema.parse(inputAppscopeAppscope7),
  );
}
export function inputAppscopeAppscope7FromJSON(
  jsonString: string,
): SafeParseResult<InputAppscopeAppscope7, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAppscopeAppscope7$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAppscopeAppscope7' from JSON`,
  );
}

/** @internal */
export const InputAppscopeType6$inboundSchema: z.ZodNativeEnum<
  typeof InputAppscopeType6
> = z.nativeEnum(InputAppscopeType6);
/** @internal */
export const InputAppscopeType6$outboundSchema: z.ZodNativeEnum<
  typeof InputAppscopeType6
> = InputAppscopeType6$inboundSchema;

/** @internal */
export const Allow6$inboundSchema: z.ZodType<Allow6, z.ZodTypeDef, unknown> = z
  .object({
    procname: z.string(),
    arg: z.string().optional(),
    config: z.string(),
  });
/** @internal */
export type Allow6$Outbound = {
  procname: string;
  arg?: string | undefined;
  config: string;
};

/** @internal */
export const Allow6$outboundSchema: z.ZodType<
  Allow6$Outbound,
  z.ZodTypeDef,
  Allow6
> = z.object({
  procname: z.string(),
  arg: z.string().optional(),
  config: z.string(),
});

export function allow6ToJSON(allow6: Allow6): string {
  return JSON.stringify(Allow6$outboundSchema.parse(allow6));
}
export function allow6FromJSON(
  jsonString: string,
): SafeParseResult<Allow6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Allow6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Allow6' from JSON`,
  );
}

/** @internal */
export const InputAppscopeFilter6$inboundSchema: z.ZodType<
  InputAppscopeFilter6,
  z.ZodTypeDef,
  unknown
> = z.object({
  allow: z.array(z.lazy(() => Allow6$inboundSchema)).optional(),
  transportURL: z.string().optional(),
});
/** @internal */
export type InputAppscopeFilter6$Outbound = {
  allow?: Array<Allow6$Outbound> | undefined;
  transportURL?: string | undefined;
};

/** @internal */
export const InputAppscopeFilter6$outboundSchema: z.ZodType<
  InputAppscopeFilter6$Outbound,
  z.ZodTypeDef,
  InputAppscopeFilter6
> = z.object({
  allow: z.array(z.lazy(() => Allow6$outboundSchema)).optional(),
  transportURL: z.string().optional(),
});

export function inputAppscopeFilter6ToJSON(
  inputAppscopeFilter6: InputAppscopeFilter6,
): string {
  return JSON.stringify(
    InputAppscopeFilter6$outboundSchema.parse(inputAppscopeFilter6),
  );
}
export function inputAppscopeFilter6FromJSON(
  jsonString: string,
): SafeParseResult<InputAppscopeFilter6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAppscopeFilter6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAppscopeFilter6' from JSON`,
  );
}

/** @internal */
export const InputAppscopeAppscope6$inboundSchema: z.ZodType<
  InputAppscopeAppscope6,
  z.ZodTypeDef,
  unknown
> = z.object({
  enableUnixPath: z.boolean().default(false),
  id: z.string().optional(),
  type: InputAppscopeType6$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  filter: z.lazy(() => InputAppscopeFilter6$inboundSchema).optional(),
  persistence: Persistence1Type$inboundSchema.optional(),
  authType: AuthType2Options$inboundSchema.default("manual"),
  description: z.string().optional(),
  host: z.string().optional(),
  port: z.number().optional(),
  tls: Tls2Type$inboundSchema.optional(),
  unixSocketPath: z.string().default("$CRIBL_HOME/state/appscope.sock"),
  unixSocketPerms: z.string(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});
/** @internal */
export type InputAppscopeAppscope6$Outbound = {
  enableUnixPath: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  ipWhitelistRegex: string;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  enableProxyHeader: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  filter?: InputAppscopeFilter6$Outbound | undefined;
  persistence?: Persistence1Type$Outbound | undefined;
  authType: string;
  description?: string | undefined;
  host?: string | undefined;
  port?: number | undefined;
  tls?: Tls2Type$Outbound | undefined;
  unixSocketPath: string;
  unixSocketPerms: string;
  authToken: string;
  textSecret?: string | undefined;
};

/** @internal */
export const InputAppscopeAppscope6$outboundSchema: z.ZodType<
  InputAppscopeAppscope6$Outbound,
  z.ZodTypeDef,
  InputAppscopeAppscope6
> = z.object({
  enableUnixPath: z.boolean().default(false),
  id: z.string().optional(),
  type: InputAppscopeType6$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  filter: z.lazy(() => InputAppscopeFilter6$outboundSchema).optional(),
  persistence: Persistence1Type$outboundSchema.optional(),
  authType: AuthType2Options$outboundSchema.default("manual"),
  description: z.string().optional(),
  host: z.string().optional(),
  port: z.number().optional(),
  tls: Tls2Type$outboundSchema.optional(),
  unixSocketPath: z.string().default("$CRIBL_HOME/state/appscope.sock"),
  unixSocketPerms: z.string(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});

export function inputAppscopeAppscope6ToJSON(
  inputAppscopeAppscope6: InputAppscopeAppscope6,
): string {
  return JSON.stringify(
    InputAppscopeAppscope6$outboundSchema.parse(inputAppscopeAppscope6),
  );
}
export function inputAppscopeAppscope6FromJSON(
  jsonString: string,
): SafeParseResult<InputAppscopeAppscope6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAppscopeAppscope6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAppscopeAppscope6' from JSON`,
  );
}

/** @internal */
export const InputAppscopeType5$inboundSchema: z.ZodNativeEnum<
  typeof InputAppscopeType5
> = z.nativeEnum(InputAppscopeType5);
/** @internal */
export const InputAppscopeType5$outboundSchema: z.ZodNativeEnum<
  typeof InputAppscopeType5
> = InputAppscopeType5$inboundSchema;

/** @internal */
export const Allow5$inboundSchema: z.ZodType<Allow5, z.ZodTypeDef, unknown> = z
  .object({
    procname: z.string(),
    arg: z.string().optional(),
    config: z.string(),
  });
/** @internal */
export type Allow5$Outbound = {
  procname: string;
  arg?: string | undefined;
  config: string;
};

/** @internal */
export const Allow5$outboundSchema: z.ZodType<
  Allow5$Outbound,
  z.ZodTypeDef,
  Allow5
> = z.object({
  procname: z.string(),
  arg: z.string().optional(),
  config: z.string(),
});

export function allow5ToJSON(allow5: Allow5): string {
  return JSON.stringify(Allow5$outboundSchema.parse(allow5));
}
export function allow5FromJSON(
  jsonString: string,
): SafeParseResult<Allow5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Allow5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Allow5' from JSON`,
  );
}

/** @internal */
export const InputAppscopeFilter5$inboundSchema: z.ZodType<
  InputAppscopeFilter5,
  z.ZodTypeDef,
  unknown
> = z.object({
  allow: z.array(z.lazy(() => Allow5$inboundSchema)).optional(),
  transportURL: z.string().optional(),
});
/** @internal */
export type InputAppscopeFilter5$Outbound = {
  allow?: Array<Allow5$Outbound> | undefined;
  transportURL?: string | undefined;
};

/** @internal */
export const InputAppscopeFilter5$outboundSchema: z.ZodType<
  InputAppscopeFilter5$Outbound,
  z.ZodTypeDef,
  InputAppscopeFilter5
> = z.object({
  allow: z.array(z.lazy(() => Allow5$outboundSchema)).optional(),
  transportURL: z.string().optional(),
});

export function inputAppscopeFilter5ToJSON(
  inputAppscopeFilter5: InputAppscopeFilter5,
): string {
  return JSON.stringify(
    InputAppscopeFilter5$outboundSchema.parse(inputAppscopeFilter5),
  );
}
export function inputAppscopeFilter5FromJSON(
  jsonString: string,
): SafeParseResult<InputAppscopeFilter5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAppscopeFilter5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAppscopeFilter5' from JSON`,
  );
}

/** @internal */
export const InputAppscopeAppscope5$inboundSchema: z.ZodType<
  InputAppscopeAppscope5,
  z.ZodTypeDef,
  unknown
> = z.object({
  enableUnixPath: z.boolean().default(false),
  id: z.string().optional(),
  type: InputAppscopeType5$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  filter: z.lazy(() => InputAppscopeFilter5$inboundSchema).optional(),
  persistence: Persistence1Type$inboundSchema.optional(),
  authType: AuthType2Options$inboundSchema.default("manual"),
  description: z.string().optional(),
  host: z.string(),
  port: z.number(),
  tls: Tls2Type$inboundSchema,
  unixSocketPath: z.string().default("$CRIBL_HOME/state/appscope.sock"),
  unixSocketPerms: z.string().optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});
/** @internal */
export type InputAppscopeAppscope5$Outbound = {
  enableUnixPath: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  ipWhitelistRegex: string;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  enableProxyHeader: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  filter?: InputAppscopeFilter5$Outbound | undefined;
  persistence?: Persistence1Type$Outbound | undefined;
  authType: string;
  description?: string | undefined;
  host: string;
  port: number;
  tls: Tls2Type$Outbound;
  unixSocketPath: string;
  unixSocketPerms?: string | undefined;
  authToken: string;
  textSecret?: string | undefined;
};

/** @internal */
export const InputAppscopeAppscope5$outboundSchema: z.ZodType<
  InputAppscopeAppscope5$Outbound,
  z.ZodTypeDef,
  InputAppscopeAppscope5
> = z.object({
  enableUnixPath: z.boolean().default(false),
  id: z.string().optional(),
  type: InputAppscopeType5$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  filter: z.lazy(() => InputAppscopeFilter5$outboundSchema).optional(),
  persistence: Persistence1Type$outboundSchema.optional(),
  authType: AuthType2Options$outboundSchema.default("manual"),
  description: z.string().optional(),
  host: z.string(),
  port: z.number(),
  tls: Tls2Type$outboundSchema,
  unixSocketPath: z.string().default("$CRIBL_HOME/state/appscope.sock"),
  unixSocketPerms: z.string().optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});

export function inputAppscopeAppscope5ToJSON(
  inputAppscopeAppscope5: InputAppscopeAppscope5,
): string {
  return JSON.stringify(
    InputAppscopeAppscope5$outboundSchema.parse(inputAppscopeAppscope5),
  );
}
export function inputAppscopeAppscope5FromJSON(
  jsonString: string,
): SafeParseResult<InputAppscopeAppscope5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAppscopeAppscope5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAppscopeAppscope5' from JSON`,
  );
}

/** @internal */
export const InputAppscopeType4$inboundSchema: z.ZodNativeEnum<
  typeof InputAppscopeType4
> = z.nativeEnum(InputAppscopeType4);
/** @internal */
export const InputAppscopeType4$outboundSchema: z.ZodNativeEnum<
  typeof InputAppscopeType4
> = InputAppscopeType4$inboundSchema;

/** @internal */
export const Allow4$inboundSchema: z.ZodType<Allow4, z.ZodTypeDef, unknown> = z
  .object({
    procname: z.string(),
    arg: z.string().optional(),
    config: z.string(),
  });
/** @internal */
export type Allow4$Outbound = {
  procname: string;
  arg?: string | undefined;
  config: string;
};

/** @internal */
export const Allow4$outboundSchema: z.ZodType<
  Allow4$Outbound,
  z.ZodTypeDef,
  Allow4
> = z.object({
  procname: z.string(),
  arg: z.string().optional(),
  config: z.string(),
});

export function allow4ToJSON(allow4: Allow4): string {
  return JSON.stringify(Allow4$outboundSchema.parse(allow4));
}
export function allow4FromJSON(
  jsonString: string,
): SafeParseResult<Allow4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Allow4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Allow4' from JSON`,
  );
}

/** @internal */
export const InputAppscopeFilter4$inboundSchema: z.ZodType<
  InputAppscopeFilter4,
  z.ZodTypeDef,
  unknown
> = z.object({
  allow: z.array(z.lazy(() => Allow4$inboundSchema)).optional(),
  transportURL: z.string().optional(),
});
/** @internal */
export type InputAppscopeFilter4$Outbound = {
  allow?: Array<Allow4$Outbound> | undefined;
  transportURL?: string | undefined;
};

/** @internal */
export const InputAppscopeFilter4$outboundSchema: z.ZodType<
  InputAppscopeFilter4$Outbound,
  z.ZodTypeDef,
  InputAppscopeFilter4
> = z.object({
  allow: z.array(z.lazy(() => Allow4$outboundSchema)).optional(),
  transportURL: z.string().optional(),
});

export function inputAppscopeFilter4ToJSON(
  inputAppscopeFilter4: InputAppscopeFilter4,
): string {
  return JSON.stringify(
    InputAppscopeFilter4$outboundSchema.parse(inputAppscopeFilter4),
  );
}
export function inputAppscopeFilter4FromJSON(
  jsonString: string,
): SafeParseResult<InputAppscopeFilter4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAppscopeFilter4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAppscopeFilter4' from JSON`,
  );
}

/** @internal */
export const InputAppscopeAppscope4$inboundSchema: z.ZodType<
  InputAppscopeAppscope4,
  z.ZodTypeDef,
  unknown
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputAppscopeType4$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema,
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableUnixPath: z.boolean().default(false),
  filter: z.lazy(() => InputAppscopeFilter4$inboundSchema).optional(),
  persistence: Persistence1Type$inboundSchema.optional(),
  authType: AuthType2Options$inboundSchema.default("manual"),
  description: z.string().optional(),
  host: z.string().optional(),
  port: z.number().optional(),
  tls: Tls2Type$inboundSchema.optional(),
  unixSocketPath: z.string().default("$CRIBL_HOME/state/appscope.sock"),
  unixSocketPerms: z.string().optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});
/** @internal */
export type InputAppscopeAppscope4$Outbound = {
  pqEnabled: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq: PqType$Outbound;
  ipWhitelistRegex: string;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  enableProxyHeader: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  enableUnixPath: boolean;
  filter?: InputAppscopeFilter4$Outbound | undefined;
  persistence?: Persistence1Type$Outbound | undefined;
  authType: string;
  description?: string | undefined;
  host?: string | undefined;
  port?: number | undefined;
  tls?: Tls2Type$Outbound | undefined;
  unixSocketPath: string;
  unixSocketPerms?: string | undefined;
  authToken: string;
  textSecret?: string | undefined;
};

/** @internal */
export const InputAppscopeAppscope4$outboundSchema: z.ZodType<
  InputAppscopeAppscope4$Outbound,
  z.ZodTypeDef,
  InputAppscopeAppscope4
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputAppscopeType4$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema,
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableUnixPath: z.boolean().default(false),
  filter: z.lazy(() => InputAppscopeFilter4$outboundSchema).optional(),
  persistence: Persistence1Type$outboundSchema.optional(),
  authType: AuthType2Options$outboundSchema.default("manual"),
  description: z.string().optional(),
  host: z.string().optional(),
  port: z.number().optional(),
  tls: Tls2Type$outboundSchema.optional(),
  unixSocketPath: z.string().default("$CRIBL_HOME/state/appscope.sock"),
  unixSocketPerms: z.string().optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});

export function inputAppscopeAppscope4ToJSON(
  inputAppscopeAppscope4: InputAppscopeAppscope4,
): string {
  return JSON.stringify(
    InputAppscopeAppscope4$outboundSchema.parse(inputAppscopeAppscope4),
  );
}
export function inputAppscopeAppscope4FromJSON(
  jsonString: string,
): SafeParseResult<InputAppscopeAppscope4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAppscopeAppscope4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAppscopeAppscope4' from JSON`,
  );
}

/** @internal */
export const InputAppscopeType3$inboundSchema: z.ZodNativeEnum<
  typeof InputAppscopeType3
> = z.nativeEnum(InputAppscopeType3);
/** @internal */
export const InputAppscopeType3$outboundSchema: z.ZodNativeEnum<
  typeof InputAppscopeType3
> = InputAppscopeType3$inboundSchema;

/** @internal */
export const Allow3$inboundSchema: z.ZodType<Allow3, z.ZodTypeDef, unknown> = z
  .object({
    procname: z.string(),
    arg: z.string().optional(),
    config: z.string(),
  });
/** @internal */
export type Allow3$Outbound = {
  procname: string;
  arg?: string | undefined;
  config: string;
};

/** @internal */
export const Allow3$outboundSchema: z.ZodType<
  Allow3$Outbound,
  z.ZodTypeDef,
  Allow3
> = z.object({
  procname: z.string(),
  arg: z.string().optional(),
  config: z.string(),
});

export function allow3ToJSON(allow3: Allow3): string {
  return JSON.stringify(Allow3$outboundSchema.parse(allow3));
}
export function allow3FromJSON(
  jsonString: string,
): SafeParseResult<Allow3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Allow3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Allow3' from JSON`,
  );
}

/** @internal */
export const InputAppscopeFilter3$inboundSchema: z.ZodType<
  InputAppscopeFilter3,
  z.ZodTypeDef,
  unknown
> = z.object({
  allow: z.array(z.lazy(() => Allow3$inboundSchema)).optional(),
  transportURL: z.string().optional(),
});
/** @internal */
export type InputAppscopeFilter3$Outbound = {
  allow?: Array<Allow3$Outbound> | undefined;
  transportURL?: string | undefined;
};

/** @internal */
export const InputAppscopeFilter3$outboundSchema: z.ZodType<
  InputAppscopeFilter3$Outbound,
  z.ZodTypeDef,
  InputAppscopeFilter3
> = z.object({
  allow: z.array(z.lazy(() => Allow3$outboundSchema)).optional(),
  transportURL: z.string().optional(),
});

export function inputAppscopeFilter3ToJSON(
  inputAppscopeFilter3: InputAppscopeFilter3,
): string {
  return JSON.stringify(
    InputAppscopeFilter3$outboundSchema.parse(inputAppscopeFilter3),
  );
}
export function inputAppscopeFilter3FromJSON(
  jsonString: string,
): SafeParseResult<InputAppscopeFilter3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAppscopeFilter3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAppscopeFilter3' from JSON`,
  );
}

/** @internal */
export const InputAppscopeAppscope3$inboundSchema: z.ZodType<
  InputAppscopeAppscope3,
  z.ZodTypeDef,
  unknown
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputAppscopeType3$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableUnixPath: z.boolean().default(false),
  filter: z.lazy(() => InputAppscopeFilter3$inboundSchema).optional(),
  persistence: Persistence1Type$inboundSchema.optional(),
  authType: AuthType2Options$inboundSchema.default("manual"),
  description: z.string().optional(),
  host: z.string().optional(),
  port: z.number().optional(),
  tls: Tls2Type$inboundSchema.optional(),
  unixSocketPath: z.string().default("$CRIBL_HOME/state/appscope.sock"),
  unixSocketPerms: z.string().optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});
/** @internal */
export type InputAppscopeAppscope3$Outbound = {
  pqEnabled: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  ipWhitelistRegex: string;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  enableProxyHeader: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  enableUnixPath: boolean;
  filter?: InputAppscopeFilter3$Outbound | undefined;
  persistence?: Persistence1Type$Outbound | undefined;
  authType: string;
  description?: string | undefined;
  host?: string | undefined;
  port?: number | undefined;
  tls?: Tls2Type$Outbound | undefined;
  unixSocketPath: string;
  unixSocketPerms?: string | undefined;
  authToken: string;
  textSecret?: string | undefined;
};

/** @internal */
export const InputAppscopeAppscope3$outboundSchema: z.ZodType<
  InputAppscopeAppscope3$Outbound,
  z.ZodTypeDef,
  InputAppscopeAppscope3
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputAppscopeType3$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableUnixPath: z.boolean().default(false),
  filter: z.lazy(() => InputAppscopeFilter3$outboundSchema).optional(),
  persistence: Persistence1Type$outboundSchema.optional(),
  authType: AuthType2Options$outboundSchema.default("manual"),
  description: z.string().optional(),
  host: z.string().optional(),
  port: z.number().optional(),
  tls: Tls2Type$outboundSchema.optional(),
  unixSocketPath: z.string().default("$CRIBL_HOME/state/appscope.sock"),
  unixSocketPerms: z.string().optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});

export function inputAppscopeAppscope3ToJSON(
  inputAppscopeAppscope3: InputAppscopeAppscope3,
): string {
  return JSON.stringify(
    InputAppscopeAppscope3$outboundSchema.parse(inputAppscopeAppscope3),
  );
}
export function inputAppscopeAppscope3FromJSON(
  jsonString: string,
): SafeParseResult<InputAppscopeAppscope3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAppscopeAppscope3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAppscopeAppscope3' from JSON`,
  );
}

/** @internal */
export const InputAppscopeType2$inboundSchema: z.ZodNativeEnum<
  typeof InputAppscopeType2
> = z.nativeEnum(InputAppscopeType2);
/** @internal */
export const InputAppscopeType2$outboundSchema: z.ZodNativeEnum<
  typeof InputAppscopeType2
> = InputAppscopeType2$inboundSchema;

/** @internal */
export const Allow2$inboundSchema: z.ZodType<Allow2, z.ZodTypeDef, unknown> = z
  .object({
    procname: z.string(),
    arg: z.string().optional(),
    config: z.string(),
  });
/** @internal */
export type Allow2$Outbound = {
  procname: string;
  arg?: string | undefined;
  config: string;
};

/** @internal */
export const Allow2$outboundSchema: z.ZodType<
  Allow2$Outbound,
  z.ZodTypeDef,
  Allow2
> = z.object({
  procname: z.string(),
  arg: z.string().optional(),
  config: z.string(),
});

export function allow2ToJSON(allow2: Allow2): string {
  return JSON.stringify(Allow2$outboundSchema.parse(allow2));
}
export function allow2FromJSON(
  jsonString: string,
): SafeParseResult<Allow2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Allow2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Allow2' from JSON`,
  );
}

/** @internal */
export const InputAppscopeFilter2$inboundSchema: z.ZodType<
  InputAppscopeFilter2,
  z.ZodTypeDef,
  unknown
> = z.object({
  allow: z.array(z.lazy(() => Allow2$inboundSchema)).optional(),
  transportURL: z.string().optional(),
});
/** @internal */
export type InputAppscopeFilter2$Outbound = {
  allow?: Array<Allow2$Outbound> | undefined;
  transportURL?: string | undefined;
};

/** @internal */
export const InputAppscopeFilter2$outboundSchema: z.ZodType<
  InputAppscopeFilter2$Outbound,
  z.ZodTypeDef,
  InputAppscopeFilter2
> = z.object({
  allow: z.array(z.lazy(() => Allow2$outboundSchema)).optional(),
  transportURL: z.string().optional(),
});

export function inputAppscopeFilter2ToJSON(
  inputAppscopeFilter2: InputAppscopeFilter2,
): string {
  return JSON.stringify(
    InputAppscopeFilter2$outboundSchema.parse(inputAppscopeFilter2),
  );
}
export function inputAppscopeFilter2FromJSON(
  jsonString: string,
): SafeParseResult<InputAppscopeFilter2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAppscopeFilter2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAppscopeFilter2' from JSON`,
  );
}

/** @internal */
export const InputAppscopeAppscope2$inboundSchema: z.ZodType<
  InputAppscopeAppscope2,
  z.ZodTypeDef,
  unknown
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputAppscopeType2$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema),
  pq: PqType$inboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableUnixPath: z.boolean().default(false),
  filter: z.lazy(() => InputAppscopeFilter2$inboundSchema).optional(),
  persistence: Persistence1Type$inboundSchema.optional(),
  authType: AuthType2Options$inboundSchema.default("manual"),
  description: z.string().optional(),
  host: z.string().optional(),
  port: z.number().optional(),
  tls: Tls2Type$inboundSchema.optional(),
  unixSocketPath: z.string().default("$CRIBL_HOME/state/appscope.sock"),
  unixSocketPerms: z.string().optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});
/** @internal */
export type InputAppscopeAppscope2$Outbound = {
  sendToRoutes: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections: Array<ConnectionsType$Outbound>;
  pq?: PqType$Outbound | undefined;
  ipWhitelistRegex: string;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  enableProxyHeader: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  enableUnixPath: boolean;
  filter?: InputAppscopeFilter2$Outbound | undefined;
  persistence?: Persistence1Type$Outbound | undefined;
  authType: string;
  description?: string | undefined;
  host?: string | undefined;
  port?: number | undefined;
  tls?: Tls2Type$Outbound | undefined;
  unixSocketPath: string;
  unixSocketPerms?: string | undefined;
  authToken: string;
  textSecret?: string | undefined;
};

/** @internal */
export const InputAppscopeAppscope2$outboundSchema: z.ZodType<
  InputAppscopeAppscope2$Outbound,
  z.ZodTypeDef,
  InputAppscopeAppscope2
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputAppscopeType2$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema),
  pq: PqType$outboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableUnixPath: z.boolean().default(false),
  filter: z.lazy(() => InputAppscopeFilter2$outboundSchema).optional(),
  persistence: Persistence1Type$outboundSchema.optional(),
  authType: AuthType2Options$outboundSchema.default("manual"),
  description: z.string().optional(),
  host: z.string().optional(),
  port: z.number().optional(),
  tls: Tls2Type$outboundSchema.optional(),
  unixSocketPath: z.string().default("$CRIBL_HOME/state/appscope.sock"),
  unixSocketPerms: z.string().optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});

export function inputAppscopeAppscope2ToJSON(
  inputAppscopeAppscope2: InputAppscopeAppscope2,
): string {
  return JSON.stringify(
    InputAppscopeAppscope2$outboundSchema.parse(inputAppscopeAppscope2),
  );
}
export function inputAppscopeAppscope2FromJSON(
  jsonString: string,
): SafeParseResult<InputAppscopeAppscope2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAppscopeAppscope2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAppscopeAppscope2' from JSON`,
  );
}

/** @internal */
export const InputAppscopeType1$inboundSchema: z.ZodNativeEnum<
  typeof InputAppscopeType1
> = z.nativeEnum(InputAppscopeType1);
/** @internal */
export const InputAppscopeType1$outboundSchema: z.ZodNativeEnum<
  typeof InputAppscopeType1
> = InputAppscopeType1$inboundSchema;

/** @internal */
export const Allow1$inboundSchema: z.ZodType<Allow1, z.ZodTypeDef, unknown> = z
  .object({
    procname: z.string(),
    arg: z.string().optional(),
    config: z.string(),
  });
/** @internal */
export type Allow1$Outbound = {
  procname: string;
  arg?: string | undefined;
  config: string;
};

/** @internal */
export const Allow1$outboundSchema: z.ZodType<
  Allow1$Outbound,
  z.ZodTypeDef,
  Allow1
> = z.object({
  procname: z.string(),
  arg: z.string().optional(),
  config: z.string(),
});

export function allow1ToJSON(allow1: Allow1): string {
  return JSON.stringify(Allow1$outboundSchema.parse(allow1));
}
export function allow1FromJSON(
  jsonString: string,
): SafeParseResult<Allow1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Allow1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Allow1' from JSON`,
  );
}

/** @internal */
export const InputAppscopeFilter1$inboundSchema: z.ZodType<
  InputAppscopeFilter1,
  z.ZodTypeDef,
  unknown
> = z.object({
  allow: z.array(z.lazy(() => Allow1$inboundSchema)).optional(),
  transportURL: z.string().optional(),
});
/** @internal */
export type InputAppscopeFilter1$Outbound = {
  allow?: Array<Allow1$Outbound> | undefined;
  transportURL?: string | undefined;
};

/** @internal */
export const InputAppscopeFilter1$outboundSchema: z.ZodType<
  InputAppscopeFilter1$Outbound,
  z.ZodTypeDef,
  InputAppscopeFilter1
> = z.object({
  allow: z.array(z.lazy(() => Allow1$outboundSchema)).optional(),
  transportURL: z.string().optional(),
});

export function inputAppscopeFilter1ToJSON(
  inputAppscopeFilter1: InputAppscopeFilter1,
): string {
  return JSON.stringify(
    InputAppscopeFilter1$outboundSchema.parse(inputAppscopeFilter1),
  );
}
export function inputAppscopeFilter1FromJSON(
  jsonString: string,
): SafeParseResult<InputAppscopeFilter1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAppscopeFilter1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAppscopeFilter1' from JSON`,
  );
}

/** @internal */
export const InputAppscopeAppscope1$inboundSchema: z.ZodType<
  InputAppscopeAppscope1,
  z.ZodTypeDef,
  unknown
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputAppscopeType1$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableUnixPath: z.boolean().default(false),
  filter: z.lazy(() => InputAppscopeFilter1$inboundSchema).optional(),
  persistence: Persistence1Type$inboundSchema.optional(),
  authType: AuthType2Options$inboundSchema.default("manual"),
  description: z.string().optional(),
  host: z.string().optional(),
  port: z.number().optional(),
  tls: Tls2Type$inboundSchema.optional(),
  unixSocketPath: z.string().default("$CRIBL_HOME/state/appscope.sock"),
  unixSocketPerms: z.string().optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});
/** @internal */
export type InputAppscopeAppscope1$Outbound = {
  sendToRoutes: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  ipWhitelistRegex: string;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  enableProxyHeader: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  enableUnixPath: boolean;
  filter?: InputAppscopeFilter1$Outbound | undefined;
  persistence?: Persistence1Type$Outbound | undefined;
  authType: string;
  description?: string | undefined;
  host?: string | undefined;
  port?: number | undefined;
  tls?: Tls2Type$Outbound | undefined;
  unixSocketPath: string;
  unixSocketPerms?: string | undefined;
  authToken: string;
  textSecret?: string | undefined;
};

/** @internal */
export const InputAppscopeAppscope1$outboundSchema: z.ZodType<
  InputAppscopeAppscope1$Outbound,
  z.ZodTypeDef,
  InputAppscopeAppscope1
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputAppscopeType1$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableUnixPath: z.boolean().default(false),
  filter: z.lazy(() => InputAppscopeFilter1$outboundSchema).optional(),
  persistence: Persistence1Type$outboundSchema.optional(),
  authType: AuthType2Options$outboundSchema.default("manual"),
  description: z.string().optional(),
  host: z.string().optional(),
  port: z.number().optional(),
  tls: Tls2Type$outboundSchema.optional(),
  unixSocketPath: z.string().default("$CRIBL_HOME/state/appscope.sock"),
  unixSocketPerms: z.string().optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});

export function inputAppscopeAppscope1ToJSON(
  inputAppscopeAppscope1: InputAppscopeAppscope1,
): string {
  return JSON.stringify(
    InputAppscopeAppscope1$outboundSchema.parse(inputAppscopeAppscope1),
  );
}
export function inputAppscopeAppscope1FromJSON(
  jsonString: string,
): SafeParseResult<InputAppscopeAppscope1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAppscopeAppscope1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAppscopeAppscope1' from JSON`,
  );
}

/** @internal */
export const InputAppscope$inboundSchema: z.ZodType<
  InputAppscope,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => InputAppscopeAppscope5$inboundSchema),
  z.lazy(() => InputAppscopeAppscope2$inboundSchema),
  z.lazy(() => InputAppscopeAppscope4$inboundSchema),
  z.lazy(() => InputAppscopeAppscope6$inboundSchema),
  z.lazy(() => InputAppscopeAppscope8$inboundSchema),
  z.lazy(() => InputAppscopeAppscope1$inboundSchema),
  z.lazy(() => InputAppscopeAppscope3$inboundSchema),
  z.lazy(() => InputAppscopeAppscope7$inboundSchema),
]);
/** @internal */
export type InputAppscope$Outbound =
  | InputAppscopeAppscope5$Outbound
  | InputAppscopeAppscope2$Outbound
  | InputAppscopeAppscope4$Outbound
  | InputAppscopeAppscope6$Outbound
  | InputAppscopeAppscope8$Outbound
  | InputAppscopeAppscope1$Outbound
  | InputAppscopeAppscope3$Outbound
  | InputAppscopeAppscope7$Outbound;

/** @internal */
export const InputAppscope$outboundSchema: z.ZodType<
  InputAppscope$Outbound,
  z.ZodTypeDef,
  InputAppscope
> = z.union([
  z.lazy(() => InputAppscopeAppscope5$outboundSchema),
  z.lazy(() => InputAppscopeAppscope2$outboundSchema),
  z.lazy(() => InputAppscopeAppscope4$outboundSchema),
  z.lazy(() => InputAppscopeAppscope6$outboundSchema),
  z.lazy(() => InputAppscopeAppscope8$outboundSchema),
  z.lazy(() => InputAppscopeAppscope1$outboundSchema),
  z.lazy(() => InputAppscopeAppscope3$outboundSchema),
  z.lazy(() => InputAppscopeAppscope7$outboundSchema),
]);

export function inputAppscopeToJSON(inputAppscope: InputAppscope): string {
  return JSON.stringify(InputAppscope$outboundSchema.parse(inputAppscope));
}
export function inputAppscopeFromJSON(
  jsonString: string,
): SafeParseResult<InputAppscope, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAppscope$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAppscope' from JSON`,
  );
}
