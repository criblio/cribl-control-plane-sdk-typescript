/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as discriminatedUnionTypes from "../types/discriminatedUnion.js";
import { discriminatedUnion } from "../types/discriminatedUnion.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeRestCollectMethodGetCollectRequestParams,
  ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound,
  ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
} from "./itemstyperestcollectmethodgetcollectrequestparams.js";
import {
  RestAuthenticationGoogleOauthCollectMethod,
  RestAuthenticationGoogleOauthCollectMethod$inboundSchema,
  RestAuthenticationGoogleOauthCollectMethod$outboundSchema,
  RestAuthenticationGoogleOauthDiscovery,
  RestAuthenticationGoogleOauthDiscovery$inboundSchema,
  RestAuthenticationGoogleOauthDiscovery$Outbound,
  RestAuthenticationGoogleOauthDiscovery$outboundSchema,
  RestAuthenticationGoogleOauthPaginationUnion,
  RestAuthenticationGoogleOauthPaginationUnion$inboundSchema,
  RestAuthenticationGoogleOauthPaginationUnion$Outbound,
  RestAuthenticationGoogleOauthPaginationUnion$outboundSchema,
  RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff,
  RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$inboundSchema,
  RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$Outbound,
  RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$outboundSchema,
  RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse,
  RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema,
  RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
  RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema,
  RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue,
  RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema,
  RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
  RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema,
} from "./restauthenticationgoogleoauthrestretryrulestypestaticenableheaderfalse.js";

export type RestAuthenticationGoogleOauthRestRetryRulesTypeStatic =
  | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse
  | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestAuthenticationGoogleOauthRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
};

export type RestAuthenticationGoogleOauthRetryRules =
  | RestAuthenticationGoogleOauthRestRetryRulesTypeNone
  | (
    | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse
    | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue & {
      type: "static";
    }
  )
  | (RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff & {
    type: "backoff";
  })
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationGoogleOauthStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationGoogleOauthScheduling = {
  stateTracking?: RestAuthenticationGoogleOauthStateTracking | undefined;
};

export type RestAuthenticationGoogleOauth = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "google_oauth";
  /**
   * Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information.
   */
  scopes: Array<string>;
  /**
   * Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right.
   */
  serviceAccountCredentials: string;
  /**
   * Email address of a user account with Super Admin permissions to the resources the collector will retrieve
   */
  subject: string;
  discovery?: RestAuthenticationGoogleOauthDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationGoogleOauthCollectMethod;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?: RestAuthenticationGoogleOauthPaginationUnion | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationGoogleOauthRestRetryRulesTypeNone
    | (
      | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse
      | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue
        & { type: "static" }
    )
    | (RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff & {
      type: "backoff";
    })
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestAuthenticationGoogleOauthScheduling | undefined;
};

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    /**
     * Custom HTTP method to use for the Discover operation
     */
    discoverVerb: string;
    /**
     * Template for body to send with the discover request
     */
    discoverBody?: string | undefined;
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    /**
     * Template for POST body to send with the discover request. To reference global variables or functions, use template parameters: `{ myVar: ${C.vars.myVar}, secret: ${C.Secret('mySecret','text').value} }`
     */
    discoverBody: string;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * If 'Strict discover response parsing' parsing is enabled, provide the response format
     */
    discoverResponseFormat: string;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationOauthSecretDiscovery =
  | (
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationOauthSecretCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationOauthSecretCollectMethod = OpenEnum<
  typeof RestAuthenticationOauthSecretCollectMethod
>;

export type RestAuthenticationOauthSecretRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationOauthSecretRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink =
  {
    type: "response_header_link";
    /**
     * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
     */
    nextRelationAttribute: string;
    /**
     * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
     */
    curRelationAttribute?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationOauthSecretRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationOauthSecretRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestAuthenticationOauthSecretRestPaginationTypeNone = {
  type: "none";
};

export type RestAuthenticationOauthSecretPaginationUnion =
  | RestAuthenticationOauthSecretRestPaginationTypeNone
  | RestAuthenticationOauthSecretRestPaginationTypeResponseBody
  | RestAuthenticationOauthSecretRestPaginationTypeResponseHeader
  | RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink
  | RestAuthenticationOauthSecretRestPaginationTypeRequestOffset
  | RestAuthenticationOauthSecretRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue =
  {
    /**
     * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
     */
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    /**
     * Time interval between a failed request and the first retry
     */
    interval?: number | undefined;
    /**
     * Maximum number of times to retry a failed HTTP request
     */
    limit?: number | undefined;
    /**
     * Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
     */
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    /**
     * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
     */
    codes?: Array<number> | undefined;
    /**
     * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
     */
    retryConnectTimeout?: boolean | undefined;
    /**
     * Retry request when a connection reset (ECONNRESET) error occurs
     */
    retryConnectReset?: boolean | undefined;
  };

export type RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse =
  {
    /**
     * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
     */
    enableHeader?: boolean | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    /**
     * Time interval between a failed request and the first retry
     */
    interval?: number | undefined;
    /**
     * Maximum number of times to retry a failed HTTP request
     */
    limit?: number | undefined;
    /**
     * Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
     */
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    /**
     * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
     */
    codes?: Array<number> | undefined;
    /**
     * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
     */
    retryConnectTimeout?: boolean | undefined;
    /**
     * Retry request when a connection reset (ECONNRESET) error occurs
     */
    retryConnectReset?: boolean | undefined;
  };

export type RestAuthenticationOauthSecretRestRetryRulesTypeBackoff =
  | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue =
  {
    /**
     * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
     */
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    /**
     * Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
     */
    interval?: number | undefined;
    /**
     * Maximum number of times to retry a failed HTTP request
     */
    limit?: number | undefined;
    /**
     * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
     */
    codes?: Array<number> | undefined;
    /**
     * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
     */
    retryConnectTimeout?: boolean | undefined;
    /**
     * Retry request when a connection reset (ECONNRESET) error occurs
     */
    retryConnectReset?: boolean | undefined;
  };

export type RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse =
  {
    /**
     * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
     */
    enableHeader?: boolean | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    /**
     * Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
     */
    interval?: number | undefined;
    /**
     * Maximum number of times to retry a failed HTTP request
     */
    limit?: number | undefined;
    /**
     * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
     */
    codes?: Array<number> | undefined;
    /**
     * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
     */
    retryConnectTimeout?: boolean | undefined;
    /**
     * Retry request when a connection reset (ECONNRESET) error occurs
     */
    retryConnectReset?: boolean | undefined;
  };

export type RestAuthenticationOauthSecretRestRetryRulesTypeStatic =
  | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse
  | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestAuthenticationOauthSecretRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
};

export type RestAuthenticationOauthSecretRetryRules =
  | RestAuthenticationOauthSecretRestRetryRulesTypeNone
  | (
    | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse
    | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue & {
      type: "static";
    }
  )
  | (
    | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue & {
      type: "backoff";
    }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationOauthSecretStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationOauthSecretScheduling = {
  stateTracking?: RestAuthenticationOauthSecretStateTracking | undefined;
};

export type RestAuthenticationOauthSecret = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "oauthSecret";
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl: string;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName: string;
  /**
   * Select or create a text secret that contains the client secret's value
   */
  textSecret: string;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationOauthSecretCollectMethod;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationOauthSecretRestPaginationTypeNone
    | RestAuthenticationOauthSecretRestPaginationTypeResponseBody
    | RestAuthenticationOauthSecretRestPaginationTypeResponseHeader
    | RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink
    | RestAuthenticationOauthSecretRestPaginationTypeRequestOffset
    | RestAuthenticationOauthSecretRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationOauthSecretRestRetryRulesTypeNone
    | (
      | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse
      | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue
        & { type: "static" }
    )
    | (
      | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue
        & { type: "backoff" }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestAuthenticationOauthSecretScheduling | undefined;
};

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    /**
     * Custom HTTP method to use for the Discover operation
     */
    discoverVerb: string;
    /**
     * Template for body to send with the discover request
     */
    discoverBody?: string | undefined;
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    /**
     * Template for POST body to send with the discover request. To reference global variables or functions, use template parameters: `{ myVar: ${C.vars.myVar}, secret: ${C.Secret('mySecret','text').value} }`
     */
    discoverBody: string;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * If 'Strict discover response parsing' parsing is enabled, provide the response format
     */
    discoverResponseFormat: string;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationOauthDiscovery =
  | (
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeJson
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeList
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationOauthCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationOauthCollectMethod = OpenEnum<
  typeof RestAuthenticationOauthCollectMethod
>;

export type RestAuthenticationOauthRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationOauthRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationOauthRestPaginationTypeResponseHeaderLink = {
  type: "response_header_link";
  /**
   * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
   */
  nextRelationAttribute: string;
  /**
   * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
   */
  curRelationAttribute?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationOauthRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationOauthRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestAuthenticationOauthRestPaginationTypeNone = {
  type: "none";
};

export type RestAuthenticationOauthPaginationUnion =
  | RestAuthenticationOauthRestPaginationTypeNone
  | RestAuthenticationOauthRestPaginationTypeResponseBody
  | RestAuthenticationOauthRestPaginationTypeResponseHeader
  | RestAuthenticationOauthRestPaginationTypeResponseHeaderLink
  | RestAuthenticationOauthRestPaginationTypeRequestOffset
  | RestAuthenticationOauthRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue = {
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  /**
   * Time interval between a failed request and the first retry
   */
  interval?: number | undefined;
  /**
   * Maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
   */
  multiplier?: number | undefined;
  maxIntervalMs?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

export type RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse =
  {
    /**
     * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
     */
    enableHeader?: boolean | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    /**
     * Time interval between a failed request and the first retry
     */
    interval?: number | undefined;
    /**
     * Maximum number of times to retry a failed HTTP request
     */
    limit?: number | undefined;
    /**
     * Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
     */
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    /**
     * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
     */
    codes?: Array<number> | undefined;
    /**
     * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
     */
    retryConnectTimeout?: boolean | undefined;
    /**
     * Retry request when a connection reset (ECONNRESET) error occurs
     */
    retryConnectReset?: boolean | undefined;
  };

export type RestAuthenticationOauthRestRetryRulesTypeBackoff =
  | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue = {
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  retryHeaderName?: string | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  /**
   * Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * Maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

export type RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse = {
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  /**
   * Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * Maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

export type RestAuthenticationOauthRestRetryRulesTypeStatic =
  | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse
  | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestAuthenticationOauthRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
};

export type RestAuthenticationOauthRetryRules =
  | RestAuthenticationOauthRestRetryRulesTypeNone
  | (
    | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse
    | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue & {
      type: "static";
    }
  )
  | (
    | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue & {
      type: "backoff";
    }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationOauthStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationOauthScheduling = {
  stateTracking?: RestAuthenticationOauthStateTracking | undefined;
};

export type RestAuthenticationOauth = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "oauth";
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl: string;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName: string;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters.
   */
  clientSecretParamValue: string;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeJson
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeList
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationOauthCollectMethod;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationOauthRestPaginationTypeNone
    | RestAuthenticationOauthRestPaginationTypeResponseBody
    | RestAuthenticationOauthRestPaginationTypeResponseHeader
    | RestAuthenticationOauthRestPaginationTypeResponseHeaderLink
    | RestAuthenticationOauthRestPaginationTypeRequestOffset
    | RestAuthenticationOauthRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationOauthRestRetryRulesTypeNone
    | (
      | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse
      | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue & {
        type: "static";
      }
    )
    | (
      | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue & {
        type: "backoff";
      }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestAuthenticationOauthScheduling | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication =
  {
    None: "none",
    Basic: "basic",
    BasicSecret: "basicSecret",
    Login: "login",
    LoginSecret: "loginSecret",
    Oauth: "oauth",
    OauthSecret: "oauthSecret",
    GoogleOauth: "google_oauth",
    GoogleOauthSecret: "google_oauthSecret",
    Hmac: "hmac",
  } as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "none";
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "list";
    /**
     * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
     */
    itemList: Array<string>;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "json";
    /**
     * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
     */
    manualDiscoverResult: string;
    /**
     * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
     */
    discoverDataField?: string | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    /**
     * Custom HTTP method to use for the Discover operation
     */
    discoverVerb: string;
    /**
     * Template for body to send with the discover request
     */
    discoverBody?: string | undefined;
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    /**
     * Template for POST body to send with the discover request. To reference global variables or functions, use template parameters: `{ myVar: ${C.vars.myVar}, secret: ${C.Secret('mySecret','text').value} }`
     */
    discoverBody: string;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * If 'Strict discover response parsing' parsing is enabled, provide the response format
     */
    discoverResponseFormat: string;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery =
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage =
  {
    type: "request_page";
    /**
     * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
     */
    pageField: string;
    /**
     * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
     */
    page?: number | undefined;
    /**
     * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
     */
    sizeField: string;
    /**
     * Maximum number of records to collect per page
     */
    size: number;
    /**
     * Name of the attribute in the response that contains the total number of pages for the query
     */
    totalPageField?: string | undefined;
    /**
     * Name of the attribute in the response that contains the total number of records for the query
     */
    totalRecordField?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
     */
    zeroIndexed: boolean;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset =
  {
    type: "request_offset";
    /**
     * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
     */
    offsetField: string;
    /**
     * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
     */
    offset?: number | undefined;
    /**
     * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
     */
    limitField: string;
    /**
     * Maximum number of records to collect per request
     */
    limit: number;
    /**
     * Name of the attribute in the response that contains the total number of records for the query
     */
    totalRecordField?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
     */
    zeroIndexed: boolean;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink =
  {
    type: "response_header_link";
    /**
     * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
     */
    nextRelationAttribute: string;
    /**
     * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
     */
    curRelationAttribute?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader =
  {
    type: "response_header";
    /**
     * Names of attributes within the response that contain next-page information
     */
    attribute: Array<string>;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody =
  {
    type: "response_body";
    /**
     * Names of attributes within the response that contain next-page information
     */
    attribute: Array<string>;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
     */
    lastPageExpr?: string | undefined;
  };

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema,
    RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema,
  ]);
/** @internal */
export type RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$Outbound =
  | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestRetryRulesTypeStatic
  > = smartUnion([
    RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema,
    RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema,
  ]);

export function restAuthenticationGoogleOauthRestRetryRulesTypeStaticToJSON(
  restAuthenticationGoogleOauthRestRetryRulesTypeStatic:
    RestAuthenticationGoogleOauthRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$outboundSchema.parse(
      restAuthenticationGoogleOauthRestRetryRulesTypeStatic,
    ),
  );
}
export function restAuthenticationGoogleOauthRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationGoogleOauthRestRetryRulesTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestAuthenticationGoogleOauthRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationGoogleOauthRestRetryRulesTypeNoneToJSON(
  restAuthenticationGoogleOauthRestRetryRulesTypeNone:
    RestAuthenticationGoogleOauthRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRestRetryRulesTypeNone$outboundSchema.parse(
      restAuthenticationGoogleOauthRestRetryRulesTypeNone,
    ),
  );
}
export function restAuthenticationGoogleOauthRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationGoogleOauthRestRetryRulesTypeNone$inboundSchema
  ),
  static: smartUnion([
    RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema,
    RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema,
  ]).and(z.object({ type: z.literal("static") })),
  backoff: RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$inboundSchema
    .and(z.object({ type: z.literal("backoff") })),
});
/** @internal */
export type RestAuthenticationGoogleOauthRetryRules$Outbound =
  | RestAuthenticationGoogleOauthRestRetryRulesTypeNone$Outbound
  | (
    | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
      & { type: "static" }
  )
  | (RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$Outbound & {
    type: "backoff";
  });

/** @internal */
export const RestAuthenticationGoogleOauthRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauthRetryRules
> = z.union([
  z.lazy(() =>
    RestAuthenticationGoogleOauthRestRetryRulesTypeNone$outboundSchema
  ),
  smartUnion([
    RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema,
    RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema,
  ]).and(z.object({ type: z.literal("static") })),
  RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$outboundSchema.and(
    z.object({ type: z.literal("backoff") }),
  ),
]);

export function restAuthenticationGoogleOauthRetryRulesToJSON(
  restAuthenticationGoogleOauthRetryRules:
    RestAuthenticationGoogleOauthRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthRetryRules$outboundSchema.parse(
      restAuthenticationGoogleOauthRetryRules,
    ),
  );
}
export function restAuthenticationGoogleOauthRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthStateTracking$inboundSchema:
  z.ZodType<RestAuthenticationGoogleOauthStateTracking, z.ZodTypeDef, unknown> =
    z.object({
      enabled: types.optional(types.boolean()),
    });
/** @internal */
export type RestAuthenticationGoogleOauthStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationGoogleOauthStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationGoogleOauthStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationGoogleOauthStateTrackingToJSON(
  restAuthenticationGoogleOauthStateTracking:
    RestAuthenticationGoogleOauthStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthStateTracking$outboundSchema.parse(
      restAuthenticationGoogleOauthStateTracking,
    ),
  );
}
export function restAuthenticationGoogleOauthStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauthScheduling$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestAuthenticationGoogleOauthStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationGoogleOauthScheduling$Outbound = {
  stateTracking?:
    | RestAuthenticationGoogleOauthStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauthScheduling$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauthScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauthScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationGoogleOauthStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationGoogleOauthSchedulingToJSON(
  restAuthenticationGoogleOauthScheduling:
    RestAuthenticationGoogleOauthScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauthScheduling$outboundSchema.parse(
      restAuthenticationGoogleOauthScheduling,
    ),
  );
}
export function restAuthenticationGoogleOauthSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationGoogleOauthScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationGoogleOauthScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationGoogleOauthScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationGoogleOauth$inboundSchema: z.ZodType<
  RestAuthenticationGoogleOauth,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("google_oauth"),
  scopes: z.array(types.string()),
  serviceAccountCredentials: types.string(),
  subject: types.string(),
  discovery: types.optional(
    RestAuthenticationGoogleOauthDiscovery$inboundSchema,
  ),
  collectUrl: types.string(),
  collectMethod: RestAuthenticationGoogleOauthCollectMethod$inboundSchema,
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(
    RestAuthenticationGoogleOauthPaginationUnion$inboundSchema,
  ),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema,
      RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema,
    ]).and(z.object({ type: z.literal("static") })),
    backoff:
      RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$inboundSchema.and(
        z.object({ type: z.literal("backoff") }),
      ),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestAuthenticationGoogleOauthScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationGoogleOauth$Outbound = {
  authentication: "google_oauth";
  scopes: Array<string>;
  serviceAccountCredentials: string;
  subject: string;
  discovery?: RestAuthenticationGoogleOauthDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationGoogleOauthPaginationUnion$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationGoogleOauthRestRetryRulesTypeNone$Outbound
    | (
      | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$Outbound & {
      type: "backoff";
    })
    | undefined;
  __scheduling?: RestAuthenticationGoogleOauthScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationGoogleOauth$outboundSchema: z.ZodType<
  RestAuthenticationGoogleOauth$Outbound,
  z.ZodTypeDef,
  RestAuthenticationGoogleOauth
> = z.object({
  authentication: z.literal("google_oauth"),
  scopes: z.array(z.string()),
  serviceAccountCredentials: z.string(),
  subject: z.string(),
  discovery: RestAuthenticationGoogleOauthDiscovery$outboundSchema.optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationGoogleOauthCollectMethod$outboundSchema,
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: RestAuthenticationGoogleOauthPaginationUnion$outboundSchema
    .optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() =>
      RestAuthenticationGoogleOauthRestRetryRulesTypeNone$outboundSchema
    ),
    smartUnion([
      RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema,
      RestAuthenticationGoogleOauthRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema,
    ]).and(z.object({ type: z.literal("static") })),
    RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff$outboundSchema.and(
      z.object({ type: z.literal("backoff") }),
    ),
  ]).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationGoogleOauthScheduling$outboundSchema
  ).optional(),
});

export function restAuthenticationGoogleOauthToJSON(
  restAuthenticationGoogleOauth: RestAuthenticationGoogleOauth,
): string {
  return JSON.stringify(
    RestAuthenticationGoogleOauth$outboundSchema.parse(
      restAuthenticationGoogleOauth,
    ),
  );
}
export function restAuthenticationGoogleOauthFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationGoogleOauth, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationGoogleOauth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationGoogleOauth' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$Outbound =
  {
    discoverType: "none";
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$outboundSchema
      .parse(restAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$Outbound =
  {
    discoverType: "list";
    itemList: Array<string>;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeList:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$outboundSchema
      .parse(restAuthenticationOauthSecretRestDiscoveryDiscoverTypeList),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$Outbound =
  {
    discoverType: "json";
    manualDiscoverResult: string;
    discoverDataField?: string | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$outboundSchema
      .parse(restAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.string(),
    discoverBody: types.optional(types.string()),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb: string;
    discoverBody?: string | undefined;
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.string(),
    discoverBody: z.string().optional(),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.string(),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody: string;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.string(),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.string(),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat: string;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.string(),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp$outboundSchema
      .parse(restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp),
  );
}
export function restAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecretDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationOauthSecretDiscovery$Outbound =
  | (
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationOauthSecretDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationOauthSecretDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthSecretDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restAuthenticationOauthSecretDiscoveryToJSON(
  restAuthenticationOauthSecretDiscovery:
    RestAuthenticationOauthSecretDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretDiscovery$outboundSchema.parse(
      restAuthenticationOauthSecretDiscovery,
    ),
  );
}
export function restAuthenticationOauthSecretDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthSecretDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretCollectMethod$inboundSchema:
  z.ZodType<RestAuthenticationOauthSecretCollectMethod, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(RestAuthenticationOauthSecretCollectMethod);
/** @internal */
export const RestAuthenticationOauthSecretCollectMethod$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationOauthSecretCollectMethod> =
    openEnums.outboundSchema(RestAuthenticationOauthSecretCollectMethod);

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestPaginationTypeRequestPage$Outbound =
  {
    type: "request_page";
    pageField: string;
    page?: number | undefined;
    sizeField: string;
    size: number;
    totalPageField?: string | undefined;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationOauthSecretRestPaginationTypeRequestPageToJSON(
  restAuthenticationOauthSecretRestPaginationTypeRequestPage:
    RestAuthenticationOauthSecretRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestPaginationTypeRequestPage$outboundSchema
      .parse(restAuthenticationOauthSecretRestPaginationTypeRequestPage),
  );
}
export function restAuthenticationOauthSecretRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestPage$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$Outbound =
  {
    type: "request_offset";
    offsetField: string;
    offset?: number | undefined;
    limitField: string;
    limit: number;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationOauthSecretRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationOauthSecretRestPaginationTypeRequestOffset:
    RestAuthenticationOauthSecretRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$outboundSchema
      .parse(restAuthenticationOauthSecretRestPaginationTypeRequestOffset),
  );
}
export function restAuthenticationOauthSecretRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationOauthSecretRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink:
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink),
  );
}
export function restAuthenticationOauthSecretRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$Outbound =
  {
    type: "response_header";
    attribute: Array<string>;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationOauthSecretRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationOauthSecretRestPaginationTypeResponseHeader:
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$outboundSchema
      .parse(restAuthenticationOauthSecretRestPaginationTypeResponseHeader),
  );
}
export function restAuthenticationOauthSecretRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestPaginationTypeResponseBody$Outbound =
  {
    type: "response_body";
    attribute: Array<string>;
    maxPages: number;
    lastPageExpr?: string | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationOauthSecretRestPaginationTypeResponseBodyToJSON(
  restAuthenticationOauthSecretRestPaginationTypeResponseBody:
    RestAuthenticationOauthSecretRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestPaginationTypeResponseBody$outboundSchema
      .parse(restAuthenticationOauthSecretRestPaginationTypeResponseBody),
  );
}
export function restAuthenticationOauthSecretRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestAuthenticationOauthSecretRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationOauthSecretRestPaginationTypeNoneToJSON(
  restAuthenticationOauthSecretRestPaginationTypeNone:
    RestAuthenticationOauthSecretRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestPaginationTypeNone$outboundSchema.parse(
      restAuthenticationOauthSecretRestPaginationTypeNone,
    ),
  );
}
export function restAuthenticationOauthSecretRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretPaginationUnion$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretPaginationUnion,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestPage$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationOauthSecretPaginationUnion$Outbound =
  | RestAuthenticationOauthSecretRestPaginationTypeNone$Outbound
  | RestAuthenticationOauthSecretRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationOauthSecretRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationOauthSecretPaginationUnion$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretPaginationUnion$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretPaginationUnion
  > = z.union([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestPage$outboundSchema
    ),
  ]);

export function restAuthenticationOauthSecretPaginationUnionToJSON(
  restAuthenticationOauthSecretPaginationUnion:
    RestAuthenticationOauthSecretPaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretPaginationUnion$outboundSchema.parse(
      restAuthenticationOauthSecretPaginationUnion,
    ),
  );
}
export function restAuthenticationOauthSecretPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretPaginationUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretPaginationUnion$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    multiplier: types.optional(types.number()),
    maxIntervalMs: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.boolean().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    multiplier: z.number().optional(),
    maxIntervalMs: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    multiplier: types.optional(types.number()),
    maxIntervalMs: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: boolean | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.boolean().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    multiplier: z.number().optional(),
    maxIntervalMs: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$Outbound =
  | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationOauthSecretRestRetryRulesTypeBackoffToJSON(
  restAuthenticationOauthSecretRestRetryRulesTypeBackoff:
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$outboundSchema.parse(
      restAuthenticationOauthSecretRestRetryRulesTypeBackoff,
    ),
  );
}
export function restAuthenticationOauthSecretRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoff$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.boolean().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue:
    RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: boolean | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.boolean().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse:
    RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationOauthSecretRestRetryRulesTypeStatic$Outbound =
  | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationOauthSecretRestRetryRulesTypeStaticToJSON(
  restAuthenticationOauthSecretRestRetryRulesTypeStatic:
    RestAuthenticationOauthSecretRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestRetryRulesTypeStatic$outboundSchema.parse(
      restAuthenticationOauthSecretRestRetryRulesTypeStatic,
    ),
  );
}
export function restAuthenticationOauthSecretRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationOauthSecretRestRetryRulesTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestAuthenticationOauthSecretRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationOauthSecretRestRetryRulesTypeNoneToJSON(
  restAuthenticationOauthSecretRestRetryRulesTypeNone:
    RestAuthenticationOauthSecretRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRestRetryRulesTypeNone$outboundSchema.parse(
      restAuthenticationOauthSecretRestRetryRulesTypeNone,
    ),
  );
}
export function restAuthenticationOauthSecretRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecretRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationOauthSecretRestRetryRulesTypeNone$inboundSchema
  ),
  static: smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  backoff: smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
});
/** @internal */
export type RestAuthenticationOauthSecretRetryRules$Outbound =
  | RestAuthenticationOauthSecretRestRetryRulesTypeNone$Outbound
  | (
    | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
      & { type: "static" }
  )
  | (
    | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestAuthenticationOauthSecretRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationOauthSecretRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthSecretRetryRules
> = z.union([
  z.lazy(() =>
    RestAuthenticationOauthSecretRestRetryRulesTypeNone$outboundSchema
  ),
  smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
]);

export function restAuthenticationOauthSecretRetryRulesToJSON(
  restAuthenticationOauthSecretRetryRules:
    RestAuthenticationOauthSecretRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretRetryRules$outboundSchema.parse(
      restAuthenticationOauthSecretRetryRules,
    ),
  );
}
export function restAuthenticationOauthSecretRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretStateTracking$inboundSchema:
  z.ZodType<RestAuthenticationOauthSecretStateTracking, z.ZodTypeDef, unknown> =
    z.object({
      enabled: types.optional(types.boolean()),
    });
/** @internal */
export type RestAuthenticationOauthSecretStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationOauthSecretStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthSecretStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthSecretStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationOauthSecretStateTrackingToJSON(
  restAuthenticationOauthSecretStateTracking:
    RestAuthenticationOauthSecretStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretStateTracking$outboundSchema.parse(
      restAuthenticationOauthSecretStateTracking,
    ),
  );
}
export function restAuthenticationOauthSecretStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecretScheduling$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecretScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestAuthenticationOauthSecretStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationOauthSecretScheduling$Outbound = {
  stateTracking?:
    | RestAuthenticationOauthSecretStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationOauthSecretScheduling$outboundSchema: z.ZodType<
  RestAuthenticationOauthSecretScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthSecretScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationOauthSecretStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationOauthSecretSchedulingToJSON(
  restAuthenticationOauthSecretScheduling:
    RestAuthenticationOauthSecretScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecretScheduling$outboundSchema.parse(
      restAuthenticationOauthSecretScheduling,
    ),
  );
}
export function restAuthenticationOauthSecretSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthSecretScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthSecretScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthSecretScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthSecret$inboundSchema: z.ZodType<
  RestAuthenticationOauthSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("oauthSecret"),
  loginUrl: types.string(),
  tokenRespAttribute: types.optional(types.string()),
  authHeaderKey: types.optional(types.string()),
  authHeaderExpr: types.string(),
  clientSecretParamName: types.string(),
  textSecret: types.string(),
  authRequestParams: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  authRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectMethod: RestAuthenticationOauthSecretCollectMethod$inboundSchema,
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestAuthenticationOauthSecretScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationOauthSecret$Outbound = {
  authentication: "oauthSecret";
  loginUrl: string;
  tokenRespAttribute?: string | undefined;
  authHeaderKey?: string | undefined;
  authHeaderExpr: string;
  clientSecretParamName: string;
  textSecret: string;
  authRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationOauthSecretRestPaginationTypeNone$Outbound
    | RestAuthenticationOauthSecretRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationOauthSecretRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationOauthSecretRestRetryRulesTypeNone$Outbound
    | (
      | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?: RestAuthenticationOauthSecretScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationOauthSecret$outboundSchema: z.ZodType<
  RestAuthenticationOauthSecret$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthSecret
> = z.object({
  authentication: z.literal("oauthSecret"),
  loginUrl: z.string(),
  tokenRespAttribute: z.string().optional(),
  authHeaderKey: z.string().optional(),
  authHeaderExpr: z.string(),
  clientSecretParamName: z.string(),
  textSecret: z.string(),
  authRequestParams: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  authRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationOauthSecretCollectMethod$outboundSchema,
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthSecretRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() =>
      RestAuthenticationOauthSecretRestRetryRulesTypeNone$outboundSchema
    ),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationOauthSecretScheduling$outboundSchema
  ).optional(),
});

export function restAuthenticationOauthSecretToJSON(
  restAuthenticationOauthSecret: RestAuthenticationOauthSecret,
): string {
  return JSON.stringify(
    RestAuthenticationOauthSecret$outboundSchema.parse(
      restAuthenticationOauthSecret,
    ),
  );
}
export function restAuthenticationOauthSecretFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauthSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthSecret' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$Outbound = {
  discoverType: "none";
};

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeNone:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$outboundSchema.parse(
      restAuthenticationOauthRestDiscoveryDiscoverTypeNone,
    ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeList$Outbound = {
  discoverType: "list";
  itemList: Array<string>;
};

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeList:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeList$outboundSchema.parse(
      restAuthenticationOauthRestDiscoveryDiscoverTypeList,
    ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeList$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$Outbound = {
  discoverType: "json";
  manualDiscoverResult: string;
  discoverDataField?: string | undefined;
};

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeJson:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$outboundSchema.parse(
      restAuthenticationOauthRestDiscoveryDiscoverTypeJson,
    ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.string(),
    discoverBody: types.optional(types.string()),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb: string;
    discoverBody?: string | undefined;
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.string(),
    discoverBody: z.string().optional(),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.string(),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody: string;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.string(),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.string(),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat: string;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.string(),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationOauthRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp$outboundSchema.parse(
      restAuthenticationOauthRestDiscoveryDiscoverTypeHttp,
    ),
  );
}
export function restAuthenticationOauthRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationOauthDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestAuthenticationOauthRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationOauthDiscovery$Outbound =
  | (
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationOauthDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationOauthDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationOauthRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restAuthenticationOauthDiscoveryToJSON(
  restAuthenticationOauthDiscovery: RestAuthenticationOauthDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationOauthDiscovery$outboundSchema.parse(
      restAuthenticationOauthDiscovery,
    ),
  );
}
export function restAuthenticationOauthDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauthDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthCollectMethod$inboundSchema: z.ZodType<
  RestAuthenticationOauthCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationOauthCollectMethod);
/** @internal */
export const RestAuthenticationOauthCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationOauthCollectMethod
> = openEnums.outboundSchema(RestAuthenticationOauthCollectMethod);

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationOauthRestPaginationTypeRequestPage$Outbound = {
  type: "request_page";
  pageField: string;
  page?: number | undefined;
  sizeField: string;
  size: number;
  totalPageField?: string | undefined;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationOauthRestPaginationTypeRequestPageToJSON(
  restAuthenticationOauthRestPaginationTypeRequestPage:
    RestAuthenticationOauthRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestPaginationTypeRequestPage$outboundSchema.parse(
      restAuthenticationOauthRestPaginationTypeRequestPage,
    ),
  );
}
export function restAuthenticationOauthRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestPaginationTypeRequestPage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationOauthRestPaginationTypeRequestOffset$Outbound = {
  type: "request_offset";
  offsetField: string;
  offset?: number | undefined;
  limitField: string;
  limit: number;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationOauthRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationOauthRestPaginationTypeRequestOffset:
    RestAuthenticationOauthRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestPaginationTypeRequestOffset$outboundSchema.parse(
      restAuthenticationOauthRestPaginationTypeRequestOffset,
    ),
  );
}
export function restAuthenticationOauthRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationOauthRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationOauthRestPaginationTypeResponseHeaderLink:
    RestAuthenticationOauthRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restAuthenticationOauthRestPaginationTypeResponseHeaderLink),
  );
}
export function restAuthenticationOauthRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationOauthRestPaginationTypeResponseHeader$Outbound = {
  type: "response_header";
  attribute: Array<string>;
  maxPages: number;
};

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationOauthRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationOauthRestPaginationTypeResponseHeader:
    RestAuthenticationOauthRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestPaginationTypeResponseHeader$outboundSchema
      .parse(restAuthenticationOauthRestPaginationTypeResponseHeader),
  );
}
export function restAuthenticationOauthRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationOauthRestPaginationTypeResponseBody$Outbound = {
  type: "response_body";
  attribute: Array<string>;
  maxPages: number;
  lastPageExpr?: string | undefined;
};

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationOauthRestPaginationTypeResponseBodyToJSON(
  restAuthenticationOauthRestPaginationTypeResponseBody:
    RestAuthenticationOauthRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestPaginationTypeResponseBody$outboundSchema.parse(
      restAuthenticationOauthRestPaginationTypeResponseBody,
    ),
  );
}
export function restAuthenticationOauthRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestPaginationTypeResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationOauthRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationOauthRestPaginationTypeNoneToJSON(
  restAuthenticationOauthRestPaginationTypeNone:
    RestAuthenticationOauthRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestPaginationTypeNone$outboundSchema.parse(
      restAuthenticationOauthRestPaginationTypeNone,
    ),
  );
}
export function restAuthenticationOauthRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthPaginationUnion$inboundSchema: z.ZodType<
  RestAuthenticationOauthPaginationUnion,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeNone$inboundSchema
  ),
  response_body: z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeResponseBody$inboundSchema
  ),
  response_header: z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeResponseHeader$inboundSchema
  ),
  response_header_link: z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$inboundSchema
  ),
  request_offset: z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeRequestOffset$inboundSchema
  ),
  request_page: z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeRequestPage$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationOauthPaginationUnion$Outbound =
  | RestAuthenticationOauthRestPaginationTypeNone$Outbound
  | RestAuthenticationOauthRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationOauthRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationOauthRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationOauthRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationOauthPaginationUnion$outboundSchema: z.ZodType<
  RestAuthenticationOauthPaginationUnion$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthPaginationUnion
> = z.union([
  z.lazy(() => RestAuthenticationOauthRestPaginationTypeNone$outboundSchema),
  z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeResponseBody$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeResponseHeader$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeRequestOffset$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeRequestPage$outboundSchema
  ),
]);

export function restAuthenticationOauthPaginationUnionToJSON(
  restAuthenticationOauthPaginationUnion:
    RestAuthenticationOauthPaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationOauthPaginationUnion$outboundSchema.parse(
      restAuthenticationOauthPaginationUnion,
    ),
  );
}
export function restAuthenticationOauthPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthPaginationUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthPaginationUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    multiplier: types.optional(types.number()),
    maxIntervalMs: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.boolean().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    multiplier: z.number().optional(),
    maxIntervalMs: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(restAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue),
  );
}
export function restAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    multiplier: types.optional(types.number()),
    maxIntervalMs: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: boolean | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.boolean().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    multiplier: z.number().optional(),
    maxIntervalMs: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(restAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse),
  );
}
export function restAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationOauthRestRetryRulesTypeBackoff$Outbound =
  | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationOauthRestRetryRulesTypeBackoffToJSON(
  restAuthenticationOauthRestRetryRulesTypeBackoff:
    RestAuthenticationOauthRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestRetryRulesTypeBackoff$outboundSchema.parse(
      restAuthenticationOauthRestRetryRulesTypeBackoff,
    ),
  );
}
export function restAuthenticationOauthRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestRetryRulesTypeBackoff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.boolean().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue:
    RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(restAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue),
  );
}
export function restAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: boolean | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.boolean().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse:
    RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(restAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse),
  );
}
export function restAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationOauthRestRetryRulesTypeStatic$Outbound =
  | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationOauthRestRetryRulesTypeStaticToJSON(
  restAuthenticationOauthRestRetryRulesTypeStatic:
    RestAuthenticationOauthRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestRetryRulesTypeStatic$outboundSchema.parse(
      restAuthenticationOauthRestRetryRulesTypeStatic,
    ),
  );
}
export function restAuthenticationOauthRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationOauthRestRetryRulesTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationOauthRestRetryRulesTypeNoneToJSON(
  restAuthenticationOauthRestRetryRulesTypeNone:
    RestAuthenticationOauthRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestRetryRulesTypeNone$outboundSchema.parse(
      restAuthenticationOauthRestRetryRulesTypeNone,
    ),
  );
}
export function restAuthenticationOauthRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationOauthRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationOauthRestRetryRulesTypeNone$inboundSchema
  ),
  static: smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  backoff: smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
});
/** @internal */
export type RestAuthenticationOauthRetryRules$Outbound =
  | RestAuthenticationOauthRestRetryRulesTypeNone$Outbound
  | (
    | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
      & { type: "static" }
  )
  | (
    | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestAuthenticationOauthRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationOauthRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthRetryRules
> = z.union([
  z.lazy(() => RestAuthenticationOauthRestRetryRulesTypeNone$outboundSchema),
  smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("static") })),
  smartUnion([
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("backoff") })),
]);

export function restAuthenticationOauthRetryRulesToJSON(
  restAuthenticationOauthRetryRules: RestAuthenticationOauthRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRetryRules$outboundSchema.parse(
      restAuthenticationOauthRetryRules,
    ),
  );
}
export function restAuthenticationOauthRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauthRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthStateTracking$inboundSchema: z.ZodType<
  RestAuthenticationOauthStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: types.optional(types.boolean()),
});
/** @internal */
export type RestAuthenticationOauthStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationOauthStateTracking$outboundSchema: z.ZodType<
  RestAuthenticationOauthStateTracking$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restAuthenticationOauthStateTrackingToJSON(
  restAuthenticationOauthStateTracking: RestAuthenticationOauthStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationOauthStateTracking$outboundSchema.parse(
      restAuthenticationOauthStateTracking,
    ),
  );
}
export function restAuthenticationOauthStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthScheduling$inboundSchema: z.ZodType<
  RestAuthenticationOauthScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestAuthenticationOauthStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationOauthScheduling$Outbound = {
  stateTracking?: RestAuthenticationOauthStateTracking$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationOauthScheduling$outboundSchema: z.ZodType<
  RestAuthenticationOauthScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationOauthStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationOauthSchedulingToJSON(
  restAuthenticationOauthScheduling: RestAuthenticationOauthScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationOauthScheduling$outboundSchema.parse(
      restAuthenticationOauthScheduling,
    ),
  );
}
export function restAuthenticationOauthSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauthScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauth$inboundSchema: z.ZodType<
  RestAuthenticationOauth,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("oauth"),
  loginUrl: types.string(),
  tokenRespAttribute: types.optional(types.string()),
  authHeaderKey: types.optional(types.string()),
  authHeaderExpr: types.string(),
  clientSecretParamName: types.string(),
  clientSecretParamValue: types.string(),
  authRequestParams: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  authRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectMethod: RestAuthenticationOauthCollectMethod$inboundSchema,
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestAuthenticationOauthScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationOauth$Outbound = {
  authentication: "oauth";
  loginUrl: string;
  tokenRespAttribute?: string | undefined;
  authHeaderKey?: string | undefined;
  authHeaderExpr: string;
  clientSecretParamName: string;
  clientSecretParamValue: string;
  authRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationOauthRestPaginationTypeNone$Outbound
    | RestAuthenticationOauthRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationOauthRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationOauthRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationOauthRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationOauthRestRetryRulesTypeNone$Outbound
    | (
      | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?: RestAuthenticationOauthScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationOauth$outboundSchema: z.ZodType<
  RestAuthenticationOauth$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauth
> = z.object({
  authentication: z.literal("oauth"),
  loginUrl: z.string(),
  tokenRespAttribute: z.string().optional(),
  authHeaderKey: z.string().optional(),
  authHeaderExpr: z.string(),
  clientSecretParamName: z.string(),
  clientSecretParamValue: z.string(),
  authRequestParams: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  authRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationOauthCollectMethod$outboundSchema,
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() => RestAuthenticationOauthRestPaginationTypeNone$outboundSchema),
    z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() => RestAuthenticationOauthRestRetryRulesTypeNone$outboundSchema),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationOauthRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]).optional(),
  __scheduling: z.lazy(() => RestAuthenticationOauthScheduling$outboundSchema)
    .optional(),
});

export function restAuthenticationOauthToJSON(
  restAuthenticationOauth: RestAuthenticationOauth,
): string {
  return JSON.stringify(
    RestAuthenticationOauth$outboundSchema.parse(restAuthenticationOauth),
  );
}
export function restAuthenticationOauthFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauth, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauth' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$Outbound =
  {
    discoverType: "none";
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$Outbound =
  {
    discoverType: "list";
    itemList: Array<string>;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$Outbound =
  {
    discoverType: "json";
    manualDiscoverResult: string;
    discoverDataField?: string | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.string(),
    discoverBody: types.optional(types.string()),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb: string;
    discoverBody?: string | undefined;
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.string(),
    discoverBody: z.string().optional(),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.string(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody: string;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.string(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.string(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat: string;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.string(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$Outbound =
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery
  > = z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoveryToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$outboundSchema
      .parse(restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$Outbound =
  {
    type: "request_page";
    pageField: string;
    page?: number | undefined;
    sizeField: string;
    size: number;
    totalPageField?: string | undefined;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPageToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$Outbound =
  {
    type: "request_offset";
    offsetField: string;
    offset?: number | undefined;
    limitField: string;
    limit: number;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$Outbound =
  {
    type: "response_header";
    attribute: Array<string>;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$Outbound =
  {
    type: "response_body";
    attribute: Array<string>;
    maxPages: number;
    lastPageExpr?: string | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBodyToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody' from JSON`,
  );
}
