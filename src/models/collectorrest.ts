/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeCollectRequestParams1,
  ItemsTypeCollectRequestParams1$inboundSchema,
  ItemsTypeCollectRequestParams1$Outbound,
  ItemsTypeCollectRequestParams1$outboundSchema,
} from "./itemstypecollectrequestparams1.js";
import {
  RetryTypeOptionsRetryRules,
  RetryTypeOptionsRetryRules$inboundSchema,
  RetryTypeOptionsRetryRules$outboundSchema,
} from "./retrytypeoptionsretryrules.js";

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const CollectorRestAuthentication12 = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type CollectorRestAuthentication12 = OpenEnum<
  typeof CollectorRestAuthentication12
>;

/**
 * Collector type: rest
 */
export const CollectorRestType13 = {
  Rest: "rest",
} as const;
/**
 * Collector type: rest
 */
export type CollectorRestType13 = ClosedEnum<typeof CollectorRestType13>;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const CollectorRestDiscoverType12 = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type CollectorRestDiscoverType12 = OpenEnum<
  typeof CollectorRestDiscoverType12
>;

export type CollectorRestDiscovery12 = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType?: CollectorRestDiscoverType12 | undefined;
};

export const CollectMethod12 = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type CollectMethod12 = OpenEnum<typeof CollectMethod12>;

export const PaginationEnum12 = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type PaginationEnum12 = OpenEnum<typeof PaginationEnum12>;

export type Pagination12 = {
  type?: PaginationEnum12 | undefined;
};

export type CollectorRestRetryRules12 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type CollectorRestStateTracking12 = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type CollectorRestScheduling12 = {
  stateTracking?: CollectorRestStateTracking12 | undefined;
};

export type CollectorRestRest12 = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: CollectorRestAuthentication12 | undefined;
  /**
   * Select or create an HMAC Function to use with authentication
   */
  hmacFunctionId: string;
  /**
   * Collector type: rest
   */
  type: CollectorRestType13;
  discovery?: CollectorRestDiscovery12 | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod?: CollectMethod12 | undefined;
  /**
   * Custom HTTP method to use for the Collect operation
   */
  collectVerb?: string | undefined;
  collectRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`
   */
  collectBody?: string | undefined;
  collectRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  pagination?: Pagination12 | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules12 | undefined;
  scheduling?: CollectorRestScheduling12 | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody?: string | undefined;
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  authRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters.
   */
  clientSecretParamValue?: string | undefined;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Select or create a text secret that contains the Google service account credentials value
   */
  textSecret?: string | undefined;
  /**
   * Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information.
   */
  scopes?: Array<string> | undefined;
  /**
   * Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Email address of a user account with Super Admin permissions to the resources the collector will retrieve
   */
  subject?: string | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const CollectorRestAuthentication11 = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type CollectorRestAuthentication11 = OpenEnum<
  typeof CollectorRestAuthentication11
>;

/**
 * Collector type: rest
 */
export const CollectorRestType12 = {
  Rest: "rest",
} as const;
/**
 * Collector type: rest
 */
export type CollectorRestType12 = ClosedEnum<typeof CollectorRestType12>;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const CollectorRestDiscoverType11 = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type CollectorRestDiscoverType11 = OpenEnum<
  typeof CollectorRestDiscoverType11
>;

export type CollectorRestDiscovery11 = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType?: CollectorRestDiscoverType11 | undefined;
};

export const CollectMethod11 = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type CollectMethod11 = OpenEnum<typeof CollectMethod11>;

export const PaginationEnum11 = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type PaginationEnum11 = OpenEnum<typeof PaginationEnum11>;

export type Pagination11 = {
  type?: PaginationEnum11 | undefined;
};

export type CollectorRestRetryRules11 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type CollectorRestStateTracking11 = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type CollectorRestScheduling11 = {
  stateTracking?: CollectorRestStateTracking11 | undefined;
};

export type CollectorRestRest11 = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: CollectorRestAuthentication11 | undefined;
  /**
   * Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information.
   */
  scopes: Array<string>;
  /**
   * Select or create a text secret that contains the Google service account credentials value
   */
  textSecret: string;
  /**
   * Email address of a user account with Super Admin permissions to the resources the collector will retrieve
   */
  subject: string;
  /**
   * Collector type: rest
   */
  type: CollectorRestType12;
  discovery?: CollectorRestDiscovery11 | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod?: CollectMethod11 | undefined;
  /**
   * Custom HTTP method to use for the Collect operation
   */
  collectVerb?: string | undefined;
  collectRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`
   */
  collectBody?: string | undefined;
  collectRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  pagination?: Pagination11 | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules11 | undefined;
  scheduling?: CollectorRestScheduling11 | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody?: string | undefined;
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  authRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters.
   */
  clientSecretParamValue?: string | undefined;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Select or create an HMAC Function to use with authentication
   */
  hmacFunctionId?: string | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const CollectorRestAuthentication10 = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type CollectorRestAuthentication10 = OpenEnum<
  typeof CollectorRestAuthentication10
>;

/**
 * Collector type: rest
 */
export const CollectorRestType11 = {
  Rest: "rest",
} as const;
/**
 * Collector type: rest
 */
export type CollectorRestType11 = ClosedEnum<typeof CollectorRestType11>;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const CollectorRestDiscoverType10 = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type CollectorRestDiscoverType10 = OpenEnum<
  typeof CollectorRestDiscoverType10
>;

export type CollectorRestDiscovery10 = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType?: CollectorRestDiscoverType10 | undefined;
};

export const CollectMethod10 = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type CollectMethod10 = OpenEnum<typeof CollectMethod10>;

export const PaginationEnum10 = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type PaginationEnum10 = OpenEnum<typeof PaginationEnum10>;

export type Pagination10 = {
  type?: PaginationEnum10 | undefined;
};

export type CollectorRestRetryRules10 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type CollectorRestStateTracking10 = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type CollectorRestScheduling10 = {
  stateTracking?: CollectorRestStateTracking10 | undefined;
};

export type CollectorRestRest10 = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: CollectorRestAuthentication10 | undefined;
  /**
   * Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information.
   */
  scopes: Array<string>;
  /**
   * Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right.
   */
  serviceAccountCredentials: string;
  /**
   * Email address of a user account with Super Admin permissions to the resources the collector will retrieve
   */
  subject: string;
  /**
   * Collector type: rest
   */
  type: CollectorRestType11;
  discovery?: CollectorRestDiscovery10 | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod?: CollectMethod10 | undefined;
  /**
   * Custom HTTP method to use for the Collect operation
   */
  collectVerb?: string | undefined;
  collectRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`
   */
  collectBody?: string | undefined;
  collectRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  pagination?: Pagination10 | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules10 | undefined;
  scheduling?: CollectorRestScheduling10 | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody?: string | undefined;
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  authRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters.
   */
  clientSecretParamValue?: string | undefined;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Select or create a text secret that contains the Google service account credentials value
   */
  textSecret?: string | undefined;
  /**
   * Select or create an HMAC Function to use with authentication
   */
  hmacFunctionId?: string | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const CollectorRestAuthentication9 = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type CollectorRestAuthentication9 = OpenEnum<
  typeof CollectorRestAuthentication9
>;

/**
 * Collector type: rest
 */
export const CollectorRestType10 = {
  Rest: "rest",
} as const;
/**
 * Collector type: rest
 */
export type CollectorRestType10 = ClosedEnum<typeof CollectorRestType10>;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const CollectorRestDiscoverType9 = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type CollectorRestDiscoverType9 = OpenEnum<
  typeof CollectorRestDiscoverType9
>;

export type CollectorRestDiscovery9 = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType?: CollectorRestDiscoverType9 | undefined;
};

export const CollectMethod9 = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type CollectMethod9 = OpenEnum<typeof CollectMethod9>;

export const PaginationEnum9 = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type PaginationEnum9 = OpenEnum<typeof PaginationEnum9>;

export type Pagination9 = {
  type?: PaginationEnum9 | undefined;
};

export type CollectorRestRetryRules9 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type CollectorRestStateTracking9 = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type CollectorRestScheduling9 = {
  stateTracking?: CollectorRestStateTracking9 | undefined;
};

export type CollectorRestRest9 = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: CollectorRestAuthentication9 | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Select or create a text secret that contains the Google service account credentials value
   */
  textSecret: string;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  authRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Collector type: rest
   */
  type: CollectorRestType10;
  discovery?: CollectorRestDiscovery9 | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod?: CollectMethod9 | undefined;
  /**
   * Custom HTTP method to use for the Collect operation
   */
  collectVerb?: string | undefined;
  collectRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`
   */
  collectBody?: string | undefined;
  collectRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  pagination?: Pagination9 | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules9 | undefined;
  scheduling?: CollectorRestScheduling9 | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody?: string | undefined;
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters.
   */
  clientSecretParamValue?: string | undefined;
  /**
   * Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information.
   */
  scopes?: Array<string> | undefined;
  /**
   * Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Email address of a user account with Super Admin permissions to the resources the collector will retrieve
   */
  subject?: string | undefined;
  /**
   * Select or create an HMAC Function to use with authentication
   */
  hmacFunctionId?: string | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const CollectorRestAuthentication8 = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type CollectorRestAuthentication8 = OpenEnum<
  typeof CollectorRestAuthentication8
>;

/**
 * Collector type: rest
 */
export const CollectorRestType9 = {
  Rest: "rest",
} as const;
/**
 * Collector type: rest
 */
export type CollectorRestType9 = ClosedEnum<typeof CollectorRestType9>;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const CollectorRestDiscoverType8 = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type CollectorRestDiscoverType8 = OpenEnum<
  typeof CollectorRestDiscoverType8
>;

export type CollectorRestDiscovery8 = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType?: CollectorRestDiscoverType8 | undefined;
};

export const CollectMethod8 = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type CollectMethod8 = OpenEnum<typeof CollectMethod8>;

export const PaginationEnum8 = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type PaginationEnum8 = OpenEnum<typeof PaginationEnum8>;

export type Pagination8 = {
  type?: PaginationEnum8 | undefined;
};

export type CollectorRestRetryRules8 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type CollectorRestStateTracking8 = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type CollectorRestScheduling8 = {
  stateTracking?: CollectorRestStateTracking8 | undefined;
};

export type CollectorRestRest8 = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: CollectorRestAuthentication8 | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters.
   */
  clientSecretParamValue: string;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  authRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Collector type: rest
   */
  type: CollectorRestType9;
  discovery?: CollectorRestDiscovery8 | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod?: CollectMethod8 | undefined;
  /**
   * Custom HTTP method to use for the Collect operation
   */
  collectVerb?: string | undefined;
  collectRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`
   */
  collectBody?: string | undefined;
  collectRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  pagination?: Pagination8 | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules8 | undefined;
  scheduling?: CollectorRestScheduling8 | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody?: string | undefined;
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Select or create a text secret that contains the Google service account credentials value
   */
  textSecret?: string | undefined;
  /**
   * Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information.
   */
  scopes?: Array<string> | undefined;
  /**
   * Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Email address of a user account with Super Admin permissions to the resources the collector will retrieve
   */
  subject?: string | undefined;
  /**
   * Select or create an HMAC Function to use with authentication
   */
  hmacFunctionId?: string | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const CollectorRestAuthentication7 = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type CollectorRestAuthentication7 = OpenEnum<
  typeof CollectorRestAuthentication7
>;

/**
 * Collector type: rest
 */
export const CollectorRestType8 = {
  Rest: "rest",
} as const;
/**
 * Collector type: rest
 */
export type CollectorRestType8 = ClosedEnum<typeof CollectorRestType8>;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const CollectorRestDiscoverType7 = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type CollectorRestDiscoverType7 = OpenEnum<
  typeof CollectorRestDiscoverType7
>;

export type CollectorRestDiscovery7 = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType?: CollectorRestDiscoverType7 | undefined;
};

export const CollectMethod7 = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type CollectMethod7 = OpenEnum<typeof CollectMethod7>;

export const PaginationEnum7 = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type PaginationEnum7 = OpenEnum<typeof PaginationEnum7>;

export type Pagination7 = {
  type?: PaginationEnum7 | undefined;
};

export type CollectorRestRetryRules7 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type CollectorRestStateTracking7 = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type CollectorRestScheduling7 = {
  stateTracking?: CollectorRestStateTracking7 | undefined;
};

export type CollectorRestRest7 = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: CollectorRestAuthentication7 | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret: string;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody?: string | undefined;
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  authRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Collector type: rest
   */
  type: CollectorRestType8;
  discovery?: CollectorRestDiscovery7 | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod?: CollectMethod7 | undefined;
  /**
   * Custom HTTP method to use for the Collect operation
   */
  collectVerb?: string | undefined;
  collectRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`
   */
  collectBody?: string | undefined;
  collectRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  pagination?: Pagination7 | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules7 | undefined;
  scheduling?: CollectorRestScheduling7 | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters.
   */
  clientSecretParamValue?: string | undefined;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Select or create a text secret that contains the Google service account credentials value
   */
  textSecret?: string | undefined;
  /**
   * Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information.
   */
  scopes?: Array<string> | undefined;
  /**
   * Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Email address of a user account with Super Admin permissions to the resources the collector will retrieve
   */
  subject?: string | undefined;
  /**
   * Select or create an HMAC Function to use with authentication
   */
  hmacFunctionId?: string | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const CollectorRestAuthentication6 = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type CollectorRestAuthentication6 = OpenEnum<
  typeof CollectorRestAuthentication6
>;

/**
 * Collector type: rest
 */
export const CollectorRestType7 = {
  Rest: "rest",
} as const;
/**
 * Collector type: rest
 */
export type CollectorRestType7 = ClosedEnum<typeof CollectorRestType7>;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const CollectorRestDiscoverType6 = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type CollectorRestDiscoverType6 = OpenEnum<
  typeof CollectorRestDiscoverType6
>;

export type CollectorRestDiscovery6 = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType?: CollectorRestDiscoverType6 | undefined;
};

export const CollectMethod6 = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type CollectMethod6 = OpenEnum<typeof CollectMethod6>;

export const PaginationEnum6 = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type PaginationEnum6 = OpenEnum<typeof PaginationEnum6>;

export type Pagination6 = {
  type?: PaginationEnum6 | undefined;
};

export type CollectorRestRetryRules6 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type CollectorRestStateTracking6 = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type CollectorRestScheduling6 = {
  stateTracking?: CollectorRestStateTracking6 | undefined;
};

export type CollectorRestRest6 = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: CollectorRestAuthentication6 | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  username: string;
  password: string;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody?: string | undefined;
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  authRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Collector type: rest
   */
  type: CollectorRestType7;
  discovery?: CollectorRestDiscovery6 | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod?: CollectMethod6 | undefined;
  /**
   * Custom HTTP method to use for the Collect operation
   */
  collectVerb?: string | undefined;
  collectRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`
   */
  collectBody?: string | undefined;
  collectRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  pagination?: Pagination6 | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules6 | undefined;
  scheduling?: CollectorRestScheduling6 | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters.
   */
  clientSecretParamValue?: string | undefined;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Select or create a text secret that contains the Google service account credentials value
   */
  textSecret?: string | undefined;
  /**
   * Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information.
   */
  scopes?: Array<string> | undefined;
  /**
   * Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Email address of a user account with Super Admin permissions to the resources the collector will retrieve
   */
  subject?: string | undefined;
  /**
   * Select or create an HMAC Function to use with authentication
   */
  hmacFunctionId?: string | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const AuthenticationRest = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type AuthenticationRest = OpenEnum<typeof AuthenticationRest>;

/**
 * Collector type: rest
 */
export const CollectorRestType5 = {
  Rest: "rest",
} as const;
/**
 * Collector type: rest
 */
export type CollectorRestType5 = ClosedEnum<typeof CollectorRestType5>;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const DiscoverTypeRest = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type DiscoverTypeRest = OpenEnum<typeof DiscoverTypeRest>;

export type DiscoveryRest = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType?: DiscoverTypeRest | undefined;
};

export const CollectMethodRest = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type CollectMethodRest = OpenEnum<typeof CollectMethodRest>;

export const PaginationRestEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type PaginationRestEnum = OpenEnum<typeof PaginationRestEnum>;

export type PaginationRest = {
  type?: PaginationRestEnum | undefined;
};

export type RetryRulesRest = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type StateTrackingRest = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type SchedulingRest = {
  stateTracking?: StateTrackingRest | undefined;
};

export type CollectorRestCollectorHealthCheckPart2Type = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: AuthenticationRest | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret: string;
  /**
   * Collector type: rest
   */
  type: CollectorRestType5;
  discovery?: DiscoveryRest | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod?: CollectMethodRest | undefined;
  /**
   * Custom HTTP method to use for the Collect operation
   */
  collectVerb?: string | undefined;
  collectRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`
   */
  collectBody?: string | undefined;
  collectRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  pagination?: PaginationRest | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RetryRulesRest | undefined;
  scheduling?: SchedulingRest | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody?: string | undefined;
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  authRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters.
   */
  clientSecretParamValue?: string | undefined;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Select or create a text secret that contains the Google service account credentials value
   */
  textSecret?: string | undefined;
  /**
   * Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information.
   */
  scopes?: Array<string> | undefined;
  /**
   * Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Email address of a user account with Super Admin permissions to the resources the collector will retrieve
   */
  subject?: string | undefined;
  /**
   * Select or create an HMAC Function to use with authentication
   */
  hmacFunctionId?: string | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const CollectorRestAuthentication5 = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type CollectorRestAuthentication5 = OpenEnum<
  typeof CollectorRestAuthentication5
>;

/**
 * Collector type: rest
 */
export const CollectorRestType6 = {
  Rest: "rest",
} as const;
/**
 * Collector type: rest
 */
export type CollectorRestType6 = ClosedEnum<typeof CollectorRestType6>;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const CollectorRestDiscoverType5 = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type CollectorRestDiscoverType5 = OpenEnum<
  typeof CollectorRestDiscoverType5
>;

export type CollectorRestDiscovery5 = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType?: CollectorRestDiscoverType5 | undefined;
};

export const CollectMethod5 = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type CollectMethod5 = OpenEnum<typeof CollectMethod5>;

export const PaginationEnum5 = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type PaginationEnum5 = OpenEnum<typeof PaginationEnum5>;

export type Pagination5 = {
  type?: PaginationEnum5 | undefined;
};

export type CollectorRestRetryRules5 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type CollectorRestStateTracking5 = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type CollectorRestScheduling5 = {
  stateTracking?: CollectorRestStateTracking5 | undefined;
};

export type CollectorRestRest5 = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: CollectorRestAuthentication5 | undefined;
  username: string;
  password: string;
  /**
   * Collector type: rest
   */
  type: CollectorRestType6;
  discovery?: CollectorRestDiscovery5 | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod?: CollectMethod5 | undefined;
  /**
   * Custom HTTP method to use for the Collect operation
   */
  collectVerb?: string | undefined;
  collectRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`
   */
  collectBody?: string | undefined;
  collectRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  pagination?: Pagination5 | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules5 | undefined;
  scheduling?: CollectorRestScheduling5 | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody?: string | undefined;
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  authRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters.
   */
  clientSecretParamValue?: string | undefined;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Select or create a text secret that contains the Google service account credentials value
   */
  textSecret?: string | undefined;
  /**
   * Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information.
   */
  scopes?: Array<string> | undefined;
  /**
   * Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Email address of a user account with Super Admin permissions to the resources the collector will retrieve
   */
  subject?: string | undefined;
  /**
   * Select or create an HMAC Function to use with authentication
   */
  hmacFunctionId?: string | undefined;
};

export type CollectorRestCollectorHealthCheckPart0Type = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: AuthenticationRest | undefined;
  /**
   * Collector type: rest
   */
  type: CollectorRestType5;
  discovery?: DiscoveryRest | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod?: CollectMethodRest | undefined;
  /**
   * Custom HTTP method to use for the Collect operation
   */
  collectVerb?: string | undefined;
  collectRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`
   */
  collectBody?: string | undefined;
  collectRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  pagination?: PaginationRest | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RetryRulesRest | undefined;
  scheduling?: SchedulingRest | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody?: string | undefined;
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  authRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters.
   */
  clientSecretParamValue?: string | undefined;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Select or create a text secret that contains the Google service account credentials value
   */
  textSecret?: string | undefined;
  /**
   * Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information.
   */
  scopes?: Array<string> | undefined;
  /**
   * Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Email address of a user account with Super Admin permissions to the resources the collector will retrieve
   */
  subject?: string | undefined;
  /**
   * Select or create an HMAC Function to use with authentication
   */
  hmacFunctionId?: string | undefined;
};

export const CollectMethod4 = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type CollectMethod4 = OpenEnum<typeof CollectMethod4>;

/**
 * Collector type: rest
 */
export const CollectorRestType4 = {
  Rest: "rest",
} as const;
/**
 * Collector type: rest
 */
export type CollectorRestType4 = ClosedEnum<typeof CollectorRestType4>;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const CollectorRestDiscoverType4 = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type CollectorRestDiscoverType4 = OpenEnum<
  typeof CollectorRestDiscoverType4
>;

export type CollectorRestDiscovery4 = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType?: CollectorRestDiscoverType4 | undefined;
};

export const PaginationEnum4 = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type PaginationEnum4 = OpenEnum<typeof PaginationEnum4>;

export type Pagination4 = {
  type?: PaginationEnum4 | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const CollectorRestAuthentication4 = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type CollectorRestAuthentication4 = OpenEnum<
  typeof CollectorRestAuthentication4
>;

export type CollectorRestRetryRules4 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type CollectorRestStateTracking4 = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type CollectorRestScheduling4 = {
  stateTracking?: CollectorRestStateTracking4 | undefined;
};

export type CollectorRestRest4 = {
  collectMethod?: CollectMethod4 | undefined;
  /**
   * Custom HTTP method to use for the Collect operation
   */
  collectVerb: string;
  /**
   * Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`
   */
  collectBody?: string | undefined;
  collectRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Collector type: rest
   */
  type: CollectorRestType4;
  discovery?: CollectorRestDiscovery4 | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  pagination?: Pagination4 | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: CollectorRestAuthentication4 | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules4 | undefined;
  scheduling?: CollectorRestScheduling4 | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody?: string | undefined;
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  authRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters.
   */
  clientSecretParamValue?: string | undefined;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Select or create a text secret that contains the Google service account credentials value
   */
  textSecret?: string | undefined;
  /**
   * Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information.
   */
  scopes?: Array<string> | undefined;
  /**
   * Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Email address of a user account with Super Admin permissions to the resources the collector will retrieve
   */
  subject?: string | undefined;
  /**
   * Select or create an HMAC Function to use with authentication
   */
  hmacFunctionId?: string | undefined;
};

export const CollectMethod3 = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type CollectMethod3 = OpenEnum<typeof CollectMethod3>;

/**
 * Collector type: rest
 */
export const CollectorRestType3 = {
  Rest: "rest",
} as const;
/**
 * Collector type: rest
 */
export type CollectorRestType3 = ClosedEnum<typeof CollectorRestType3>;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const CollectorRestDiscoverType3 = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type CollectorRestDiscoverType3 = OpenEnum<
  typeof CollectorRestDiscoverType3
>;

export type CollectorRestDiscovery3 = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType?: CollectorRestDiscoverType3 | undefined;
};

export const PaginationEnum3 = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type PaginationEnum3 = OpenEnum<typeof PaginationEnum3>;

export type Pagination3 = {
  type?: PaginationEnum3 | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const CollectorRestAuthentication3 = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type CollectorRestAuthentication3 = OpenEnum<
  typeof CollectorRestAuthentication3
>;

export type CollectorRestRetryRules3 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type CollectorRestStateTracking3 = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type CollectorRestScheduling3 = {
  stateTracking?: CollectorRestStateTracking3 | undefined;
};

export type CollectorRestRest3 = {
  collectMethod?: CollectMethod3 | undefined;
  /**
   * Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`
   */
  collectBody: string;
  /**
   * Collector type: rest
   */
  type: CollectorRestType3;
  discovery?: CollectorRestDiscovery3 | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  /**
   * Custom HTTP method to use for the Collect operation
   */
  collectVerb?: string | undefined;
  collectRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  collectRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  pagination?: Pagination3 | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: CollectorRestAuthentication3 | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules3 | undefined;
  scheduling?: CollectorRestScheduling3 | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody?: string | undefined;
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  authRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters.
   */
  clientSecretParamValue?: string | undefined;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Select or create a text secret that contains the Google service account credentials value
   */
  textSecret?: string | undefined;
  /**
   * Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information.
   */
  scopes?: Array<string> | undefined;
  /**
   * Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Email address of a user account with Super Admin permissions to the resources the collector will retrieve
   */
  subject?: string | undefined;
  /**
   * Select or create an HMAC Function to use with authentication
   */
  hmacFunctionId?: string | undefined;
};

export const CollectMethod2 = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type CollectMethod2 = OpenEnum<typeof CollectMethod2>;

/**
 * Collector type: rest
 */
export const CollectorRestType2 = {
  Rest: "rest",
} as const;
/**
 * Collector type: rest
 */
export type CollectorRestType2 = ClosedEnum<typeof CollectorRestType2>;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const CollectorRestDiscoverType2 = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type CollectorRestDiscoverType2 = OpenEnum<
  typeof CollectorRestDiscoverType2
>;

export type CollectorRestDiscovery2 = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType?: CollectorRestDiscoverType2 | undefined;
};

export const PaginationEnum2 = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type PaginationEnum2 = OpenEnum<typeof PaginationEnum2>;

export type Pagination2 = {
  type?: PaginationEnum2 | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const CollectorRestAuthentication2 = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type CollectorRestAuthentication2 = OpenEnum<
  typeof CollectorRestAuthentication2
>;

export type CollectorRestRetryRules2 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type CollectorRestStateTracking2 = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type CollectorRestScheduling2 = {
  stateTracking?: CollectorRestStateTracking2 | undefined;
};

export type CollectorRestRest2 = {
  collectMethod?: CollectMethod2 | undefined;
  collectRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Collector type: rest
   */
  type: CollectorRestType2;
  discovery?: CollectorRestDiscovery2 | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  /**
   * Custom HTTP method to use for the Collect operation
   */
  collectVerb?: string | undefined;
  /**
   * Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`
   */
  collectBody?: string | undefined;
  collectRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  pagination?: Pagination2 | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: CollectorRestAuthentication2 | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules2 | undefined;
  scheduling?: CollectorRestScheduling2 | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody?: string | undefined;
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  authRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters.
   */
  clientSecretParamValue?: string | undefined;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Select or create a text secret that contains the Google service account credentials value
   */
  textSecret?: string | undefined;
  /**
   * Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information.
   */
  scopes?: Array<string> | undefined;
  /**
   * Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Email address of a user account with Super Admin permissions to the resources the collector will retrieve
   */
  subject?: string | undefined;
  /**
   * Select or create an HMAC Function to use with authentication
   */
  hmacFunctionId?: string | undefined;
};

export const CollectMethod1 = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type CollectMethod1 = OpenEnum<typeof CollectMethod1>;

/**
 * Collector type: rest
 */
export const CollectorRestType1 = {
  Rest: "rest",
} as const;
/**
 * Collector type: rest
 */
export type CollectorRestType1 = ClosedEnum<typeof CollectorRestType1>;

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const CollectorRestDiscoverType1 = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type CollectorRestDiscoverType1 = OpenEnum<
  typeof CollectorRestDiscoverType1
>;

export type CollectorRestDiscovery1 = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType?: CollectorRestDiscoverType1 | undefined;
};

export const PaginationEnum1 = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type PaginationEnum1 = OpenEnum<typeof PaginationEnum1>;

export type Pagination1 = {
  type?: PaginationEnum1 | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const CollectorRestAuthentication1 = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type CollectorRestAuthentication1 = OpenEnum<
  typeof CollectorRestAuthentication1
>;

export type CollectorRestRetryRules1 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type CollectorRestStateTracking1 = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type CollectorRestScheduling1 = {
  stateTracking?: CollectorRestStateTracking1 | undefined;
};

export type CollectorRestRest1 = {
  collectMethod?: CollectMethod1 | undefined;
  collectRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Collector type: rest
   */
  type: CollectorRestType1;
  discovery?: CollectorRestDiscovery1 | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  /**
   * Custom HTTP method to use for the Collect operation
   */
  collectVerb?: string | undefined;
  /**
   * Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`
   */
  collectBody?: string | undefined;
  collectRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  pagination?: Pagination1 | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: CollectorRestAuthentication1 | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules1 | undefined;
  scheduling?: CollectorRestScheduling1 | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody?: string | undefined;
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  authRequestHeaders?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters.
   */
  clientSecretParamValue?: string | undefined;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeCollectRequestParams1> | undefined;
  /**
   * Select or create a text secret that contains the Google service account credentials value
   */
  textSecret?: string | undefined;
  /**
   * Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information.
   */
  scopes?: Array<string> | undefined;
  /**
   * Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Email address of a user account with Super Admin permissions to the resources the collector will retrieve
   */
  subject?: string | undefined;
  /**
   * Select or create an HMAC Function to use with authentication
   */
  hmacFunctionId?: string | undefined;
};

export type CollectorRest =
  | CollectorRestRest10
  | CollectorRestRest11
  | CollectorRestRest5
  | CollectorRestRest6
  | CollectorRestRest3
  | CollectorRestRest4
  | CollectorRestCollectorHealthCheckPart2Type
  | CollectorRestRest7
  | CollectorRestRest8
  | CollectorRestRest9
  | CollectorRestRest12
  | CollectorRestRest1
  | CollectorRestRest2
  | CollectorRestCollectorHealthCheckPart0Type;

/** @internal */
export const CollectorRestAuthentication12$inboundSchema: z.ZodType<
  CollectorRestAuthentication12,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestAuthentication12);
/** @internal */
export const CollectorRestAuthentication12$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestAuthentication12
> = openEnums.outboundSchema(CollectorRestAuthentication12);

/** @internal */
export const CollectorRestType13$inboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType13
> = z.nativeEnum(CollectorRestType13);
/** @internal */
export const CollectorRestType13$outboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType13
> = CollectorRestType13$inboundSchema;

/** @internal */
export const CollectorRestDiscoverType12$inboundSchema: z.ZodType<
  CollectorRestDiscoverType12,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestDiscoverType12);
/** @internal */
export const CollectorRestDiscoverType12$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestDiscoverType12
> = openEnums.outboundSchema(CollectorRestDiscoverType12);

/** @internal */
export const CollectorRestDiscovery12$inboundSchema: z.ZodType<
  CollectorRestDiscovery12,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: CollectorRestDiscoverType12$inboundSchema.default("none"),
});
/** @internal */
export type CollectorRestDiscovery12$Outbound = {
  discoverType: string;
};

/** @internal */
export const CollectorRestDiscovery12$outboundSchema: z.ZodType<
  CollectorRestDiscovery12$Outbound,
  z.ZodTypeDef,
  CollectorRestDiscovery12
> = z.object({
  discoverType: CollectorRestDiscoverType12$outboundSchema.default("none"),
});

export function collectorRestDiscovery12ToJSON(
  collectorRestDiscovery12: CollectorRestDiscovery12,
): string {
  return JSON.stringify(
    CollectorRestDiscovery12$outboundSchema.parse(collectorRestDiscovery12),
  );
}
export function collectorRestDiscovery12FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestDiscovery12, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestDiscovery12$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestDiscovery12' from JSON`,
  );
}

/** @internal */
export const CollectMethod12$inboundSchema: z.ZodType<
  CollectMethod12,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectMethod12);
/** @internal */
export const CollectMethod12$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectMethod12
> = openEnums.outboundSchema(CollectMethod12);

/** @internal */
export const PaginationEnum12$inboundSchema: z.ZodType<
  PaginationEnum12,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(PaginationEnum12);
/** @internal */
export const PaginationEnum12$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  PaginationEnum12
> = openEnums.outboundSchema(PaginationEnum12);

/** @internal */
export const Pagination12$inboundSchema: z.ZodType<
  Pagination12,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: PaginationEnum12$inboundSchema.default("none"),
});
/** @internal */
export type Pagination12$Outbound = {
  type: string;
};

/** @internal */
export const Pagination12$outboundSchema: z.ZodType<
  Pagination12$Outbound,
  z.ZodTypeDef,
  Pagination12
> = z.object({
  type: PaginationEnum12$outboundSchema.default("none"),
});

export function pagination12ToJSON(pagination12: Pagination12): string {
  return JSON.stringify(Pagination12$outboundSchema.parse(pagination12));
}
export function pagination12FromJSON(
  jsonString: string,
): SafeParseResult<Pagination12, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Pagination12$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Pagination12' from JSON`,
  );
}

/** @internal */
export const CollectorRestRetryRules12$inboundSchema: z.ZodType<
  CollectorRestRetryRules12,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type CollectorRestRetryRules12$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const CollectorRestRetryRules12$outboundSchema: z.ZodType<
  CollectorRestRetryRules12$Outbound,
  z.ZodTypeDef,
  CollectorRestRetryRules12
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function collectorRestRetryRules12ToJSON(
  collectorRestRetryRules12: CollectorRestRetryRules12,
): string {
  return JSON.stringify(
    CollectorRestRetryRules12$outboundSchema.parse(collectorRestRetryRules12),
  );
}
export function collectorRestRetryRules12FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRetryRules12, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRetryRules12$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRetryRules12' from JSON`,
  );
}

/** @internal */
export const CollectorRestStateTracking12$inboundSchema: z.ZodType<
  CollectorRestStateTracking12,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type CollectorRestStateTracking12$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const CollectorRestStateTracking12$outboundSchema: z.ZodType<
  CollectorRestStateTracking12$Outbound,
  z.ZodTypeDef,
  CollectorRestStateTracking12
> = z.object({
  enabled: z.boolean().optional(),
});

export function collectorRestStateTracking12ToJSON(
  collectorRestStateTracking12: CollectorRestStateTracking12,
): string {
  return JSON.stringify(
    CollectorRestStateTracking12$outboundSchema.parse(
      collectorRestStateTracking12,
    ),
  );
}
export function collectorRestStateTracking12FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestStateTracking12, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestStateTracking12$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestStateTracking12' from JSON`,
  );
}

/** @internal */
export const CollectorRestScheduling12$inboundSchema: z.ZodType<
  CollectorRestScheduling12,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking12$inboundSchema)
    .optional(),
});
/** @internal */
export type CollectorRestScheduling12$Outbound = {
  stateTracking?: CollectorRestStateTracking12$Outbound | undefined;
};

/** @internal */
export const CollectorRestScheduling12$outboundSchema: z.ZodType<
  CollectorRestScheduling12$Outbound,
  z.ZodTypeDef,
  CollectorRestScheduling12
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking12$outboundSchema)
    .optional(),
});

export function collectorRestScheduling12ToJSON(
  collectorRestScheduling12: CollectorRestScheduling12,
): string {
  return JSON.stringify(
    CollectorRestScheduling12$outboundSchema.parse(collectorRestScheduling12),
  );
}
export function collectorRestScheduling12FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestScheduling12, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestScheduling12$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestScheduling12' from JSON`,
  );
}

/** @internal */
export const CollectorRestRest12$inboundSchema: z.ZodType<
  CollectorRestRest12,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: CollectorRestAuthentication12$inboundSchema.default("none"),
  hmacFunctionId: z.string(),
  type: CollectorRestType13$inboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery12$inboundSchema).optional(),
  collectUrl: z.string(),
  collectMethod: CollectMethod12$inboundSchema.default("get"),
  collectVerb: z.string().optional(),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  collectBody: z.string().optional(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination12$inboundSchema).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules12$inboundSchema).optional(),
  __scheduling: z.lazy(() => CollectorRestScheduling12$inboundSchema)
    .optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginUrl: z.string().default(""),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  tokenRespAttribute: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  serviceAccountCredentials: z.string().optional(),
  subject: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "__scheduling": "scheduling",
  });
});
/** @internal */
export type CollectorRestRest12$Outbound = {
  authentication: string;
  hmacFunctionId: string;
  type: string;
  discovery?: CollectorRestDiscovery12$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: string | undefined;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  collectBody?: string | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  pagination?: Pagination12$Outbound | undefined;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  decodeUrl: boolean;
  rejectUnauthorized: boolean;
  captureHeaders: boolean;
  stopOnEmptyResults: boolean;
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules12$Outbound | undefined;
  __scheduling?: CollectorRestScheduling12$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  loginUrl: string;
  loginBody: string;
  getAuthTokenFromHeader: boolean;
  authHeaderKey: string;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  tokenRespAttribute?: string | undefined;
  clientSecretParamName: string;
  clientSecretParamValue?: string | undefined;
  authRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  textSecret?: string | undefined;
  scopes?: Array<string> | undefined;
  serviceAccountCredentials?: string | undefined;
  subject?: string | undefined;
};

/** @internal */
export const CollectorRestRest12$outboundSchema: z.ZodType<
  CollectorRestRest12$Outbound,
  z.ZodTypeDef,
  CollectorRestRest12
> = z.object({
  authentication: CollectorRestAuthentication12$outboundSchema.default("none"),
  hmacFunctionId: z.string(),
  type: CollectorRestType13$outboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery12$outboundSchema).optional(),
  collectUrl: z.string(),
  collectMethod: CollectMethod12$outboundSchema.default("get"),
  collectVerb: z.string().optional(),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  collectBody: z.string().optional(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination12$outboundSchema).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules12$outboundSchema).optional(),
  scheduling: z.lazy(() => CollectorRestScheduling12$outboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginUrl: z.string().default(""),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  tokenRespAttribute: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  serviceAccountCredentials: z.string().optional(),
  subject: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    scheduling: "__scheduling",
  });
});

export function collectorRestRest12ToJSON(
  collectorRestRest12: CollectorRestRest12,
): string {
  return JSON.stringify(
    CollectorRestRest12$outboundSchema.parse(collectorRestRest12),
  );
}
export function collectorRestRest12FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRest12, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRest12$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRest12' from JSON`,
  );
}

/** @internal */
export const CollectorRestAuthentication11$inboundSchema: z.ZodType<
  CollectorRestAuthentication11,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestAuthentication11);
/** @internal */
export const CollectorRestAuthentication11$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestAuthentication11
> = openEnums.outboundSchema(CollectorRestAuthentication11);

/** @internal */
export const CollectorRestType12$inboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType12
> = z.nativeEnum(CollectorRestType12);
/** @internal */
export const CollectorRestType12$outboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType12
> = CollectorRestType12$inboundSchema;

/** @internal */
export const CollectorRestDiscoverType11$inboundSchema: z.ZodType<
  CollectorRestDiscoverType11,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestDiscoverType11);
/** @internal */
export const CollectorRestDiscoverType11$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestDiscoverType11
> = openEnums.outboundSchema(CollectorRestDiscoverType11);

/** @internal */
export const CollectorRestDiscovery11$inboundSchema: z.ZodType<
  CollectorRestDiscovery11,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: CollectorRestDiscoverType11$inboundSchema.default("none"),
});
/** @internal */
export type CollectorRestDiscovery11$Outbound = {
  discoverType: string;
};

/** @internal */
export const CollectorRestDiscovery11$outboundSchema: z.ZodType<
  CollectorRestDiscovery11$Outbound,
  z.ZodTypeDef,
  CollectorRestDiscovery11
> = z.object({
  discoverType: CollectorRestDiscoverType11$outboundSchema.default("none"),
});

export function collectorRestDiscovery11ToJSON(
  collectorRestDiscovery11: CollectorRestDiscovery11,
): string {
  return JSON.stringify(
    CollectorRestDiscovery11$outboundSchema.parse(collectorRestDiscovery11),
  );
}
export function collectorRestDiscovery11FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestDiscovery11, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestDiscovery11$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestDiscovery11' from JSON`,
  );
}

/** @internal */
export const CollectMethod11$inboundSchema: z.ZodType<
  CollectMethod11,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectMethod11);
/** @internal */
export const CollectMethod11$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectMethod11
> = openEnums.outboundSchema(CollectMethod11);

/** @internal */
export const PaginationEnum11$inboundSchema: z.ZodType<
  PaginationEnum11,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(PaginationEnum11);
/** @internal */
export const PaginationEnum11$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  PaginationEnum11
> = openEnums.outboundSchema(PaginationEnum11);

/** @internal */
export const Pagination11$inboundSchema: z.ZodType<
  Pagination11,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: PaginationEnum11$inboundSchema.default("none"),
});
/** @internal */
export type Pagination11$Outbound = {
  type: string;
};

/** @internal */
export const Pagination11$outboundSchema: z.ZodType<
  Pagination11$Outbound,
  z.ZodTypeDef,
  Pagination11
> = z.object({
  type: PaginationEnum11$outboundSchema.default("none"),
});

export function pagination11ToJSON(pagination11: Pagination11): string {
  return JSON.stringify(Pagination11$outboundSchema.parse(pagination11));
}
export function pagination11FromJSON(
  jsonString: string,
): SafeParseResult<Pagination11, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Pagination11$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Pagination11' from JSON`,
  );
}

/** @internal */
export const CollectorRestRetryRules11$inboundSchema: z.ZodType<
  CollectorRestRetryRules11,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type CollectorRestRetryRules11$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const CollectorRestRetryRules11$outboundSchema: z.ZodType<
  CollectorRestRetryRules11$Outbound,
  z.ZodTypeDef,
  CollectorRestRetryRules11
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function collectorRestRetryRules11ToJSON(
  collectorRestRetryRules11: CollectorRestRetryRules11,
): string {
  return JSON.stringify(
    CollectorRestRetryRules11$outboundSchema.parse(collectorRestRetryRules11),
  );
}
export function collectorRestRetryRules11FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRetryRules11, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRetryRules11$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRetryRules11' from JSON`,
  );
}

/** @internal */
export const CollectorRestStateTracking11$inboundSchema: z.ZodType<
  CollectorRestStateTracking11,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type CollectorRestStateTracking11$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const CollectorRestStateTracking11$outboundSchema: z.ZodType<
  CollectorRestStateTracking11$Outbound,
  z.ZodTypeDef,
  CollectorRestStateTracking11
> = z.object({
  enabled: z.boolean().optional(),
});

export function collectorRestStateTracking11ToJSON(
  collectorRestStateTracking11: CollectorRestStateTracking11,
): string {
  return JSON.stringify(
    CollectorRestStateTracking11$outboundSchema.parse(
      collectorRestStateTracking11,
    ),
  );
}
export function collectorRestStateTracking11FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestStateTracking11, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestStateTracking11$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestStateTracking11' from JSON`,
  );
}

/** @internal */
export const CollectorRestScheduling11$inboundSchema: z.ZodType<
  CollectorRestScheduling11,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking11$inboundSchema)
    .optional(),
});
/** @internal */
export type CollectorRestScheduling11$Outbound = {
  stateTracking?: CollectorRestStateTracking11$Outbound | undefined;
};

/** @internal */
export const CollectorRestScheduling11$outboundSchema: z.ZodType<
  CollectorRestScheduling11$Outbound,
  z.ZodTypeDef,
  CollectorRestScheduling11
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking11$outboundSchema)
    .optional(),
});

export function collectorRestScheduling11ToJSON(
  collectorRestScheduling11: CollectorRestScheduling11,
): string {
  return JSON.stringify(
    CollectorRestScheduling11$outboundSchema.parse(collectorRestScheduling11),
  );
}
export function collectorRestScheduling11FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestScheduling11, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestScheduling11$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestScheduling11' from JSON`,
  );
}

/** @internal */
export const CollectorRestRest11$inboundSchema: z.ZodType<
  CollectorRestRest11,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: CollectorRestAuthentication11$inboundSchema.default("none"),
  scopes: z.array(z.string()),
  textSecret: z.string(),
  subject: z.string(),
  type: CollectorRestType12$inboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery11$inboundSchema).optional(),
  collectUrl: z.string(),
  collectMethod: CollectMethod11$inboundSchema.default("get"),
  collectVerb: z.string().optional(),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  collectBody: z.string().optional(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination11$inboundSchema).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules11$inboundSchema).optional(),
  __scheduling: z.lazy(() => CollectorRestScheduling11$inboundSchema)
    .optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginUrl: z.string().default(""),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  tokenRespAttribute: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  serviceAccountCredentials: z.string().optional(),
  hmacFunctionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "__scheduling": "scheduling",
  });
});
/** @internal */
export type CollectorRestRest11$Outbound = {
  authentication: string;
  scopes: Array<string>;
  textSecret: string;
  subject: string;
  type: string;
  discovery?: CollectorRestDiscovery11$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: string | undefined;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  collectBody?: string | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  pagination?: Pagination11$Outbound | undefined;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  decodeUrl: boolean;
  rejectUnauthorized: boolean;
  captureHeaders: boolean;
  stopOnEmptyResults: boolean;
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules11$Outbound | undefined;
  __scheduling?: CollectorRestScheduling11$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  loginUrl: string;
  loginBody: string;
  getAuthTokenFromHeader: boolean;
  authHeaderKey: string;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  tokenRespAttribute?: string | undefined;
  clientSecretParamName: string;
  clientSecretParamValue?: string | undefined;
  authRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  serviceAccountCredentials?: string | undefined;
  hmacFunctionId?: string | undefined;
};

/** @internal */
export const CollectorRestRest11$outboundSchema: z.ZodType<
  CollectorRestRest11$Outbound,
  z.ZodTypeDef,
  CollectorRestRest11
> = z.object({
  authentication: CollectorRestAuthentication11$outboundSchema.default("none"),
  scopes: z.array(z.string()),
  textSecret: z.string(),
  subject: z.string(),
  type: CollectorRestType12$outboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery11$outboundSchema).optional(),
  collectUrl: z.string(),
  collectMethod: CollectMethod11$outboundSchema.default("get"),
  collectVerb: z.string().optional(),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  collectBody: z.string().optional(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination11$outboundSchema).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules11$outboundSchema).optional(),
  scheduling: z.lazy(() => CollectorRestScheduling11$outboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginUrl: z.string().default(""),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  tokenRespAttribute: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  serviceAccountCredentials: z.string().optional(),
  hmacFunctionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    scheduling: "__scheduling",
  });
});

export function collectorRestRest11ToJSON(
  collectorRestRest11: CollectorRestRest11,
): string {
  return JSON.stringify(
    CollectorRestRest11$outboundSchema.parse(collectorRestRest11),
  );
}
export function collectorRestRest11FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRest11, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRest11$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRest11' from JSON`,
  );
}

/** @internal */
export const CollectorRestAuthentication10$inboundSchema: z.ZodType<
  CollectorRestAuthentication10,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestAuthentication10);
/** @internal */
export const CollectorRestAuthentication10$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestAuthentication10
> = openEnums.outboundSchema(CollectorRestAuthentication10);

/** @internal */
export const CollectorRestType11$inboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType11
> = z.nativeEnum(CollectorRestType11);
/** @internal */
export const CollectorRestType11$outboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType11
> = CollectorRestType11$inboundSchema;

/** @internal */
export const CollectorRestDiscoverType10$inboundSchema: z.ZodType<
  CollectorRestDiscoverType10,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestDiscoverType10);
/** @internal */
export const CollectorRestDiscoverType10$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestDiscoverType10
> = openEnums.outboundSchema(CollectorRestDiscoverType10);

/** @internal */
export const CollectorRestDiscovery10$inboundSchema: z.ZodType<
  CollectorRestDiscovery10,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: CollectorRestDiscoverType10$inboundSchema.default("none"),
});
/** @internal */
export type CollectorRestDiscovery10$Outbound = {
  discoverType: string;
};

/** @internal */
export const CollectorRestDiscovery10$outboundSchema: z.ZodType<
  CollectorRestDiscovery10$Outbound,
  z.ZodTypeDef,
  CollectorRestDiscovery10
> = z.object({
  discoverType: CollectorRestDiscoverType10$outboundSchema.default("none"),
});

export function collectorRestDiscovery10ToJSON(
  collectorRestDiscovery10: CollectorRestDiscovery10,
): string {
  return JSON.stringify(
    CollectorRestDiscovery10$outboundSchema.parse(collectorRestDiscovery10),
  );
}
export function collectorRestDiscovery10FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestDiscovery10, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestDiscovery10$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestDiscovery10' from JSON`,
  );
}

/** @internal */
export const CollectMethod10$inboundSchema: z.ZodType<
  CollectMethod10,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectMethod10);
/** @internal */
export const CollectMethod10$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectMethod10
> = openEnums.outboundSchema(CollectMethod10);

/** @internal */
export const PaginationEnum10$inboundSchema: z.ZodType<
  PaginationEnum10,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(PaginationEnum10);
/** @internal */
export const PaginationEnum10$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  PaginationEnum10
> = openEnums.outboundSchema(PaginationEnum10);

/** @internal */
export const Pagination10$inboundSchema: z.ZodType<
  Pagination10,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: PaginationEnum10$inboundSchema.default("none"),
});
/** @internal */
export type Pagination10$Outbound = {
  type: string;
};

/** @internal */
export const Pagination10$outboundSchema: z.ZodType<
  Pagination10$Outbound,
  z.ZodTypeDef,
  Pagination10
> = z.object({
  type: PaginationEnum10$outboundSchema.default("none"),
});

export function pagination10ToJSON(pagination10: Pagination10): string {
  return JSON.stringify(Pagination10$outboundSchema.parse(pagination10));
}
export function pagination10FromJSON(
  jsonString: string,
): SafeParseResult<Pagination10, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Pagination10$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Pagination10' from JSON`,
  );
}

/** @internal */
export const CollectorRestRetryRules10$inboundSchema: z.ZodType<
  CollectorRestRetryRules10,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type CollectorRestRetryRules10$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const CollectorRestRetryRules10$outboundSchema: z.ZodType<
  CollectorRestRetryRules10$Outbound,
  z.ZodTypeDef,
  CollectorRestRetryRules10
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function collectorRestRetryRules10ToJSON(
  collectorRestRetryRules10: CollectorRestRetryRules10,
): string {
  return JSON.stringify(
    CollectorRestRetryRules10$outboundSchema.parse(collectorRestRetryRules10),
  );
}
export function collectorRestRetryRules10FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRetryRules10, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRetryRules10$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRetryRules10' from JSON`,
  );
}

/** @internal */
export const CollectorRestStateTracking10$inboundSchema: z.ZodType<
  CollectorRestStateTracking10,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type CollectorRestStateTracking10$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const CollectorRestStateTracking10$outboundSchema: z.ZodType<
  CollectorRestStateTracking10$Outbound,
  z.ZodTypeDef,
  CollectorRestStateTracking10
> = z.object({
  enabled: z.boolean().optional(),
});

export function collectorRestStateTracking10ToJSON(
  collectorRestStateTracking10: CollectorRestStateTracking10,
): string {
  return JSON.stringify(
    CollectorRestStateTracking10$outboundSchema.parse(
      collectorRestStateTracking10,
    ),
  );
}
export function collectorRestStateTracking10FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestStateTracking10, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestStateTracking10$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestStateTracking10' from JSON`,
  );
}

/** @internal */
export const CollectorRestScheduling10$inboundSchema: z.ZodType<
  CollectorRestScheduling10,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking10$inboundSchema)
    .optional(),
});
/** @internal */
export type CollectorRestScheduling10$Outbound = {
  stateTracking?: CollectorRestStateTracking10$Outbound | undefined;
};

/** @internal */
export const CollectorRestScheduling10$outboundSchema: z.ZodType<
  CollectorRestScheduling10$Outbound,
  z.ZodTypeDef,
  CollectorRestScheduling10
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking10$outboundSchema)
    .optional(),
});

export function collectorRestScheduling10ToJSON(
  collectorRestScheduling10: CollectorRestScheduling10,
): string {
  return JSON.stringify(
    CollectorRestScheduling10$outboundSchema.parse(collectorRestScheduling10),
  );
}
export function collectorRestScheduling10FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestScheduling10, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestScheduling10$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestScheduling10' from JSON`,
  );
}

/** @internal */
export const CollectorRestRest10$inboundSchema: z.ZodType<
  CollectorRestRest10,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: CollectorRestAuthentication10$inboundSchema.default("none"),
  scopes: z.array(z.string()),
  serviceAccountCredentials: z.string(),
  subject: z.string(),
  type: CollectorRestType11$inboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery10$inboundSchema).optional(),
  collectUrl: z.string(),
  collectMethod: CollectMethod10$inboundSchema.default("get"),
  collectVerb: z.string().optional(),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  collectBody: z.string().optional(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination10$inboundSchema).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules10$inboundSchema).optional(),
  __scheduling: z.lazy(() => CollectorRestScheduling10$inboundSchema)
    .optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginUrl: z.string().default(""),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  tokenRespAttribute: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  hmacFunctionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "__scheduling": "scheduling",
  });
});
/** @internal */
export type CollectorRestRest10$Outbound = {
  authentication: string;
  scopes: Array<string>;
  serviceAccountCredentials: string;
  subject: string;
  type: string;
  discovery?: CollectorRestDiscovery10$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: string | undefined;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  collectBody?: string | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  pagination?: Pagination10$Outbound | undefined;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  decodeUrl: boolean;
  rejectUnauthorized: boolean;
  captureHeaders: boolean;
  stopOnEmptyResults: boolean;
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules10$Outbound | undefined;
  __scheduling?: CollectorRestScheduling10$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  loginUrl: string;
  loginBody: string;
  getAuthTokenFromHeader: boolean;
  authHeaderKey: string;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  tokenRespAttribute?: string | undefined;
  clientSecretParamName: string;
  clientSecretParamValue?: string | undefined;
  authRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  textSecret?: string | undefined;
  hmacFunctionId?: string | undefined;
};

/** @internal */
export const CollectorRestRest10$outboundSchema: z.ZodType<
  CollectorRestRest10$Outbound,
  z.ZodTypeDef,
  CollectorRestRest10
> = z.object({
  authentication: CollectorRestAuthentication10$outboundSchema.default("none"),
  scopes: z.array(z.string()),
  serviceAccountCredentials: z.string(),
  subject: z.string(),
  type: CollectorRestType11$outboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery10$outboundSchema).optional(),
  collectUrl: z.string(),
  collectMethod: CollectMethod10$outboundSchema.default("get"),
  collectVerb: z.string().optional(),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  collectBody: z.string().optional(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination10$outboundSchema).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules10$outboundSchema).optional(),
  scheduling: z.lazy(() => CollectorRestScheduling10$outboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginUrl: z.string().default(""),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  tokenRespAttribute: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  hmacFunctionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    scheduling: "__scheduling",
  });
});

export function collectorRestRest10ToJSON(
  collectorRestRest10: CollectorRestRest10,
): string {
  return JSON.stringify(
    CollectorRestRest10$outboundSchema.parse(collectorRestRest10),
  );
}
export function collectorRestRest10FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRest10, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRest10$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRest10' from JSON`,
  );
}

/** @internal */
export const CollectorRestAuthentication9$inboundSchema: z.ZodType<
  CollectorRestAuthentication9,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestAuthentication9);
/** @internal */
export const CollectorRestAuthentication9$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestAuthentication9
> = openEnums.outboundSchema(CollectorRestAuthentication9);

/** @internal */
export const CollectorRestType10$inboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType10
> = z.nativeEnum(CollectorRestType10);
/** @internal */
export const CollectorRestType10$outboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType10
> = CollectorRestType10$inboundSchema;

/** @internal */
export const CollectorRestDiscoverType9$inboundSchema: z.ZodType<
  CollectorRestDiscoverType9,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestDiscoverType9);
/** @internal */
export const CollectorRestDiscoverType9$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestDiscoverType9
> = openEnums.outboundSchema(CollectorRestDiscoverType9);

/** @internal */
export const CollectorRestDiscovery9$inboundSchema: z.ZodType<
  CollectorRestDiscovery9,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: CollectorRestDiscoverType9$inboundSchema.default("none"),
});
/** @internal */
export type CollectorRestDiscovery9$Outbound = {
  discoverType: string;
};

/** @internal */
export const CollectorRestDiscovery9$outboundSchema: z.ZodType<
  CollectorRestDiscovery9$Outbound,
  z.ZodTypeDef,
  CollectorRestDiscovery9
> = z.object({
  discoverType: CollectorRestDiscoverType9$outboundSchema.default("none"),
});

export function collectorRestDiscovery9ToJSON(
  collectorRestDiscovery9: CollectorRestDiscovery9,
): string {
  return JSON.stringify(
    CollectorRestDiscovery9$outboundSchema.parse(collectorRestDiscovery9),
  );
}
export function collectorRestDiscovery9FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestDiscovery9, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestDiscovery9$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestDiscovery9' from JSON`,
  );
}

/** @internal */
export const CollectMethod9$inboundSchema: z.ZodType<
  CollectMethod9,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectMethod9);
/** @internal */
export const CollectMethod9$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectMethod9
> = openEnums.outboundSchema(CollectMethod9);

/** @internal */
export const PaginationEnum9$inboundSchema: z.ZodType<
  PaginationEnum9,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(PaginationEnum9);
/** @internal */
export const PaginationEnum9$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  PaginationEnum9
> = openEnums.outboundSchema(PaginationEnum9);

/** @internal */
export const Pagination9$inboundSchema: z.ZodType<
  Pagination9,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: PaginationEnum9$inboundSchema.default("none"),
});
/** @internal */
export type Pagination9$Outbound = {
  type: string;
};

/** @internal */
export const Pagination9$outboundSchema: z.ZodType<
  Pagination9$Outbound,
  z.ZodTypeDef,
  Pagination9
> = z.object({
  type: PaginationEnum9$outboundSchema.default("none"),
});

export function pagination9ToJSON(pagination9: Pagination9): string {
  return JSON.stringify(Pagination9$outboundSchema.parse(pagination9));
}
export function pagination9FromJSON(
  jsonString: string,
): SafeParseResult<Pagination9, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Pagination9$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Pagination9' from JSON`,
  );
}

/** @internal */
export const CollectorRestRetryRules9$inboundSchema: z.ZodType<
  CollectorRestRetryRules9,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type CollectorRestRetryRules9$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const CollectorRestRetryRules9$outboundSchema: z.ZodType<
  CollectorRestRetryRules9$Outbound,
  z.ZodTypeDef,
  CollectorRestRetryRules9
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function collectorRestRetryRules9ToJSON(
  collectorRestRetryRules9: CollectorRestRetryRules9,
): string {
  return JSON.stringify(
    CollectorRestRetryRules9$outboundSchema.parse(collectorRestRetryRules9),
  );
}
export function collectorRestRetryRules9FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRetryRules9, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRetryRules9$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRetryRules9' from JSON`,
  );
}

/** @internal */
export const CollectorRestStateTracking9$inboundSchema: z.ZodType<
  CollectorRestStateTracking9,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type CollectorRestStateTracking9$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const CollectorRestStateTracking9$outboundSchema: z.ZodType<
  CollectorRestStateTracking9$Outbound,
  z.ZodTypeDef,
  CollectorRestStateTracking9
> = z.object({
  enabled: z.boolean().optional(),
});

export function collectorRestStateTracking9ToJSON(
  collectorRestStateTracking9: CollectorRestStateTracking9,
): string {
  return JSON.stringify(
    CollectorRestStateTracking9$outboundSchema.parse(
      collectorRestStateTracking9,
    ),
  );
}
export function collectorRestStateTracking9FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestStateTracking9, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestStateTracking9$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestStateTracking9' from JSON`,
  );
}

/** @internal */
export const CollectorRestScheduling9$inboundSchema: z.ZodType<
  CollectorRestScheduling9,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking9$inboundSchema)
    .optional(),
});
/** @internal */
export type CollectorRestScheduling9$Outbound = {
  stateTracking?: CollectorRestStateTracking9$Outbound | undefined;
};

/** @internal */
export const CollectorRestScheduling9$outboundSchema: z.ZodType<
  CollectorRestScheduling9$Outbound,
  z.ZodTypeDef,
  CollectorRestScheduling9
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking9$outboundSchema)
    .optional(),
});

export function collectorRestScheduling9ToJSON(
  collectorRestScheduling9: CollectorRestScheduling9,
): string {
  return JSON.stringify(
    CollectorRestScheduling9$outboundSchema.parse(collectorRestScheduling9),
  );
}
export function collectorRestScheduling9FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestScheduling9, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestScheduling9$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestScheduling9' from JSON`,
  );
}

/** @internal */
export const CollectorRestRest9$inboundSchema: z.ZodType<
  CollectorRestRest9,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: CollectorRestAuthentication9$inboundSchema.default("none"),
  loginUrl: z.string().default(""),
  tokenRespAttribute: z.string().optional(),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  clientSecretParamName: z.string().default("client_secret"),
  textSecret: z.string(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  type: CollectorRestType10$inboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery9$inboundSchema).optional(),
  collectUrl: z.string(),
  collectMethod: CollectMethod9$inboundSchema.default("get"),
  collectVerb: z.string().optional(),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  collectBody: z.string().optional(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination9$inboundSchema).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules9$inboundSchema).optional(),
  __scheduling: z.lazy(() => CollectorRestScheduling9$inboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  clientSecretParamValue: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  serviceAccountCredentials: z.string().optional(),
  subject: z.string().optional(),
  hmacFunctionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "__scheduling": "scheduling",
  });
});
/** @internal */
export type CollectorRestRest9$Outbound = {
  authentication: string;
  loginUrl: string;
  tokenRespAttribute?: string | undefined;
  authHeaderKey: string;
  authHeaderExpr: string;
  clientSecretParamName: string;
  textSecret: string;
  authRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  type: string;
  discovery?: CollectorRestDiscovery9$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: string | undefined;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  collectBody?: string | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  pagination?: Pagination9$Outbound | undefined;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  decodeUrl: boolean;
  rejectUnauthorized: boolean;
  captureHeaders: boolean;
  stopOnEmptyResults: boolean;
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules9$Outbound | undefined;
  __scheduling?: CollectorRestScheduling9$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  loginBody: string;
  getAuthTokenFromHeader: boolean;
  clientSecretParamValue?: string | undefined;
  scopes?: Array<string> | undefined;
  serviceAccountCredentials?: string | undefined;
  subject?: string | undefined;
  hmacFunctionId?: string | undefined;
};

/** @internal */
export const CollectorRestRest9$outboundSchema: z.ZodType<
  CollectorRestRest9$Outbound,
  z.ZodTypeDef,
  CollectorRestRest9
> = z.object({
  authentication: CollectorRestAuthentication9$outboundSchema.default("none"),
  loginUrl: z.string().default(""),
  tokenRespAttribute: z.string().optional(),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  clientSecretParamName: z.string().default("client_secret"),
  textSecret: z.string(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  type: CollectorRestType10$outboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery9$outboundSchema).optional(),
  collectUrl: z.string(),
  collectMethod: CollectMethod9$outboundSchema.default("get"),
  collectVerb: z.string().optional(),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  collectBody: z.string().optional(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination9$outboundSchema).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules9$outboundSchema).optional(),
  scheduling: z.lazy(() => CollectorRestScheduling9$outboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  clientSecretParamValue: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  serviceAccountCredentials: z.string().optional(),
  subject: z.string().optional(),
  hmacFunctionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    scheduling: "__scheduling",
  });
});

export function collectorRestRest9ToJSON(
  collectorRestRest9: CollectorRestRest9,
): string {
  return JSON.stringify(
    CollectorRestRest9$outboundSchema.parse(collectorRestRest9),
  );
}
export function collectorRestRest9FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRest9, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRest9$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRest9' from JSON`,
  );
}

/** @internal */
export const CollectorRestAuthentication8$inboundSchema: z.ZodType<
  CollectorRestAuthentication8,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestAuthentication8);
/** @internal */
export const CollectorRestAuthentication8$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestAuthentication8
> = openEnums.outboundSchema(CollectorRestAuthentication8);

/** @internal */
export const CollectorRestType9$inboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType9
> = z.nativeEnum(CollectorRestType9);
/** @internal */
export const CollectorRestType9$outboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType9
> = CollectorRestType9$inboundSchema;

/** @internal */
export const CollectorRestDiscoverType8$inboundSchema: z.ZodType<
  CollectorRestDiscoverType8,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestDiscoverType8);
/** @internal */
export const CollectorRestDiscoverType8$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestDiscoverType8
> = openEnums.outboundSchema(CollectorRestDiscoverType8);

/** @internal */
export const CollectorRestDiscovery8$inboundSchema: z.ZodType<
  CollectorRestDiscovery8,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: CollectorRestDiscoverType8$inboundSchema.default("none"),
});
/** @internal */
export type CollectorRestDiscovery8$Outbound = {
  discoverType: string;
};

/** @internal */
export const CollectorRestDiscovery8$outboundSchema: z.ZodType<
  CollectorRestDiscovery8$Outbound,
  z.ZodTypeDef,
  CollectorRestDiscovery8
> = z.object({
  discoverType: CollectorRestDiscoverType8$outboundSchema.default("none"),
});

export function collectorRestDiscovery8ToJSON(
  collectorRestDiscovery8: CollectorRestDiscovery8,
): string {
  return JSON.stringify(
    CollectorRestDiscovery8$outboundSchema.parse(collectorRestDiscovery8),
  );
}
export function collectorRestDiscovery8FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestDiscovery8, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestDiscovery8$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestDiscovery8' from JSON`,
  );
}

/** @internal */
export const CollectMethod8$inboundSchema: z.ZodType<
  CollectMethod8,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectMethod8);
/** @internal */
export const CollectMethod8$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectMethod8
> = openEnums.outboundSchema(CollectMethod8);

/** @internal */
export const PaginationEnum8$inboundSchema: z.ZodType<
  PaginationEnum8,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(PaginationEnum8);
/** @internal */
export const PaginationEnum8$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  PaginationEnum8
> = openEnums.outboundSchema(PaginationEnum8);

/** @internal */
export const Pagination8$inboundSchema: z.ZodType<
  Pagination8,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: PaginationEnum8$inboundSchema.default("none"),
});
/** @internal */
export type Pagination8$Outbound = {
  type: string;
};

/** @internal */
export const Pagination8$outboundSchema: z.ZodType<
  Pagination8$Outbound,
  z.ZodTypeDef,
  Pagination8
> = z.object({
  type: PaginationEnum8$outboundSchema.default("none"),
});

export function pagination8ToJSON(pagination8: Pagination8): string {
  return JSON.stringify(Pagination8$outboundSchema.parse(pagination8));
}
export function pagination8FromJSON(
  jsonString: string,
): SafeParseResult<Pagination8, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Pagination8$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Pagination8' from JSON`,
  );
}

/** @internal */
export const CollectorRestRetryRules8$inboundSchema: z.ZodType<
  CollectorRestRetryRules8,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type CollectorRestRetryRules8$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const CollectorRestRetryRules8$outboundSchema: z.ZodType<
  CollectorRestRetryRules8$Outbound,
  z.ZodTypeDef,
  CollectorRestRetryRules8
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function collectorRestRetryRules8ToJSON(
  collectorRestRetryRules8: CollectorRestRetryRules8,
): string {
  return JSON.stringify(
    CollectorRestRetryRules8$outboundSchema.parse(collectorRestRetryRules8),
  );
}
export function collectorRestRetryRules8FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRetryRules8, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRetryRules8$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRetryRules8' from JSON`,
  );
}

/** @internal */
export const CollectorRestStateTracking8$inboundSchema: z.ZodType<
  CollectorRestStateTracking8,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type CollectorRestStateTracking8$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const CollectorRestStateTracking8$outboundSchema: z.ZodType<
  CollectorRestStateTracking8$Outbound,
  z.ZodTypeDef,
  CollectorRestStateTracking8
> = z.object({
  enabled: z.boolean().optional(),
});

export function collectorRestStateTracking8ToJSON(
  collectorRestStateTracking8: CollectorRestStateTracking8,
): string {
  return JSON.stringify(
    CollectorRestStateTracking8$outboundSchema.parse(
      collectorRestStateTracking8,
    ),
  );
}
export function collectorRestStateTracking8FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestStateTracking8, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestStateTracking8$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestStateTracking8' from JSON`,
  );
}

/** @internal */
export const CollectorRestScheduling8$inboundSchema: z.ZodType<
  CollectorRestScheduling8,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking8$inboundSchema)
    .optional(),
});
/** @internal */
export type CollectorRestScheduling8$Outbound = {
  stateTracking?: CollectorRestStateTracking8$Outbound | undefined;
};

/** @internal */
export const CollectorRestScheduling8$outboundSchema: z.ZodType<
  CollectorRestScheduling8$Outbound,
  z.ZodTypeDef,
  CollectorRestScheduling8
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking8$outboundSchema)
    .optional(),
});

export function collectorRestScheduling8ToJSON(
  collectorRestScheduling8: CollectorRestScheduling8,
): string {
  return JSON.stringify(
    CollectorRestScheduling8$outboundSchema.parse(collectorRestScheduling8),
  );
}
export function collectorRestScheduling8FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestScheduling8, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestScheduling8$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestScheduling8' from JSON`,
  );
}

/** @internal */
export const CollectorRestRest8$inboundSchema: z.ZodType<
  CollectorRestRest8,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: CollectorRestAuthentication8$inboundSchema.default("none"),
  loginUrl: z.string().default(""),
  tokenRespAttribute: z.string().optional(),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  type: CollectorRestType9$inboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery8$inboundSchema).optional(),
  collectUrl: z.string(),
  collectMethod: CollectMethod8$inboundSchema.default("get"),
  collectVerb: z.string().optional(),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  collectBody: z.string().optional(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination8$inboundSchema).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules8$inboundSchema).optional(),
  __scheduling: z.lazy(() => CollectorRestScheduling8$inboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  textSecret: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  serviceAccountCredentials: z.string().optional(),
  subject: z.string().optional(),
  hmacFunctionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "__scheduling": "scheduling",
  });
});
/** @internal */
export type CollectorRestRest8$Outbound = {
  authentication: string;
  loginUrl: string;
  tokenRespAttribute?: string | undefined;
  authHeaderKey: string;
  authHeaderExpr: string;
  clientSecretParamName: string;
  clientSecretParamValue: string;
  authRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  type: string;
  discovery?: CollectorRestDiscovery8$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: string | undefined;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  collectBody?: string | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  pagination?: Pagination8$Outbound | undefined;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  decodeUrl: boolean;
  rejectUnauthorized: boolean;
  captureHeaders: boolean;
  stopOnEmptyResults: boolean;
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules8$Outbound | undefined;
  __scheduling?: CollectorRestScheduling8$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  loginBody: string;
  getAuthTokenFromHeader: boolean;
  textSecret?: string | undefined;
  scopes?: Array<string> | undefined;
  serviceAccountCredentials?: string | undefined;
  subject?: string | undefined;
  hmacFunctionId?: string | undefined;
};

/** @internal */
export const CollectorRestRest8$outboundSchema: z.ZodType<
  CollectorRestRest8$Outbound,
  z.ZodTypeDef,
  CollectorRestRest8
> = z.object({
  authentication: CollectorRestAuthentication8$outboundSchema.default("none"),
  loginUrl: z.string().default(""),
  tokenRespAttribute: z.string().optional(),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  type: CollectorRestType9$outboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery8$outboundSchema).optional(),
  collectUrl: z.string(),
  collectMethod: CollectMethod8$outboundSchema.default("get"),
  collectVerb: z.string().optional(),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  collectBody: z.string().optional(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination8$outboundSchema).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules8$outboundSchema).optional(),
  scheduling: z.lazy(() => CollectorRestScheduling8$outboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  textSecret: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  serviceAccountCredentials: z.string().optional(),
  subject: z.string().optional(),
  hmacFunctionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    scheduling: "__scheduling",
  });
});

export function collectorRestRest8ToJSON(
  collectorRestRest8: CollectorRestRest8,
): string {
  return JSON.stringify(
    CollectorRestRest8$outboundSchema.parse(collectorRestRest8),
  );
}
export function collectorRestRest8FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRest8, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRest8$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRest8' from JSON`,
  );
}

/** @internal */
export const CollectorRestAuthentication7$inboundSchema: z.ZodType<
  CollectorRestAuthentication7,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestAuthentication7);
/** @internal */
export const CollectorRestAuthentication7$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestAuthentication7
> = openEnums.outboundSchema(CollectorRestAuthentication7);

/** @internal */
export const CollectorRestType8$inboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType8
> = z.nativeEnum(CollectorRestType8);
/** @internal */
export const CollectorRestType8$outboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType8
> = CollectorRestType8$inboundSchema;

/** @internal */
export const CollectorRestDiscoverType7$inboundSchema: z.ZodType<
  CollectorRestDiscoverType7,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestDiscoverType7);
/** @internal */
export const CollectorRestDiscoverType7$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestDiscoverType7
> = openEnums.outboundSchema(CollectorRestDiscoverType7);

/** @internal */
export const CollectorRestDiscovery7$inboundSchema: z.ZodType<
  CollectorRestDiscovery7,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: CollectorRestDiscoverType7$inboundSchema.default("none"),
});
/** @internal */
export type CollectorRestDiscovery7$Outbound = {
  discoverType: string;
};

/** @internal */
export const CollectorRestDiscovery7$outboundSchema: z.ZodType<
  CollectorRestDiscovery7$Outbound,
  z.ZodTypeDef,
  CollectorRestDiscovery7
> = z.object({
  discoverType: CollectorRestDiscoverType7$outboundSchema.default("none"),
});

export function collectorRestDiscovery7ToJSON(
  collectorRestDiscovery7: CollectorRestDiscovery7,
): string {
  return JSON.stringify(
    CollectorRestDiscovery7$outboundSchema.parse(collectorRestDiscovery7),
  );
}
export function collectorRestDiscovery7FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestDiscovery7, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestDiscovery7$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestDiscovery7' from JSON`,
  );
}

/** @internal */
export const CollectMethod7$inboundSchema: z.ZodType<
  CollectMethod7,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectMethod7);
/** @internal */
export const CollectMethod7$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectMethod7
> = openEnums.outboundSchema(CollectMethod7);

/** @internal */
export const PaginationEnum7$inboundSchema: z.ZodType<
  PaginationEnum7,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(PaginationEnum7);
/** @internal */
export const PaginationEnum7$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  PaginationEnum7
> = openEnums.outboundSchema(PaginationEnum7);

/** @internal */
export const Pagination7$inboundSchema: z.ZodType<
  Pagination7,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: PaginationEnum7$inboundSchema.default("none"),
});
/** @internal */
export type Pagination7$Outbound = {
  type: string;
};

/** @internal */
export const Pagination7$outboundSchema: z.ZodType<
  Pagination7$Outbound,
  z.ZodTypeDef,
  Pagination7
> = z.object({
  type: PaginationEnum7$outboundSchema.default("none"),
});

export function pagination7ToJSON(pagination7: Pagination7): string {
  return JSON.stringify(Pagination7$outboundSchema.parse(pagination7));
}
export function pagination7FromJSON(
  jsonString: string,
): SafeParseResult<Pagination7, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Pagination7$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Pagination7' from JSON`,
  );
}

/** @internal */
export const CollectorRestRetryRules7$inboundSchema: z.ZodType<
  CollectorRestRetryRules7,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type CollectorRestRetryRules7$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const CollectorRestRetryRules7$outboundSchema: z.ZodType<
  CollectorRestRetryRules7$Outbound,
  z.ZodTypeDef,
  CollectorRestRetryRules7
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function collectorRestRetryRules7ToJSON(
  collectorRestRetryRules7: CollectorRestRetryRules7,
): string {
  return JSON.stringify(
    CollectorRestRetryRules7$outboundSchema.parse(collectorRestRetryRules7),
  );
}
export function collectorRestRetryRules7FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRetryRules7, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRetryRules7$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRetryRules7' from JSON`,
  );
}

/** @internal */
export const CollectorRestStateTracking7$inboundSchema: z.ZodType<
  CollectorRestStateTracking7,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type CollectorRestStateTracking7$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const CollectorRestStateTracking7$outboundSchema: z.ZodType<
  CollectorRestStateTracking7$Outbound,
  z.ZodTypeDef,
  CollectorRestStateTracking7
> = z.object({
  enabled: z.boolean().optional(),
});

export function collectorRestStateTracking7ToJSON(
  collectorRestStateTracking7: CollectorRestStateTracking7,
): string {
  return JSON.stringify(
    CollectorRestStateTracking7$outboundSchema.parse(
      collectorRestStateTracking7,
    ),
  );
}
export function collectorRestStateTracking7FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestStateTracking7, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestStateTracking7$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestStateTracking7' from JSON`,
  );
}

/** @internal */
export const CollectorRestScheduling7$inboundSchema: z.ZodType<
  CollectorRestScheduling7,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking7$inboundSchema)
    .optional(),
});
/** @internal */
export type CollectorRestScheduling7$Outbound = {
  stateTracking?: CollectorRestStateTracking7$Outbound | undefined;
};

/** @internal */
export const CollectorRestScheduling7$outboundSchema: z.ZodType<
  CollectorRestScheduling7$Outbound,
  z.ZodTypeDef,
  CollectorRestScheduling7
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking7$outboundSchema)
    .optional(),
});

export function collectorRestScheduling7ToJSON(
  collectorRestScheduling7: CollectorRestScheduling7,
): string {
  return JSON.stringify(
    CollectorRestScheduling7$outboundSchema.parse(collectorRestScheduling7),
  );
}
export function collectorRestScheduling7FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestScheduling7, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestScheduling7$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestScheduling7' from JSON`,
  );
}

/** @internal */
export const CollectorRestRest7$inboundSchema: z.ZodType<
  CollectorRestRest7,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: CollectorRestAuthentication7$inboundSchema.default("none"),
  loginUrl: z.string().default(""),
  credentialsSecret: z.string(),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  type: CollectorRestType8$inboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery7$inboundSchema).optional(),
  collectUrl: z.string(),
  collectMethod: CollectMethod7$inboundSchema.default("get"),
  collectVerb: z.string().optional(),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  collectBody: z.string().optional(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination7$inboundSchema).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules7$inboundSchema).optional(),
  __scheduling: z.lazy(() => CollectorRestScheduling7$inboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  tokenRespAttribute: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  serviceAccountCredentials: z.string().optional(),
  subject: z.string().optional(),
  hmacFunctionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "__scheduling": "scheduling",
  });
});
/** @internal */
export type CollectorRestRest7$Outbound = {
  authentication: string;
  loginUrl: string;
  credentialsSecret: string;
  loginBody: string;
  getAuthTokenFromHeader: boolean;
  authHeaderKey: string;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  type: string;
  discovery?: CollectorRestDiscovery7$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: string | undefined;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  collectBody?: string | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  pagination?: Pagination7$Outbound | undefined;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  decodeUrl: boolean;
  rejectUnauthorized: boolean;
  captureHeaders: boolean;
  stopOnEmptyResults: boolean;
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules7$Outbound | undefined;
  __scheduling?: CollectorRestScheduling7$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  tokenRespAttribute?: string | undefined;
  clientSecretParamName: string;
  clientSecretParamValue?: string | undefined;
  authRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  textSecret?: string | undefined;
  scopes?: Array<string> | undefined;
  serviceAccountCredentials?: string | undefined;
  subject?: string | undefined;
  hmacFunctionId?: string | undefined;
};

/** @internal */
export const CollectorRestRest7$outboundSchema: z.ZodType<
  CollectorRestRest7$Outbound,
  z.ZodTypeDef,
  CollectorRestRest7
> = z.object({
  authentication: CollectorRestAuthentication7$outboundSchema.default("none"),
  loginUrl: z.string().default(""),
  credentialsSecret: z.string(),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  type: CollectorRestType8$outboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery7$outboundSchema).optional(),
  collectUrl: z.string(),
  collectMethod: CollectMethod7$outboundSchema.default("get"),
  collectVerb: z.string().optional(),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  collectBody: z.string().optional(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination7$outboundSchema).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules7$outboundSchema).optional(),
  scheduling: z.lazy(() => CollectorRestScheduling7$outboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  tokenRespAttribute: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  serviceAccountCredentials: z.string().optional(),
  subject: z.string().optional(),
  hmacFunctionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    scheduling: "__scheduling",
  });
});

export function collectorRestRest7ToJSON(
  collectorRestRest7: CollectorRestRest7,
): string {
  return JSON.stringify(
    CollectorRestRest7$outboundSchema.parse(collectorRestRest7),
  );
}
export function collectorRestRest7FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRest7, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRest7$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRest7' from JSON`,
  );
}

/** @internal */
export const CollectorRestAuthentication6$inboundSchema: z.ZodType<
  CollectorRestAuthentication6,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestAuthentication6);
/** @internal */
export const CollectorRestAuthentication6$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestAuthentication6
> = openEnums.outboundSchema(CollectorRestAuthentication6);

/** @internal */
export const CollectorRestType7$inboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType7
> = z.nativeEnum(CollectorRestType7);
/** @internal */
export const CollectorRestType7$outboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType7
> = CollectorRestType7$inboundSchema;

/** @internal */
export const CollectorRestDiscoverType6$inboundSchema: z.ZodType<
  CollectorRestDiscoverType6,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestDiscoverType6);
/** @internal */
export const CollectorRestDiscoverType6$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestDiscoverType6
> = openEnums.outboundSchema(CollectorRestDiscoverType6);

/** @internal */
export const CollectorRestDiscovery6$inboundSchema: z.ZodType<
  CollectorRestDiscovery6,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: CollectorRestDiscoverType6$inboundSchema.default("none"),
});
/** @internal */
export type CollectorRestDiscovery6$Outbound = {
  discoverType: string;
};

/** @internal */
export const CollectorRestDiscovery6$outboundSchema: z.ZodType<
  CollectorRestDiscovery6$Outbound,
  z.ZodTypeDef,
  CollectorRestDiscovery6
> = z.object({
  discoverType: CollectorRestDiscoverType6$outboundSchema.default("none"),
});

export function collectorRestDiscovery6ToJSON(
  collectorRestDiscovery6: CollectorRestDiscovery6,
): string {
  return JSON.stringify(
    CollectorRestDiscovery6$outboundSchema.parse(collectorRestDiscovery6),
  );
}
export function collectorRestDiscovery6FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestDiscovery6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestDiscovery6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestDiscovery6' from JSON`,
  );
}

/** @internal */
export const CollectMethod6$inboundSchema: z.ZodType<
  CollectMethod6,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectMethod6);
/** @internal */
export const CollectMethod6$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectMethod6
> = openEnums.outboundSchema(CollectMethod6);

/** @internal */
export const PaginationEnum6$inboundSchema: z.ZodType<
  PaginationEnum6,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(PaginationEnum6);
/** @internal */
export const PaginationEnum6$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  PaginationEnum6
> = openEnums.outboundSchema(PaginationEnum6);

/** @internal */
export const Pagination6$inboundSchema: z.ZodType<
  Pagination6,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: PaginationEnum6$inboundSchema.default("none"),
});
/** @internal */
export type Pagination6$Outbound = {
  type: string;
};

/** @internal */
export const Pagination6$outboundSchema: z.ZodType<
  Pagination6$Outbound,
  z.ZodTypeDef,
  Pagination6
> = z.object({
  type: PaginationEnum6$outboundSchema.default("none"),
});

export function pagination6ToJSON(pagination6: Pagination6): string {
  return JSON.stringify(Pagination6$outboundSchema.parse(pagination6));
}
export function pagination6FromJSON(
  jsonString: string,
): SafeParseResult<Pagination6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Pagination6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Pagination6' from JSON`,
  );
}

/** @internal */
export const CollectorRestRetryRules6$inboundSchema: z.ZodType<
  CollectorRestRetryRules6,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type CollectorRestRetryRules6$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const CollectorRestRetryRules6$outboundSchema: z.ZodType<
  CollectorRestRetryRules6$Outbound,
  z.ZodTypeDef,
  CollectorRestRetryRules6
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function collectorRestRetryRules6ToJSON(
  collectorRestRetryRules6: CollectorRestRetryRules6,
): string {
  return JSON.stringify(
    CollectorRestRetryRules6$outboundSchema.parse(collectorRestRetryRules6),
  );
}
export function collectorRestRetryRules6FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRetryRules6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRetryRules6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRetryRules6' from JSON`,
  );
}

/** @internal */
export const CollectorRestStateTracking6$inboundSchema: z.ZodType<
  CollectorRestStateTracking6,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type CollectorRestStateTracking6$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const CollectorRestStateTracking6$outboundSchema: z.ZodType<
  CollectorRestStateTracking6$Outbound,
  z.ZodTypeDef,
  CollectorRestStateTracking6
> = z.object({
  enabled: z.boolean().optional(),
});

export function collectorRestStateTracking6ToJSON(
  collectorRestStateTracking6: CollectorRestStateTracking6,
): string {
  return JSON.stringify(
    CollectorRestStateTracking6$outboundSchema.parse(
      collectorRestStateTracking6,
    ),
  );
}
export function collectorRestStateTracking6FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestStateTracking6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestStateTracking6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestStateTracking6' from JSON`,
  );
}

/** @internal */
export const CollectorRestScheduling6$inboundSchema: z.ZodType<
  CollectorRestScheduling6,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking6$inboundSchema)
    .optional(),
});
/** @internal */
export type CollectorRestScheduling6$Outbound = {
  stateTracking?: CollectorRestStateTracking6$Outbound | undefined;
};

/** @internal */
export const CollectorRestScheduling6$outboundSchema: z.ZodType<
  CollectorRestScheduling6$Outbound,
  z.ZodTypeDef,
  CollectorRestScheduling6
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking6$outboundSchema)
    .optional(),
});

export function collectorRestScheduling6ToJSON(
  collectorRestScheduling6: CollectorRestScheduling6,
): string {
  return JSON.stringify(
    CollectorRestScheduling6$outboundSchema.parse(collectorRestScheduling6),
  );
}
export function collectorRestScheduling6FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestScheduling6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestScheduling6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestScheduling6' from JSON`,
  );
}

/** @internal */
export const CollectorRestRest6$inboundSchema: z.ZodType<
  CollectorRestRest6,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: CollectorRestAuthentication6$inboundSchema.default("none"),
  loginUrl: z.string().default(""),
  username: z.string(),
  password: z.string(),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  type: CollectorRestType7$inboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery6$inboundSchema).optional(),
  collectUrl: z.string(),
  collectMethod: CollectMethod6$inboundSchema.default("get"),
  collectVerb: z.string().optional(),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  collectBody: z.string().optional(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination6$inboundSchema).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules6$inboundSchema).optional(),
  __scheduling: z.lazy(() => CollectorRestScheduling6$inboundSchema).optional(),
  credentialsSecret: z.string().optional(),
  tokenRespAttribute: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  serviceAccountCredentials: z.string().optional(),
  subject: z.string().optional(),
  hmacFunctionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "__scheduling": "scheduling",
  });
});
/** @internal */
export type CollectorRestRest6$Outbound = {
  authentication: string;
  loginUrl: string;
  username: string;
  password: string;
  loginBody: string;
  getAuthTokenFromHeader: boolean;
  authHeaderKey: string;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  type: string;
  discovery?: CollectorRestDiscovery6$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: string | undefined;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  collectBody?: string | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  pagination?: Pagination6$Outbound | undefined;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  decodeUrl: boolean;
  rejectUnauthorized: boolean;
  captureHeaders: boolean;
  stopOnEmptyResults: boolean;
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules6$Outbound | undefined;
  __scheduling?: CollectorRestScheduling6$Outbound | undefined;
  credentialsSecret?: string | undefined;
  tokenRespAttribute?: string | undefined;
  clientSecretParamName: string;
  clientSecretParamValue?: string | undefined;
  authRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  textSecret?: string | undefined;
  scopes?: Array<string> | undefined;
  serviceAccountCredentials?: string | undefined;
  subject?: string | undefined;
  hmacFunctionId?: string | undefined;
};

/** @internal */
export const CollectorRestRest6$outboundSchema: z.ZodType<
  CollectorRestRest6$Outbound,
  z.ZodTypeDef,
  CollectorRestRest6
> = z.object({
  authentication: CollectorRestAuthentication6$outboundSchema.default("none"),
  loginUrl: z.string().default(""),
  username: z.string(),
  password: z.string(),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  type: CollectorRestType7$outboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery6$outboundSchema).optional(),
  collectUrl: z.string(),
  collectMethod: CollectMethod6$outboundSchema.default("get"),
  collectVerb: z.string().optional(),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  collectBody: z.string().optional(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination6$outboundSchema).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules6$outboundSchema).optional(),
  scheduling: z.lazy(() => CollectorRestScheduling6$outboundSchema).optional(),
  credentialsSecret: z.string().optional(),
  tokenRespAttribute: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  serviceAccountCredentials: z.string().optional(),
  subject: z.string().optional(),
  hmacFunctionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    scheduling: "__scheduling",
  });
});

export function collectorRestRest6ToJSON(
  collectorRestRest6: CollectorRestRest6,
): string {
  return JSON.stringify(
    CollectorRestRest6$outboundSchema.parse(collectorRestRest6),
  );
}
export function collectorRestRest6FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRest6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRest6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRest6' from JSON`,
  );
}

/** @internal */
export const AuthenticationRest$inboundSchema: z.ZodType<
  AuthenticationRest,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(AuthenticationRest);
/** @internal */
export const AuthenticationRest$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  AuthenticationRest
> = openEnums.outboundSchema(AuthenticationRest);

/** @internal */
export const CollectorRestType5$inboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType5
> = z.nativeEnum(CollectorRestType5);
/** @internal */
export const CollectorRestType5$outboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType5
> = CollectorRestType5$inboundSchema;

/** @internal */
export const DiscoverTypeRest$inboundSchema: z.ZodType<
  DiscoverTypeRest,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(DiscoverTypeRest);
/** @internal */
export const DiscoverTypeRest$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  DiscoverTypeRest
> = openEnums.outboundSchema(DiscoverTypeRest);

/** @internal */
export const DiscoveryRest$inboundSchema: z.ZodType<
  DiscoveryRest,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: DiscoverTypeRest$inboundSchema.default("none"),
});
/** @internal */
export type DiscoveryRest$Outbound = {
  discoverType: string;
};

/** @internal */
export const DiscoveryRest$outboundSchema: z.ZodType<
  DiscoveryRest$Outbound,
  z.ZodTypeDef,
  DiscoveryRest
> = z.object({
  discoverType: DiscoverTypeRest$outboundSchema.default("none"),
});

export function discoveryRestToJSON(discoveryRest: DiscoveryRest): string {
  return JSON.stringify(DiscoveryRest$outboundSchema.parse(discoveryRest));
}
export function discoveryRestFromJSON(
  jsonString: string,
): SafeParseResult<DiscoveryRest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DiscoveryRest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DiscoveryRest' from JSON`,
  );
}

/** @internal */
export const CollectMethodRest$inboundSchema: z.ZodType<
  CollectMethodRest,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectMethodRest);
/** @internal */
export const CollectMethodRest$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectMethodRest
> = openEnums.outboundSchema(CollectMethodRest);

/** @internal */
export const PaginationRestEnum$inboundSchema: z.ZodType<
  PaginationRestEnum,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(PaginationRestEnum);
/** @internal */
export const PaginationRestEnum$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  PaginationRestEnum
> = openEnums.outboundSchema(PaginationRestEnum);

/** @internal */
export const PaginationRest$inboundSchema: z.ZodType<
  PaginationRest,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: PaginationRestEnum$inboundSchema.default("none"),
});
/** @internal */
export type PaginationRest$Outbound = {
  type: string;
};

/** @internal */
export const PaginationRest$outboundSchema: z.ZodType<
  PaginationRest$Outbound,
  z.ZodTypeDef,
  PaginationRest
> = z.object({
  type: PaginationRestEnum$outboundSchema.default("none"),
});

export function paginationRestToJSON(paginationRest: PaginationRest): string {
  return JSON.stringify(PaginationRest$outboundSchema.parse(paginationRest));
}
export function paginationRestFromJSON(
  jsonString: string,
): SafeParseResult<PaginationRest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaginationRest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaginationRest' from JSON`,
  );
}

/** @internal */
export const RetryRulesRest$inboundSchema: z.ZodType<
  RetryRulesRest,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RetryRulesRest$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RetryRulesRest$outboundSchema: z.ZodType<
  RetryRulesRest$Outbound,
  z.ZodTypeDef,
  RetryRulesRest
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function retryRulesRestToJSON(retryRulesRest: RetryRulesRest): string {
  return JSON.stringify(RetryRulesRest$outboundSchema.parse(retryRulesRest));
}
export function retryRulesRestFromJSON(
  jsonString: string,
): SafeParseResult<RetryRulesRest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetryRulesRest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetryRulesRest' from JSON`,
  );
}

/** @internal */
export const StateTrackingRest$inboundSchema: z.ZodType<
  StateTrackingRest,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type StateTrackingRest$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const StateTrackingRest$outboundSchema: z.ZodType<
  StateTrackingRest$Outbound,
  z.ZodTypeDef,
  StateTrackingRest
> = z.object({
  enabled: z.boolean().optional(),
});

export function stateTrackingRestToJSON(
  stateTrackingRest: StateTrackingRest,
): string {
  return JSON.stringify(
    StateTrackingRest$outboundSchema.parse(stateTrackingRest),
  );
}
export function stateTrackingRestFromJSON(
  jsonString: string,
): SafeParseResult<StateTrackingRest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StateTrackingRest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StateTrackingRest' from JSON`,
  );
}

/** @internal */
export const SchedulingRest$inboundSchema: z.ZodType<
  SchedulingRest,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => StateTrackingRest$inboundSchema).optional(),
});
/** @internal */
export type SchedulingRest$Outbound = {
  stateTracking?: StateTrackingRest$Outbound | undefined;
};

/** @internal */
export const SchedulingRest$outboundSchema: z.ZodType<
  SchedulingRest$Outbound,
  z.ZodTypeDef,
  SchedulingRest
> = z.object({
  stateTracking: z.lazy(() => StateTrackingRest$outboundSchema).optional(),
});

export function schedulingRestToJSON(schedulingRest: SchedulingRest): string {
  return JSON.stringify(SchedulingRest$outboundSchema.parse(schedulingRest));
}
export function schedulingRestFromJSON(
  jsonString: string,
): SafeParseResult<SchedulingRest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SchedulingRest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SchedulingRest' from JSON`,
  );
}

/** @internal */
export const CollectorRestCollectorHealthCheckPart2Type$inboundSchema:
  z.ZodType<CollectorRestCollectorHealthCheckPart2Type, z.ZodTypeDef, unknown> =
    z.object({
      authentication: AuthenticationRest$inboundSchema.default("none"),
      credentialsSecret: z.string(),
      type: CollectorRestType5$inboundSchema,
      discovery: z.lazy(() => DiscoveryRest$inboundSchema).optional(),
      collectUrl: z.string(),
      collectMethod: CollectMethodRest$inboundSchema.default("get"),
      collectVerb: z.string().optional(),
      collectRequestParams: z.array(
        ItemsTypeCollectRequestParams1$inboundSchema,
      ).optional(),
      collectBody: z.string().optional(),
      collectRequestHeaders: z.array(
        ItemsTypeCollectRequestParams1$inboundSchema,
      ).optional(),
      pagination: z.lazy(() => PaginationRest$inboundSchema).optional(),
      timeout: z.number().default(0),
      useRoundRobinDns: z.boolean().default(false),
      disableTimeFilter: z.boolean().default(false),
      decodeUrl: z.boolean().default(true),
      rejectUnauthorized: z.boolean().default(false),
      captureHeaders: z.boolean().default(false),
      stopOnEmptyResults: z.boolean().default(false),
      safeHeaders: z.array(z.string()).optional(),
      retryRules: z.lazy(() => RetryRulesRest$inboundSchema).optional(),
      __scheduling: z.lazy(() => SchedulingRest$inboundSchema).optional(),
      username: z.string().optional(),
      password: z.string().optional(),
      loginUrl: z.string().default(""),
      loginBody: z.string().default(
        "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
      ),
      getAuthTokenFromHeader: z.boolean().default(false),
      authHeaderKey: z.string().default("Authorization"),
      authHeaderExpr: z.string().default("`Bearer ${token}`"),
      authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
        .optional(),
      tokenRespAttribute: z.string().optional(),
      clientSecretParamName: z.string().default("client_secret"),
      clientSecretParamValue: z.string().optional(),
      authRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
        .optional(),
      textSecret: z.string().optional(),
      scopes: z.array(z.string()).optional(),
      serviceAccountCredentials: z.string().optional(),
      subject: z.string().optional(),
      hmacFunctionId: z.string().optional(),
    }).transform((v) => {
      return remap$(v, {
        "__scheduling": "scheduling",
      });
    });
/** @internal */
export type CollectorRestCollectorHealthCheckPart2Type$Outbound = {
  authentication: string;
  credentialsSecret: string;
  type: string;
  discovery?: DiscoveryRest$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: string | undefined;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  collectBody?: string | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  pagination?: PaginationRest$Outbound | undefined;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  decodeUrl: boolean;
  rejectUnauthorized: boolean;
  captureHeaders: boolean;
  stopOnEmptyResults: boolean;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RetryRulesRest$Outbound | undefined;
  __scheduling?: SchedulingRest$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  loginUrl: string;
  loginBody: string;
  getAuthTokenFromHeader: boolean;
  authHeaderKey: string;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  tokenRespAttribute?: string | undefined;
  clientSecretParamName: string;
  clientSecretParamValue?: string | undefined;
  authRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  textSecret?: string | undefined;
  scopes?: Array<string> | undefined;
  serviceAccountCredentials?: string | undefined;
  subject?: string | undefined;
  hmacFunctionId?: string | undefined;
};

/** @internal */
export const CollectorRestCollectorHealthCheckPart2Type$outboundSchema:
  z.ZodType<
    CollectorRestCollectorHealthCheckPart2Type$Outbound,
    z.ZodTypeDef,
    CollectorRestCollectorHealthCheckPart2Type
  > = z.object({
    authentication: AuthenticationRest$outboundSchema.default("none"),
    credentialsSecret: z.string(),
    type: CollectorRestType5$outboundSchema,
    discovery: z.lazy(() => DiscoveryRest$outboundSchema).optional(),
    collectUrl: z.string(),
    collectMethod: CollectMethodRest$outboundSchema.default("get"),
    collectVerb: z.string().optional(),
    collectRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
      .optional(),
    collectBody: z.string().optional(),
    collectRequestHeaders: z.array(
      ItemsTypeCollectRequestParams1$outboundSchema,
    ).optional(),
    pagination: z.lazy(() => PaginationRest$outboundSchema).optional(),
    timeout: z.number().default(0),
    useRoundRobinDns: z.boolean().default(false),
    disableTimeFilter: z.boolean().default(false),
    decodeUrl: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(false),
    captureHeaders: z.boolean().default(false),
    stopOnEmptyResults: z.boolean().default(false),
    safeHeaders: z.array(z.string()).optional(),
    retryRules: z.lazy(() => RetryRulesRest$outboundSchema).optional(),
    scheduling: z.lazy(() => SchedulingRest$outboundSchema).optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    loginUrl: z.string().default(""),
    loginBody: z.string().default(
      "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
    ),
    getAuthTokenFromHeader: z.boolean().default(false),
    authHeaderKey: z.string().default("Authorization"),
    authHeaderExpr: z.string().default("`Bearer ${token}`"),
    authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
      .optional(),
    tokenRespAttribute: z.string().optional(),
    clientSecretParamName: z.string().default("client_secret"),
    clientSecretParamValue: z.string().optional(),
    authRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
      .optional(),
    textSecret: z.string().optional(),
    scopes: z.array(z.string()).optional(),
    serviceAccountCredentials: z.string().optional(),
    subject: z.string().optional(),
    hmacFunctionId: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      scheduling: "__scheduling",
    });
  });

export function collectorRestCollectorHealthCheckPart2TypeToJSON(
  collectorRestCollectorHealthCheckPart2Type:
    CollectorRestCollectorHealthCheckPart2Type,
): string {
  return JSON.stringify(
    CollectorRestCollectorHealthCheckPart2Type$outboundSchema.parse(
      collectorRestCollectorHealthCheckPart2Type,
    ),
  );
}
export function collectorRestCollectorHealthCheckPart2TypeFromJSON(
  jsonString: string,
): SafeParseResult<
  CollectorRestCollectorHealthCheckPart2Type,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CollectorRestCollectorHealthCheckPart2Type$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CollectorRestCollectorHealthCheckPart2Type' from JSON`,
  );
}

/** @internal */
export const CollectorRestAuthentication5$inboundSchema: z.ZodType<
  CollectorRestAuthentication5,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestAuthentication5);
/** @internal */
export const CollectorRestAuthentication5$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestAuthentication5
> = openEnums.outboundSchema(CollectorRestAuthentication5);

/** @internal */
export const CollectorRestType6$inboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType6
> = z.nativeEnum(CollectorRestType6);
/** @internal */
export const CollectorRestType6$outboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType6
> = CollectorRestType6$inboundSchema;

/** @internal */
export const CollectorRestDiscoverType5$inboundSchema: z.ZodType<
  CollectorRestDiscoverType5,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestDiscoverType5);
/** @internal */
export const CollectorRestDiscoverType5$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestDiscoverType5
> = openEnums.outboundSchema(CollectorRestDiscoverType5);

/** @internal */
export const CollectorRestDiscovery5$inboundSchema: z.ZodType<
  CollectorRestDiscovery5,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: CollectorRestDiscoverType5$inboundSchema.default("none"),
});
/** @internal */
export type CollectorRestDiscovery5$Outbound = {
  discoverType: string;
};

/** @internal */
export const CollectorRestDiscovery5$outboundSchema: z.ZodType<
  CollectorRestDiscovery5$Outbound,
  z.ZodTypeDef,
  CollectorRestDiscovery5
> = z.object({
  discoverType: CollectorRestDiscoverType5$outboundSchema.default("none"),
});

export function collectorRestDiscovery5ToJSON(
  collectorRestDiscovery5: CollectorRestDiscovery5,
): string {
  return JSON.stringify(
    CollectorRestDiscovery5$outboundSchema.parse(collectorRestDiscovery5),
  );
}
export function collectorRestDiscovery5FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestDiscovery5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestDiscovery5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestDiscovery5' from JSON`,
  );
}

/** @internal */
export const CollectMethod5$inboundSchema: z.ZodType<
  CollectMethod5,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectMethod5);
/** @internal */
export const CollectMethod5$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectMethod5
> = openEnums.outboundSchema(CollectMethod5);

/** @internal */
export const PaginationEnum5$inboundSchema: z.ZodType<
  PaginationEnum5,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(PaginationEnum5);
/** @internal */
export const PaginationEnum5$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  PaginationEnum5
> = openEnums.outboundSchema(PaginationEnum5);

/** @internal */
export const Pagination5$inboundSchema: z.ZodType<
  Pagination5,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: PaginationEnum5$inboundSchema.default("none"),
});
/** @internal */
export type Pagination5$Outbound = {
  type: string;
};

/** @internal */
export const Pagination5$outboundSchema: z.ZodType<
  Pagination5$Outbound,
  z.ZodTypeDef,
  Pagination5
> = z.object({
  type: PaginationEnum5$outboundSchema.default("none"),
});

export function pagination5ToJSON(pagination5: Pagination5): string {
  return JSON.stringify(Pagination5$outboundSchema.parse(pagination5));
}
export function pagination5FromJSON(
  jsonString: string,
): SafeParseResult<Pagination5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Pagination5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Pagination5' from JSON`,
  );
}

/** @internal */
export const CollectorRestRetryRules5$inboundSchema: z.ZodType<
  CollectorRestRetryRules5,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type CollectorRestRetryRules5$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const CollectorRestRetryRules5$outboundSchema: z.ZodType<
  CollectorRestRetryRules5$Outbound,
  z.ZodTypeDef,
  CollectorRestRetryRules5
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function collectorRestRetryRules5ToJSON(
  collectorRestRetryRules5: CollectorRestRetryRules5,
): string {
  return JSON.stringify(
    CollectorRestRetryRules5$outboundSchema.parse(collectorRestRetryRules5),
  );
}
export function collectorRestRetryRules5FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRetryRules5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRetryRules5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRetryRules5' from JSON`,
  );
}

/** @internal */
export const CollectorRestStateTracking5$inboundSchema: z.ZodType<
  CollectorRestStateTracking5,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type CollectorRestStateTracking5$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const CollectorRestStateTracking5$outboundSchema: z.ZodType<
  CollectorRestStateTracking5$Outbound,
  z.ZodTypeDef,
  CollectorRestStateTracking5
> = z.object({
  enabled: z.boolean().optional(),
});

export function collectorRestStateTracking5ToJSON(
  collectorRestStateTracking5: CollectorRestStateTracking5,
): string {
  return JSON.stringify(
    CollectorRestStateTracking5$outboundSchema.parse(
      collectorRestStateTracking5,
    ),
  );
}
export function collectorRestStateTracking5FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestStateTracking5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestStateTracking5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestStateTracking5' from JSON`,
  );
}

/** @internal */
export const CollectorRestScheduling5$inboundSchema: z.ZodType<
  CollectorRestScheduling5,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking5$inboundSchema)
    .optional(),
});
/** @internal */
export type CollectorRestScheduling5$Outbound = {
  stateTracking?: CollectorRestStateTracking5$Outbound | undefined;
};

/** @internal */
export const CollectorRestScheduling5$outboundSchema: z.ZodType<
  CollectorRestScheduling5$Outbound,
  z.ZodTypeDef,
  CollectorRestScheduling5
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking5$outboundSchema)
    .optional(),
});

export function collectorRestScheduling5ToJSON(
  collectorRestScheduling5: CollectorRestScheduling5,
): string {
  return JSON.stringify(
    CollectorRestScheduling5$outboundSchema.parse(collectorRestScheduling5),
  );
}
export function collectorRestScheduling5FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestScheduling5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestScheduling5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestScheduling5' from JSON`,
  );
}

/** @internal */
export const CollectorRestRest5$inboundSchema: z.ZodType<
  CollectorRestRest5,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: CollectorRestAuthentication5$inboundSchema.default("none"),
  username: z.string(),
  password: z.string(),
  type: CollectorRestType6$inboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery5$inboundSchema).optional(),
  collectUrl: z.string(),
  collectMethod: CollectMethod5$inboundSchema.default("get"),
  collectVerb: z.string().optional(),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  collectBody: z.string().optional(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination5$inboundSchema).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules5$inboundSchema).optional(),
  __scheduling: z.lazy(() => CollectorRestScheduling5$inboundSchema).optional(),
  credentialsSecret: z.string().optional(),
  loginUrl: z.string().default(""),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  tokenRespAttribute: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  serviceAccountCredentials: z.string().optional(),
  subject: z.string().optional(),
  hmacFunctionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "__scheduling": "scheduling",
  });
});
/** @internal */
export type CollectorRestRest5$Outbound = {
  authentication: string;
  username: string;
  password: string;
  type: string;
  discovery?: CollectorRestDiscovery5$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: string | undefined;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  collectBody?: string | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  pagination?: Pagination5$Outbound | undefined;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  decodeUrl: boolean;
  rejectUnauthorized: boolean;
  captureHeaders: boolean;
  stopOnEmptyResults: boolean;
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules5$Outbound | undefined;
  __scheduling?: CollectorRestScheduling5$Outbound | undefined;
  credentialsSecret?: string | undefined;
  loginUrl: string;
  loginBody: string;
  getAuthTokenFromHeader: boolean;
  authHeaderKey: string;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  tokenRespAttribute?: string | undefined;
  clientSecretParamName: string;
  clientSecretParamValue?: string | undefined;
  authRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  textSecret?: string | undefined;
  scopes?: Array<string> | undefined;
  serviceAccountCredentials?: string | undefined;
  subject?: string | undefined;
  hmacFunctionId?: string | undefined;
};

/** @internal */
export const CollectorRestRest5$outboundSchema: z.ZodType<
  CollectorRestRest5$Outbound,
  z.ZodTypeDef,
  CollectorRestRest5
> = z.object({
  authentication: CollectorRestAuthentication5$outboundSchema.default("none"),
  username: z.string(),
  password: z.string(),
  type: CollectorRestType6$outboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery5$outboundSchema).optional(),
  collectUrl: z.string(),
  collectMethod: CollectMethod5$outboundSchema.default("get"),
  collectVerb: z.string().optional(),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  collectBody: z.string().optional(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination5$outboundSchema).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules5$outboundSchema).optional(),
  scheduling: z.lazy(() => CollectorRestScheduling5$outboundSchema).optional(),
  credentialsSecret: z.string().optional(),
  loginUrl: z.string().default(""),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  tokenRespAttribute: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  serviceAccountCredentials: z.string().optional(),
  subject: z.string().optional(),
  hmacFunctionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    scheduling: "__scheduling",
  });
});

export function collectorRestRest5ToJSON(
  collectorRestRest5: CollectorRestRest5,
): string {
  return JSON.stringify(
    CollectorRestRest5$outboundSchema.parse(collectorRestRest5),
  );
}
export function collectorRestRest5FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRest5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRest5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRest5' from JSON`,
  );
}

/** @internal */
export const CollectorRestCollectorHealthCheckPart0Type$inboundSchema:
  z.ZodType<CollectorRestCollectorHealthCheckPart0Type, z.ZodTypeDef, unknown> =
    z.object({
      authentication: AuthenticationRest$inboundSchema.default("none"),
      type: CollectorRestType5$inboundSchema,
      discovery: z.lazy(() => DiscoveryRest$inboundSchema).optional(),
      collectUrl: z.string(),
      collectMethod: CollectMethodRest$inboundSchema.default("get"),
      collectVerb: z.string().optional(),
      collectRequestParams: z.array(
        ItemsTypeCollectRequestParams1$inboundSchema,
      ).optional(),
      collectBody: z.string().optional(),
      collectRequestHeaders: z.array(
        ItemsTypeCollectRequestParams1$inboundSchema,
      ).optional(),
      pagination: z.lazy(() => PaginationRest$inboundSchema).optional(),
      timeout: z.number().default(0),
      useRoundRobinDns: z.boolean().default(false),
      disableTimeFilter: z.boolean().default(false),
      decodeUrl: z.boolean().default(true),
      rejectUnauthorized: z.boolean().default(false),
      captureHeaders: z.boolean().default(false),
      stopOnEmptyResults: z.boolean().default(false),
      safeHeaders: z.array(z.string()).optional(),
      retryRules: z.lazy(() => RetryRulesRest$inboundSchema).optional(),
      __scheduling: z.lazy(() => SchedulingRest$inboundSchema).optional(),
      username: z.string().optional(),
      password: z.string().optional(),
      credentialsSecret: z.string().optional(),
      loginUrl: z.string().default(""),
      loginBody: z.string().default(
        "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
      ),
      getAuthTokenFromHeader: z.boolean().default(false),
      authHeaderKey: z.string().default("Authorization"),
      authHeaderExpr: z.string().default("`Bearer ${token}`"),
      authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
        .optional(),
      tokenRespAttribute: z.string().optional(),
      clientSecretParamName: z.string().default("client_secret"),
      clientSecretParamValue: z.string().optional(),
      authRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
        .optional(),
      textSecret: z.string().optional(),
      scopes: z.array(z.string()).optional(),
      serviceAccountCredentials: z.string().optional(),
      subject: z.string().optional(),
      hmacFunctionId: z.string().optional(),
    }).transform((v) => {
      return remap$(v, {
        "__scheduling": "scheduling",
      });
    });
/** @internal */
export type CollectorRestCollectorHealthCheckPart0Type$Outbound = {
  authentication: string;
  type: string;
  discovery?: DiscoveryRest$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: string | undefined;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  collectBody?: string | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  pagination?: PaginationRest$Outbound | undefined;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  decodeUrl: boolean;
  rejectUnauthorized: boolean;
  captureHeaders: boolean;
  stopOnEmptyResults: boolean;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RetryRulesRest$Outbound | undefined;
  __scheduling?: SchedulingRest$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  loginUrl: string;
  loginBody: string;
  getAuthTokenFromHeader: boolean;
  authHeaderKey: string;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  tokenRespAttribute?: string | undefined;
  clientSecretParamName: string;
  clientSecretParamValue?: string | undefined;
  authRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  textSecret?: string | undefined;
  scopes?: Array<string> | undefined;
  serviceAccountCredentials?: string | undefined;
  subject?: string | undefined;
  hmacFunctionId?: string | undefined;
};

/** @internal */
export const CollectorRestCollectorHealthCheckPart0Type$outboundSchema:
  z.ZodType<
    CollectorRestCollectorHealthCheckPart0Type$Outbound,
    z.ZodTypeDef,
    CollectorRestCollectorHealthCheckPart0Type
  > = z.object({
    authentication: AuthenticationRest$outboundSchema.default("none"),
    type: CollectorRestType5$outboundSchema,
    discovery: z.lazy(() => DiscoveryRest$outboundSchema).optional(),
    collectUrl: z.string(),
    collectMethod: CollectMethodRest$outboundSchema.default("get"),
    collectVerb: z.string().optional(),
    collectRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
      .optional(),
    collectBody: z.string().optional(),
    collectRequestHeaders: z.array(
      ItemsTypeCollectRequestParams1$outboundSchema,
    ).optional(),
    pagination: z.lazy(() => PaginationRest$outboundSchema).optional(),
    timeout: z.number().default(0),
    useRoundRobinDns: z.boolean().default(false),
    disableTimeFilter: z.boolean().default(false),
    decodeUrl: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(false),
    captureHeaders: z.boolean().default(false),
    stopOnEmptyResults: z.boolean().default(false),
    safeHeaders: z.array(z.string()).optional(),
    retryRules: z.lazy(() => RetryRulesRest$outboundSchema).optional(),
    scheduling: z.lazy(() => SchedulingRest$outboundSchema).optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
    loginUrl: z.string().default(""),
    loginBody: z.string().default(
      "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
    ),
    getAuthTokenFromHeader: z.boolean().default(false),
    authHeaderKey: z.string().default("Authorization"),
    authHeaderExpr: z.string().default("`Bearer ${token}`"),
    authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
      .optional(),
    tokenRespAttribute: z.string().optional(),
    clientSecretParamName: z.string().default("client_secret"),
    clientSecretParamValue: z.string().optional(),
    authRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
      .optional(),
    textSecret: z.string().optional(),
    scopes: z.array(z.string()).optional(),
    serviceAccountCredentials: z.string().optional(),
    subject: z.string().optional(),
    hmacFunctionId: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      scheduling: "__scheduling",
    });
  });

export function collectorRestCollectorHealthCheckPart0TypeToJSON(
  collectorRestCollectorHealthCheckPart0Type:
    CollectorRestCollectorHealthCheckPart0Type,
): string {
  return JSON.stringify(
    CollectorRestCollectorHealthCheckPart0Type$outboundSchema.parse(
      collectorRestCollectorHealthCheckPart0Type,
    ),
  );
}
export function collectorRestCollectorHealthCheckPart0TypeFromJSON(
  jsonString: string,
): SafeParseResult<
  CollectorRestCollectorHealthCheckPart0Type,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CollectorRestCollectorHealthCheckPart0Type$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CollectorRestCollectorHealthCheckPart0Type' from JSON`,
  );
}

/** @internal */
export const CollectMethod4$inboundSchema: z.ZodType<
  CollectMethod4,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectMethod4);
/** @internal */
export const CollectMethod4$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectMethod4
> = openEnums.outboundSchema(CollectMethod4);

/** @internal */
export const CollectorRestType4$inboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType4
> = z.nativeEnum(CollectorRestType4);
/** @internal */
export const CollectorRestType4$outboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType4
> = CollectorRestType4$inboundSchema;

/** @internal */
export const CollectorRestDiscoverType4$inboundSchema: z.ZodType<
  CollectorRestDiscoverType4,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestDiscoverType4);
/** @internal */
export const CollectorRestDiscoverType4$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestDiscoverType4
> = openEnums.outboundSchema(CollectorRestDiscoverType4);

/** @internal */
export const CollectorRestDiscovery4$inboundSchema: z.ZodType<
  CollectorRestDiscovery4,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: CollectorRestDiscoverType4$inboundSchema.default("none"),
});
/** @internal */
export type CollectorRestDiscovery4$Outbound = {
  discoverType: string;
};

/** @internal */
export const CollectorRestDiscovery4$outboundSchema: z.ZodType<
  CollectorRestDiscovery4$Outbound,
  z.ZodTypeDef,
  CollectorRestDiscovery4
> = z.object({
  discoverType: CollectorRestDiscoverType4$outboundSchema.default("none"),
});

export function collectorRestDiscovery4ToJSON(
  collectorRestDiscovery4: CollectorRestDiscovery4,
): string {
  return JSON.stringify(
    CollectorRestDiscovery4$outboundSchema.parse(collectorRestDiscovery4),
  );
}
export function collectorRestDiscovery4FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestDiscovery4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestDiscovery4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestDiscovery4' from JSON`,
  );
}

/** @internal */
export const PaginationEnum4$inboundSchema: z.ZodType<
  PaginationEnum4,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(PaginationEnum4);
/** @internal */
export const PaginationEnum4$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  PaginationEnum4
> = openEnums.outboundSchema(PaginationEnum4);

/** @internal */
export const Pagination4$inboundSchema: z.ZodType<
  Pagination4,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: PaginationEnum4$inboundSchema.default("none"),
});
/** @internal */
export type Pagination4$Outbound = {
  type: string;
};

/** @internal */
export const Pagination4$outboundSchema: z.ZodType<
  Pagination4$Outbound,
  z.ZodTypeDef,
  Pagination4
> = z.object({
  type: PaginationEnum4$outboundSchema.default("none"),
});

export function pagination4ToJSON(pagination4: Pagination4): string {
  return JSON.stringify(Pagination4$outboundSchema.parse(pagination4));
}
export function pagination4FromJSON(
  jsonString: string,
): SafeParseResult<Pagination4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Pagination4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Pagination4' from JSON`,
  );
}

/** @internal */
export const CollectorRestAuthentication4$inboundSchema: z.ZodType<
  CollectorRestAuthentication4,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestAuthentication4);
/** @internal */
export const CollectorRestAuthentication4$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestAuthentication4
> = openEnums.outboundSchema(CollectorRestAuthentication4);

/** @internal */
export const CollectorRestRetryRules4$inboundSchema: z.ZodType<
  CollectorRestRetryRules4,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type CollectorRestRetryRules4$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const CollectorRestRetryRules4$outboundSchema: z.ZodType<
  CollectorRestRetryRules4$Outbound,
  z.ZodTypeDef,
  CollectorRestRetryRules4
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function collectorRestRetryRules4ToJSON(
  collectorRestRetryRules4: CollectorRestRetryRules4,
): string {
  return JSON.stringify(
    CollectorRestRetryRules4$outboundSchema.parse(collectorRestRetryRules4),
  );
}
export function collectorRestRetryRules4FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRetryRules4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRetryRules4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRetryRules4' from JSON`,
  );
}

/** @internal */
export const CollectorRestStateTracking4$inboundSchema: z.ZodType<
  CollectorRestStateTracking4,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type CollectorRestStateTracking4$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const CollectorRestStateTracking4$outboundSchema: z.ZodType<
  CollectorRestStateTracking4$Outbound,
  z.ZodTypeDef,
  CollectorRestStateTracking4
> = z.object({
  enabled: z.boolean().optional(),
});

export function collectorRestStateTracking4ToJSON(
  collectorRestStateTracking4: CollectorRestStateTracking4,
): string {
  return JSON.stringify(
    CollectorRestStateTracking4$outboundSchema.parse(
      collectorRestStateTracking4,
    ),
  );
}
export function collectorRestStateTracking4FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestStateTracking4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestStateTracking4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestStateTracking4' from JSON`,
  );
}

/** @internal */
export const CollectorRestScheduling4$inboundSchema: z.ZodType<
  CollectorRestScheduling4,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking4$inboundSchema)
    .optional(),
});
/** @internal */
export type CollectorRestScheduling4$Outbound = {
  stateTracking?: CollectorRestStateTracking4$Outbound | undefined;
};

/** @internal */
export const CollectorRestScheduling4$outboundSchema: z.ZodType<
  CollectorRestScheduling4$Outbound,
  z.ZodTypeDef,
  CollectorRestScheduling4
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking4$outboundSchema)
    .optional(),
});

export function collectorRestScheduling4ToJSON(
  collectorRestScheduling4: CollectorRestScheduling4,
): string {
  return JSON.stringify(
    CollectorRestScheduling4$outboundSchema.parse(collectorRestScheduling4),
  );
}
export function collectorRestScheduling4FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestScheduling4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestScheduling4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestScheduling4' from JSON`,
  );
}

/** @internal */
export const CollectorRestRest4$inboundSchema: z.ZodType<
  CollectorRestRest4,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: CollectMethod4$inboundSchema.default("get"),
  collectVerb: z.string(),
  collectBody: z.string().optional(),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  type: CollectorRestType4$inboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery4$inboundSchema).optional(),
  collectUrl: z.string(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination4$inboundSchema).optional(),
  authentication: CollectorRestAuthentication4$inboundSchema.default("none"),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules4$inboundSchema).optional(),
  __scheduling: z.lazy(() => CollectorRestScheduling4$inboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginUrl: z.string().default(""),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  tokenRespAttribute: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  serviceAccountCredentials: z.string().optional(),
  subject: z.string().optional(),
  hmacFunctionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "__scheduling": "scheduling",
  });
});
/** @internal */
export type CollectorRestRest4$Outbound = {
  collectMethod: string;
  collectVerb: string;
  collectBody?: string | undefined;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  type: string;
  discovery?: CollectorRestDiscovery4$Outbound | undefined;
  collectUrl: string;
  collectRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  pagination?: Pagination4$Outbound | undefined;
  authentication: string;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  decodeUrl: boolean;
  rejectUnauthorized: boolean;
  captureHeaders: boolean;
  stopOnEmptyResults: boolean;
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules4$Outbound | undefined;
  __scheduling?: CollectorRestScheduling4$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  loginUrl: string;
  loginBody: string;
  getAuthTokenFromHeader: boolean;
  authHeaderKey: string;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  tokenRespAttribute?: string | undefined;
  clientSecretParamName: string;
  clientSecretParamValue?: string | undefined;
  authRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  textSecret?: string | undefined;
  scopes?: Array<string> | undefined;
  serviceAccountCredentials?: string | undefined;
  subject?: string | undefined;
  hmacFunctionId?: string | undefined;
};

/** @internal */
export const CollectorRestRest4$outboundSchema: z.ZodType<
  CollectorRestRest4$Outbound,
  z.ZodTypeDef,
  CollectorRestRest4
> = z.object({
  collectMethod: CollectMethod4$outboundSchema.default("get"),
  collectVerb: z.string(),
  collectBody: z.string().optional(),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  type: CollectorRestType4$outboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery4$outboundSchema).optional(),
  collectUrl: z.string(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination4$outboundSchema).optional(),
  authentication: CollectorRestAuthentication4$outboundSchema.default("none"),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules4$outboundSchema).optional(),
  scheduling: z.lazy(() => CollectorRestScheduling4$outboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginUrl: z.string().default(""),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  tokenRespAttribute: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  serviceAccountCredentials: z.string().optional(),
  subject: z.string().optional(),
  hmacFunctionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    scheduling: "__scheduling",
  });
});

export function collectorRestRest4ToJSON(
  collectorRestRest4: CollectorRestRest4,
): string {
  return JSON.stringify(
    CollectorRestRest4$outboundSchema.parse(collectorRestRest4),
  );
}
export function collectorRestRest4FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRest4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRest4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRest4' from JSON`,
  );
}

/** @internal */
export const CollectMethod3$inboundSchema: z.ZodType<
  CollectMethod3,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectMethod3);
/** @internal */
export const CollectMethod3$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectMethod3
> = openEnums.outboundSchema(CollectMethod3);

/** @internal */
export const CollectorRestType3$inboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType3
> = z.nativeEnum(CollectorRestType3);
/** @internal */
export const CollectorRestType3$outboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType3
> = CollectorRestType3$inboundSchema;

/** @internal */
export const CollectorRestDiscoverType3$inboundSchema: z.ZodType<
  CollectorRestDiscoverType3,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestDiscoverType3);
/** @internal */
export const CollectorRestDiscoverType3$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestDiscoverType3
> = openEnums.outboundSchema(CollectorRestDiscoverType3);

/** @internal */
export const CollectorRestDiscovery3$inboundSchema: z.ZodType<
  CollectorRestDiscovery3,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: CollectorRestDiscoverType3$inboundSchema.default("none"),
});
/** @internal */
export type CollectorRestDiscovery3$Outbound = {
  discoverType: string;
};

/** @internal */
export const CollectorRestDiscovery3$outboundSchema: z.ZodType<
  CollectorRestDiscovery3$Outbound,
  z.ZodTypeDef,
  CollectorRestDiscovery3
> = z.object({
  discoverType: CollectorRestDiscoverType3$outboundSchema.default("none"),
});

export function collectorRestDiscovery3ToJSON(
  collectorRestDiscovery3: CollectorRestDiscovery3,
): string {
  return JSON.stringify(
    CollectorRestDiscovery3$outboundSchema.parse(collectorRestDiscovery3),
  );
}
export function collectorRestDiscovery3FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestDiscovery3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestDiscovery3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestDiscovery3' from JSON`,
  );
}

/** @internal */
export const PaginationEnum3$inboundSchema: z.ZodType<
  PaginationEnum3,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(PaginationEnum3);
/** @internal */
export const PaginationEnum3$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  PaginationEnum3
> = openEnums.outboundSchema(PaginationEnum3);

/** @internal */
export const Pagination3$inboundSchema: z.ZodType<
  Pagination3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: PaginationEnum3$inboundSchema.default("none"),
});
/** @internal */
export type Pagination3$Outbound = {
  type: string;
};

/** @internal */
export const Pagination3$outboundSchema: z.ZodType<
  Pagination3$Outbound,
  z.ZodTypeDef,
  Pagination3
> = z.object({
  type: PaginationEnum3$outboundSchema.default("none"),
});

export function pagination3ToJSON(pagination3: Pagination3): string {
  return JSON.stringify(Pagination3$outboundSchema.parse(pagination3));
}
export function pagination3FromJSON(
  jsonString: string,
): SafeParseResult<Pagination3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Pagination3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Pagination3' from JSON`,
  );
}

/** @internal */
export const CollectorRestAuthentication3$inboundSchema: z.ZodType<
  CollectorRestAuthentication3,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestAuthentication3);
/** @internal */
export const CollectorRestAuthentication3$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestAuthentication3
> = openEnums.outboundSchema(CollectorRestAuthentication3);

/** @internal */
export const CollectorRestRetryRules3$inboundSchema: z.ZodType<
  CollectorRestRetryRules3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type CollectorRestRetryRules3$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const CollectorRestRetryRules3$outboundSchema: z.ZodType<
  CollectorRestRetryRules3$Outbound,
  z.ZodTypeDef,
  CollectorRestRetryRules3
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function collectorRestRetryRules3ToJSON(
  collectorRestRetryRules3: CollectorRestRetryRules3,
): string {
  return JSON.stringify(
    CollectorRestRetryRules3$outboundSchema.parse(collectorRestRetryRules3),
  );
}
export function collectorRestRetryRules3FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRetryRules3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRetryRules3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRetryRules3' from JSON`,
  );
}

/** @internal */
export const CollectorRestStateTracking3$inboundSchema: z.ZodType<
  CollectorRestStateTracking3,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type CollectorRestStateTracking3$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const CollectorRestStateTracking3$outboundSchema: z.ZodType<
  CollectorRestStateTracking3$Outbound,
  z.ZodTypeDef,
  CollectorRestStateTracking3
> = z.object({
  enabled: z.boolean().optional(),
});

export function collectorRestStateTracking3ToJSON(
  collectorRestStateTracking3: CollectorRestStateTracking3,
): string {
  return JSON.stringify(
    CollectorRestStateTracking3$outboundSchema.parse(
      collectorRestStateTracking3,
    ),
  );
}
export function collectorRestStateTracking3FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestStateTracking3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestStateTracking3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestStateTracking3' from JSON`,
  );
}

/** @internal */
export const CollectorRestScheduling3$inboundSchema: z.ZodType<
  CollectorRestScheduling3,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking3$inboundSchema)
    .optional(),
});
/** @internal */
export type CollectorRestScheduling3$Outbound = {
  stateTracking?: CollectorRestStateTracking3$Outbound | undefined;
};

/** @internal */
export const CollectorRestScheduling3$outboundSchema: z.ZodType<
  CollectorRestScheduling3$Outbound,
  z.ZodTypeDef,
  CollectorRestScheduling3
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking3$outboundSchema)
    .optional(),
});

export function collectorRestScheduling3ToJSON(
  collectorRestScheduling3: CollectorRestScheduling3,
): string {
  return JSON.stringify(
    CollectorRestScheduling3$outboundSchema.parse(collectorRestScheduling3),
  );
}
export function collectorRestScheduling3FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestScheduling3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestScheduling3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestScheduling3' from JSON`,
  );
}

/** @internal */
export const CollectorRestRest3$inboundSchema: z.ZodType<
  CollectorRestRest3,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: CollectMethod3$inboundSchema.default("get"),
  collectBody: z.string(),
  type: CollectorRestType3$inboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery3$inboundSchema).optional(),
  collectUrl: z.string(),
  collectVerb: z.string().optional(),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination3$inboundSchema).optional(),
  authentication: CollectorRestAuthentication3$inboundSchema.default("none"),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules3$inboundSchema).optional(),
  __scheduling: z.lazy(() => CollectorRestScheduling3$inboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginUrl: z.string().default(""),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  tokenRespAttribute: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  serviceAccountCredentials: z.string().optional(),
  subject: z.string().optional(),
  hmacFunctionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "__scheduling": "scheduling",
  });
});
/** @internal */
export type CollectorRestRest3$Outbound = {
  collectMethod: string;
  collectBody: string;
  type: string;
  discovery?: CollectorRestDiscovery3$Outbound | undefined;
  collectUrl: string;
  collectVerb?: string | undefined;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  pagination?: Pagination3$Outbound | undefined;
  authentication: string;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  decodeUrl: boolean;
  rejectUnauthorized: boolean;
  captureHeaders: boolean;
  stopOnEmptyResults: boolean;
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules3$Outbound | undefined;
  __scheduling?: CollectorRestScheduling3$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  loginUrl: string;
  loginBody: string;
  getAuthTokenFromHeader: boolean;
  authHeaderKey: string;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  tokenRespAttribute?: string | undefined;
  clientSecretParamName: string;
  clientSecretParamValue?: string | undefined;
  authRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  textSecret?: string | undefined;
  scopes?: Array<string> | undefined;
  serviceAccountCredentials?: string | undefined;
  subject?: string | undefined;
  hmacFunctionId?: string | undefined;
};

/** @internal */
export const CollectorRestRest3$outboundSchema: z.ZodType<
  CollectorRestRest3$Outbound,
  z.ZodTypeDef,
  CollectorRestRest3
> = z.object({
  collectMethod: CollectMethod3$outboundSchema.default("get"),
  collectBody: z.string(),
  type: CollectorRestType3$outboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery3$outboundSchema).optional(),
  collectUrl: z.string(),
  collectVerb: z.string().optional(),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination3$outboundSchema).optional(),
  authentication: CollectorRestAuthentication3$outboundSchema.default("none"),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules3$outboundSchema).optional(),
  scheduling: z.lazy(() => CollectorRestScheduling3$outboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginUrl: z.string().default(""),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  tokenRespAttribute: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  serviceAccountCredentials: z.string().optional(),
  subject: z.string().optional(),
  hmacFunctionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    scheduling: "__scheduling",
  });
});

export function collectorRestRest3ToJSON(
  collectorRestRest3: CollectorRestRest3,
): string {
  return JSON.stringify(
    CollectorRestRest3$outboundSchema.parse(collectorRestRest3),
  );
}
export function collectorRestRest3FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRest3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRest3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRest3' from JSON`,
  );
}

/** @internal */
export const CollectMethod2$inboundSchema: z.ZodType<
  CollectMethod2,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectMethod2);
/** @internal */
export const CollectMethod2$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectMethod2
> = openEnums.outboundSchema(CollectMethod2);

/** @internal */
export const CollectorRestType2$inboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType2
> = z.nativeEnum(CollectorRestType2);
/** @internal */
export const CollectorRestType2$outboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType2
> = CollectorRestType2$inboundSchema;

/** @internal */
export const CollectorRestDiscoverType2$inboundSchema: z.ZodType<
  CollectorRestDiscoverType2,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestDiscoverType2);
/** @internal */
export const CollectorRestDiscoverType2$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestDiscoverType2
> = openEnums.outboundSchema(CollectorRestDiscoverType2);

/** @internal */
export const CollectorRestDiscovery2$inboundSchema: z.ZodType<
  CollectorRestDiscovery2,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: CollectorRestDiscoverType2$inboundSchema.default("none"),
});
/** @internal */
export type CollectorRestDiscovery2$Outbound = {
  discoverType: string;
};

/** @internal */
export const CollectorRestDiscovery2$outboundSchema: z.ZodType<
  CollectorRestDiscovery2$Outbound,
  z.ZodTypeDef,
  CollectorRestDiscovery2
> = z.object({
  discoverType: CollectorRestDiscoverType2$outboundSchema.default("none"),
});

export function collectorRestDiscovery2ToJSON(
  collectorRestDiscovery2: CollectorRestDiscovery2,
): string {
  return JSON.stringify(
    CollectorRestDiscovery2$outboundSchema.parse(collectorRestDiscovery2),
  );
}
export function collectorRestDiscovery2FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestDiscovery2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestDiscovery2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestDiscovery2' from JSON`,
  );
}

/** @internal */
export const PaginationEnum2$inboundSchema: z.ZodType<
  PaginationEnum2,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(PaginationEnum2);
/** @internal */
export const PaginationEnum2$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  PaginationEnum2
> = openEnums.outboundSchema(PaginationEnum2);

/** @internal */
export const Pagination2$inboundSchema: z.ZodType<
  Pagination2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: PaginationEnum2$inboundSchema.default("none"),
});
/** @internal */
export type Pagination2$Outbound = {
  type: string;
};

/** @internal */
export const Pagination2$outboundSchema: z.ZodType<
  Pagination2$Outbound,
  z.ZodTypeDef,
  Pagination2
> = z.object({
  type: PaginationEnum2$outboundSchema.default("none"),
});

export function pagination2ToJSON(pagination2: Pagination2): string {
  return JSON.stringify(Pagination2$outboundSchema.parse(pagination2));
}
export function pagination2FromJSON(
  jsonString: string,
): SafeParseResult<Pagination2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Pagination2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Pagination2' from JSON`,
  );
}

/** @internal */
export const CollectorRestAuthentication2$inboundSchema: z.ZodType<
  CollectorRestAuthentication2,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestAuthentication2);
/** @internal */
export const CollectorRestAuthentication2$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestAuthentication2
> = openEnums.outboundSchema(CollectorRestAuthentication2);

/** @internal */
export const CollectorRestRetryRules2$inboundSchema: z.ZodType<
  CollectorRestRetryRules2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type CollectorRestRetryRules2$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const CollectorRestRetryRules2$outboundSchema: z.ZodType<
  CollectorRestRetryRules2$Outbound,
  z.ZodTypeDef,
  CollectorRestRetryRules2
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function collectorRestRetryRules2ToJSON(
  collectorRestRetryRules2: CollectorRestRetryRules2,
): string {
  return JSON.stringify(
    CollectorRestRetryRules2$outboundSchema.parse(collectorRestRetryRules2),
  );
}
export function collectorRestRetryRules2FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRetryRules2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRetryRules2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRetryRules2' from JSON`,
  );
}

/** @internal */
export const CollectorRestStateTracking2$inboundSchema: z.ZodType<
  CollectorRestStateTracking2,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type CollectorRestStateTracking2$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const CollectorRestStateTracking2$outboundSchema: z.ZodType<
  CollectorRestStateTracking2$Outbound,
  z.ZodTypeDef,
  CollectorRestStateTracking2
> = z.object({
  enabled: z.boolean().optional(),
});

export function collectorRestStateTracking2ToJSON(
  collectorRestStateTracking2: CollectorRestStateTracking2,
): string {
  return JSON.stringify(
    CollectorRestStateTracking2$outboundSchema.parse(
      collectorRestStateTracking2,
    ),
  );
}
export function collectorRestStateTracking2FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestStateTracking2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestStateTracking2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestStateTracking2' from JSON`,
  );
}

/** @internal */
export const CollectorRestScheduling2$inboundSchema: z.ZodType<
  CollectorRestScheduling2,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking2$inboundSchema)
    .optional(),
});
/** @internal */
export type CollectorRestScheduling2$Outbound = {
  stateTracking?: CollectorRestStateTracking2$Outbound | undefined;
};

/** @internal */
export const CollectorRestScheduling2$outboundSchema: z.ZodType<
  CollectorRestScheduling2$Outbound,
  z.ZodTypeDef,
  CollectorRestScheduling2
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking2$outboundSchema)
    .optional(),
});

export function collectorRestScheduling2ToJSON(
  collectorRestScheduling2: CollectorRestScheduling2,
): string {
  return JSON.stringify(
    CollectorRestScheduling2$outboundSchema.parse(collectorRestScheduling2),
  );
}
export function collectorRestScheduling2FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestScheduling2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestScheduling2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestScheduling2' from JSON`,
  );
}

/** @internal */
export const CollectorRestRest2$inboundSchema: z.ZodType<
  CollectorRestRest2,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: CollectMethod2$inboundSchema.default("get"),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  type: CollectorRestType2$inboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery2$inboundSchema).optional(),
  collectUrl: z.string(),
  collectVerb: z.string().optional(),
  collectBody: z.string().optional(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination2$inboundSchema).optional(),
  authentication: CollectorRestAuthentication2$inboundSchema.default("none"),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules2$inboundSchema).optional(),
  __scheduling: z.lazy(() => CollectorRestScheduling2$inboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginUrl: z.string().default(""),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  tokenRespAttribute: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  serviceAccountCredentials: z.string().optional(),
  subject: z.string().optional(),
  hmacFunctionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "__scheduling": "scheduling",
  });
});
/** @internal */
export type CollectorRestRest2$Outbound = {
  collectMethod: string;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  type: string;
  discovery?: CollectorRestDiscovery2$Outbound | undefined;
  collectUrl: string;
  collectVerb?: string | undefined;
  collectBody?: string | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  pagination?: Pagination2$Outbound | undefined;
  authentication: string;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  decodeUrl: boolean;
  rejectUnauthorized: boolean;
  captureHeaders: boolean;
  stopOnEmptyResults: boolean;
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules2$Outbound | undefined;
  __scheduling?: CollectorRestScheduling2$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  loginUrl: string;
  loginBody: string;
  getAuthTokenFromHeader: boolean;
  authHeaderKey: string;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  tokenRespAttribute?: string | undefined;
  clientSecretParamName: string;
  clientSecretParamValue?: string | undefined;
  authRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  textSecret?: string | undefined;
  scopes?: Array<string> | undefined;
  serviceAccountCredentials?: string | undefined;
  subject?: string | undefined;
  hmacFunctionId?: string | undefined;
};

/** @internal */
export const CollectorRestRest2$outboundSchema: z.ZodType<
  CollectorRestRest2$Outbound,
  z.ZodTypeDef,
  CollectorRestRest2
> = z.object({
  collectMethod: CollectMethod2$outboundSchema.default("get"),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  type: CollectorRestType2$outboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery2$outboundSchema).optional(),
  collectUrl: z.string(),
  collectVerb: z.string().optional(),
  collectBody: z.string().optional(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination2$outboundSchema).optional(),
  authentication: CollectorRestAuthentication2$outboundSchema.default("none"),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules2$outboundSchema).optional(),
  scheduling: z.lazy(() => CollectorRestScheduling2$outboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginUrl: z.string().default(""),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  tokenRespAttribute: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  serviceAccountCredentials: z.string().optional(),
  subject: z.string().optional(),
  hmacFunctionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    scheduling: "__scheduling",
  });
});

export function collectorRestRest2ToJSON(
  collectorRestRest2: CollectorRestRest2,
): string {
  return JSON.stringify(
    CollectorRestRest2$outboundSchema.parse(collectorRestRest2),
  );
}
export function collectorRestRest2FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRest2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRest2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRest2' from JSON`,
  );
}

/** @internal */
export const CollectMethod1$inboundSchema: z.ZodType<
  CollectMethod1,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectMethod1);
/** @internal */
export const CollectMethod1$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectMethod1
> = openEnums.outboundSchema(CollectMethod1);

/** @internal */
export const CollectorRestType1$inboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType1
> = z.nativeEnum(CollectorRestType1);
/** @internal */
export const CollectorRestType1$outboundSchema: z.ZodNativeEnum<
  typeof CollectorRestType1
> = CollectorRestType1$inboundSchema;

/** @internal */
export const CollectorRestDiscoverType1$inboundSchema: z.ZodType<
  CollectorRestDiscoverType1,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestDiscoverType1);
/** @internal */
export const CollectorRestDiscoverType1$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestDiscoverType1
> = openEnums.outboundSchema(CollectorRestDiscoverType1);

/** @internal */
export const CollectorRestDiscovery1$inboundSchema: z.ZodType<
  CollectorRestDiscovery1,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: CollectorRestDiscoverType1$inboundSchema.default("none"),
});
/** @internal */
export type CollectorRestDiscovery1$Outbound = {
  discoverType: string;
};

/** @internal */
export const CollectorRestDiscovery1$outboundSchema: z.ZodType<
  CollectorRestDiscovery1$Outbound,
  z.ZodTypeDef,
  CollectorRestDiscovery1
> = z.object({
  discoverType: CollectorRestDiscoverType1$outboundSchema.default("none"),
});

export function collectorRestDiscovery1ToJSON(
  collectorRestDiscovery1: CollectorRestDiscovery1,
): string {
  return JSON.stringify(
    CollectorRestDiscovery1$outboundSchema.parse(collectorRestDiscovery1),
  );
}
export function collectorRestDiscovery1FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestDiscovery1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestDiscovery1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestDiscovery1' from JSON`,
  );
}

/** @internal */
export const PaginationEnum1$inboundSchema: z.ZodType<
  PaginationEnum1,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(PaginationEnum1);
/** @internal */
export const PaginationEnum1$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  PaginationEnum1
> = openEnums.outboundSchema(PaginationEnum1);

/** @internal */
export const Pagination1$inboundSchema: z.ZodType<
  Pagination1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: PaginationEnum1$inboundSchema.default("none"),
});
/** @internal */
export type Pagination1$Outbound = {
  type: string;
};

/** @internal */
export const Pagination1$outboundSchema: z.ZodType<
  Pagination1$Outbound,
  z.ZodTypeDef,
  Pagination1
> = z.object({
  type: PaginationEnum1$outboundSchema.default("none"),
});

export function pagination1ToJSON(pagination1: Pagination1): string {
  return JSON.stringify(Pagination1$outboundSchema.parse(pagination1));
}
export function pagination1FromJSON(
  jsonString: string,
): SafeParseResult<Pagination1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Pagination1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Pagination1' from JSON`,
  );
}

/** @internal */
export const CollectorRestAuthentication1$inboundSchema: z.ZodType<
  CollectorRestAuthentication1,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestAuthentication1);
/** @internal */
export const CollectorRestAuthentication1$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestAuthentication1
> = openEnums.outboundSchema(CollectorRestAuthentication1);

/** @internal */
export const CollectorRestRetryRules1$inboundSchema: z.ZodType<
  CollectorRestRetryRules1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type CollectorRestRetryRules1$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const CollectorRestRetryRules1$outboundSchema: z.ZodType<
  CollectorRestRetryRules1$Outbound,
  z.ZodTypeDef,
  CollectorRestRetryRules1
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function collectorRestRetryRules1ToJSON(
  collectorRestRetryRules1: CollectorRestRetryRules1,
): string {
  return JSON.stringify(
    CollectorRestRetryRules1$outboundSchema.parse(collectorRestRetryRules1),
  );
}
export function collectorRestRetryRules1FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRetryRules1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRetryRules1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRetryRules1' from JSON`,
  );
}

/** @internal */
export const CollectorRestStateTracking1$inboundSchema: z.ZodType<
  CollectorRestStateTracking1,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type CollectorRestStateTracking1$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const CollectorRestStateTracking1$outboundSchema: z.ZodType<
  CollectorRestStateTracking1$Outbound,
  z.ZodTypeDef,
  CollectorRestStateTracking1
> = z.object({
  enabled: z.boolean().optional(),
});

export function collectorRestStateTracking1ToJSON(
  collectorRestStateTracking1: CollectorRestStateTracking1,
): string {
  return JSON.stringify(
    CollectorRestStateTracking1$outboundSchema.parse(
      collectorRestStateTracking1,
    ),
  );
}
export function collectorRestStateTracking1FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestStateTracking1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestStateTracking1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestStateTracking1' from JSON`,
  );
}

/** @internal */
export const CollectorRestScheduling1$inboundSchema: z.ZodType<
  CollectorRestScheduling1,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking1$inboundSchema)
    .optional(),
});
/** @internal */
export type CollectorRestScheduling1$Outbound = {
  stateTracking?: CollectorRestStateTracking1$Outbound | undefined;
};

/** @internal */
export const CollectorRestScheduling1$outboundSchema: z.ZodType<
  CollectorRestScheduling1$Outbound,
  z.ZodTypeDef,
  CollectorRestScheduling1
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking1$outboundSchema)
    .optional(),
});

export function collectorRestScheduling1ToJSON(
  collectorRestScheduling1: CollectorRestScheduling1,
): string {
  return JSON.stringify(
    CollectorRestScheduling1$outboundSchema.parse(collectorRestScheduling1),
  );
}
export function collectorRestScheduling1FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestScheduling1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestScheduling1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestScheduling1' from JSON`,
  );
}

/** @internal */
export const CollectorRestRest1$inboundSchema: z.ZodType<
  CollectorRestRest1,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: CollectMethod1$inboundSchema.default("get"),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  type: CollectorRestType1$inboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery1$inboundSchema).optional(),
  collectUrl: z.string(),
  collectVerb: z.string().optional(),
  collectBody: z.string().optional(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination1$inboundSchema).optional(),
  authentication: CollectorRestAuthentication1$inboundSchema.default("none"),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules1$inboundSchema).optional(),
  __scheduling: z.lazy(() => CollectorRestScheduling1$inboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginUrl: z.string().default(""),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  tokenRespAttribute: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$inboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  serviceAccountCredentials: z.string().optional(),
  subject: z.string().optional(),
  hmacFunctionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "__scheduling": "scheduling",
  });
});
/** @internal */
export type CollectorRestRest1$Outbound = {
  collectMethod: string;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  type: string;
  discovery?: CollectorRestDiscovery1$Outbound | undefined;
  collectUrl: string;
  collectVerb?: string | undefined;
  collectBody?: string | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  pagination?: Pagination1$Outbound | undefined;
  authentication: string;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  decodeUrl: boolean;
  rejectUnauthorized: boolean;
  captureHeaders: boolean;
  stopOnEmptyResults: boolean;
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules1$Outbound | undefined;
  __scheduling?: CollectorRestScheduling1$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  loginUrl: string;
  loginBody: string;
  getAuthTokenFromHeader: boolean;
  authHeaderKey: string;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  tokenRespAttribute?: string | undefined;
  clientSecretParamName: string;
  clientSecretParamValue?: string | undefined;
  authRequestParams?:
    | Array<ItemsTypeCollectRequestParams1$Outbound>
    | undefined;
  textSecret?: string | undefined;
  scopes?: Array<string> | undefined;
  serviceAccountCredentials?: string | undefined;
  subject?: string | undefined;
  hmacFunctionId?: string | undefined;
};

/** @internal */
export const CollectorRestRest1$outboundSchema: z.ZodType<
  CollectorRestRest1$Outbound,
  z.ZodTypeDef,
  CollectorRestRest1
> = z.object({
  collectMethod: CollectMethod1$outboundSchema.default("get"),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  type: CollectorRestType1$outboundSchema,
  discovery: z.lazy(() => CollectorRestDiscovery1$outboundSchema).optional(),
  collectUrl: z.string(),
  collectVerb: z.string().optional(),
  collectBody: z.string().optional(),
  collectRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  pagination: z.lazy(() => Pagination1$outboundSchema).optional(),
  authentication: CollectorRestAuthentication1$outboundSchema.default("none"),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules1$outboundSchema).optional(),
  scheduling: z.lazy(() => CollectorRestScheduling1$outboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginUrl: z.string().default(""),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  getAuthTokenFromHeader: z.boolean().default(false),
  authHeaderKey: z.string().default("Authorization"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  tokenRespAttribute: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeCollectRequestParams1$outboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  serviceAccountCredentials: z.string().optional(),
  subject: z.string().optional(),
  hmacFunctionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    scheduling: "__scheduling",
  });
});

export function collectorRestRest1ToJSON(
  collectorRestRest1: CollectorRestRest1,
): string {
  return JSON.stringify(
    CollectorRestRest1$outboundSchema.parse(collectorRestRest1),
  );
}
export function collectorRestRest1FromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRest1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRest1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRest1' from JSON`,
  );
}

/** @internal */
export const CollectorRest$inboundSchema: z.ZodType<
  CollectorRest,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CollectorRestRest10$inboundSchema),
  z.lazy(() => CollectorRestRest11$inboundSchema),
  z.lazy(() => CollectorRestRest5$inboundSchema),
  z.lazy(() => CollectorRestRest6$inboundSchema),
  z.lazy(() => CollectorRestRest3$inboundSchema),
  z.lazy(() => CollectorRestRest4$inboundSchema),
  z.lazy(() => CollectorRestCollectorHealthCheckPart2Type$inboundSchema),
  z.lazy(() => CollectorRestRest7$inboundSchema),
  z.lazy(() => CollectorRestRest8$inboundSchema),
  z.lazy(() => CollectorRestRest9$inboundSchema),
  z.lazy(() => CollectorRestRest12$inboundSchema),
  z.lazy(() => CollectorRestRest1$inboundSchema),
  z.lazy(() => CollectorRestRest2$inboundSchema),
  z.lazy(() => CollectorRestCollectorHealthCheckPart0Type$inboundSchema),
]);
/** @internal */
export type CollectorRest$Outbound =
  | CollectorRestRest10$Outbound
  | CollectorRestRest11$Outbound
  | CollectorRestRest5$Outbound
  | CollectorRestRest6$Outbound
  | CollectorRestRest3$Outbound
  | CollectorRestRest4$Outbound
  | CollectorRestCollectorHealthCheckPart2Type$Outbound
  | CollectorRestRest7$Outbound
  | CollectorRestRest8$Outbound
  | CollectorRestRest9$Outbound
  | CollectorRestRest12$Outbound
  | CollectorRestRest1$Outbound
  | CollectorRestRest2$Outbound
  | CollectorRestCollectorHealthCheckPart0Type$Outbound;

/** @internal */
export const CollectorRest$outboundSchema: z.ZodType<
  CollectorRest$Outbound,
  z.ZodTypeDef,
  CollectorRest
> = z.union([
  z.lazy(() => CollectorRestRest10$outboundSchema),
  z.lazy(() => CollectorRestRest11$outboundSchema),
  z.lazy(() => CollectorRestRest5$outboundSchema),
  z.lazy(() => CollectorRestRest6$outboundSchema),
  z.lazy(() => CollectorRestRest3$outboundSchema),
  z.lazy(() => CollectorRestRest4$outboundSchema),
  z.lazy(() => CollectorRestCollectorHealthCheckPart2Type$outboundSchema),
  z.lazy(() => CollectorRestRest7$outboundSchema),
  z.lazy(() => CollectorRestRest8$outboundSchema),
  z.lazy(() => CollectorRestRest9$outboundSchema),
  z.lazy(() => CollectorRestRest12$outboundSchema),
  z.lazy(() => CollectorRestRest1$outboundSchema),
  z.lazy(() => CollectorRestRest2$outboundSchema),
  z.lazy(() => CollectorRestCollectorHealthCheckPart0Type$outboundSchema),
]);

export function collectorRestToJSON(collectorRest: CollectorRest): string {
  return JSON.stringify(CollectorRest$outboundSchema.parse(collectorRest));
}
export function collectorRestFromJSON(
  jsonString: string,
): SafeParseResult<CollectorRest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRest' from JSON`,
  );
}
