/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const CollectorRestDiscoverType = {
  Http: "http",
  Json: "json",
  List: "list",
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type CollectorRestDiscoverType = OpenEnum<
  typeof CollectorRestDiscoverType
>;

export type CollectorRestDiscovery = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType?: CollectorRestDiscoverType | undefined;
};

export const CollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type CollectMethod = OpenEnum<typeof CollectMethod>;

export type CollectorRestCollectRequestHeader = {
  name: string;
  /**
   * JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants.
   */
  value: string;
};

export const PaginationEnum = {
  /**
   * None
   */
  None: "none",
  /**
   * Response Body Attribute
   */
  ResponseBody: "response_body",
  /**
   * Response Header Attribute
   */
  ResponseHeader: "response_header",
  /**
   * RFC 5988 - Web Linking
   */
  ResponseHeaderLink: "response_header_link",
  /**
   * Offset/Limit
   */
  RequestOffset: "request_offset",
  /**
   * Page/Size
   */
  RequestPage: "request_page",
} as const;
export type PaginationEnum = OpenEnum<typeof PaginationEnum>;

export type Pagination = {
  type?: PaginationEnum | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const CollectorRestAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type CollectorRestAuthentication = OpenEnum<
  typeof CollectorRestAuthentication
>;

/**
 * Algorithm to use when performing HTTP retries
 */
export const CollectorRestRetryType = {
  /**
   * Disabled
   */
  None: "none",
  /**
   * Backoff
   */
  Backoff: "backoff",
  /**
   * Static
   */
  Static: "static",
} as const;
/**
 * Algorithm to use when performing HTTP retries
 */
export type CollectorRestRetryType = OpenEnum<typeof CollectorRestRetryType>;

export type CollectorRestRetryRules = {
  /**
   * Algorithm to use when performing HTTP retries
   */
  type?: CollectorRestRetryType | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type CollectorRestStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type CollectorRestScheduling = {
  stateTracking?: CollectorRestStateTracking | undefined;
};

export type CollectorRest = {
  /**
   * Collector type: rest
   */
  type: "rest";
  discovery?: CollectorRestDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod?: CollectMethod | undefined;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?: Array<CollectorRestCollectRequestHeader> | undefined;
  pagination?: Pagination | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: CollectorRestAuthentication | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules | undefined;
  scheduling?: CollectorRestScheduling | undefined;
};

/** @internal */
export const CollectorRestDiscoverType$inboundSchema: z.ZodType<
  CollectorRestDiscoverType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestDiscoverType);
/** @internal */
export const CollectorRestDiscoverType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestDiscoverType
> = openEnums.outboundSchema(CollectorRestDiscoverType);

/** @internal */
export const CollectorRestDiscovery$inboundSchema: z.ZodType<
  CollectorRestDiscovery,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: CollectorRestDiscoverType$inboundSchema.default("none"),
});
/** @internal */
export type CollectorRestDiscovery$Outbound = {
  discoverType: string;
};

/** @internal */
export const CollectorRestDiscovery$outboundSchema: z.ZodType<
  CollectorRestDiscovery$Outbound,
  z.ZodTypeDef,
  CollectorRestDiscovery
> = z.object({
  discoverType: CollectorRestDiscoverType$outboundSchema.default("none"),
});

export function collectorRestDiscoveryToJSON(
  collectorRestDiscovery: CollectorRestDiscovery,
): string {
  return JSON.stringify(
    CollectorRestDiscovery$outboundSchema.parse(collectorRestDiscovery),
  );
}
export function collectorRestDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestDiscovery' from JSON`,
  );
}

/** @internal */
export const CollectMethod$inboundSchema: z.ZodType<
  CollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectMethod);
/** @internal */
export const CollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectMethod
> = openEnums.outboundSchema(CollectMethod);

/** @internal */
export const CollectorRestCollectRequestHeader$inboundSchema: z.ZodType<
  CollectorRestCollectRequestHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type CollectorRestCollectRequestHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CollectorRestCollectRequestHeader$outboundSchema: z.ZodType<
  CollectorRestCollectRequestHeader$Outbound,
  z.ZodTypeDef,
  CollectorRestCollectRequestHeader
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function collectorRestCollectRequestHeaderToJSON(
  collectorRestCollectRequestHeader: CollectorRestCollectRequestHeader,
): string {
  return JSON.stringify(
    CollectorRestCollectRequestHeader$outboundSchema.parse(
      collectorRestCollectRequestHeader,
    ),
  );
}
export function collectorRestCollectRequestHeaderFromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestCollectRequestHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestCollectRequestHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestCollectRequestHeader' from JSON`,
  );
}

/** @internal */
export const PaginationEnum$inboundSchema: z.ZodType<
  PaginationEnum,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(PaginationEnum);
/** @internal */
export const PaginationEnum$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  PaginationEnum
> = openEnums.outboundSchema(PaginationEnum);

/** @internal */
export const Pagination$inboundSchema: z.ZodType<
  Pagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: PaginationEnum$inboundSchema.default("none"),
});
/** @internal */
export type Pagination$Outbound = {
  type: string;
};

/** @internal */
export const Pagination$outboundSchema: z.ZodType<
  Pagination$Outbound,
  z.ZodTypeDef,
  Pagination
> = z.object({
  type: PaginationEnum$outboundSchema.default("none"),
});

export function paginationToJSON(pagination: Pagination): string {
  return JSON.stringify(Pagination$outboundSchema.parse(pagination));
}
export function paginationFromJSON(
  jsonString: string,
): SafeParseResult<Pagination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Pagination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Pagination' from JSON`,
  );
}

/** @internal */
export const CollectorRestAuthentication$inboundSchema: z.ZodType<
  CollectorRestAuthentication,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestAuthentication);
/** @internal */
export const CollectorRestAuthentication$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestAuthentication
> = openEnums.outboundSchema(CollectorRestAuthentication);

/** @internal */
export const CollectorRestRetryType$inboundSchema: z.ZodType<
  CollectorRestRetryType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorRestRetryType);
/** @internal */
export const CollectorRestRetryType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorRestRetryType
> = openEnums.outboundSchema(CollectorRestRetryType);

/** @internal */
export const CollectorRestRetryRules$inboundSchema: z.ZodType<
  CollectorRestRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CollectorRestRetryType$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type CollectorRestRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const CollectorRestRetryRules$outboundSchema: z.ZodType<
  CollectorRestRetryRules$Outbound,
  z.ZodTypeDef,
  CollectorRestRetryRules
> = z.object({
  type: CollectorRestRetryType$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  maxIntervalMs: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function collectorRestRetryRulesToJSON(
  collectorRestRetryRules: CollectorRestRetryRules,
): string {
  return JSON.stringify(
    CollectorRestRetryRules$outboundSchema.parse(collectorRestRetryRules),
  );
}
export function collectorRestRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestRetryRules' from JSON`,
  );
}

/** @internal */
export const CollectorRestStateTracking$inboundSchema: z.ZodType<
  CollectorRestStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type CollectorRestStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const CollectorRestStateTracking$outboundSchema: z.ZodType<
  CollectorRestStateTracking$Outbound,
  z.ZodTypeDef,
  CollectorRestStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function collectorRestStateTrackingToJSON(
  collectorRestStateTracking: CollectorRestStateTracking,
): string {
  return JSON.stringify(
    CollectorRestStateTracking$outboundSchema.parse(collectorRestStateTracking),
  );
}
export function collectorRestStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestStateTracking' from JSON`,
  );
}

/** @internal */
export const CollectorRestScheduling$inboundSchema: z.ZodType<
  CollectorRestScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking$inboundSchema)
    .optional(),
});
/** @internal */
export type CollectorRestScheduling$Outbound = {
  stateTracking?: CollectorRestStateTracking$Outbound | undefined;
};

/** @internal */
export const CollectorRestScheduling$outboundSchema: z.ZodType<
  CollectorRestScheduling$Outbound,
  z.ZodTypeDef,
  CollectorRestScheduling
> = z.object({
  stateTracking: z.lazy(() => CollectorRestStateTracking$outboundSchema)
    .optional(),
});

export function collectorRestSchedulingToJSON(
  collectorRestScheduling: CollectorRestScheduling,
): string {
  return JSON.stringify(
    CollectorRestScheduling$outboundSchema.parse(collectorRestScheduling),
  );
}
export function collectorRestSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<CollectorRestScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRestScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRestScheduling' from JSON`,
  );
}

/** @internal */
export const CollectorRest$inboundSchema: z.ZodType<
  CollectorRest,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("rest"),
  discovery: z.lazy(() => CollectorRestDiscovery$inboundSchema).optional(),
  collectUrl: z.string(),
  collectMethod: CollectMethod$inboundSchema.default("get"),
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorRestCollectRequestHeader$inboundSchema),
  ).optional(),
  pagination: z.lazy(() => Pagination$inboundSchema).optional(),
  authentication: CollectorRestAuthentication$inboundSchema.default("none"),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules$inboundSchema).optional(),
  __scheduling: z.lazy(() => CollectorRestScheduling$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "__scheduling": "scheduling",
  });
});
/** @internal */
export type CollectorRest$Outbound = {
  type: "rest";
  discovery?: CollectorRestDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<CollectorRestCollectRequestHeader$Outbound>
    | undefined;
  pagination?: Pagination$Outbound | undefined;
  authentication: string;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  decodeUrl: boolean;
  rejectUnauthorized: boolean;
  captureHeaders: boolean;
  stopOnEmptyResults: boolean;
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorRestRetryRules$Outbound | undefined;
  __scheduling?: CollectorRestScheduling$Outbound | undefined;
};

/** @internal */
export const CollectorRest$outboundSchema: z.ZodType<
  CollectorRest$Outbound,
  z.ZodTypeDef,
  CollectorRest
> = z.object({
  type: z.literal("rest"),
  discovery: z.lazy(() => CollectorRestDiscovery$outboundSchema).optional(),
  collectUrl: z.string(),
  collectMethod: CollectMethod$outboundSchema.default("get"),
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorRestCollectRequestHeader$outboundSchema),
  ).optional(),
  pagination: z.lazy(() => Pagination$outboundSchema).optional(),
  authentication: CollectorRestAuthentication$outboundSchema.default("none"),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(false),
  decodeUrl: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  stopOnEmptyResults: z.boolean().default(false),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorRestRetryRules$outboundSchema).optional(),
  scheduling: z.lazy(() => CollectorRestScheduling$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    scheduling: "__scheduling",
  });
});

export function collectorRestToJSON(collectorRest: CollectorRest): string {
  return JSON.stringify(CollectorRest$outboundSchema.parse(collectorRest));
}
export function collectorRestFromJSON(
  jsonString: string,
): SafeParseResult<CollectorRest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorRest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorRest' from JSON`,
  );
}
