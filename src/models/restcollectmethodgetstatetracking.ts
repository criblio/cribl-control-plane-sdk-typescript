/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as discriminatedUnionTypes from "../types/discriminatedUnion.js";
import { discriminatedUnion } from "../types/discriminatedUnion.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeRestCollectMethodGetCollectRequestParams,
  ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound,
  ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
} from "./itemstyperestcollectmethodgetcollectrequestparams.js";
import {
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeJson,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$inboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$Outbound,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$outboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeList,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeList$inboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeList$Outbound,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeList$outboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeNone,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$inboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$Outbound,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$outboundSchema,
} from "./restauthenticationnonerestdiscoverydiscovertypehttpdiscovermethodpost.js";

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationNoneDiscovery =
  | (
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeJson
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeList
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationNoneCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationNoneCollectMethod = OpenEnum<
  typeof RestAuthenticationNoneCollectMethod
>;

export type RestAuthenticationNoneRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationNoneRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationNoneRestPaginationTypeResponseHeaderLink = {
  type: "response_header_link";
  /**
   * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
   */
  nextRelationAttribute: string;
  /**
   * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
   */
  curRelationAttribute?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationNoneRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationNoneRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestAuthenticationNoneRestPaginationTypeNone = {
  type: "none";
};

export type RestAuthenticationNonePaginationUnion =
  | RestAuthenticationNoneRestPaginationTypeNone
  | RestAuthenticationNoneRestPaginationTypeResponseBody
  | RestAuthenticationNoneRestPaginationTypeResponseHeader
  | RestAuthenticationNoneRestPaginationTypeResponseHeaderLink
  | RestAuthenticationNoneRestPaginationTypeRequestOffset
  | RestAuthenticationNoneRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationNoneRestRetryRulesTypeBackoff = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationNoneRestRetryRulesTypeStatic = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestAuthenticationNoneRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationNoneRetryRules =
  | RestAuthenticationNoneRestRetryRulesTypeNone
  | RestAuthenticationNoneRestRetryRulesTypeStatic
  | RestAuthenticationNoneRestRetryRulesTypeBackoff
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationNoneStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationNoneScheduling = {
  stateTracking?: RestAuthenticationNoneStateTracking | undefined;
};

export type RestAuthenticationNone = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "none";
  discovery?:
    | (
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeJson
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeList
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationNoneCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationNoneRestPaginationTypeNone
    | RestAuthenticationNoneRestPaginationTypeResponseBody
    | RestAuthenticationNoneRestPaginationTypeResponseHeader
    | RestAuthenticationNoneRestPaginationTypeResponseHeaderLink
    | RestAuthenticationNoneRestPaginationTypeRequestOffset
    | RestAuthenticationNoneRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationNoneRestRetryRulesTypeNone
    | RestAuthenticationNoneRestRetryRulesTypeStatic
    | RestAuthenticationNoneRestRetryRulesTypeBackoff
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestAuthenticationNoneScheduling | undefined;
};

export const RestCollectMethodOtherCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestCollectMethodOtherCollectMethod = OpenEnum<
  typeof RestCollectMethodOtherCollectMethod
>;

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp =
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestCollectMethodOtherDiscovery =
  | (
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeJson
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeList
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export type RestCollectMethodOtherRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodOtherRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodOtherRestPaginationTypeResponseHeaderLink = {
  type: "response_header_link";
  /**
   * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
   */
  nextRelationAttribute: string;
  /**
   * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
   */
  curRelationAttribute?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestCollectMethodOtherRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestCollectMethodOtherRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestCollectMethodOtherRestPaginationTypeNone = {
  type: "none";
};

export type RestCollectMethodOtherPaginationUnion =
  | RestCollectMethodOtherRestPaginationTypeNone
  | RestCollectMethodOtherRestPaginationTypeResponseBody
  | RestCollectMethodOtherRestPaginationTypeResponseHeader
  | RestCollectMethodOtherRestPaginationTypeResponseHeaderLink
  | RestCollectMethodOtherRestPaginationTypeRequestOffset
  | RestCollectMethodOtherRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const RestCollectMethodOtherAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type RestCollectMethodOtherAuthentication = OpenEnum<
  typeof RestCollectMethodOtherAuthentication
>;

export type RestCollectMethodOtherRestRetryRulesTypeBackoff = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodOtherRestRetryRulesTypeStatic = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestCollectMethodOtherRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodOtherRetryRules =
  | RestCollectMethodOtherRestRetryRulesTypeNone
  | RestCollectMethodOtherRestRetryRulesTypeStatic
  | RestCollectMethodOtherRestRetryRulesTypeBackoff
  | discriminatedUnionTypes.Unknown<"type">;

export type RestCollectMethodOtherStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestCollectMethodOtherScheduling = {
  stateTracking?: RestCollectMethodOtherStateTracking | undefined;
};

export type RestCollectMethodOther = {
  collectMethod: RestCollectMethodOtherCollectMethod;
  collectVerb?: any | undefined;
  collectBody?: any | undefined;
  collectRequestParams?: any | undefined;
  discovery?:
    | (
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeJson
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeList
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestCollectMethodOtherRestPaginationTypeNone
    | RestCollectMethodOtherRestPaginationTypeResponseBody
    | RestCollectMethodOtherRestPaginationTypeResponseHeader
    | RestCollectMethodOtherRestPaginationTypeResponseHeaderLink
    | RestCollectMethodOtherRestPaginationTypeRequestOffset
    | RestCollectMethodOtherRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: RestCollectMethodOtherAuthentication;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestCollectMethodOtherRestRetryRulesTypeNone
    | RestCollectMethodOtherRestRetryRulesTypeStatic
    | RestCollectMethodOtherRestRetryRulesTypeBackoff
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestCollectMethodOtherScheduling | undefined;
};

export const RestCollectMethodPostWithBodyCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestCollectMethodPostWithBodyCollectMethod = OpenEnum<
  typeof RestCollectMethodPostWithBodyCollectMethod
>;

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp =
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestCollectMethodPostWithBodyDiscovery =
  | (
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export type RestCollectMethodPostWithBodyRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink =
  {
    type: "response_header_link";
    /**
     * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
     */
    nextRelationAttribute: string;
    /**
     * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
     */
    curRelationAttribute?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestCollectMethodPostWithBodyRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestCollectMethodPostWithBodyRestPaginationTypeNone = {
  type: "none";
};

export type RestCollectMethodPostWithBodyPaginationUnion =
  | RestCollectMethodPostWithBodyRestPaginationTypeNone
  | RestCollectMethodPostWithBodyRestPaginationTypeResponseBody
  | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader
  | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink
  | RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset
  | RestCollectMethodPostWithBodyRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const RestCollectMethodPostWithBodyAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type RestCollectMethodPostWithBodyAuthentication = OpenEnum<
  typeof RestCollectMethodPostWithBodyAuthentication
>;

export type RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodPostWithBodyRestRetryRulesTypeStatic = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestCollectMethodPostWithBodyRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodPostWithBodyRetryRules =
  | RestCollectMethodPostWithBodyRestRetryRulesTypeNone
  | RestCollectMethodPostWithBodyRestRetryRulesTypeStatic
  | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff
  | discriminatedUnionTypes.Unknown<"type">;

export type RestCollectMethodPostWithBodyStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestCollectMethodPostWithBodyScheduling = {
  stateTracking?: RestCollectMethodPostWithBodyStateTracking | undefined;
};

export type RestCollectMethodPostWithBody = {
  collectMethod: RestCollectMethodPostWithBodyCollectMethod;
  collectBody?: any | undefined;
  discovery?:
    | (
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestCollectMethodPostWithBodyRestPaginationTypeNone
    | RestCollectMethodPostWithBodyRestPaginationTypeResponseBody
    | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader
    | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink
    | RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset
    | RestCollectMethodPostWithBodyRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: RestCollectMethodPostWithBodyAuthentication;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestCollectMethodPostWithBodyRestRetryRulesTypeNone
    | RestCollectMethodPostWithBodyRestRetryRulesTypeStatic
    | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestCollectMethodPostWithBodyScheduling | undefined;
};

export const RestCollectMethodPostCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestCollectMethodPostCollectMethod = OpenEnum<
  typeof RestCollectMethodPostCollectMethod
>;

export type RestCollectMethodPostRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestCollectMethodPostRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestCollectMethodPostRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttp =
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestCollectMethodPostDiscovery =
  | (
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestCollectMethodPostRestDiscoveryDiscoverTypeJson
  | RestCollectMethodPostRestDiscoveryDiscoverTypeList
  | RestCollectMethodPostRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export type RestCollectMethodPostRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodPostRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodPostRestPaginationTypeResponseHeaderLink = {
  type: "response_header_link";
  /**
   * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
   */
  nextRelationAttribute: string;
  /**
   * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
   */
  curRelationAttribute?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestCollectMethodPostRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestCollectMethodPostRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestCollectMethodPostRestPaginationTypeNone = {
  type: "none";
};

export type RestCollectMethodPostPaginationUnion =
  | RestCollectMethodPostRestPaginationTypeNone
  | RestCollectMethodPostRestPaginationTypeResponseBody
  | RestCollectMethodPostRestPaginationTypeResponseHeader
  | RestCollectMethodPostRestPaginationTypeResponseHeaderLink
  | RestCollectMethodPostRestPaginationTypeRequestOffset
  | RestCollectMethodPostRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const RestCollectMethodPostAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type RestCollectMethodPostAuthentication = OpenEnum<
  typeof RestCollectMethodPostAuthentication
>;

export type RestCollectMethodPostRestRetryRulesTypeBackoff = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodPostRestRetryRulesTypeStatic = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestCollectMethodPostRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodPostRetryRules =
  | RestCollectMethodPostRestRetryRulesTypeNone
  | RestCollectMethodPostRestRetryRulesTypeStatic
  | RestCollectMethodPostRestRetryRulesTypeBackoff
  | discriminatedUnionTypes.Unknown<"type">;

export type RestCollectMethodPostStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestCollectMethodPostScheduling = {
  stateTracking?: RestCollectMethodPostStateTracking | undefined;
};

export type RestCollectMethodPost = {
  collectMethod: RestCollectMethodPostCollectMethod;
  collectRequestParams?: any | undefined;
  discovery?:
    | (
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestCollectMethodPostRestDiscoveryDiscoverTypeJson
    | RestCollectMethodPostRestDiscoveryDiscoverTypeList
    | RestCollectMethodPostRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectVerb?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestCollectMethodPostRestPaginationTypeNone
    | RestCollectMethodPostRestPaginationTypeResponseBody
    | RestCollectMethodPostRestPaginationTypeResponseHeader
    | RestCollectMethodPostRestPaginationTypeResponseHeaderLink
    | RestCollectMethodPostRestPaginationTypeRequestOffset
    | RestCollectMethodPostRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: RestCollectMethodPostAuthentication;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestCollectMethodPostRestRetryRulesTypeNone
    | RestCollectMethodPostRestRetryRulesTypeStatic
    | RestCollectMethodPostRestRetryRulesTypeBackoff
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestCollectMethodPostScheduling | undefined;
};

export const RestCollectMethodGetCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestCollectMethodGetCollectMethod = OpenEnum<
  typeof RestCollectMethodGetCollectMethod
>;

export type RestCollectMethodGetRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestCollectMethodGetRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestCollectMethodGetRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttp =
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestCollectMethodGetDiscovery =
  | (
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestCollectMethodGetRestDiscoveryDiscoverTypeJson
  | RestCollectMethodGetRestDiscoveryDiscoverTypeList
  | RestCollectMethodGetRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export type RestCollectMethodGetRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodGetRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestCollectMethodGetRestPaginationTypeResponseHeaderLink = {
  type: "response_header_link";
  /**
   * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
   */
  nextRelationAttribute: string;
  /**
   * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
   */
  curRelationAttribute?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestCollectMethodGetRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestCollectMethodGetRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestCollectMethodGetRestPaginationTypeNone = {
  type: "none";
};

export type RestCollectMethodGetPaginationUnion =
  | RestCollectMethodGetRestPaginationTypeNone
  | RestCollectMethodGetRestPaginationTypeResponseBody
  | RestCollectMethodGetRestPaginationTypeResponseHeader
  | RestCollectMethodGetRestPaginationTypeResponseHeaderLink
  | RestCollectMethodGetRestPaginationTypeRequestOffset
  | RestCollectMethodGetRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const RestCollectMethodGetAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type RestCollectMethodGetAuthentication = OpenEnum<
  typeof RestCollectMethodGetAuthentication
>;

export type RestCollectMethodGetRestRetryRulesTypeBackoff = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodGetRestRetryRulesTypeStatic = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestCollectMethodGetRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestCollectMethodGetRetryRules =
  | RestCollectMethodGetRestRetryRulesTypeNone
  | RestCollectMethodGetRestRetryRulesTypeStatic
  | RestCollectMethodGetRestRetryRulesTypeBackoff
  | discriminatedUnionTypes.Unknown<"type">;

export type RestCollectMethodGetStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema,
    post_with_body:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema,
    other:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema,
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema,
  ]);

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp$outboundSchema.parse(
      restAuthenticationNoneRestDiscoveryDiscoverTypeHttp,
    ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationNoneDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema,
    post_with_body:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema,
    other:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema,
  }).and(z.object({ discoverType: z.literal("http") })),
  json: RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$inboundSchema,
  list: RestAuthenticationNoneRestDiscoveryDiscoverTypeList$inboundSchema,
  none: RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$inboundSchema,
});
/** @internal */
export type RestAuthenticationNoneDiscovery$Outbound =
  | (
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationNoneDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationNoneDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNoneDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema,
  ]).and(z.object({ discoverType: z.literal("http") })),
  RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$outboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeList$outboundSchema,
  RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$outboundSchema,
]);

export function restAuthenticationNoneDiscoveryToJSON(
  restAuthenticationNoneDiscovery: RestAuthenticationNoneDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationNoneDiscovery$outboundSchema.parse(
      restAuthenticationNoneDiscovery,
    ),
  );
}
export function restAuthenticationNoneDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNoneDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationNoneDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneCollectMethod$inboundSchema: z.ZodType<
  RestAuthenticationNoneCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationNoneCollectMethod);
/** @internal */
export const RestAuthenticationNoneCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationNoneCollectMethod
> = openEnums.outboundSchema(RestAuthenticationNoneCollectMethod);

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationNoneRestPaginationTypeRequestPage$Outbound = {
  type: "request_page";
  pageField: string;
  page?: number | undefined;
  sizeField: string;
  size: number;
  totalPageField?: string | undefined;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationNoneRestPaginationTypeRequestPageToJSON(
  restAuthenticationNoneRestPaginationTypeRequestPage:
    RestAuthenticationNoneRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestPaginationTypeRequestPage$outboundSchema.parse(
      restAuthenticationNoneRestPaginationTypeRequestPage,
    ),
  );
}
export function restAuthenticationNoneRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestPaginationTypeRequestPage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationNoneRestPaginationTypeRequestOffset$Outbound = {
  type: "request_offset";
  offsetField: string;
  offset?: number | undefined;
  limitField: string;
  limit: number;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationNoneRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationNoneRestPaginationTypeRequestOffset:
    RestAuthenticationNoneRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestPaginationTypeRequestOffset$outboundSchema.parse(
      restAuthenticationNoneRestPaginationTypeRequestOffset,
    ),
  );
}
export function restAuthenticationNoneRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestPaginationTypeRequestOffset$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationNoneRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationNoneRestPaginationTypeResponseHeaderLink:
    RestAuthenticationNoneRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restAuthenticationNoneRestPaginationTypeResponseHeaderLink),
  );
}
export function restAuthenticationNoneRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationNoneRestPaginationTypeResponseHeader$Outbound = {
  type: "response_header";
  attribute: Array<string>;
  maxPages: number;
};

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationNoneRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationNoneRestPaginationTypeResponseHeader:
    RestAuthenticationNoneRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestPaginationTypeResponseHeader$outboundSchema.parse(
      restAuthenticationNoneRestPaginationTypeResponseHeader,
    ),
  );
}
export function restAuthenticationNoneRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationNoneRestPaginationTypeResponseBody$Outbound = {
  type: "response_body";
  attribute: Array<string>;
  maxPages: number;
  lastPageExpr?: string | undefined;
};

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationNoneRestPaginationTypeResponseBodyToJSON(
  restAuthenticationNoneRestPaginationTypeResponseBody:
    RestAuthenticationNoneRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestPaginationTypeResponseBody$outboundSchema.parse(
      restAuthenticationNoneRestPaginationTypeResponseBody,
    ),
  );
}
export function restAuthenticationNoneRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestPaginationTypeResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationNoneRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestAuthenticationNoneRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationNoneRestPaginationTypeNoneToJSON(
  restAuthenticationNoneRestPaginationTypeNone:
    RestAuthenticationNoneRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestPaginationTypeNone$outboundSchema.parse(
      restAuthenticationNoneRestPaginationTypeNone,
    ),
  );
}
export function restAuthenticationNoneRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNonePaginationUnion$inboundSchema: z.ZodType<
  RestAuthenticationNonePaginationUnion,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeNone$inboundSchema
  ),
  response_body: z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeResponseBody$inboundSchema
  ),
  response_header: z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeResponseHeader$inboundSchema
  ),
  response_header_link: z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$inboundSchema
  ),
  request_offset: z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeRequestOffset$inboundSchema
  ),
  request_page: z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeRequestPage$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationNonePaginationUnion$Outbound =
  | RestAuthenticationNoneRestPaginationTypeNone$Outbound
  | RestAuthenticationNoneRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationNoneRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationNoneRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationNoneRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationNonePaginationUnion$outboundSchema: z.ZodType<
  RestAuthenticationNonePaginationUnion$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNonePaginationUnion
> = z.union([
  z.lazy(() => RestAuthenticationNoneRestPaginationTypeNone$outboundSchema),
  z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeResponseBody$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeResponseHeader$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeRequestOffset$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationNoneRestPaginationTypeRequestPage$outboundSchema
  ),
]);

export function restAuthenticationNonePaginationUnionToJSON(
  restAuthenticationNonePaginationUnion: RestAuthenticationNonePaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationNonePaginationUnion$outboundSchema.parse(
      restAuthenticationNonePaginationUnion,
    ),
  );
}
export function restAuthenticationNonePaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNonePaginationUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNonePaginationUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNonePaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("backoff"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationNoneRestRetryRulesTypeBackoff$Outbound = {
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestRetryRulesTypeBackoff
  > = z.object({
    type: z.literal("backoff"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationNoneRestRetryRulesTypeBackoffToJSON(
  restAuthenticationNoneRestRetryRulesTypeBackoff:
    RestAuthenticationNoneRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestRetryRulesTypeBackoff$outboundSchema.parse(
      restAuthenticationNoneRestRetryRulesTypeBackoff,
    ),
  );
}
export function restAuthenticationNoneRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestRetryRulesTypeBackoff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("static"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationNoneRestRetryRulesTypeStatic$Outbound = {
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestRetryRulesTypeStatic
  > = z.object({
    type: z.literal("static"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationNoneRestRetryRulesTypeStaticToJSON(
  restAuthenticationNoneRestRetryRulesTypeStatic:
    RestAuthenticationNoneRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestRetryRulesTypeStatic$outboundSchema.parse(
      restAuthenticationNoneRestRetryRulesTypeStatic,
    ),
  );
}
export function restAuthenticationNoneRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationNoneRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationNoneRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationNoneRestRetryRulesTypeNoneToJSON(
  restAuthenticationNoneRestRetryRulesTypeNone:
    RestAuthenticationNoneRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestRetryRulesTypeNone$outboundSchema.parse(
      restAuthenticationNoneRestRetryRulesTypeNone,
    ),
  );
}
export function restAuthenticationNoneRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationNoneRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationNoneRestRetryRulesTypeNone$inboundSchema
  ),
  static: z.lazy(() =>
    RestAuthenticationNoneRestRetryRulesTypeStatic$inboundSchema
  ),
  backoff: z.lazy(() =>
    RestAuthenticationNoneRestRetryRulesTypeBackoff$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationNoneRetryRules$Outbound =
  | RestAuthenticationNoneRestRetryRulesTypeNone$Outbound
  | RestAuthenticationNoneRestRetryRulesTypeStatic$Outbound
  | RestAuthenticationNoneRestRetryRulesTypeBackoff$Outbound;

/** @internal */
export const RestAuthenticationNoneRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationNoneRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNoneRetryRules
> = z.union([
  z.lazy(() => RestAuthenticationNoneRestRetryRulesTypeNone$outboundSchema),
  z.lazy(() => RestAuthenticationNoneRestRetryRulesTypeStatic$outboundSchema),
  z.lazy(() => RestAuthenticationNoneRestRetryRulesTypeBackoff$outboundSchema),
]);

export function restAuthenticationNoneRetryRulesToJSON(
  restAuthenticationNoneRetryRules: RestAuthenticationNoneRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRetryRules$outboundSchema.parse(
      restAuthenticationNoneRetryRules,
    ),
  );
}
export function restAuthenticationNoneRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNoneRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationNoneRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneStateTracking$inboundSchema: z.ZodType<
  RestAuthenticationNoneStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: types.optional(types.boolean()),
});
/** @internal */
export type RestAuthenticationNoneStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationNoneStateTracking$outboundSchema: z.ZodType<
  RestAuthenticationNoneStateTracking$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNoneStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restAuthenticationNoneStateTrackingToJSON(
  restAuthenticationNoneStateTracking: RestAuthenticationNoneStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationNoneStateTracking$outboundSchema.parse(
      restAuthenticationNoneStateTracking,
    ),
  );
}
export function restAuthenticationNoneStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNoneStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneScheduling$inboundSchema: z.ZodType<
  RestAuthenticationNoneScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestAuthenticationNoneStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationNoneScheduling$Outbound = {
  stateTracking?: RestAuthenticationNoneStateTracking$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationNoneScheduling$outboundSchema: z.ZodType<
  RestAuthenticationNoneScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNoneScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationNoneStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationNoneSchedulingToJSON(
  restAuthenticationNoneScheduling: RestAuthenticationNoneScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationNoneScheduling$outboundSchema.parse(
      restAuthenticationNoneScheduling,
    ),
  );
}
export function restAuthenticationNoneSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNoneScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationNoneScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNone$inboundSchema: z.ZodType<
  RestAuthenticationNone,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("none"),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post:
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema,
      post_with_body:
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema,
      other:
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema,
    }).and(z.object({ discoverType: z.literal("http") })),
    json: RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$inboundSchema,
    list: RestAuthenticationNoneRestDiscoveryDiscoverTypeList$inboundSchema,
    none: RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$inboundSchema,
  })),
  collectUrl: types.string(),
  collectMethod: RestAuthenticationNoneCollectMethod$inboundSchema,
  collectVerb: types.optional(z.any()),
  collectRequestParams: types.optional(z.any()),
  collectBody: types.optional(z.any()),
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeNone$inboundSchema
    ),
    static: z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeStatic$inboundSchema
    ),
    backoff: z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeBackoff$inboundSchema
    ),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestAuthenticationNoneScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationNone$Outbound = {
  authentication: "none";
  discovery?:
    | (
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationNoneRestPaginationTypeNone$Outbound
    | RestAuthenticationNoneRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationNoneRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationNoneRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationNoneRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationNoneRestRetryRulesTypeNone$Outbound
    | RestAuthenticationNoneRestRetryRulesTypeStatic$Outbound
    | RestAuthenticationNoneRestRetryRulesTypeBackoff$Outbound
    | undefined;
  __scheduling?: RestAuthenticationNoneScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationNone$outboundSchema: z.ZodType<
  RestAuthenticationNone$Outbound,
  z.ZodTypeDef,
  RestAuthenticationNone
> = z.object({
  authentication: z.literal("none"),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema,
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema,
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema,
    ]).and(z.object({ discoverType: z.literal("http") })),
    RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$outboundSchema,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeList$outboundSchema,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$outboundSchema,
  ]).optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationNoneCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() => RestAuthenticationNoneRestPaginationTypeNone$outboundSchema),
    z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationNoneRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() => RestAuthenticationNoneRestRetryRulesTypeNone$outboundSchema),
    z.lazy(() => RestAuthenticationNoneRestRetryRulesTypeStatic$outboundSchema),
    z.lazy(() =>
      RestAuthenticationNoneRestRetryRulesTypeBackoff$outboundSchema
    ),
  ]).optional(),
  __scheduling: z.lazy(() => RestAuthenticationNoneScheduling$outboundSchema)
    .optional(),
});

export function restAuthenticationNoneToJSON(
  restAuthenticationNone: RestAuthenticationNone,
): string {
  return JSON.stringify(
    RestAuthenticationNone$outboundSchema.parse(restAuthenticationNone),
  );
}
export function restAuthenticationNoneFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationNone, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationNone$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherCollectMethod$inboundSchema: z.ZodType<
  RestCollectMethodOtherCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodOtherCollectMethod);
/** @internal */
export const RestCollectMethodOtherCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodOtherCollectMethod
> = openEnums.outboundSchema(RestCollectMethodOtherCollectMethod);

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$Outbound = {
  discoverType: "none";
};

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeNoneToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeNone:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$outboundSchema.parse(
      restCollectMethodOtherRestDiscoveryDiscoverTypeNone,
    ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeList$Outbound = {
  discoverType: "list";
  itemList: Array<string>;
};

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeListToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeList:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeList$outboundSchema.parse(
      restCollectMethodOtherRestDiscoveryDiscoverTypeList,
    ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeList$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$Outbound = {
  discoverType: "json";
  manualDiscoverResult: string;
  discoverDataField?: string | undefined;
};

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeJsonToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeJson:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$outboundSchema.parse(
      restCollectMethodOtherRestDiscoveryDiscoverTypeJson,
    ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpToJSON(
  restCollectMethodOtherRestDiscoveryDiscoverTypeHttp:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp$outboundSchema.parse(
      restCollectMethodOtherRestDiscoveryDiscoverTypeHttp,
    ),
  );
}
export function restCollectMethodOtherRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherDiscovery$inboundSchema: z.ZodType<
  RestCollectMethodOtherDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestCollectMethodOtherRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodOtherDiscovery$Outbound =
  | (
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$Outbound
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeList$Outbound
  | RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestCollectMethodOtherDiscovery$outboundSchema: z.ZodType<
  RestCollectMethodOtherDiscovery$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodOtherRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restCollectMethodOtherDiscoveryToJSON(
  restCollectMethodOtherDiscovery: RestCollectMethodOtherDiscovery,
): string {
  return JSON.stringify(
    RestCollectMethodOtherDiscovery$outboundSchema.parse(
      restCollectMethodOtherDiscovery,
    ),
  );
}
export function restCollectMethodOtherDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodOtherDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherDiscovery' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodOtherRestPaginationTypeRequestPage$Outbound = {
  type: "request_page";
  pageField: string;
  page?: number | undefined;
  sizeField: string;
  size: number;
  totalPageField?: string | undefined;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodOtherRestPaginationTypeRequestPageToJSON(
  restCollectMethodOtherRestPaginationTypeRequestPage:
    RestCollectMethodOtherRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestPaginationTypeRequestPage$outboundSchema.parse(
      restCollectMethodOtherRestPaginationTypeRequestPage,
    ),
  );
}
export function restCollectMethodOtherRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestPaginationTypeRequestPage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodOtherRestPaginationTypeRequestOffset$Outbound = {
  type: "request_offset";
  offsetField: string;
  offset?: number | undefined;
  limitField: string;
  limit: number;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodOtherRestPaginationTypeRequestOffsetToJSON(
  restCollectMethodOtherRestPaginationTypeRequestOffset:
    RestCollectMethodOtherRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestPaginationTypeRequestOffset$outboundSchema.parse(
      restCollectMethodOtherRestPaginationTypeRequestOffset,
    ),
  );
}
export function restCollectMethodOtherRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestPaginationTypeRequestOffset$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restCollectMethodOtherRestPaginationTypeResponseHeaderLinkToJSON(
  restCollectMethodOtherRestPaginationTypeResponseHeaderLink:
    RestCollectMethodOtherRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restCollectMethodOtherRestPaginationTypeResponseHeaderLink),
  );
}
export function restCollectMethodOtherRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodOtherRestPaginationTypeResponseHeader$Outbound = {
  type: "response_header";
  attribute: Array<string>;
  maxPages: number;
};

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restCollectMethodOtherRestPaginationTypeResponseHeaderToJSON(
  restCollectMethodOtherRestPaginationTypeResponseHeader:
    RestCollectMethodOtherRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestPaginationTypeResponseHeader$outboundSchema.parse(
      restCollectMethodOtherRestPaginationTypeResponseHeader,
    ),
  );
}
export function restCollectMethodOtherRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodOtherRestPaginationTypeResponseBody$Outbound = {
  type: "response_body";
  attribute: Array<string>;
  maxPages: number;
  lastPageExpr?: string | undefined;
};

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restCollectMethodOtherRestPaginationTypeResponseBodyToJSON(
  restCollectMethodOtherRestPaginationTypeResponseBody:
    RestCollectMethodOtherRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestPaginationTypeResponseBody$outboundSchema.parse(
      restCollectMethodOtherRestPaginationTypeResponseBody,
    ),
  );
}
export function restCollectMethodOtherRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestPaginationTypeResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodOtherRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestCollectMethodOtherRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restCollectMethodOtherRestPaginationTypeNoneToJSON(
  restCollectMethodOtherRestPaginationTypeNone:
    RestCollectMethodOtherRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestPaginationTypeNone$outboundSchema.parse(
      restCollectMethodOtherRestPaginationTypeNone,
    ),
  );
}
export function restCollectMethodOtherRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherPaginationUnion$inboundSchema: z.ZodType<
  RestCollectMethodOtherPaginationUnion,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeNone$inboundSchema
  ),
  response_body: z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeResponseBody$inboundSchema
  ),
  response_header: z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeResponseHeader$inboundSchema
  ),
  response_header_link: z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$inboundSchema
  ),
  request_offset: z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeRequestOffset$inboundSchema
  ),
  request_page: z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeRequestPage$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodOtherPaginationUnion$Outbound =
  | RestCollectMethodOtherRestPaginationTypeNone$Outbound
  | RestCollectMethodOtherRestPaginationTypeResponseBody$Outbound
  | RestCollectMethodOtherRestPaginationTypeResponseHeader$Outbound
  | RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$Outbound
  | RestCollectMethodOtherRestPaginationTypeRequestOffset$Outbound
  | RestCollectMethodOtherRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestCollectMethodOtherPaginationUnion$outboundSchema: z.ZodType<
  RestCollectMethodOtherPaginationUnion$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherPaginationUnion
> = z.union([
  z.lazy(() => RestCollectMethodOtherRestPaginationTypeNone$outboundSchema),
  z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeResponseBody$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeResponseHeader$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeRequestOffset$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodOtherRestPaginationTypeRequestPage$outboundSchema
  ),
]);

export function restCollectMethodOtherPaginationUnionToJSON(
  restCollectMethodOtherPaginationUnion: RestCollectMethodOtherPaginationUnion,
): string {
  return JSON.stringify(
    RestCollectMethodOtherPaginationUnion$outboundSchema.parse(
      restCollectMethodOtherPaginationUnion,
    ),
  );
}
export function restCollectMethodOtherPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherPaginationUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherPaginationUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherAuthentication$inboundSchema: z.ZodType<
  RestCollectMethodOtherAuthentication,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodOtherAuthentication);
/** @internal */
export const RestCollectMethodOtherAuthentication$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodOtherAuthentication
> = openEnums.outboundSchema(RestCollectMethodOtherAuthentication);

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("backoff"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodOtherRestRetryRulesTypeBackoff$Outbound = {
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestRetryRulesTypeBackoff
  > = z.object({
    type: z.literal("backoff"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restCollectMethodOtherRestRetryRulesTypeBackoffToJSON(
  restCollectMethodOtherRestRetryRulesTypeBackoff:
    RestCollectMethodOtherRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestRetryRulesTypeBackoff$outboundSchema.parse(
      restCollectMethodOtherRestRetryRulesTypeBackoff,
    ),
  );
}
export function restCollectMethodOtherRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestRetryRulesTypeBackoff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("static"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodOtherRestRetryRulesTypeStatic$Outbound = {
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestRetryRulesTypeStatic
  > = z.object({
    type: z.literal("static"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restCollectMethodOtherRestRetryRulesTypeStaticToJSON(
  restCollectMethodOtherRestRetryRulesTypeStatic:
    RestCollectMethodOtherRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestRetryRulesTypeStatic$outboundSchema.parse(
      restCollectMethodOtherRestRetryRulesTypeStatic,
    ),
  );
}
export function restCollectMethodOtherRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodOtherRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestCollectMethodOtherRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodOtherRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodOtherRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restCollectMethodOtherRestRetryRulesTypeNoneToJSON(
  restCollectMethodOtherRestRetryRulesTypeNone:
    RestCollectMethodOtherRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRestRetryRulesTypeNone$outboundSchema.parse(
      restCollectMethodOtherRestRetryRulesTypeNone,
    ),
  );
}
export function restCollectMethodOtherRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodOtherRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodOtherRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherRetryRules$inboundSchema: z.ZodType<
  RestCollectMethodOtherRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestCollectMethodOtherRestRetryRulesTypeNone$inboundSchema
  ),
  static: z.lazy(() =>
    RestCollectMethodOtherRestRetryRulesTypeStatic$inboundSchema
  ),
  backoff: z.lazy(() =>
    RestCollectMethodOtherRestRetryRulesTypeBackoff$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodOtherRetryRules$Outbound =
  | RestCollectMethodOtherRestRetryRulesTypeNone$Outbound
  | RestCollectMethodOtherRestRetryRulesTypeStatic$Outbound
  | RestCollectMethodOtherRestRetryRulesTypeBackoff$Outbound;

/** @internal */
export const RestCollectMethodOtherRetryRules$outboundSchema: z.ZodType<
  RestCollectMethodOtherRetryRules$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherRetryRules
> = z.union([
  z.lazy(() => RestCollectMethodOtherRestRetryRulesTypeNone$outboundSchema),
  z.lazy(() => RestCollectMethodOtherRestRetryRulesTypeStatic$outboundSchema),
  z.lazy(() => RestCollectMethodOtherRestRetryRulesTypeBackoff$outboundSchema),
]);

export function restCollectMethodOtherRetryRulesToJSON(
  restCollectMethodOtherRetryRules: RestCollectMethodOtherRetryRules,
): string {
  return JSON.stringify(
    RestCollectMethodOtherRetryRules$outboundSchema.parse(
      restCollectMethodOtherRetryRules,
    ),
  );
}
export function restCollectMethodOtherRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodOtherRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherRetryRules' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherStateTracking$inboundSchema: z.ZodType<
  RestCollectMethodOtherStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: types.optional(types.boolean()),
});
/** @internal */
export type RestCollectMethodOtherStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestCollectMethodOtherStateTracking$outboundSchema: z.ZodType<
  RestCollectMethodOtherStateTracking$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restCollectMethodOtherStateTrackingToJSON(
  restCollectMethodOtherStateTracking: RestCollectMethodOtherStateTracking,
): string {
  return JSON.stringify(
    RestCollectMethodOtherStateTracking$outboundSchema.parse(
      restCollectMethodOtherStateTracking,
    ),
  );
}
export function restCollectMethodOtherStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodOtherStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherStateTracking' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOtherScheduling$inboundSchema: z.ZodType<
  RestCollectMethodOtherScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestCollectMethodOtherStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestCollectMethodOtherScheduling$Outbound = {
  stateTracking?: RestCollectMethodOtherStateTracking$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodOtherScheduling$outboundSchema: z.ZodType<
  RestCollectMethodOtherScheduling$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOtherScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestCollectMethodOtherStateTracking$outboundSchema
  ).optional(),
});

export function restCollectMethodOtherSchedulingToJSON(
  restCollectMethodOtherScheduling: RestCollectMethodOtherScheduling,
): string {
  return JSON.stringify(
    RestCollectMethodOtherScheduling$outboundSchema.parse(
      restCollectMethodOtherScheduling,
    ),
  );
}
export function restCollectMethodOtherSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOtherScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodOtherScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOtherScheduling' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodOther$inboundSchema: z.ZodType<
  RestCollectMethodOther,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: RestCollectMethodOtherCollectMethod$inboundSchema,
  collectVerb: types.optional(z.any()),
  collectBody: types.optional(z.any()),
  collectRequestParams: types.optional(z.any()),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  authentication: RestCollectMethodOtherAuthentication$inboundSchema,
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeNone$inboundSchema
    ),
    static: z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeStatic$inboundSchema
    ),
    backoff: z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeBackoff$inboundSchema
    ),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestCollectMethodOtherScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestCollectMethodOther$Outbound = {
  collectMethod: string;
  collectVerb?: any | undefined;
  collectBody?: any | undefined;
  collectRequestParams?: any | undefined;
  discovery?:
    | (
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$Outbound
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeList$Outbound
    | RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestCollectMethodOtherRestPaginationTypeNone$Outbound
    | RestCollectMethodOtherRestPaginationTypeResponseBody$Outbound
    | RestCollectMethodOtherRestPaginationTypeResponseHeader$Outbound
    | RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$Outbound
    | RestCollectMethodOtherRestPaginationTypeRequestOffset$Outbound
    | RestCollectMethodOtherRestPaginationTypeRequestPage$Outbound
    | undefined;
  authentication: string;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestCollectMethodOtherRestRetryRulesTypeNone$Outbound
    | RestCollectMethodOtherRestRetryRulesTypeStatic$Outbound
    | RestCollectMethodOtherRestRetryRulesTypeBackoff$Outbound
    | undefined;
  __scheduling?: RestCollectMethodOtherScheduling$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodOther$outboundSchema: z.ZodType<
  RestCollectMethodOther$Outbound,
  z.ZodTypeDef,
  RestCollectMethodOther
> = z.object({
  collectMethod: RestCollectMethodOtherCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestParams: z.any().optional(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() => RestCollectMethodOtherRestPaginationTypeNone$outboundSchema),
    z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodOtherRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  authentication: RestCollectMethodOtherAuthentication$outboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() => RestCollectMethodOtherRestRetryRulesTypeNone$outboundSchema),
    z.lazy(() => RestCollectMethodOtherRestRetryRulesTypeStatic$outboundSchema),
    z.lazy(() =>
      RestCollectMethodOtherRestRetryRulesTypeBackoff$outboundSchema
    ),
  ]).optional(),
  __scheduling: z.lazy(() => RestCollectMethodOtherScheduling$outboundSchema)
    .optional(),
});

export function restCollectMethodOtherToJSON(
  restCollectMethodOther: RestCollectMethodOther,
): string {
  return JSON.stringify(
    RestCollectMethodOther$outboundSchema.parse(restCollectMethodOther),
  );
}
export function restCollectMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodOther, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodOther$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodOther' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyCollectMethod$inboundSchema:
  z.ZodType<RestCollectMethodPostWithBodyCollectMethod, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(RestCollectMethodPostWithBodyCollectMethod);
/** @internal */
export const RestCollectMethodPostWithBodyCollectMethod$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestCollectMethodPostWithBodyCollectMethod> =
    openEnums.outboundSchema(RestCollectMethodPostWithBodyCollectMethod);

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$Outbound =
  {
    discoverType: "none";
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNoneToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$outboundSchema
      .parse(restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$Outbound =
  {
    discoverType: "list";
    itemList: Array<string>;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeListToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$outboundSchema
      .parse(restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$Outbound =
  {
    discoverType: "json";
    manualDiscoverResult: string;
    discoverDataField?: string | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJsonToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$outboundSchema
      .parse(restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpToJSON(
  restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp$outboundSchema
      .parse(restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp),
  );
}
export function restCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyDiscovery$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodPostWithBodyDiscovery$Outbound =
  | (
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$Outbound
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$Outbound
  | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestCollectMethodPostWithBodyDiscovery$outboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyDiscovery$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostWithBodyDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restCollectMethodPostWithBodyDiscoveryToJSON(
  restCollectMethodPostWithBodyDiscovery:
    RestCollectMethodPostWithBodyDiscovery,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyDiscovery$outboundSchema.parse(
      restCollectMethodPostWithBodyDiscovery,
    ),
  );
}
export function restCollectMethodPostWithBodyDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostWithBodyDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyDiscovery' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$Outbound =
  {
    type: "request_page";
    pageField: string;
    page?: number | undefined;
    sizeField: string;
    size: number;
    totalPageField?: string | undefined;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodPostWithBodyRestPaginationTypeRequestPageToJSON(
  restCollectMethodPostWithBodyRestPaginationTypeRequestPage:
    RestCollectMethodPostWithBodyRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$outboundSchema
      .parse(restCollectMethodPostWithBodyRestPaginationTypeRequestPage),
  );
}
export function restCollectMethodPostWithBodyRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$Outbound =
  {
    type: "request_offset";
    offsetField: string;
    offset?: number | undefined;
    limitField: string;
    limit: number;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodPostWithBodyRestPaginationTypeRequestOffsetToJSON(
  restCollectMethodPostWithBodyRestPaginationTypeRequestOffset:
    RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$outboundSchema
      .parse(restCollectMethodPostWithBodyRestPaginationTypeRequestOffset),
  );
}
export function restCollectMethodPostWithBodyRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLinkToJSON(
  restCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink:
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink),
  );
}
export function restCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$Outbound =
  {
    type: "response_header";
    attribute: Array<string>;
    maxPages: number;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restCollectMethodPostWithBodyRestPaginationTypeResponseHeaderToJSON(
  restCollectMethodPostWithBodyRestPaginationTypeResponseHeader:
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$outboundSchema
      .parse(restCollectMethodPostWithBodyRestPaginationTypeResponseHeader),
  );
}
export function restCollectMethodPostWithBodyRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$Outbound =
  {
    type: "response_body";
    attribute: Array<string>;
    maxPages: number;
    lastPageExpr?: string | undefined;
  };

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restCollectMethodPostWithBodyRestPaginationTypeResponseBodyToJSON(
  restCollectMethodPostWithBodyRestPaginationTypeResponseBody:
    RestCollectMethodPostWithBodyRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$outboundSchema
      .parse(restCollectMethodPostWithBodyRestPaginationTypeResponseBody),
  );
}
export function restCollectMethodPostWithBodyRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestCollectMethodPostWithBodyRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restCollectMethodPostWithBodyRestPaginationTypeNoneToJSON(
  restCollectMethodPostWithBodyRestPaginationTypeNone:
    RestCollectMethodPostWithBodyRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestPaginationTypeNone$outboundSchema.parse(
      restCollectMethodPostWithBodyRestPaginationTypeNone,
    ),
  );
}
export function restCollectMethodPostWithBodyRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyPaginationUnion$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyPaginationUnion,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$inboundSchema
    ),
  });
/** @internal */
export type RestCollectMethodPostWithBodyPaginationUnion$Outbound =
  | RestCollectMethodPostWithBodyRestPaginationTypeNone$Outbound
  | RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$Outbound
  | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$Outbound
  | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$Outbound
  | RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$Outbound
  | RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestCollectMethodPostWithBodyPaginationUnion$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyPaginationUnion$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyPaginationUnion
  > = z.union([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$outboundSchema
    ),
  ]);

export function restCollectMethodPostWithBodyPaginationUnionToJSON(
  restCollectMethodPostWithBodyPaginationUnion:
    RestCollectMethodPostWithBodyPaginationUnion,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyPaginationUnion$outboundSchema.parse(
      restCollectMethodPostWithBodyPaginationUnion,
    ),
  );
}
export function restCollectMethodPostWithBodyPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyPaginationUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyPaginationUnion$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyAuthentication$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyAuthentication,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RestCollectMethodPostWithBodyAuthentication);
/** @internal */
export const RestCollectMethodPostWithBodyAuthentication$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestCollectMethodPostWithBodyAuthentication> =
    openEnums.outboundSchema(RestCollectMethodPostWithBodyAuthentication);

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("backoff"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$Outbound = {
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff
  > = z.object({
    type: z.literal("backoff"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restCollectMethodPostWithBodyRestRetryRulesTypeBackoffToJSON(
  restCollectMethodPostWithBodyRestRetryRulesTypeBackoff:
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$outboundSchema.parse(
      restCollectMethodPostWithBodyRestRetryRulesTypeBackoff,
    ),
  );
}
export function restCollectMethodPostWithBodyRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("static"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$Outbound = {
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestRetryRulesTypeStatic
  > = z.object({
    type: z.literal("static"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restCollectMethodPostWithBodyRestRetryRulesTypeStaticToJSON(
  restCollectMethodPostWithBodyRestRetryRulesTypeStatic:
    RestCollectMethodPostWithBodyRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$outboundSchema.parse(
      restCollectMethodPostWithBodyRestRetryRulesTypeStatic,
    ),
  );
}
export function restCollectMethodPostWithBodyRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodPostWithBodyRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestCollectMethodPostWithBodyRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restCollectMethodPostWithBodyRestRetryRulesTypeNoneToJSON(
  restCollectMethodPostWithBodyRestRetryRulesTypeNone:
    RestCollectMethodPostWithBodyRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRestRetryRulesTypeNone$outboundSchema.parse(
      restCollectMethodPostWithBodyRestRetryRulesTypeNone,
    ),
  );
}
export function restCollectMethodPostWithBodyRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyRetryRules$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestCollectMethodPostWithBodyRestRetryRulesTypeNone$inboundSchema
  ),
  static: z.lazy(() =>
    RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$inboundSchema
  ),
  backoff: z.lazy(() =>
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodPostWithBodyRetryRules$Outbound =
  | RestCollectMethodPostWithBodyRestRetryRulesTypeNone$Outbound
  | RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$Outbound
  | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$Outbound;

/** @internal */
export const RestCollectMethodPostWithBodyRetryRules$outboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyRetryRules$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostWithBodyRetryRules
> = z.union([
  z.lazy(() =>
    RestCollectMethodPostWithBodyRestRetryRulesTypeNone$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$outboundSchema
  ),
]);

export function restCollectMethodPostWithBodyRetryRulesToJSON(
  restCollectMethodPostWithBodyRetryRules:
    RestCollectMethodPostWithBodyRetryRules,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyRetryRules$outboundSchema.parse(
      restCollectMethodPostWithBodyRetryRules,
    ),
  );
}
export function restCollectMethodPostWithBodyRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyRetryRules' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyStateTracking$inboundSchema:
  z.ZodType<RestCollectMethodPostWithBodyStateTracking, z.ZodTypeDef, unknown> =
    z.object({
      enabled: types.optional(types.boolean()),
    });
/** @internal */
export type RestCollectMethodPostWithBodyStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestCollectMethodPostWithBodyStateTracking$outboundSchema:
  z.ZodType<
    RestCollectMethodPostWithBodyStateTracking$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostWithBodyStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restCollectMethodPostWithBodyStateTrackingToJSON(
  restCollectMethodPostWithBodyStateTracking:
    RestCollectMethodPostWithBodyStateTracking,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyStateTracking$outboundSchema.parse(
      restCollectMethodPostWithBodyStateTracking,
    ),
  );
}
export function restCollectMethodPostWithBodyStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyStateTracking' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBodyScheduling$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestCollectMethodPostWithBodyStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestCollectMethodPostWithBodyScheduling$Outbound = {
  stateTracking?:
    | RestCollectMethodPostWithBodyStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestCollectMethodPostWithBodyScheduling$outboundSchema: z.ZodType<
  RestCollectMethodPostWithBodyScheduling$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostWithBodyScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestCollectMethodPostWithBodyStateTracking$outboundSchema
  ).optional(),
});

export function restCollectMethodPostWithBodySchedulingToJSON(
  restCollectMethodPostWithBodyScheduling:
    RestCollectMethodPostWithBodyScheduling,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBodyScheduling$outboundSchema.parse(
      restCollectMethodPostWithBodyScheduling,
    ),
  );
}
export function restCollectMethodPostWithBodySchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostWithBodyScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostWithBodyScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostWithBodyScheduling' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostWithBody$inboundSchema: z.ZodType<
  RestCollectMethodPostWithBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: RestCollectMethodPostWithBodyCollectMethod$inboundSchema,
  collectBody: types.optional(z.any()),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectVerb: types.optional(z.any()),
  collectRequestParams: types.optional(z.any()),
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  authentication: RestCollectMethodPostWithBodyAuthentication$inboundSchema,
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeNone$inboundSchema
    ),
    static: z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$inboundSchema
    ),
    backoff: z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$inboundSchema
    ),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestCollectMethodPostWithBodyScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestCollectMethodPostWithBody$Outbound = {
  collectMethod: string;
  collectBody?: any | undefined;
  discovery?:
    | (
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$Outbound
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$Outbound
    | RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestCollectMethodPostWithBodyRestPaginationTypeNone$Outbound
    | RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$Outbound
    | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$Outbound
    | RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$Outbound
    | RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$Outbound
    | RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$Outbound
    | undefined;
  authentication: string;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestCollectMethodPostWithBodyRestRetryRulesTypeNone$Outbound
    | RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$Outbound
    | RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$Outbound
    | undefined;
  __scheduling?: RestCollectMethodPostWithBodyScheduling$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodPostWithBody$outboundSchema: z.ZodType<
  RestCollectMethodPostWithBody$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostWithBody
> = z.object({
  collectMethod: RestCollectMethodPostWithBodyCollectMethod$outboundSchema,
  collectBody: z.any().optional(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  authentication: RestCollectMethodPostWithBodyAuthentication$outboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeStatic$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff$outboundSchema
    ),
  ]).optional(),
  __scheduling: z.lazy(() =>
    RestCollectMethodPostWithBodyScheduling$outboundSchema
  ).optional(),
});

export function restCollectMethodPostWithBodyToJSON(
  restCollectMethodPostWithBody: RestCollectMethodPostWithBody,
): string {
  return JSON.stringify(
    RestCollectMethodPostWithBody$outboundSchema.parse(
      restCollectMethodPostWithBody,
    ),
  );
}
export function restCollectMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostWithBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPostWithBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostCollectMethod$inboundSchema: z.ZodType<
  RestCollectMethodPostCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodPostCollectMethod);
/** @internal */
export const RestCollectMethodPostCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodPostCollectMethod
> = openEnums.outboundSchema(RestCollectMethodPostCollectMethod);

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeNone$Outbound = {
  discoverType: "none";
};

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeNoneToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeNone:
    RestCollectMethodPostRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeNone$outboundSchema.parse(
      restCollectMethodPostRestDiscoveryDiscoverTypeNone,
    ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeList$Outbound = {
  discoverType: "list";
  itemList: Array<string>;
};

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeListToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeList:
    RestCollectMethodPostRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeList$outboundSchema.parse(
      restCollectMethodPostRestDiscoveryDiscoverTypeList,
    ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeList$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeJson$Outbound = {
  discoverType: "json";
  manualDiscoverResult: string;
  discoverDataField?: string | undefined;
};

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeJsonToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeJson:
    RestCollectMethodPostRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeJson$outboundSchema.parse(
      restCollectMethodPostRestDiscoveryDiscoverTypeJson,
    ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeJson$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestCollectMethodPostRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestCollectMethodPostRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpToJSON(
  restCollectMethodPostRestDiscoveryDiscoverTypeHttp:
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestDiscoveryDiscoverTypeHttp$outboundSchema.parse(
      restCollectMethodPostRestDiscoveryDiscoverTypeHttp,
    ),
  );
}
export function restCollectMethodPostRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttp$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostDiscovery$inboundSchema: z.ZodType<
  RestCollectMethodPostDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestCollectMethodPostRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestCollectMethodPostRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestCollectMethodPostRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodPostDiscovery$Outbound =
  | (
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestCollectMethodPostRestDiscoveryDiscoverTypeJson$Outbound
  | RestCollectMethodPostRestDiscoveryDiscoverTypeList$Outbound
  | RestCollectMethodPostRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestCollectMethodPostDiscovery$outboundSchema: z.ZodType<
  RestCollectMethodPostDiscovery$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestCollectMethodPostRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restCollectMethodPostDiscoveryToJSON(
  restCollectMethodPostDiscovery: RestCollectMethodPostDiscovery,
): string {
  return JSON.stringify(
    RestCollectMethodPostDiscovery$outboundSchema.parse(
      restCollectMethodPostDiscovery,
    ),
  );
}
export function restCollectMethodPostDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPostDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostDiscovery' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodPostRestPaginationTypeRequestPage$Outbound = {
  type: "request_page";
  pageField: string;
  page?: number | undefined;
  sizeField: string;
  size: number;
  totalPageField?: string | undefined;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestCollectMethodPostRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodPostRestPaginationTypeRequestPageToJSON(
  restCollectMethodPostRestPaginationTypeRequestPage:
    RestCollectMethodPostRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestPaginationTypeRequestPage$outboundSchema.parse(
      restCollectMethodPostRestPaginationTypeRequestPage,
    ),
  );
}
export function restCollectMethodPostRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestPaginationTypeRequestPage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodPostRestPaginationTypeRequestOffset$Outbound = {
  type: "request_offset";
  offsetField: string;
  offset?: number | undefined;
  limitField: string;
  limit: number;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestCollectMethodPostRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodPostRestPaginationTypeRequestOffsetToJSON(
  restCollectMethodPostRestPaginationTypeRequestOffset:
    RestCollectMethodPostRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestPaginationTypeRequestOffset$outboundSchema.parse(
      restCollectMethodPostRestPaginationTypeRequestOffset,
    ),
  );
}
export function restCollectMethodPostRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestPaginationTypeRequestOffset$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodPostRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestCollectMethodPostRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restCollectMethodPostRestPaginationTypeResponseHeaderLinkToJSON(
  restCollectMethodPostRestPaginationTypeResponseHeaderLink:
    RestCollectMethodPostRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restCollectMethodPostRestPaginationTypeResponseHeaderLink),
  );
}
export function restCollectMethodPostRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodPostRestPaginationTypeResponseHeader$Outbound = {
  type: "response_header";
  attribute: Array<string>;
  maxPages: number;
};

/** @internal */
export const RestCollectMethodPostRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restCollectMethodPostRestPaginationTypeResponseHeaderToJSON(
  restCollectMethodPostRestPaginationTypeResponseHeader:
    RestCollectMethodPostRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestPaginationTypeResponseHeader$outboundSchema.parse(
      restCollectMethodPostRestPaginationTypeResponseHeader,
    ),
  );
}
export function restCollectMethodPostRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestPaginationTypeResponseHeader$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodPostRestPaginationTypeResponseBody$Outbound = {
  type: "response_body";
  attribute: Array<string>;
  maxPages: number;
  lastPageExpr?: string | undefined;
};

/** @internal */
export const RestCollectMethodPostRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restCollectMethodPostRestPaginationTypeResponseBodyToJSON(
  restCollectMethodPostRestPaginationTypeResponseBody:
    RestCollectMethodPostRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestPaginationTypeResponseBody$outboundSchema.parse(
      restCollectMethodPostRestPaginationTypeResponseBody,
    ),
  );
}
export function restCollectMethodPostRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestPaginationTypeResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodPostRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestCollectMethodPostRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restCollectMethodPostRestPaginationTypeNoneToJSON(
  restCollectMethodPostRestPaginationTypeNone:
    RestCollectMethodPostRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestPaginationTypeNone$outboundSchema.parse(
      restCollectMethodPostRestPaginationTypeNone,
    ),
  );
}
export function restCollectMethodPostRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostPaginationUnion$inboundSchema: z.ZodType<
  RestCollectMethodPostPaginationUnion,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() => RestCollectMethodPostRestPaginationTypeNone$inboundSchema),
  response_body: z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeResponseBody$inboundSchema
  ),
  response_header: z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeResponseHeader$inboundSchema
  ),
  response_header_link: z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeResponseHeaderLink$inboundSchema
  ),
  request_offset: z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeRequestOffset$inboundSchema
  ),
  request_page: z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeRequestPage$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodPostPaginationUnion$Outbound =
  | RestCollectMethodPostRestPaginationTypeNone$Outbound
  | RestCollectMethodPostRestPaginationTypeResponseBody$Outbound
  | RestCollectMethodPostRestPaginationTypeResponseHeader$Outbound
  | RestCollectMethodPostRestPaginationTypeResponseHeaderLink$Outbound
  | RestCollectMethodPostRestPaginationTypeRequestOffset$Outbound
  | RestCollectMethodPostRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestCollectMethodPostPaginationUnion$outboundSchema: z.ZodType<
  RestCollectMethodPostPaginationUnion$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostPaginationUnion
> = z.union([
  z.lazy(() => RestCollectMethodPostRestPaginationTypeNone$outboundSchema),
  z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeResponseBody$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeResponseHeader$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeResponseHeaderLink$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeRequestOffset$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodPostRestPaginationTypeRequestPage$outboundSchema
  ),
]);

export function restCollectMethodPostPaginationUnionToJSON(
  restCollectMethodPostPaginationUnion: RestCollectMethodPostPaginationUnion,
): string {
  return JSON.stringify(
    RestCollectMethodPostPaginationUnion$outboundSchema.parse(
      restCollectMethodPostPaginationUnion,
    ),
  );
}
export function restCollectMethodPostPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostPaginationUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostPaginationUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostAuthentication$inboundSchema: z.ZodType<
  RestCollectMethodPostAuthentication,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodPostAuthentication);
/** @internal */
export const RestCollectMethodPostAuthentication$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodPostAuthentication
> = openEnums.outboundSchema(RestCollectMethodPostAuthentication);

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("backoff"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodPostRestRetryRulesTypeBackoff$Outbound = {
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestRetryRulesTypeBackoff
  > = z.object({
    type: z.literal("backoff"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restCollectMethodPostRestRetryRulesTypeBackoffToJSON(
  restCollectMethodPostRestRetryRulesTypeBackoff:
    RestCollectMethodPostRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestRetryRulesTypeBackoff$outboundSchema.parse(
      restCollectMethodPostRestRetryRulesTypeBackoff,
    ),
  );
}
export function restCollectMethodPostRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestRetryRulesTypeBackoff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("static"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodPostRestRetryRulesTypeStatic$Outbound = {
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestRetryRulesTypeStatic
  > = z.object({
    type: z.literal("static"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restCollectMethodPostRestRetryRulesTypeStaticToJSON(
  restCollectMethodPostRestRetryRulesTypeStatic:
    RestCollectMethodPostRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestRetryRulesTypeStatic$outboundSchema.parse(
      restCollectMethodPostRestRetryRulesTypeStatic,
    ),
  );
}
export function restCollectMethodPostRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodPostRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestCollectMethodPostRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodPostRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodPostRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restCollectMethodPostRestRetryRulesTypeNoneToJSON(
  restCollectMethodPostRestRetryRulesTypeNone:
    RestCollectMethodPostRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodPostRestRetryRulesTypeNone$outboundSchema.parse(
      restCollectMethodPostRestRetryRulesTypeNone,
    ),
  );
}
export function restCollectMethodPostRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodPostRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodPostRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostRetryRules$inboundSchema: z.ZodType<
  RestCollectMethodPostRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() => RestCollectMethodPostRestRetryRulesTypeNone$inboundSchema),
  static: z.lazy(() =>
    RestCollectMethodPostRestRetryRulesTypeStatic$inboundSchema
  ),
  backoff: z.lazy(() =>
    RestCollectMethodPostRestRetryRulesTypeBackoff$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodPostRetryRules$Outbound =
  | RestCollectMethodPostRestRetryRulesTypeNone$Outbound
  | RestCollectMethodPostRestRetryRulesTypeStatic$Outbound
  | RestCollectMethodPostRestRetryRulesTypeBackoff$Outbound;

/** @internal */
export const RestCollectMethodPostRetryRules$outboundSchema: z.ZodType<
  RestCollectMethodPostRetryRules$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostRetryRules
> = z.union([
  z.lazy(() => RestCollectMethodPostRestRetryRulesTypeNone$outboundSchema),
  z.lazy(() => RestCollectMethodPostRestRetryRulesTypeStatic$outboundSchema),
  z.lazy(() => RestCollectMethodPostRestRetryRulesTypeBackoff$outboundSchema),
]);

export function restCollectMethodPostRetryRulesToJSON(
  restCollectMethodPostRetryRules: RestCollectMethodPostRetryRules,
): string {
  return JSON.stringify(
    RestCollectMethodPostRetryRules$outboundSchema.parse(
      restCollectMethodPostRetryRules,
    ),
  );
}
export function restCollectMethodPostRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPostRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostRetryRules' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostStateTracking$inboundSchema: z.ZodType<
  RestCollectMethodPostStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: types.optional(types.boolean()),
});
/** @internal */
export type RestCollectMethodPostStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestCollectMethodPostStateTracking$outboundSchema: z.ZodType<
  RestCollectMethodPostStateTracking$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restCollectMethodPostStateTrackingToJSON(
  restCollectMethodPostStateTracking: RestCollectMethodPostStateTracking,
): string {
  return JSON.stringify(
    RestCollectMethodPostStateTracking$outboundSchema.parse(
      restCollectMethodPostStateTracking,
    ),
  );
}
export function restCollectMethodPostStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodPostStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostStateTracking' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPostScheduling$inboundSchema: z.ZodType<
  RestCollectMethodPostScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestCollectMethodPostStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestCollectMethodPostScheduling$Outbound = {
  stateTracking?: RestCollectMethodPostStateTracking$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodPostScheduling$outboundSchema: z.ZodType<
  RestCollectMethodPostScheduling$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPostScheduling
> = z.object({
  stateTracking: z.lazy(() => RestCollectMethodPostStateTracking$outboundSchema)
    .optional(),
});

export function restCollectMethodPostSchedulingToJSON(
  restCollectMethodPostScheduling: RestCollectMethodPostScheduling,
): string {
  return JSON.stringify(
    RestCollectMethodPostScheduling$outboundSchema.parse(
      restCollectMethodPostScheduling,
    ),
  );
}
export function restCollectMethodPostSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPostScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPostScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPostScheduling' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodPost$inboundSchema: z.ZodType<
  RestCollectMethodPost,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: RestCollectMethodPostCollectMethod$inboundSchema,
  collectRequestParams: types.optional(z.any()),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectVerb: types.optional(z.any()),
  collectBody: types.optional(z.any()),
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  authentication: RestCollectMethodPostAuthentication$inboundSchema,
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeNone$inboundSchema
    ),
    static: z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeStatic$inboundSchema
    ),
    backoff: z.lazy(() =>
      RestCollectMethodPostRestRetryRulesTypeBackoff$inboundSchema
    ),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestCollectMethodPostScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestCollectMethodPost$Outbound = {
  collectMethod: string;
  collectRequestParams?: any | undefined;
  discovery?:
    | (
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestCollectMethodPostRestDiscoveryDiscoverTypeJson$Outbound
    | RestCollectMethodPostRestDiscoveryDiscoverTypeList$Outbound
    | RestCollectMethodPostRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectVerb?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestCollectMethodPostRestPaginationTypeNone$Outbound
    | RestCollectMethodPostRestPaginationTypeResponseBody$Outbound
    | RestCollectMethodPostRestPaginationTypeResponseHeader$Outbound
    | RestCollectMethodPostRestPaginationTypeResponseHeaderLink$Outbound
    | RestCollectMethodPostRestPaginationTypeRequestOffset$Outbound
    | RestCollectMethodPostRestPaginationTypeRequestPage$Outbound
    | undefined;
  authentication: string;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestCollectMethodPostRestRetryRulesTypeNone$Outbound
    | RestCollectMethodPostRestRetryRulesTypeStatic$Outbound
    | RestCollectMethodPostRestRetryRulesTypeBackoff$Outbound
    | undefined;
  __scheduling?: RestCollectMethodPostScheduling$Outbound | undefined;
};

/** @internal */
export const RestCollectMethodPost$outboundSchema: z.ZodType<
  RestCollectMethodPost$Outbound,
  z.ZodTypeDef,
  RestCollectMethodPost
> = z.object({
  collectMethod: RestCollectMethodPostCollectMethod$outboundSchema,
  collectRequestParams: z.any().optional(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestCollectMethodPostRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectVerb: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() => RestCollectMethodPostRestPaginationTypeNone$outboundSchema),
    z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodPostRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  authentication: RestCollectMethodPostAuthentication$outboundSchema,
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() => RestCollectMethodPostRestRetryRulesTypeNone$outboundSchema),
    z.lazy(() => RestCollectMethodPostRestRetryRulesTypeStatic$outboundSchema),
    z.lazy(() => RestCollectMethodPostRestRetryRulesTypeBackoff$outboundSchema),
  ]).optional(),
  __scheduling: z.lazy(() => RestCollectMethodPostScheduling$outboundSchema)
    .optional(),
});

export function restCollectMethodPostToJSON(
  restCollectMethodPost: RestCollectMethodPost,
): string {
  return JSON.stringify(
    RestCollectMethodPost$outboundSchema.parse(restCollectMethodPost),
  );
}
export function restCollectMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodPost, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodPost$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodPost' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetCollectMethod$inboundSchema: z.ZodType<
  RestCollectMethodGetCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodGetCollectMethod);
/** @internal */
export const RestCollectMethodGetCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodGetCollectMethod
> = openEnums.outboundSchema(RestCollectMethodGetCollectMethod);

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeNone$Outbound = {
  discoverType: "none";
};

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeNoneToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeNone:
    RestCollectMethodGetRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeNone$outboundSchema.parse(
      restCollectMethodGetRestDiscoveryDiscoverTypeNone,
    ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeList$Outbound = {
  discoverType: "list";
  itemList: Array<string>;
};

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeListToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeList:
    RestCollectMethodGetRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeList$outboundSchema.parse(
      restCollectMethodGetRestDiscoveryDiscoverTypeList,
    ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeList$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeJson$Outbound = {
  discoverType: "json";
  manualDiscoverResult: string;
  discoverDataField?: string | undefined;
};

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeJsonToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeJson:
    RestCollectMethodGetRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeJson$outboundSchema.parse(
      restCollectMethodGetRestDiscoveryDiscoverTypeJson,
    ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeJson$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestCollectMethodGetRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestCollectMethodGetRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpToJSON(
  restCollectMethodGetRestDiscoveryDiscoverTypeHttp:
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestDiscoveryDiscoverTypeHttp$outboundSchema.parse(
      restCollectMethodGetRestDiscoveryDiscoverTypeHttp,
    ),
  );
}
export function restCollectMethodGetRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttp$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetDiscovery$inboundSchema: z.ZodType<
  RestCollectMethodGetDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestCollectMethodGetRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestCollectMethodGetRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestCollectMethodGetRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodGetDiscovery$Outbound =
  | (
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestCollectMethodGetRestDiscoveryDiscoverTypeJson$Outbound
  | RestCollectMethodGetRestDiscoveryDiscoverTypeList$Outbound
  | RestCollectMethodGetRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestCollectMethodGetDiscovery$outboundSchema: z.ZodType<
  RestCollectMethodGetDiscovery$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestCollectMethodGetRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestCollectMethodGetRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodGetRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodGetRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restCollectMethodGetDiscoveryToJSON(
  restCollectMethodGetDiscovery: RestCollectMethodGetDiscovery,
): string {
  return JSON.stringify(
    RestCollectMethodGetDiscovery$outboundSchema.parse(
      restCollectMethodGetDiscovery,
    ),
  );
}
export function restCollectMethodGetDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGetDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetDiscovery' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodGetRestPaginationTypeRequestPage$Outbound = {
  type: "request_page";
  pageField: string;
  page?: number | undefined;
  sizeField: string;
  size: number;
  totalPageField?: string | undefined;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestCollectMethodGetRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodGetRestPaginationTypeRequestPageToJSON(
  restCollectMethodGetRestPaginationTypeRequestPage:
    RestCollectMethodGetRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestPaginationTypeRequestPage$outboundSchema.parse(
      restCollectMethodGetRestPaginationTypeRequestPage,
    ),
  );
}
export function restCollectMethodGetRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestPaginationTypeRequestPage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestCollectMethodGetRestPaginationTypeRequestOffset$Outbound = {
  type: "request_offset";
  offsetField: string;
  offset?: number | undefined;
  limitField: string;
  limit: number;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestCollectMethodGetRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restCollectMethodGetRestPaginationTypeRequestOffsetToJSON(
  restCollectMethodGetRestPaginationTypeRequestOffset:
    RestCollectMethodGetRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestPaginationTypeRequestOffset$outboundSchema.parse(
      restCollectMethodGetRestPaginationTypeRequestOffset,
    ),
  );
}
export function restCollectMethodGetRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestPaginationTypeRequestOffset$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodGetRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestCollectMethodGetRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restCollectMethodGetRestPaginationTypeResponseHeaderLinkToJSON(
  restCollectMethodGetRestPaginationTypeResponseHeaderLink:
    RestCollectMethodGetRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restCollectMethodGetRestPaginationTypeResponseHeaderLink),
  );
}
export function restCollectMethodGetRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestCollectMethodGetRestPaginationTypeResponseHeader$Outbound = {
  type: "response_header";
  attribute: Array<string>;
  maxPages: number;
};

/** @internal */
export const RestCollectMethodGetRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restCollectMethodGetRestPaginationTypeResponseHeaderToJSON(
  restCollectMethodGetRestPaginationTypeResponseHeader:
    RestCollectMethodGetRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestPaginationTypeResponseHeader$outboundSchema.parse(
      restCollectMethodGetRestPaginationTypeResponseHeader,
    ),
  );
}
export function restCollectMethodGetRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestPaginationTypeResponseHeader$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestCollectMethodGetRestPaginationTypeResponseBody$Outbound = {
  type: "response_body";
  attribute: Array<string>;
  maxPages: number;
  lastPageExpr?: string | undefined;
};

/** @internal */
export const RestCollectMethodGetRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restCollectMethodGetRestPaginationTypeResponseBodyToJSON(
  restCollectMethodGetRestPaginationTypeResponseBody:
    RestCollectMethodGetRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestPaginationTypeResponseBody$outboundSchema.parse(
      restCollectMethodGetRestPaginationTypeResponseBody,
    ),
  );
}
export function restCollectMethodGetRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestPaginationTypeResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestPaginationTypeNone$inboundSchema:
  z.ZodType<RestCollectMethodGetRestPaginationTypeNone, z.ZodTypeDef, unknown> =
    z.object({
      type: types.literal("none"),
    });
/** @internal */
export type RestCollectMethodGetRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestCollectMethodGetRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restCollectMethodGetRestPaginationTypeNoneToJSON(
  restCollectMethodGetRestPaginationTypeNone:
    RestCollectMethodGetRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestPaginationTypeNone$outboundSchema.parse(
      restCollectMethodGetRestPaginationTypeNone,
    ),
  );
}
export function restCollectMethodGetRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetPaginationUnion$inboundSchema: z.ZodType<
  RestCollectMethodGetPaginationUnion,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() => RestCollectMethodGetRestPaginationTypeNone$inboundSchema),
  response_body: z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeResponseBody$inboundSchema
  ),
  response_header: z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeResponseHeader$inboundSchema
  ),
  response_header_link: z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeResponseHeaderLink$inboundSchema
  ),
  request_offset: z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeRequestOffset$inboundSchema
  ),
  request_page: z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeRequestPage$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodGetPaginationUnion$Outbound =
  | RestCollectMethodGetRestPaginationTypeNone$Outbound
  | RestCollectMethodGetRestPaginationTypeResponseBody$Outbound
  | RestCollectMethodGetRestPaginationTypeResponseHeader$Outbound
  | RestCollectMethodGetRestPaginationTypeResponseHeaderLink$Outbound
  | RestCollectMethodGetRestPaginationTypeRequestOffset$Outbound
  | RestCollectMethodGetRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestCollectMethodGetPaginationUnion$outboundSchema: z.ZodType<
  RestCollectMethodGetPaginationUnion$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetPaginationUnion
> = z.union([
  z.lazy(() => RestCollectMethodGetRestPaginationTypeNone$outboundSchema),
  z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeResponseBody$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeResponseHeader$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeResponseHeaderLink$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeRequestOffset$outboundSchema
  ),
  z.lazy(() =>
    RestCollectMethodGetRestPaginationTypeRequestPage$outboundSchema
  ),
]);

export function restCollectMethodGetPaginationUnionToJSON(
  restCollectMethodGetPaginationUnion: RestCollectMethodGetPaginationUnion,
): string {
  return JSON.stringify(
    RestCollectMethodGetPaginationUnion$outboundSchema.parse(
      restCollectMethodGetPaginationUnion,
    ),
  );
}
export function restCollectMethodGetPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetPaginationUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetPaginationUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetAuthentication$inboundSchema: z.ZodType<
  RestCollectMethodGetAuthentication,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestCollectMethodGetAuthentication);
/** @internal */
export const RestCollectMethodGetAuthentication$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestCollectMethodGetAuthentication
> = openEnums.outboundSchema(RestCollectMethodGetAuthentication);

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("backoff"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodGetRestRetryRulesTypeBackoff$Outbound = {
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestRetryRulesTypeBackoff
  > = z.object({
    type: z.literal("backoff"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restCollectMethodGetRestRetryRulesTypeBackoffToJSON(
  restCollectMethodGetRestRetryRulesTypeBackoff:
    RestCollectMethodGetRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestRetryRulesTypeBackoff$outboundSchema.parse(
      restCollectMethodGetRestRetryRulesTypeBackoff,
    ),
  );
}
export function restCollectMethodGetRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestRetryRulesTypeBackoff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("static"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestCollectMethodGetRestRetryRulesTypeStatic$Outbound = {
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestRetryRulesTypeStatic
  > = z.object({
    type: z.literal("static"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restCollectMethodGetRestRetryRulesTypeStaticToJSON(
  restCollectMethodGetRestRetryRulesTypeStatic:
    RestCollectMethodGetRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestRetryRulesTypeStatic$outboundSchema.parse(
      restCollectMethodGetRestRetryRulesTypeStatic,
    ),
  );
}
export function restCollectMethodGetRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<RestCollectMethodGetRestRetryRulesTypeNone, z.ZodTypeDef, unknown> =
    z.object({
      type: types.literal("none"),
      interval: types.optional(z.any()),
      limit: types.optional(z.any()),
      multiplier: types.optional(z.any()),
      maxIntervalMs: types.optional(z.any()),
      codes: types.optional(z.any()),
      enableHeader: types.optional(z.any()),
      retryConnectTimeout: types.optional(z.any()),
      retryConnectReset: types.optional(z.any()),
    });
/** @internal */
export type RestCollectMethodGetRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestCollectMethodGetRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestCollectMethodGetRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestCollectMethodGetRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restCollectMethodGetRestRetryRulesTypeNoneToJSON(
  restCollectMethodGetRestRetryRulesTypeNone:
    RestCollectMethodGetRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestCollectMethodGetRestRetryRulesTypeNone$outboundSchema.parse(
      restCollectMethodGetRestRetryRulesTypeNone,
    ),
  );
}
export function restCollectMethodGetRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestCollectMethodGetRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestCollectMethodGetRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestCollectMethodGetRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetRetryRules$inboundSchema: z.ZodType<
  RestCollectMethodGetRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() => RestCollectMethodGetRestRetryRulesTypeNone$inboundSchema),
  static: z.lazy(() =>
    RestCollectMethodGetRestRetryRulesTypeStatic$inboundSchema
  ),
  backoff: z.lazy(() =>
    RestCollectMethodGetRestRetryRulesTypeBackoff$inboundSchema
  ),
});
/** @internal */
export type RestCollectMethodGetRetryRules$Outbound =
  | RestCollectMethodGetRestRetryRulesTypeNone$Outbound
  | RestCollectMethodGetRestRetryRulesTypeStatic$Outbound
  | RestCollectMethodGetRestRetryRulesTypeBackoff$Outbound;

/** @internal */
export const RestCollectMethodGetRetryRules$outboundSchema: z.ZodType<
  RestCollectMethodGetRetryRules$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetRetryRules
> = z.union([
  z.lazy(() => RestCollectMethodGetRestRetryRulesTypeNone$outboundSchema),
  z.lazy(() => RestCollectMethodGetRestRetryRulesTypeStatic$outboundSchema),
  z.lazy(() => RestCollectMethodGetRestRetryRulesTypeBackoff$outboundSchema),
]);

export function restCollectMethodGetRetryRulesToJSON(
  restCollectMethodGetRetryRules: RestCollectMethodGetRetryRules,
): string {
  return JSON.stringify(
    RestCollectMethodGetRetryRules$outboundSchema.parse(
      restCollectMethodGetRetryRules,
    ),
  );
}
export function restCollectMethodGetRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGetRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetRetryRules' from JSON`,
  );
}

/** @internal */
export const RestCollectMethodGetStateTracking$inboundSchema: z.ZodType<
  RestCollectMethodGetStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: types.optional(types.boolean()),
});
/** @internal */
export type RestCollectMethodGetStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestCollectMethodGetStateTracking$outboundSchema: z.ZodType<
  RestCollectMethodGetStateTracking$Outbound,
  z.ZodTypeDef,
  RestCollectMethodGetStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restCollectMethodGetStateTrackingToJSON(
  restCollectMethodGetStateTracking: RestCollectMethodGetStateTracking,
): string {
  return JSON.stringify(
    RestCollectMethodGetStateTracking$outboundSchema.parse(
      restCollectMethodGetStateTracking,
    ),
  );
}
export function restCollectMethodGetStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestCollectMethodGetStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestCollectMethodGetStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestCollectMethodGetStateTracking' from JSON`,
  );
}
