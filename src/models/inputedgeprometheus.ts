/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import {
  DiskSpoolingType,
  DiskSpoolingType$inboundSchema,
  DiskSpoolingType$Outbound,
  DiskSpoolingType$outboundSchema,
} from "./diskspoolingtype.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeConnectionsOptional,
  ItemsTypeConnectionsOptional$inboundSchema,
  ItemsTypeConnectionsOptional$Outbound,
  ItemsTypeConnectionsOptional$outboundSchema,
} from "./itemstypeconnectionsoptional.js";
import {
  ItemsTypeNotificationMetadata,
  ItemsTypeNotificationMetadata$inboundSchema,
  ItemsTypeNotificationMetadata$Outbound,
  ItemsTypeNotificationMetadata$outboundSchema,
} from "./itemstypenotificationmetadata.js";
import {
  ItemsTypeSearchFilter,
  ItemsTypeSearchFilter$inboundSchema,
  ItemsTypeSearchFilter$Outbound,
  ItemsTypeSearchFilter$outboundSchema,
} from "./itemstypesearchfilter.js";
import {
  PqType,
  PqType$inboundSchema,
  PqType$Outbound,
  PqType$outboundSchema,
} from "./pqtype.js";
import {
  ProtocolOptionsTargetsItems,
  ProtocolOptionsTargetsItems$inboundSchema,
  ProtocolOptionsTargetsItems$outboundSchema,
} from "./protocoloptionstargetsitems.js";
import {
  RecordTypeOptions,
  RecordTypeOptions$inboundSchema,
  RecordTypeOptions$outboundSchema,
} from "./recordtypeoptions.js";
import {
  SignatureVersionOptions1,
  SignatureVersionOptions1$inboundSchema,
  SignatureVersionOptions1$outboundSchema,
} from "./signatureversionoptions1.js";

/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export const InputEdgePrometheusDiscoveryType = {
  /**
   * Static
   */
  Static: "static",
  /**
   * DNS
   */
  Dns: "dns",
  /**
   * AWS EC2
   */
  Ec2: "ec2",
  /**
   * Kubernetes Node
   */
  K8sNode: "k8s-node",
  /**
   * Kubernetes Pods
   */
  K8sPods: "k8s-pods",
} as const;
/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export type InputEdgePrometheusDiscoveryType = OpenEnum<
  typeof InputEdgePrometheusDiscoveryType
>;

/**
 * Enter credentials directly, or select a stored secret
 */
export const InputEdgePrometheusAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
  Kubernetes: "kubernetes",
} as const;
/**
 * Enter credentials directly, or select a stored secret
 */
export type InputEdgePrometheusAuthenticationMethod = OpenEnum<
  typeof InputEdgePrometheusAuthenticationMethod
>;

export type Target = {
  /**
   * Protocol to use when collecting metrics
   */
  protocol?: ProtocolOptionsTargetsItems | undefined;
  /**
   * Name of host from which to pull metrics.
   */
  host: string;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  port?: number | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  path?: string | undefined;
};

export type PodFilter = {
  /**
   * JavaScript expression applied to pods objects. Return 'true' to include it.
   */
  filter: string;
  /**
   * Optional description of this rule's purpose
   */
  description?: string | undefined;
};

export type InputEdgePrometheus = {
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: "edge_prometheus";
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnectionsOptional> | undefined;
  pq?: PqType | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType: InputEdgePrometheusDiscoveryType;
  /**
   * How often in seconds to scrape targets for metrics.
   */
  interval: number;
  /**
   * Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable
   */
  timeout?: number | undefined;
  persistence?: DiskSpoolingType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: InputEdgePrometheusAuthenticationMethod | undefined;
  description?: string | undefined;
  targets?: Array<Target> | undefined;
  /**
   * DNS record type to resolve
   */
  recordType?: RecordTypeOptions | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePort?: number | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: ProtocolOptionsTargetsItems | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Use public IP address for discovered targets. Disable to use the private IP address.
   */
  usePublicIp?: boolean | undefined;
  /**
   * Filter to apply when searching for EC2 instances
   */
  searchFilter?: Array<ItemsTypeSearchFilter> | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing EC2 requests
   */
  signatureVersion?: SignatureVersionOptions1 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocolExpr?: string | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePortExpr?: string | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePathExpr?: string | undefined;
  /**
   *   Add rules to decide which pods to discover for metrics.
   *
   * @remarks
   *   Pods are searched if no rules are given or of all the rules'
   *   expressions evaluate to true.
   */
  podFilter?: Array<PodFilter> | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime.
   */
  __template_awsApiKey?: string | undefined;
  /**
   * Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime.
   */
  __template_awsSecretKey?: string | undefined;
  /**
   * Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime.
   */
  __template_region?: string | undefined;
  /**
   * Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime.
   */
  __template_assumeRoleArn?: string | undefined;
  /**
   * Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime.
   */
  __template_assumeRoleExternalId?: string | undefined;
};

/** @internal */
export const InputEdgePrometheusDiscoveryType$inboundSchema: z.ZodType<
  InputEdgePrometheusDiscoveryType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputEdgePrometheusDiscoveryType);
/** @internal */
export const InputEdgePrometheusDiscoveryType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputEdgePrometheusDiscoveryType
> = openEnums.outboundSchema(InputEdgePrometheusDiscoveryType);

/** @internal */
export const InputEdgePrometheusAuthenticationMethod$inboundSchema: z.ZodType<
  InputEdgePrometheusAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputEdgePrometheusAuthenticationMethod);
/** @internal */
export const InputEdgePrometheusAuthenticationMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputEdgePrometheusAuthenticationMethod
> = openEnums.outboundSchema(InputEdgePrometheusAuthenticationMethod);

/** @internal */
export const Target$inboundSchema: z.ZodType<Target, z.ZodTypeDef, unknown> = z
  .object({
    protocol: types.optional(ProtocolOptionsTargetsItems$inboundSchema),
    host: types.string(),
    port: types.optional(types.number()),
    path: types.optional(types.string()),
  });
/** @internal */
export type Target$Outbound = {
  protocol?: string | undefined;
  host: string;
  port?: number | undefined;
  path?: string | undefined;
};

/** @internal */
export const Target$outboundSchema: z.ZodType<
  Target$Outbound,
  z.ZodTypeDef,
  Target
> = z.object({
  protocol: ProtocolOptionsTargetsItems$outboundSchema.optional(),
  host: z.string(),
  port: z.number().optional(),
  path: z.string().optional(),
});

export function targetToJSON(target: Target): string {
  return JSON.stringify(Target$outboundSchema.parse(target));
}
export function targetFromJSON(
  jsonString: string,
): SafeParseResult<Target, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Target$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Target' from JSON`,
  );
}

/** @internal */
export const PodFilter$inboundSchema: z.ZodType<
  PodFilter,
  z.ZodTypeDef,
  unknown
> = z.object({
  filter: types.string(),
  description: types.optional(types.string()),
});
/** @internal */
export type PodFilter$Outbound = {
  filter: string;
  description?: string | undefined;
};

/** @internal */
export const PodFilter$outboundSchema: z.ZodType<
  PodFilter$Outbound,
  z.ZodTypeDef,
  PodFilter
> = z.object({
  filter: z.string(),
  description: z.string().optional(),
});

export function podFilterToJSON(podFilter: PodFilter): string {
  return JSON.stringify(PodFilter$outboundSchema.parse(podFilter));
}
export function podFilterFromJSON(
  jsonString: string,
): SafeParseResult<PodFilter, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PodFilter$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PodFilter' from JSON`,
  );
}

/** @internal */
export const InputEdgePrometheus$inboundSchema: z.ZodType<
  InputEdgePrometheus,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.optional(types.string()),
  type: types.literal("edge_prometheus"),
  disabled: types.optional(types.boolean()),
  pipeline: types.optional(types.string()),
  sendToRoutes: types.optional(types.boolean()),
  environment: types.optional(types.string()),
  pqEnabled: types.optional(types.boolean()),
  streamtags: types.optional(z.array(types.string())),
  connections: types.optional(
    z.array(ItemsTypeConnectionsOptional$inboundSchema),
  ),
  pq: types.optional(PqType$inboundSchema),
  dimensionList: types.optional(z.array(types.string())),
  discoveryType: InputEdgePrometheusDiscoveryType$inboundSchema,
  interval: types.number(),
  timeout: types.optional(types.number()),
  persistence: types.optional(DiskSpoolingType$inboundSchema),
  metadata: types.optional(
    z.array(ItemsTypeNotificationMetadata$inboundSchema),
  ),
  authType: types.optional(
    InputEdgePrometheusAuthenticationMethod$inboundSchema,
  ),
  description: types.optional(types.string()),
  targets: types.optional(z.array(z.lazy(() => Target$inboundSchema))),
  recordType: types.optional(RecordTypeOptions$inboundSchema),
  scrapePort: types.optional(types.number()),
  nameList: types.optional(z.array(types.string())),
  scrapeProtocol: types.optional(ProtocolOptionsTargetsItems$inboundSchema),
  scrapePath: types.optional(types.string()),
  awsAuthenticationMethod: types.optional(types.string()),
  awsApiKey: types.optional(types.string()),
  awsSecret: types.optional(types.string()),
  usePublicIp: types.optional(types.boolean()),
  searchFilter: types.optional(z.array(ItemsTypeSearchFilter$inboundSchema)),
  awsSecretKey: types.optional(types.string()),
  region: types.optional(types.string()),
  endpoint: types.optional(types.string()),
  signatureVersion: types.optional(SignatureVersionOptions1$inboundSchema),
  reuseConnections: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  enableAssumeRole: types.optional(types.boolean()),
  assumeRoleArn: types.optional(types.string()),
  assumeRoleExternalId: types.optional(types.string()),
  durationSeconds: types.optional(types.number()),
  scrapeProtocolExpr: types.optional(types.string()),
  scrapePortExpr: types.optional(types.string()),
  scrapePathExpr: types.optional(types.string()),
  podFilter: types.optional(z.array(z.lazy(() => PodFilter$inboundSchema))),
  username: types.optional(types.string()),
  password: types.optional(types.string()),
  credentialsSecret: types.optional(types.string()),
  __template_awsApiKey: types.optional(types.string()),
  __template_awsSecretKey: types.optional(types.string()),
  __template_region: types.optional(types.string()),
  __template_assumeRoleArn: types.optional(types.string()),
  __template_assumeRoleExternalId: types.optional(types.string()),
});
/** @internal */
export type InputEdgePrometheus$Outbound = {
  id?: string | undefined;
  type: "edge_prometheus";
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  dimensionList?: Array<string> | undefined;
  discoveryType: string;
  interval: number;
  timeout?: number | undefined;
  persistence?: DiskSpoolingType$Outbound | undefined;
  metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  targets?: Array<Target$Outbound> | undefined;
  recordType?: string | undefined;
  scrapePort?: number | undefined;
  nameList?: Array<string> | undefined;
  scrapeProtocol?: string | undefined;
  scrapePath?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  usePublicIp?: boolean | undefined;
  searchFilter?: Array<ItemsTypeSearchFilter$Outbound> | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  scrapeProtocolExpr?: string | undefined;
  scrapePortExpr?: string | undefined;
  scrapePathExpr?: string | undefined;
  podFilter?: Array<PodFilter$Outbound> | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  __template_awsApiKey?: string | undefined;
  __template_awsSecretKey?: string | undefined;
  __template_region?: string | undefined;
  __template_assumeRoleArn?: string | undefined;
  __template_assumeRoleExternalId?: string | undefined;
};

/** @internal */
export const InputEdgePrometheus$outboundSchema: z.ZodType<
  InputEdgePrometheus$Outbound,
  z.ZodTypeDef,
  InputEdgePrometheus
> = z.object({
  id: z.string().optional(),
  type: z.literal("edge_prometheus"),
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ItemsTypeConnectionsOptional$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  dimensionList: z.array(z.string()).optional(),
  discoveryType: InputEdgePrometheusDiscoveryType$outboundSchema,
  interval: z.number(),
  timeout: z.number().optional(),
  persistence: DiskSpoolingType$outboundSchema.optional(),
  metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
  authType: InputEdgePrometheusAuthenticationMethod$outboundSchema.optional(),
  description: z.string().optional(),
  targets: z.array(z.lazy(() => Target$outboundSchema)).optional(),
  recordType: RecordTypeOptions$outboundSchema.optional(),
  scrapePort: z.number().optional(),
  nameList: z.array(z.string()).optional(),
  scrapeProtocol: ProtocolOptionsTargetsItems$outboundSchema.optional(),
  scrapePath: z.string().optional(),
  awsAuthenticationMethod: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  usePublicIp: z.boolean().optional(),
  searchFilter: z.array(ItemsTypeSearchFilter$outboundSchema).optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions1$outboundSchema.optional(),
  reuseConnections: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  enableAssumeRole: z.boolean().optional(),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().optional(),
  scrapeProtocolExpr: z.string().optional(),
  scrapePortExpr: z.string().optional(),
  scrapePathExpr: z.string().optional(),
  podFilter: z.array(z.lazy(() => PodFilter$outboundSchema)).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  __template_awsApiKey: z.string().optional(),
  __template_awsSecretKey: z.string().optional(),
  __template_region: z.string().optional(),
  __template_assumeRoleArn: z.string().optional(),
  __template_assumeRoleExternalId: z.string().optional(),
});

export function inputEdgePrometheusToJSON(
  inputEdgePrometheus: InputEdgePrometheus,
): string {
  return JSON.stringify(
    InputEdgePrometheus$outboundSchema.parse(inputEdgePrometheus),
  );
}
export function inputEdgePrometheusFromJSON(
  jsonString: string,
): SafeParseResult<InputEdgePrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputEdgePrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputEdgePrometheus' from JSON`,
  );
}
