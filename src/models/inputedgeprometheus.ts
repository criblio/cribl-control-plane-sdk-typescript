/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  DiskSpoolingType,
  DiskSpoolingType$inboundSchema,
  DiskSpoolingType$Outbound,
  DiskSpoolingType$outboundSchema,
} from "./diskspoolingtype.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeConnections,
  ItemsTypeConnections$inboundSchema,
  ItemsTypeConnections$Outbound,
  ItemsTypeConnections$outboundSchema,
} from "./itemstypeconnections.js";
import {
  ItemsTypeNotificationMetadata,
  ItemsTypeNotificationMetadata$inboundSchema,
  ItemsTypeNotificationMetadata$Outbound,
  ItemsTypeNotificationMetadata$outboundSchema,
} from "./itemstypenotificationmetadata.js";
import {
  ItemsTypeSearchFilter,
  ItemsTypeSearchFilter$inboundSchema,
  ItemsTypeSearchFilter$Outbound,
  ItemsTypeSearchFilter$outboundSchema,
} from "./itemstypesearchfilter.js";
import {
  PqType,
  PqType$inboundSchema,
  PqType$Outbound,
  PqType$outboundSchema,
} from "./pqtype.js";
import {
  ProtocolOptionsTargetsItems,
  ProtocolOptionsTargetsItems$inboundSchema,
  ProtocolOptionsTargetsItems$outboundSchema,
} from "./protocoloptionstargetsitems.js";
import {
  RecordTypeOptions,
  RecordTypeOptions$inboundSchema,
  RecordTypeOptions$outboundSchema,
} from "./recordtypeoptions.js";
import {
  SignatureVersionOptions1,
  SignatureVersionOptions1$inboundSchema,
  SignatureVersionOptions1$outboundSchema,
} from "./signatureversionoptions1.js";

export const InputEdgePrometheusType = {
  EdgePrometheus: "edge_prometheus",
} as const;
export type InputEdgePrometheusType = ClosedEnum<
  typeof InputEdgePrometheusType
>;

/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export const InputEdgePrometheusDiscoveryType = {
  /**
   * Static
   */
  Static: "static",
  /**
   * DNS
   */
  Dns: "dns",
  /**
   * AWS EC2
   */
  Ec2: "ec2",
  /**
   * Kubernetes Node
   */
  K8sNode: "k8s-node",
  /**
   * Kubernetes Pods
   */
  K8sPods: "k8s-pods",
} as const;
/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export type InputEdgePrometheusDiscoveryType = OpenEnum<
  typeof InputEdgePrometheusDiscoveryType
>;

/**
 * Enter credentials directly, or select a stored secret
 */
export const InputEdgePrometheusAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
  Kubernetes: "kubernetes",
} as const;
/**
 * Enter credentials directly, or select a stored secret
 */
export type InputEdgePrometheusAuthenticationMethod = OpenEnum<
  typeof InputEdgePrometheusAuthenticationMethod
>;

export type Target = {
  /**
   * Protocol to use when collecting metrics
   */
  protocol?: ProtocolOptionsTargetsItems | undefined;
  /**
   * Name of host from which to pull metrics.
   */
  host: string;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  port?: number | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  path?: string | undefined;
};

export type PodFilter = {
  /**
   * JavaScript expression applied to pods objects. Return 'true' to include it.
   */
  filter: string;
  /**
   * Optional description of this rule's purpose
   */
  description?: string | undefined;
};

export type InputEdgePrometheusInputCollectionPart1Type1 = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  pq?: PqType | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputEdgePrometheusType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnections> | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType?: InputEdgePrometheusDiscoveryType | undefined;
  /**
   * How often in seconds to scrape targets for metrics.
   */
  interval?: number | undefined;
  /**
   * Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable
   */
  timeout?: number | undefined;
  persistence?: DiskSpoolingType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: InputEdgePrometheusAuthenticationMethod | undefined;
  description?: string | undefined;
  targets?: Array<Target> | undefined;
  /**
   * DNS record type to resolve
   */
  recordType?: RecordTypeOptions | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePort?: number | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: ProtocolOptionsTargetsItems | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Use public IP address for discovered targets. Disable to use the private IP address.
   */
  usePublicIp?: boolean | undefined;
  /**
   * Filter to apply when searching for EC2 instances
   */
  searchFilter?: Array<ItemsTypeSearchFilter> | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing EC2 requests
   */
  signatureVersion?: SignatureVersionOptions1 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocolExpr?: string | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePortExpr?: string | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePathExpr?: string | undefined;
  /**
   *   Add rules to decide which pods to discover for metrics.
   *
   * @remarks
   *   Pods are searched if no rules are given or of all the rules'
   *   expressions evaluate to true.
   */
  podFilter?: Array<PodFilter> | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export type InputEdgePrometheusInputCollectionPart0Type1 = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputEdgePrometheusType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnections> | undefined;
  pq?: PqType | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType?: InputEdgePrometheusDiscoveryType | undefined;
  /**
   * How often in seconds to scrape targets for metrics.
   */
  interval?: number | undefined;
  /**
   * Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable
   */
  timeout?: number | undefined;
  persistence?: DiskSpoolingType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: InputEdgePrometheusAuthenticationMethod | undefined;
  description?: string | undefined;
  targets?: Array<Target> | undefined;
  /**
   * DNS record type to resolve
   */
  recordType?: RecordTypeOptions | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePort?: number | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: ProtocolOptionsTargetsItems | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Use public IP address for discovered targets. Disable to use the private IP address.
   */
  usePublicIp?: boolean | undefined;
  /**
   * Filter to apply when searching for EC2 instances
   */
  searchFilter?: Array<ItemsTypeSearchFilter> | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing EC2 requests
   */
  signatureVersion?: SignatureVersionOptions1 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocolExpr?: string | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePortExpr?: string | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePathExpr?: string | undefined;
  /**
   *   Add rules to decide which pods to discover for metrics.
   *
   * @remarks
   *   Pods are searched if no rules are given or of all the rules'
   *   expressions evaluate to true.
   */
  podFilter?: Array<PodFilter> | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export type InputEdgePrometheusInputCollectionPart1Type = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnections> | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputEdgePrometheusType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: PqType | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType?: InputEdgePrometheusDiscoveryType | undefined;
  /**
   * How often in seconds to scrape targets for metrics.
   */
  interval?: number | undefined;
  /**
   * Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable
   */
  timeout?: number | undefined;
  persistence?: DiskSpoolingType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: InputEdgePrometheusAuthenticationMethod | undefined;
  description?: string | undefined;
  targets?: Array<Target> | undefined;
  /**
   * DNS record type to resolve
   */
  recordType?: RecordTypeOptions | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePort?: number | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: ProtocolOptionsTargetsItems | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Use public IP address for discovered targets. Disable to use the private IP address.
   */
  usePublicIp?: boolean | undefined;
  /**
   * Filter to apply when searching for EC2 instances
   */
  searchFilter?: Array<ItemsTypeSearchFilter> | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing EC2 requests
   */
  signatureVersion?: SignatureVersionOptions1 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocolExpr?: string | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePortExpr?: string | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePathExpr?: string | undefined;
  /**
   *   Add rules to decide which pods to discover for metrics.
   *
   * @remarks
   *   Pods are searched if no rules are given or of all the rules'
   *   expressions evaluate to true.
   */
  podFilter?: Array<PodFilter> | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export type InputEdgePrometheusInputCollectionPart0Type = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputEdgePrometheusType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnections> | undefined;
  pq?: PqType | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType?: InputEdgePrometheusDiscoveryType | undefined;
  /**
   * How often in seconds to scrape targets for metrics.
   */
  interval?: number | undefined;
  /**
   * Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable
   */
  timeout?: number | undefined;
  persistence?: DiskSpoolingType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: InputEdgePrometheusAuthenticationMethod | undefined;
  description?: string | undefined;
  targets?: Array<Target> | undefined;
  /**
   * DNS record type to resolve
   */
  recordType?: RecordTypeOptions | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePort?: number | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: ProtocolOptionsTargetsItems | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Use public IP address for discovered targets. Disable to use the private IP address.
   */
  usePublicIp?: boolean | undefined;
  /**
   * Filter to apply when searching for EC2 instances
   */
  searchFilter?: Array<ItemsTypeSearchFilter> | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing EC2 requests
   */
  signatureVersion?: SignatureVersionOptions1 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocolExpr?: string | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePortExpr?: string | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePathExpr?: string | undefined;
  /**
   *   Add rules to decide which pods to discover for metrics.
   *
   * @remarks
   *   Pods are searched if no rules are given or of all the rules'
   *   expressions evaluate to true.
   */
  podFilter?: Array<PodFilter> | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export type InputEdgePrometheus =
  | InputEdgePrometheusInputCollectionPart0Type
  | InputEdgePrometheusInputCollectionPart1Type
  | InputEdgePrometheusInputCollectionPart0Type1
  | InputEdgePrometheusInputCollectionPart1Type1;

/** @internal */
export const InputEdgePrometheusType$inboundSchema: z.ZodNativeEnum<
  typeof InputEdgePrometheusType
> = z.nativeEnum(InputEdgePrometheusType);
/** @internal */
export const InputEdgePrometheusType$outboundSchema: z.ZodNativeEnum<
  typeof InputEdgePrometheusType
> = InputEdgePrometheusType$inboundSchema;

/** @internal */
export const InputEdgePrometheusDiscoveryType$inboundSchema: z.ZodType<
  InputEdgePrometheusDiscoveryType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputEdgePrometheusDiscoveryType);
/** @internal */
export const InputEdgePrometheusDiscoveryType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputEdgePrometheusDiscoveryType
> = openEnums.outboundSchema(InputEdgePrometheusDiscoveryType);

/** @internal */
export const InputEdgePrometheusAuthenticationMethod$inboundSchema: z.ZodType<
  InputEdgePrometheusAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputEdgePrometheusAuthenticationMethod);
/** @internal */
export const InputEdgePrometheusAuthenticationMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputEdgePrometheusAuthenticationMethod
> = openEnums.outboundSchema(InputEdgePrometheusAuthenticationMethod);

/** @internal */
export const Target$inboundSchema: z.ZodType<Target, z.ZodTypeDef, unknown> = z
  .object({
    protocol: ProtocolOptionsTargetsItems$inboundSchema.default("http"),
    host: z.string(),
    port: z.number().default(9090),
    path: z.string().default("/metrics"),
  });
/** @internal */
export type Target$Outbound = {
  protocol: string;
  host: string;
  port: number;
  path: string;
};

/** @internal */
export const Target$outboundSchema: z.ZodType<
  Target$Outbound,
  z.ZodTypeDef,
  Target
> = z.object({
  protocol: ProtocolOptionsTargetsItems$outboundSchema.default("http"),
  host: z.string(),
  port: z.number().default(9090),
  path: z.string().default("/metrics"),
});

export function targetToJSON(target: Target): string {
  return JSON.stringify(Target$outboundSchema.parse(target));
}
export function targetFromJSON(
  jsonString: string,
): SafeParseResult<Target, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Target$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Target' from JSON`,
  );
}

/** @internal */
export const PodFilter$inboundSchema: z.ZodType<
  PodFilter,
  z.ZodTypeDef,
  unknown
> = z.object({
  filter: z.string(),
  description: z.string().optional(),
});
/** @internal */
export type PodFilter$Outbound = {
  filter: string;
  description?: string | undefined;
};

/** @internal */
export const PodFilter$outboundSchema: z.ZodType<
  PodFilter$Outbound,
  z.ZodTypeDef,
  PodFilter
> = z.object({
  filter: z.string(),
  description: z.string().optional(),
});

export function podFilterToJSON(podFilter: PodFilter): string {
  return JSON.stringify(PodFilter$outboundSchema.parse(podFilter));
}
export function podFilterFromJSON(
  jsonString: string,
): SafeParseResult<PodFilter, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PodFilter$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PodFilter' from JSON`,
  );
}

/** @internal */
export const InputEdgePrometheusInputCollectionPart1Type1$inboundSchema:
  z.ZodType<
    InputEdgePrometheusInputCollectionPart1Type1,
    z.ZodTypeDef,
    unknown
  > = z.object({
    pqEnabled: z.boolean().default(false),
    pq: PqType$inboundSchema.optional(),
    id: z.string().optional(),
    type: InputEdgePrometheusType$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnections$inboundSchema).optional(),
    dimensionList: z.array(z.string()).optional(),
    discoveryType: InputEdgePrometheusDiscoveryType$inboundSchema.default(
      "static",
    ),
    interval: z.number().default(15),
    timeout: z.number().default(5000),
    persistence: DiskSpoolingType$inboundSchema.optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
    authType: InputEdgePrometheusAuthenticationMethod$inboundSchema.default(
      "manual",
    ),
    description: z.string().optional(),
    targets: z.array(z.lazy(() => Target$inboundSchema)).optional(),
    recordType: RecordTypeOptions$inboundSchema.default("SRV"),
    scrapePort: z.number().default(9090),
    nameList: z.array(z.string()).optional(),
    scrapeProtocol: ProtocolOptionsTargetsItems$inboundSchema.default("http"),
    scrapePath: z.string().default("/metrics"),
    awsAuthenticationMethod: z.string().default("auto"),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    usePublicIp: z.boolean().default(true),
    searchFilter: z.array(ItemsTypeSearchFilter$inboundSchema).optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: SignatureVersionOptions1$inboundSchema.default("v4"),
    reuseConnections: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    enableAssumeRole: z.boolean().default(false),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().default(3600),
    scrapeProtocolExpr: z.string().default(
      "metadata.annotations['prometheus.io/scheme'] || 'http'",
    ),
    scrapePortExpr: z.string().default(
      "metadata.annotations['prometheus.io/port'] || 9090",
    ),
    scrapePathExpr: z.string().default(
      "metadata.annotations['prometheus.io/path'] || '/metrics'",
    ),
    podFilter: z.array(z.lazy(() => PodFilter$inboundSchema)).optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
  });
/** @internal */
export type InputEdgePrometheusInputCollectionPart1Type1$Outbound = {
  pqEnabled: boolean;
  pq?: PqType$Outbound | undefined;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ItemsTypeConnections$Outbound> | undefined;
  dimensionList?: Array<string> | undefined;
  discoveryType: string;
  interval: number;
  timeout: number;
  persistence?: DiskSpoolingType$Outbound | undefined;
  metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
  authType: string;
  description?: string | undefined;
  targets?: Array<Target$Outbound> | undefined;
  recordType: string;
  scrapePort: number;
  nameList?: Array<string> | undefined;
  scrapeProtocol: string;
  scrapePath: string;
  awsAuthenticationMethod: string;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  usePublicIp: boolean;
  searchFilter?: Array<ItemsTypeSearchFilter$Outbound> | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  scrapeProtocolExpr: string;
  scrapePortExpr: string;
  scrapePathExpr: string;
  podFilter?: Array<PodFilter$Outbound> | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputEdgePrometheusInputCollectionPart1Type1$outboundSchema:
  z.ZodType<
    InputEdgePrometheusInputCollectionPart1Type1$Outbound,
    z.ZodTypeDef,
    InputEdgePrometheusInputCollectionPart1Type1
  > = z.object({
    pqEnabled: z.boolean().default(false),
    pq: PqType$outboundSchema.optional(),
    id: z.string().optional(),
    type: InputEdgePrometheusType$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnections$outboundSchema).optional(),
    dimensionList: z.array(z.string()).optional(),
    discoveryType: InputEdgePrometheusDiscoveryType$outboundSchema.default(
      "static",
    ),
    interval: z.number().default(15),
    timeout: z.number().default(5000),
    persistence: DiskSpoolingType$outboundSchema.optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
    authType: InputEdgePrometheusAuthenticationMethod$outboundSchema.default(
      "manual",
    ),
    description: z.string().optional(),
    targets: z.array(z.lazy(() => Target$outboundSchema)).optional(),
    recordType: RecordTypeOptions$outboundSchema.default("SRV"),
    scrapePort: z.number().default(9090),
    nameList: z.array(z.string()).optional(),
    scrapeProtocol: ProtocolOptionsTargetsItems$outboundSchema.default("http"),
    scrapePath: z.string().default("/metrics"),
    awsAuthenticationMethod: z.string().default("auto"),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    usePublicIp: z.boolean().default(true),
    searchFilter: z.array(ItemsTypeSearchFilter$outboundSchema).optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: SignatureVersionOptions1$outboundSchema.default("v4"),
    reuseConnections: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    enableAssumeRole: z.boolean().default(false),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().default(3600),
    scrapeProtocolExpr: z.string().default(
      "metadata.annotations['prometheus.io/scheme'] || 'http'",
    ),
    scrapePortExpr: z.string().default(
      "metadata.annotations['prometheus.io/port'] || 9090",
    ),
    scrapePathExpr: z.string().default(
      "metadata.annotations['prometheus.io/path'] || '/metrics'",
    ),
    podFilter: z.array(z.lazy(() => PodFilter$outboundSchema)).optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
  });

export function inputEdgePrometheusInputCollectionPart1Type1ToJSON(
  inputEdgePrometheusInputCollectionPart1Type1:
    InputEdgePrometheusInputCollectionPart1Type1,
): string {
  return JSON.stringify(
    InputEdgePrometheusInputCollectionPart1Type1$outboundSchema.parse(
      inputEdgePrometheusInputCollectionPart1Type1,
    ),
  );
}
export function inputEdgePrometheusInputCollectionPart1Type1FromJSON(
  jsonString: string,
): SafeParseResult<
  InputEdgePrometheusInputCollectionPart1Type1,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputEdgePrometheusInputCollectionPart1Type1$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputEdgePrometheusInputCollectionPart1Type1' from JSON`,
  );
}

/** @internal */
export const InputEdgePrometheusInputCollectionPart0Type1$inboundSchema:
  z.ZodType<
    InputEdgePrometheusInputCollectionPart0Type1,
    z.ZodTypeDef,
    unknown
  > = z.object({
    pqEnabled: z.boolean().default(false),
    id: z.string().optional(),
    type: InputEdgePrometheusType$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnections$inboundSchema).optional(),
    pq: PqType$inboundSchema.optional(),
    dimensionList: z.array(z.string()).optional(),
    discoveryType: InputEdgePrometheusDiscoveryType$inboundSchema.default(
      "static",
    ),
    interval: z.number().default(15),
    timeout: z.number().default(5000),
    persistence: DiskSpoolingType$inboundSchema.optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
    authType: InputEdgePrometheusAuthenticationMethod$inboundSchema.default(
      "manual",
    ),
    description: z.string().optional(),
    targets: z.array(z.lazy(() => Target$inboundSchema)).optional(),
    recordType: RecordTypeOptions$inboundSchema.default("SRV"),
    scrapePort: z.number().default(9090),
    nameList: z.array(z.string()).optional(),
    scrapeProtocol: ProtocolOptionsTargetsItems$inboundSchema.default("http"),
    scrapePath: z.string().default("/metrics"),
    awsAuthenticationMethod: z.string().default("auto"),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    usePublicIp: z.boolean().default(true),
    searchFilter: z.array(ItemsTypeSearchFilter$inboundSchema).optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: SignatureVersionOptions1$inboundSchema.default("v4"),
    reuseConnections: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    enableAssumeRole: z.boolean().default(false),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().default(3600),
    scrapeProtocolExpr: z.string().default(
      "metadata.annotations['prometheus.io/scheme'] || 'http'",
    ),
    scrapePortExpr: z.string().default(
      "metadata.annotations['prometheus.io/port'] || 9090",
    ),
    scrapePathExpr: z.string().default(
      "metadata.annotations['prometheus.io/path'] || '/metrics'",
    ),
    podFilter: z.array(z.lazy(() => PodFilter$inboundSchema)).optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
  });
/** @internal */
export type InputEdgePrometheusInputCollectionPart0Type1$Outbound = {
  pqEnabled: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ItemsTypeConnections$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  dimensionList?: Array<string> | undefined;
  discoveryType: string;
  interval: number;
  timeout: number;
  persistence?: DiskSpoolingType$Outbound | undefined;
  metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
  authType: string;
  description?: string | undefined;
  targets?: Array<Target$Outbound> | undefined;
  recordType: string;
  scrapePort: number;
  nameList?: Array<string> | undefined;
  scrapeProtocol: string;
  scrapePath: string;
  awsAuthenticationMethod: string;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  usePublicIp: boolean;
  searchFilter?: Array<ItemsTypeSearchFilter$Outbound> | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  scrapeProtocolExpr: string;
  scrapePortExpr: string;
  scrapePathExpr: string;
  podFilter?: Array<PodFilter$Outbound> | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputEdgePrometheusInputCollectionPart0Type1$outboundSchema:
  z.ZodType<
    InputEdgePrometheusInputCollectionPart0Type1$Outbound,
    z.ZodTypeDef,
    InputEdgePrometheusInputCollectionPart0Type1
  > = z.object({
    pqEnabled: z.boolean().default(false),
    id: z.string().optional(),
    type: InputEdgePrometheusType$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnections$outboundSchema).optional(),
    pq: PqType$outboundSchema.optional(),
    dimensionList: z.array(z.string()).optional(),
    discoveryType: InputEdgePrometheusDiscoveryType$outboundSchema.default(
      "static",
    ),
    interval: z.number().default(15),
    timeout: z.number().default(5000),
    persistence: DiskSpoolingType$outboundSchema.optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
    authType: InputEdgePrometheusAuthenticationMethod$outboundSchema.default(
      "manual",
    ),
    description: z.string().optional(),
    targets: z.array(z.lazy(() => Target$outboundSchema)).optional(),
    recordType: RecordTypeOptions$outboundSchema.default("SRV"),
    scrapePort: z.number().default(9090),
    nameList: z.array(z.string()).optional(),
    scrapeProtocol: ProtocolOptionsTargetsItems$outboundSchema.default("http"),
    scrapePath: z.string().default("/metrics"),
    awsAuthenticationMethod: z.string().default("auto"),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    usePublicIp: z.boolean().default(true),
    searchFilter: z.array(ItemsTypeSearchFilter$outboundSchema).optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: SignatureVersionOptions1$outboundSchema.default("v4"),
    reuseConnections: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    enableAssumeRole: z.boolean().default(false),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().default(3600),
    scrapeProtocolExpr: z.string().default(
      "metadata.annotations['prometheus.io/scheme'] || 'http'",
    ),
    scrapePortExpr: z.string().default(
      "metadata.annotations['prometheus.io/port'] || 9090",
    ),
    scrapePathExpr: z.string().default(
      "metadata.annotations['prometheus.io/path'] || '/metrics'",
    ),
    podFilter: z.array(z.lazy(() => PodFilter$outboundSchema)).optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
  });

export function inputEdgePrometheusInputCollectionPart0Type1ToJSON(
  inputEdgePrometheusInputCollectionPart0Type1:
    InputEdgePrometheusInputCollectionPart0Type1,
): string {
  return JSON.stringify(
    InputEdgePrometheusInputCollectionPart0Type1$outboundSchema.parse(
      inputEdgePrometheusInputCollectionPart0Type1,
    ),
  );
}
export function inputEdgePrometheusInputCollectionPart0Type1FromJSON(
  jsonString: string,
): SafeParseResult<
  InputEdgePrometheusInputCollectionPart0Type1,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputEdgePrometheusInputCollectionPart0Type1$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputEdgePrometheusInputCollectionPart0Type1' from JSON`,
  );
}

/** @internal */
export const InputEdgePrometheusInputCollectionPart1Type$inboundSchema:
  z.ZodType<
    InputEdgePrometheusInputCollectionPart1Type,
    z.ZodTypeDef,
    unknown
  > = z.object({
    sendToRoutes: z.boolean().default(true),
    connections: z.array(ItemsTypeConnections$inboundSchema).optional(),
    id: z.string().optional(),
    type: InputEdgePrometheusType$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    pq: PqType$inboundSchema.optional(),
    dimensionList: z.array(z.string()).optional(),
    discoveryType: InputEdgePrometheusDiscoveryType$inboundSchema.default(
      "static",
    ),
    interval: z.number().default(15),
    timeout: z.number().default(5000),
    persistence: DiskSpoolingType$inboundSchema.optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
    authType: InputEdgePrometheusAuthenticationMethod$inboundSchema.default(
      "manual",
    ),
    description: z.string().optional(),
    targets: z.array(z.lazy(() => Target$inboundSchema)).optional(),
    recordType: RecordTypeOptions$inboundSchema.default("SRV"),
    scrapePort: z.number().default(9090),
    nameList: z.array(z.string()).optional(),
    scrapeProtocol: ProtocolOptionsTargetsItems$inboundSchema.default("http"),
    scrapePath: z.string().default("/metrics"),
    awsAuthenticationMethod: z.string().default("auto"),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    usePublicIp: z.boolean().default(true),
    searchFilter: z.array(ItemsTypeSearchFilter$inboundSchema).optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: SignatureVersionOptions1$inboundSchema.default("v4"),
    reuseConnections: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    enableAssumeRole: z.boolean().default(false),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().default(3600),
    scrapeProtocolExpr: z.string().default(
      "metadata.annotations['prometheus.io/scheme'] || 'http'",
    ),
    scrapePortExpr: z.string().default(
      "metadata.annotations['prometheus.io/port'] || 9090",
    ),
    scrapePathExpr: z.string().default(
      "metadata.annotations['prometheus.io/path'] || '/metrics'",
    ),
    podFilter: z.array(z.lazy(() => PodFilter$inboundSchema)).optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
  });
/** @internal */
export type InputEdgePrometheusInputCollectionPart1Type$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<ItemsTypeConnections$Outbound> | undefined;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  pq?: PqType$Outbound | undefined;
  dimensionList?: Array<string> | undefined;
  discoveryType: string;
  interval: number;
  timeout: number;
  persistence?: DiskSpoolingType$Outbound | undefined;
  metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
  authType: string;
  description?: string | undefined;
  targets?: Array<Target$Outbound> | undefined;
  recordType: string;
  scrapePort: number;
  nameList?: Array<string> | undefined;
  scrapeProtocol: string;
  scrapePath: string;
  awsAuthenticationMethod: string;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  usePublicIp: boolean;
  searchFilter?: Array<ItemsTypeSearchFilter$Outbound> | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  scrapeProtocolExpr: string;
  scrapePortExpr: string;
  scrapePathExpr: string;
  podFilter?: Array<PodFilter$Outbound> | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputEdgePrometheusInputCollectionPart1Type$outboundSchema:
  z.ZodType<
    InputEdgePrometheusInputCollectionPart1Type$Outbound,
    z.ZodTypeDef,
    InputEdgePrometheusInputCollectionPart1Type
  > = z.object({
    sendToRoutes: z.boolean().default(true),
    connections: z.array(ItemsTypeConnections$outboundSchema).optional(),
    id: z.string().optional(),
    type: InputEdgePrometheusType$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    pq: PqType$outboundSchema.optional(),
    dimensionList: z.array(z.string()).optional(),
    discoveryType: InputEdgePrometheusDiscoveryType$outboundSchema.default(
      "static",
    ),
    interval: z.number().default(15),
    timeout: z.number().default(5000),
    persistence: DiskSpoolingType$outboundSchema.optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
    authType: InputEdgePrometheusAuthenticationMethod$outboundSchema.default(
      "manual",
    ),
    description: z.string().optional(),
    targets: z.array(z.lazy(() => Target$outboundSchema)).optional(),
    recordType: RecordTypeOptions$outboundSchema.default("SRV"),
    scrapePort: z.number().default(9090),
    nameList: z.array(z.string()).optional(),
    scrapeProtocol: ProtocolOptionsTargetsItems$outboundSchema.default("http"),
    scrapePath: z.string().default("/metrics"),
    awsAuthenticationMethod: z.string().default("auto"),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    usePublicIp: z.boolean().default(true),
    searchFilter: z.array(ItemsTypeSearchFilter$outboundSchema).optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: SignatureVersionOptions1$outboundSchema.default("v4"),
    reuseConnections: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    enableAssumeRole: z.boolean().default(false),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().default(3600),
    scrapeProtocolExpr: z.string().default(
      "metadata.annotations['prometheus.io/scheme'] || 'http'",
    ),
    scrapePortExpr: z.string().default(
      "metadata.annotations['prometheus.io/port'] || 9090",
    ),
    scrapePathExpr: z.string().default(
      "metadata.annotations['prometheus.io/path'] || '/metrics'",
    ),
    podFilter: z.array(z.lazy(() => PodFilter$outboundSchema)).optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
  });

export function inputEdgePrometheusInputCollectionPart1TypeToJSON(
  inputEdgePrometheusInputCollectionPart1Type:
    InputEdgePrometheusInputCollectionPart1Type,
): string {
  return JSON.stringify(
    InputEdgePrometheusInputCollectionPart1Type$outboundSchema.parse(
      inputEdgePrometheusInputCollectionPart1Type,
    ),
  );
}
export function inputEdgePrometheusInputCollectionPart1TypeFromJSON(
  jsonString: string,
): SafeParseResult<
  InputEdgePrometheusInputCollectionPart1Type,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputEdgePrometheusInputCollectionPart1Type$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputEdgePrometheusInputCollectionPart1Type' from JSON`,
  );
}

/** @internal */
export const InputEdgePrometheusInputCollectionPart0Type$inboundSchema:
  z.ZodType<
    InputEdgePrometheusInputCollectionPart0Type,
    z.ZodTypeDef,
    unknown
  > = z.object({
    sendToRoutes: z.boolean().default(true),
    id: z.string().optional(),
    type: InputEdgePrometheusType$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnections$inboundSchema).optional(),
    pq: PqType$inboundSchema.optional(),
    dimensionList: z.array(z.string()).optional(),
    discoveryType: InputEdgePrometheusDiscoveryType$inboundSchema.default(
      "static",
    ),
    interval: z.number().default(15),
    timeout: z.number().default(5000),
    persistence: DiskSpoolingType$inboundSchema.optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
    authType: InputEdgePrometheusAuthenticationMethod$inboundSchema.default(
      "manual",
    ),
    description: z.string().optional(),
    targets: z.array(z.lazy(() => Target$inboundSchema)).optional(),
    recordType: RecordTypeOptions$inboundSchema.default("SRV"),
    scrapePort: z.number().default(9090),
    nameList: z.array(z.string()).optional(),
    scrapeProtocol: ProtocolOptionsTargetsItems$inboundSchema.default("http"),
    scrapePath: z.string().default("/metrics"),
    awsAuthenticationMethod: z.string().default("auto"),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    usePublicIp: z.boolean().default(true),
    searchFilter: z.array(ItemsTypeSearchFilter$inboundSchema).optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: SignatureVersionOptions1$inboundSchema.default("v4"),
    reuseConnections: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    enableAssumeRole: z.boolean().default(false),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().default(3600),
    scrapeProtocolExpr: z.string().default(
      "metadata.annotations['prometheus.io/scheme'] || 'http'",
    ),
    scrapePortExpr: z.string().default(
      "metadata.annotations['prometheus.io/port'] || 9090",
    ),
    scrapePathExpr: z.string().default(
      "metadata.annotations['prometheus.io/path'] || '/metrics'",
    ),
    podFilter: z.array(z.lazy(() => PodFilter$inboundSchema)).optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
  });
/** @internal */
export type InputEdgePrometheusInputCollectionPart0Type$Outbound = {
  sendToRoutes: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ItemsTypeConnections$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  dimensionList?: Array<string> | undefined;
  discoveryType: string;
  interval: number;
  timeout: number;
  persistence?: DiskSpoolingType$Outbound | undefined;
  metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
  authType: string;
  description?: string | undefined;
  targets?: Array<Target$Outbound> | undefined;
  recordType: string;
  scrapePort: number;
  nameList?: Array<string> | undefined;
  scrapeProtocol: string;
  scrapePath: string;
  awsAuthenticationMethod: string;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  usePublicIp: boolean;
  searchFilter?: Array<ItemsTypeSearchFilter$Outbound> | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  scrapeProtocolExpr: string;
  scrapePortExpr: string;
  scrapePathExpr: string;
  podFilter?: Array<PodFilter$Outbound> | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputEdgePrometheusInputCollectionPart0Type$outboundSchema:
  z.ZodType<
    InputEdgePrometheusInputCollectionPart0Type$Outbound,
    z.ZodTypeDef,
    InputEdgePrometheusInputCollectionPart0Type
  > = z.object({
    sendToRoutes: z.boolean().default(true),
    id: z.string().optional(),
    type: InputEdgePrometheusType$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnections$outboundSchema).optional(),
    pq: PqType$outboundSchema.optional(),
    dimensionList: z.array(z.string()).optional(),
    discoveryType: InputEdgePrometheusDiscoveryType$outboundSchema.default(
      "static",
    ),
    interval: z.number().default(15),
    timeout: z.number().default(5000),
    persistence: DiskSpoolingType$outboundSchema.optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
    authType: InputEdgePrometheusAuthenticationMethod$outboundSchema.default(
      "manual",
    ),
    description: z.string().optional(),
    targets: z.array(z.lazy(() => Target$outboundSchema)).optional(),
    recordType: RecordTypeOptions$outboundSchema.default("SRV"),
    scrapePort: z.number().default(9090),
    nameList: z.array(z.string()).optional(),
    scrapeProtocol: ProtocolOptionsTargetsItems$outboundSchema.default("http"),
    scrapePath: z.string().default("/metrics"),
    awsAuthenticationMethod: z.string().default("auto"),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    usePublicIp: z.boolean().default(true),
    searchFilter: z.array(ItemsTypeSearchFilter$outboundSchema).optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: SignatureVersionOptions1$outboundSchema.default("v4"),
    reuseConnections: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    enableAssumeRole: z.boolean().default(false),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().default(3600),
    scrapeProtocolExpr: z.string().default(
      "metadata.annotations['prometheus.io/scheme'] || 'http'",
    ),
    scrapePortExpr: z.string().default(
      "metadata.annotations['prometheus.io/port'] || 9090",
    ),
    scrapePathExpr: z.string().default(
      "metadata.annotations['prometheus.io/path'] || '/metrics'",
    ),
    podFilter: z.array(z.lazy(() => PodFilter$outboundSchema)).optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
  });

export function inputEdgePrometheusInputCollectionPart0TypeToJSON(
  inputEdgePrometheusInputCollectionPart0Type:
    InputEdgePrometheusInputCollectionPart0Type,
): string {
  return JSON.stringify(
    InputEdgePrometheusInputCollectionPart0Type$outboundSchema.parse(
      inputEdgePrometheusInputCollectionPart0Type,
    ),
  );
}
export function inputEdgePrometheusInputCollectionPart0TypeFromJSON(
  jsonString: string,
): SafeParseResult<
  InputEdgePrometheusInputCollectionPart0Type,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputEdgePrometheusInputCollectionPart0Type$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputEdgePrometheusInputCollectionPart0Type' from JSON`,
  );
}

/** @internal */
export const InputEdgePrometheus$inboundSchema: z.ZodType<
  InputEdgePrometheus,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => InputEdgePrometheusInputCollectionPart0Type$inboundSchema),
  z.lazy(() => InputEdgePrometheusInputCollectionPart1Type$inboundSchema),
  z.lazy(() => InputEdgePrometheusInputCollectionPart0Type1$inboundSchema),
  z.lazy(() => InputEdgePrometheusInputCollectionPart1Type1$inboundSchema),
]);
/** @internal */
export type InputEdgePrometheus$Outbound =
  | InputEdgePrometheusInputCollectionPart0Type$Outbound
  | InputEdgePrometheusInputCollectionPart1Type$Outbound
  | InputEdgePrometheusInputCollectionPart0Type1$Outbound
  | InputEdgePrometheusInputCollectionPart1Type1$Outbound;

/** @internal */
export const InputEdgePrometheus$outboundSchema: z.ZodType<
  InputEdgePrometheus$Outbound,
  z.ZodTypeDef,
  InputEdgePrometheus
> = z.union([
  z.lazy(() => InputEdgePrometheusInputCollectionPart0Type$outboundSchema),
  z.lazy(() => InputEdgePrometheusInputCollectionPart1Type$outboundSchema),
  z.lazy(() => InputEdgePrometheusInputCollectionPart0Type1$outboundSchema),
  z.lazy(() => InputEdgePrometheusInputCollectionPart1Type1$outboundSchema),
]);

export function inputEdgePrometheusToJSON(
  inputEdgePrometheus: InputEdgePrometheus,
): string {
  return JSON.stringify(
    InputEdgePrometheus$outboundSchema.parse(inputEdgePrometheus),
  );
}
export function inputEdgePrometheusFromJSON(
  jsonString: string,
): SafeParseResult<InputEdgePrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputEdgePrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputEdgePrometheus' from JSON`,
  );
}
