/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

/**
 * Credentials to use when authenticating with the schema registry using basic HTTP authentication
 */
export type KafkaSchemaRegistryTypeAuth = {
  disabled?: boolean | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export const KafkaSchemaRegistryTypeMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type KafkaSchemaRegistryTypeMinimumTLSVersion = OpenEnum<
  typeof KafkaSchemaRegistryTypeMinimumTLSVersion
>;

export const KafkaSchemaRegistryTypeMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type KafkaSchemaRegistryTypeMaximumTLSVersion = OpenEnum<
  typeof KafkaSchemaRegistryTypeMaximumTLSVersion
>;

export type KafkaSchemaRegistryTypeTLSSettingsClientSide = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: KafkaSchemaRegistryTypeMinimumTLSVersion | undefined;
  maxVersion?: KafkaSchemaRegistryTypeMaximumTLSVersion | undefined;
};

export type KafkaSchemaRegistryType = {
  disabled?: boolean | undefined;
  /**
   * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http.
   */
  schemaRegistryURL?: string | undefined;
  /**
   * Maximum time to wait for a Schema Registry connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for the Schema Registry to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * Maximum number of times to try fetching schemas from the Schema Registry
   */
  maxRetries?: number | undefined;
  /**
   * Credentials to use when authenticating with the schema registry using basic HTTP authentication
   */
  auth?: KafkaSchemaRegistryTypeAuth | undefined;
  tls?: KafkaSchemaRegistryTypeTLSSettingsClientSide | undefined;
};

/** @internal */
export const KafkaSchemaRegistryTypeAuth$inboundSchema: z.ZodType<
  KafkaSchemaRegistryTypeAuth,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});
/** @internal */
export type KafkaSchemaRegistryTypeAuth$Outbound = {
  disabled: boolean;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const KafkaSchemaRegistryTypeAuth$outboundSchema: z.ZodType<
  KafkaSchemaRegistryTypeAuth$Outbound,
  z.ZodTypeDef,
  KafkaSchemaRegistryTypeAuth
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

export function kafkaSchemaRegistryTypeAuthToJSON(
  kafkaSchemaRegistryTypeAuth: KafkaSchemaRegistryTypeAuth,
): string {
  return JSON.stringify(
    KafkaSchemaRegistryTypeAuth$outboundSchema.parse(
      kafkaSchemaRegistryTypeAuth,
    ),
  );
}
export function kafkaSchemaRegistryTypeAuthFromJSON(
  jsonString: string,
): SafeParseResult<KafkaSchemaRegistryTypeAuth, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KafkaSchemaRegistryTypeAuth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KafkaSchemaRegistryTypeAuth' from JSON`,
  );
}

/** @internal */
export const KafkaSchemaRegistryTypeMinimumTLSVersion$inboundSchema: z.ZodType<
  KafkaSchemaRegistryTypeMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(KafkaSchemaRegistryTypeMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const KafkaSchemaRegistryTypeMinimumTLSVersion$outboundSchema: z.ZodType<
  KafkaSchemaRegistryTypeMinimumTLSVersion,
  z.ZodTypeDef,
  KafkaSchemaRegistryTypeMinimumTLSVersion
> = z.union([
  z.nativeEnum(KafkaSchemaRegistryTypeMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const KafkaSchemaRegistryTypeMaximumTLSVersion$inboundSchema: z.ZodType<
  KafkaSchemaRegistryTypeMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(KafkaSchemaRegistryTypeMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const KafkaSchemaRegistryTypeMaximumTLSVersion$outboundSchema: z.ZodType<
  KafkaSchemaRegistryTypeMaximumTLSVersion,
  z.ZodTypeDef,
  KafkaSchemaRegistryTypeMaximumTLSVersion
> = z.union([
  z.nativeEnum(KafkaSchemaRegistryTypeMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const KafkaSchemaRegistryTypeTLSSettingsClientSide$inboundSchema:
  z.ZodType<
    KafkaSchemaRegistryTypeTLSSettingsClientSide,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion: KafkaSchemaRegistryTypeMinimumTLSVersion$inboundSchema
      .optional(),
    maxVersion: KafkaSchemaRegistryTypeMaximumTLSVersion$inboundSchema
      .optional(),
  });
/** @internal */
export type KafkaSchemaRegistryTypeTLSSettingsClientSide$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const KafkaSchemaRegistryTypeTLSSettingsClientSide$outboundSchema:
  z.ZodType<
    KafkaSchemaRegistryTypeTLSSettingsClientSide$Outbound,
    z.ZodTypeDef,
    KafkaSchemaRegistryTypeTLSSettingsClientSide
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion: KafkaSchemaRegistryTypeMinimumTLSVersion$outboundSchema
      .optional(),
    maxVersion: KafkaSchemaRegistryTypeMaximumTLSVersion$outboundSchema
      .optional(),
  });

export function kafkaSchemaRegistryTypeTLSSettingsClientSideToJSON(
  kafkaSchemaRegistryTypeTLSSettingsClientSide:
    KafkaSchemaRegistryTypeTLSSettingsClientSide,
): string {
  return JSON.stringify(
    KafkaSchemaRegistryTypeTLSSettingsClientSide$outboundSchema.parse(
      kafkaSchemaRegistryTypeTLSSettingsClientSide,
    ),
  );
}
export function kafkaSchemaRegistryTypeTLSSettingsClientSideFromJSON(
  jsonString: string,
): SafeParseResult<
  KafkaSchemaRegistryTypeTLSSettingsClientSide,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      KafkaSchemaRegistryTypeTLSSettingsClientSide$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'KafkaSchemaRegistryTypeTLSSettingsClientSide' from JSON`,
  );
}

/** @internal */
export const KafkaSchemaRegistryType$inboundSchema: z.ZodType<
  KafkaSchemaRegistryType,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  schemaRegistryURL: z.string().default("http://localhost:8081"),
  connectionTimeout: z.number().default(30000),
  requestTimeout: z.number().default(30000),
  maxRetries: z.number().default(1),
  auth: z.lazy(() => KafkaSchemaRegistryTypeAuth$inboundSchema).optional(),
  tls: z.lazy(() => KafkaSchemaRegistryTypeTLSSettingsClientSide$inboundSchema)
    .optional(),
});
/** @internal */
export type KafkaSchemaRegistryType$Outbound = {
  disabled: boolean;
  schemaRegistryURL: string;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  auth?: KafkaSchemaRegistryTypeAuth$Outbound | undefined;
  tls?: KafkaSchemaRegistryTypeTLSSettingsClientSide$Outbound | undefined;
};

/** @internal */
export const KafkaSchemaRegistryType$outboundSchema: z.ZodType<
  KafkaSchemaRegistryType$Outbound,
  z.ZodTypeDef,
  KafkaSchemaRegistryType
> = z.object({
  disabled: z.boolean().default(true),
  schemaRegistryURL: z.string().default("http://localhost:8081"),
  connectionTimeout: z.number().default(30000),
  requestTimeout: z.number().default(30000),
  maxRetries: z.number().default(1),
  auth: z.lazy(() => KafkaSchemaRegistryTypeAuth$outboundSchema).optional(),
  tls: z.lazy(() => KafkaSchemaRegistryTypeTLSSettingsClientSide$outboundSchema)
    .optional(),
});

export function kafkaSchemaRegistryTypeToJSON(
  kafkaSchemaRegistryType: KafkaSchemaRegistryType,
): string {
  return JSON.stringify(
    KafkaSchemaRegistryType$outboundSchema.parse(kafkaSchemaRegistryType),
  );
}
export function kafkaSchemaRegistryTypeFromJSON(
  jsonString: string,
): SafeParseResult<KafkaSchemaRegistryType, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KafkaSchemaRegistryType$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KafkaSchemaRegistryType' from JSON`,
  );
}
