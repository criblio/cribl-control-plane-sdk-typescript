/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const CollectorDatabaseHiddenDefaultBreakers = {
  Cribl: "Cribl",
} as const;
export type CollectorDatabaseHiddenDefaultBreakers = OpenEnum<
  typeof CollectorDatabaseHiddenDefaultBreakers
>;

export type CollectorDatabaseStateTracking = {
  /**
   * Enable tracking of collection progress between consecutive scheduled executions.
   */
  enabled?: boolean | undefined;
};

export type CollectorDatabaseScheduling = {
  stateTracking?: CollectorDatabaseStateTracking | undefined;
};

export type CollectorDatabase = {
  /**
   * Collector type: database
   */
  type: "database";
  /**
   * Select an existing Connection, or go to Knowledge > Database Connections to add one
   */
  connectionId: string;
  /**
   * An expression that resolves to the query string for selecting data from the database. Has access to the special ${earliest} and ${latest} variables, which will resolve to the Collector run's start and end time.
   */
  query: string;
  /**
   * Enforces a basic query validation that allows only a single 'select' statement. Disable for more complex queries or when using semicolons. Caution: Disabling query validation allows DDL and DML statements to be executed, which could be destructive to your database.
   */
  queryValidationEnabled?: boolean | undefined;
  defaultBreakers?: CollectorDatabaseHiddenDefaultBreakers | undefined;
  scheduling?: CollectorDatabaseScheduling | undefined;
};

/** @internal */
export const CollectorDatabaseHiddenDefaultBreakers$inboundSchema: z.ZodType<
  CollectorDatabaseHiddenDefaultBreakers,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorDatabaseHiddenDefaultBreakers);
/** @internal */
export const CollectorDatabaseHiddenDefaultBreakers$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorDatabaseHiddenDefaultBreakers
> = openEnums.outboundSchema(CollectorDatabaseHiddenDefaultBreakers);

/** @internal */
export const CollectorDatabaseStateTracking$inboundSchema: z.ZodType<
  CollectorDatabaseStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type CollectorDatabaseStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const CollectorDatabaseStateTracking$outboundSchema: z.ZodType<
  CollectorDatabaseStateTracking$Outbound,
  z.ZodTypeDef,
  CollectorDatabaseStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function collectorDatabaseStateTrackingToJSON(
  collectorDatabaseStateTracking: CollectorDatabaseStateTracking,
): string {
  return JSON.stringify(
    CollectorDatabaseStateTracking$outboundSchema.parse(
      collectorDatabaseStateTracking,
    ),
  );
}
export function collectorDatabaseStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<CollectorDatabaseStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorDatabaseStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorDatabaseStateTracking' from JSON`,
  );
}

/** @internal */
export const CollectorDatabaseScheduling$inboundSchema: z.ZodType<
  CollectorDatabaseScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: z.lazy(() => CollectorDatabaseStateTracking$inboundSchema)
    .optional(),
});
/** @internal */
export type CollectorDatabaseScheduling$Outbound = {
  stateTracking?: CollectorDatabaseStateTracking$Outbound | undefined;
};

/** @internal */
export const CollectorDatabaseScheduling$outboundSchema: z.ZodType<
  CollectorDatabaseScheduling$Outbound,
  z.ZodTypeDef,
  CollectorDatabaseScheduling
> = z.object({
  stateTracking: z.lazy(() => CollectorDatabaseStateTracking$outboundSchema)
    .optional(),
});

export function collectorDatabaseSchedulingToJSON(
  collectorDatabaseScheduling: CollectorDatabaseScheduling,
): string {
  return JSON.stringify(
    CollectorDatabaseScheduling$outboundSchema.parse(
      collectorDatabaseScheduling,
    ),
  );
}
export function collectorDatabaseSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<CollectorDatabaseScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorDatabaseScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorDatabaseScheduling' from JSON`,
  );
}

/** @internal */
export const CollectorDatabase$inboundSchema: z.ZodType<
  CollectorDatabase,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("database"),
  connectionId: z.string(),
  query: z.string(),
  queryValidationEnabled: z.boolean().default(true),
  defaultBreakers: CollectorDatabaseHiddenDefaultBreakers$inboundSchema
    .optional(),
  __scheduling: z.lazy(() => CollectorDatabaseScheduling$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "__scheduling": "scheduling",
  });
});
/** @internal */
export type CollectorDatabase$Outbound = {
  type: "database";
  connectionId: string;
  query: string;
  queryValidationEnabled: boolean;
  defaultBreakers?: string | undefined;
  __scheduling?: CollectorDatabaseScheduling$Outbound | undefined;
};

/** @internal */
export const CollectorDatabase$outboundSchema: z.ZodType<
  CollectorDatabase$Outbound,
  z.ZodTypeDef,
  CollectorDatabase
> = z.object({
  type: z.literal("database"),
  connectionId: z.string(),
  query: z.string(),
  queryValidationEnabled: z.boolean().default(true),
  defaultBreakers: CollectorDatabaseHiddenDefaultBreakers$outboundSchema
    .optional(),
  scheduling: z.lazy(() => CollectorDatabaseScheduling$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    scheduling: "__scheduling",
  });
});

export function collectorDatabaseToJSON(
  collectorDatabase: CollectorDatabase,
): string {
  return JSON.stringify(
    CollectorDatabase$outboundSchema.parse(collectorDatabase),
  );
}
export function collectorDatabaseFromJSON(
  jsonString: string,
): SafeParseResult<CollectorDatabase, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorDatabase$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorDatabase' from JSON`,
  );
}
