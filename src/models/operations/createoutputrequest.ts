/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import * as openEnums from "../../types/enums.js";
import { OpenEnum } from "../../types/enums.js";
import * as models from "../index.js";
import {
  AuthenticationMethodAzureLogs,
  AuthenticationMethodAzureLogs$outboundSchema,
  OutputAzureEventhub,
  OutputAzureEventhub$Outbound,
  OutputAzureEventhub$outboundSchema,
  OutputChronicle,
  OutputChronicle$Outbound,
  OutputChronicle$outboundSchema,
  OutputClickHouse,
  OutputClickHouse$Outbound,
  OutputClickHouse$outboundSchema,
  OutputCloudflareR2,
  OutputCloudflareR2$Outbound,
  OutputCloudflareR2$outboundSchema,
  OutputCloudwatch,
  OutputCloudwatch$Outbound,
  OutputCloudwatch$outboundSchema,
  OutputConfluentCloud,
  OutputConfluentCloud$Outbound,
  OutputConfluentCloud$outboundSchema,
  OutputCriblHttp,
  OutputCriblHttp$Outbound,
  OutputCriblHttp$outboundSchema,
  OutputCriblLake,
  OutputCriblLake$Outbound,
  OutputCriblLake$outboundSchema,
  OutputCriblSearchEngine,
  OutputCriblSearchEngine$Outbound,
  OutputCriblSearchEngine$outboundSchema,
  OutputCriblTcp,
  OutputCriblTcp$Outbound,
  OutputCriblTcp$outboundSchema,
  OutputCrowdstrikeNextGenSiem,
  OutputCrowdstrikeNextGenSiem$Outbound,
  OutputCrowdstrikeNextGenSiem$outboundSchema,
  OutputDatabricks,
  OutputDatabricks$Outbound,
  OutputDatabricks$outboundSchema,
  OutputDatadog,
  OutputDatadog$Outbound,
  OutputDatadog$outboundSchema,
  OutputDataset,
  OutputDataset$Outbound,
  OutputDataset$outboundSchema,
  OutputDiskSpool,
  OutputDiskSpool$Outbound,
  OutputDiskSpool$outboundSchema,
  OutputDlS3,
  OutputDlS3$Outbound,
  OutputDlS3$outboundSchema,
  OutputDynatraceHttp,
  OutputDynatraceHttp$Outbound,
  OutputDynatraceHttp$outboundSchema,
  OutputDynatraceOtlp,
  OutputDynatraceOtlp$Outbound,
  OutputDynatraceOtlp$outboundSchema,
  OutputElastic,
  OutputElastic$Outbound,
  OutputElastic$outboundSchema,
  OutputElasticCloud,
  OutputElasticCloud$Outbound,
  OutputElasticCloud$outboundSchema,
  OutputExabeam,
  OutputExabeam$Outbound,
  OutputExabeam$outboundSchema,
  OutputGoogleChronicle,
  OutputGoogleChronicle$Outbound,
  OutputGoogleChronicle$outboundSchema,
  OutputGoogleCloudLogging,
  OutputGoogleCloudLogging$Outbound,
  OutputGoogleCloudLogging$outboundSchema,
  OutputGoogleCloudStorage,
  OutputGoogleCloudStorage$Outbound,
  OutputGoogleCloudStorage$outboundSchema,
  OutputGooglePubsub,
  OutputGooglePubsub$Outbound,
  OutputGooglePubsub$outboundSchema,
  OutputGrafanaCloud,
  OutputGrafanaCloud$Outbound,
  OutputGrafanaCloud$outboundSchema,
  OutputGraphite,
  OutputGraphite$Outbound,
  OutputGraphite$outboundSchema,
  OutputHoneycomb,
  OutputHoneycomb$Outbound,
  OutputHoneycomb$outboundSchema,
  OutputHumioHec,
  OutputHumioHec$Outbound,
  OutputHumioHec$outboundSchema,
  OutputInfluxdb,
  OutputInfluxdb$Outbound,
  OutputInfluxdb$outboundSchema,
  OutputKafka,
  OutputKafka$Outbound,
  OutputKafka$outboundSchema,
  OutputKinesis,
  OutputKinesis$Outbound,
  OutputKinesis$outboundSchema,
  OutputLoki,
  OutputLoki$Outbound,
  OutputLoki$outboundSchema,
  OutputMicrosoftFabric,
  OutputMicrosoftFabric$Outbound,
  OutputMicrosoftFabric$outboundSchema,
  OutputMinio,
  OutputMinio$Outbound,
  OutputMinio$outboundSchema,
  OutputMsk,
  OutputMsk$Outbound,
  OutputMsk$outboundSchema,
  OutputNetflow,
  OutputNetflow$Outbound,
  OutputNetflow$outboundSchema,
  OutputNewrelic,
  OutputNewrelic$Outbound,
  OutputNewrelic$outboundSchema,
  OutputNewrelicEvents,
  OutputNewrelicEvents$Outbound,
  OutputNewrelicEvents$outboundSchema,
  OutputOpenTelemetry,
  OutputOpenTelemetry$Outbound,
  OutputOpenTelemetry$outboundSchema,
  OutputPrometheus,
  OutputPrometheus$Outbound,
  OutputPrometheus$outboundSchema,
  OutputRing,
  OutputRing$Outbound,
  OutputRing$outboundSchema,
  OutputRouter,
  OutputRouter$Outbound,
  OutputRouter$outboundSchema,
  OutputSecurityLake,
  OutputSecurityLake$Outbound,
  OutputSecurityLake$outboundSchema,
  OutputSentinelOneAiSiem,
  OutputSentinelOneAiSiem$Outbound,
  OutputSentinelOneAiSiem$outboundSchema,
  OutputServiceNow,
  OutputServiceNow$Outbound,
  OutputServiceNow$outboundSchema,
  OutputSnmp,
  OutputSnmp$Outbound,
  OutputSnmp$outboundSchema,
  OutputSns,
  OutputSns$Outbound,
  OutputSns$outboundSchema,
  OutputSqs,
  OutputSqs$Outbound,
  OutputSqs$outboundSchema,
  OutputStatsd,
  OutputStatsd$Outbound,
  OutputStatsd$outboundSchema,
  OutputStatsdExt,
  OutputStatsdExt$Outbound,
  OutputStatsdExt$outboundSchema,
  OutputSumoLogic,
  OutputSumoLogic$Outbound,
  OutputSumoLogic$outboundSchema,
  OutputXsiam,
  OutputXsiam$Outbound,
  OutputXsiam$outboundSchema,
  PqControlsAzureLogs,
  PqControlsAzureLogs$Outbound,
  PqControlsAzureLogs$outboundSchema,
} from "./pqcontrolsazurelogs.js";

export type OutputAzureLogs = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: "azure_logs";
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The Log Type of events sent to this LogAnalytics workspace. Defaults to `Cribl`. Use only letters, numbers, and `_` characters, and can't exceed 100 characters. Can be overwritten by event field __logType.
   */
  logType: string;
  /**
   * Optional Resource ID of the Azure resource to associate the data with. Can be overridden by the __resourceId event field. This ID populates the _ResourceId property, allowing the data to be included in resource-centric queries. If the ID is neither specified nor overridden, resource-centric queries will omit the data.
   */
  resourceId?: string | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<models.ItemsTypeExtraHttpHeaders> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: models.FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * The DNS name of the Log API endpoint that sends log data to a Log Analytics workspace in Azure Monitor. Defaults to .ods.opinsights.azure.com. @{product} will add a prefix and suffix to construct a URI in this format: <https://<Workspace_ID><your_DNS_name>/api/logs?api-version=<API version>.
   */
  apiUrl?: string | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<models.ItemsTypeResponseRetrySettings>
    | undefined;
  timeoutRetrySettings?: models.TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: models.BackpressureBehaviorOptions | undefined;
  /**
   * Enter workspace ID and workspace key directly, or select a stored secret
   */
  authType?: AuthenticationMethodAzureLogs | undefined;
  description?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: models.ModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: models.CompressionOptionsPq | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: models.QueueFullBehaviorOptions | undefined;
  pqControls?: PqControlsAzureLogs | undefined;
  /**
   * Azure Log Analytics Workspace ID. See Azure Dashboard Workspace > Advanced settings.
   */
  workspaceId?: string | undefined;
  /**
   * Azure Log Analytics Workspace Primary or Secondary Shared Key. See Azure Dashboard Workspace > Advanced settings.
   */
  workspaceKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  keypairSecret?: string | undefined;
};

export const IngestionMode = {
  /**
   * Batching
   */
  Batching: "batching",
  /**
   * Streaming
   */
  Streaming: "streaming",
} as const;
export type IngestionMode = OpenEnum<typeof IngestionMode>;

/**
 * The type of OAuth 2.0 client credentials grant flow to use
 */
export const OauthTypeAuthenticationMethod = {
  /**
   * Client secret
   */
  ClientSecret: "clientSecret",
  /**
   * Client secret (text secret)
   */
  ClientTextSecret: "clientTextSecret",
  /**
   * Certificate
   */
  Certificate: "certificate",
} as const;
/**
 * The type of OAuth 2.0 client credentials grant flow to use
 */
export type OauthTypeAuthenticationMethod = OpenEnum<
  typeof OauthTypeAuthenticationMethod
>;

export type Certificate = {
  /**
   * The certificate you registered as credentials for your app in the Azure portal
   */
  certificateName?: string | undefined;
};

export const PrefixOptional = {
  /**
   * drop-by
   */
  DropBy: "dropBy",
  /**
   * ingest-by
   */
  IngestBy: "ingestBy",
} as const;
export type PrefixOptional = OpenEnum<typeof PrefixOptional>;

export type ExtentTag = {
  prefix?: PrefixOptional | undefined;
  value: string;
};

export type IngestIfNotExist = {
  value: string;
};

/**
 * Level of ingestion status reporting. Defaults to FailuresOnly.
 */
export const ReportLevel = {
  /**
   * FailuresOnly
   */
  FailuresOnly: "failuresOnly",
  /**
   * DoNotReport
   */
  DoNotReport: "doNotReport",
  /**
   * FailuresAndSuccesses
   */
  FailuresAndSuccesses: "failuresAndSuccesses",
} as const;
/**
 * Level of ingestion status reporting. Defaults to FailuresOnly.
 */
export type ReportLevel = OpenEnum<typeof ReportLevel>;

/**
 * Target of the ingestion status reporting. Defaults to Queue.
 */
export const ReportMethod = {
  /**
   * Queue
   */
  Queue: "queue",
  /**
   * Table
   */
  Table: "table",
  /**
   * QueueAndTable
   */
  QueueAndTable: "queueAndTable",
} as const;
/**
 * Target of the ingestion status reporting. Defaults to Queue.
 */
export type ReportMethod = OpenEnum<typeof ReportMethod>;

export type AdditionalProperty = {
  key: string;
  value: string;
};

export type PqControlsAzureDataExplorer = {};

export type OutputAzureDataExplorer = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: "azure_data_explorer";
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The base URI for your cluster. Typically, `https://<cluster>.<region>.kusto.windows.net`.
   */
  clusterUrl: string;
  /**
   * Name of the database containing the table where data will be ingested
   */
  database: string;
  /**
   * Name of the table to ingest data into
   */
  table: string;
  /**
   * When saving or starting the Destination, validate the database name and credentials; also validate table name, except when creating a new table. Disable if your Azure app does not have both the Database Viewer and the Table Viewer role.
   */
  validateDatabaseSettings?: boolean | undefined;
  ingestMode?: IngestionMode | undefined;
  /**
   * Endpoint used to acquire authentication tokens from Azure
   */
  oauthEndpoint: models.MicrosoftEntraIdAuthenticationEndpointOptionsSasl;
  /**
   * Directory ID (tenant identifier) in Azure Active Directory
   */
  tenantId: string;
  /**
   * client_id to pass in the OAuth request parameter
   */
  clientId: string;
  /**
   * Scope to pass in the OAuth request parameter
   */
  scope: string;
  /**
   * The type of OAuth 2.0 client credentials grant flow to use
   */
  oauthType: OauthTypeAuthenticationMethod;
  description?: string | undefined;
  /**
   * The client secret that you generated for your app in the Azure portal
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  certificate?: Certificate | undefined;
  /**
   * Format of the output data
   */
  format?: models.DataFormatOptions | undefined;
  /**
   * Data compression format to apply to HTTP content before it is delivered
   */
  compress: models.CompressionOptions2;
  /**
   * Compression level to apply before moving files to final destination
   */
  compressionLevel?: models.CompressionLevelOptions | undefined;
  /**
   * Automatically calculate the schema based on the events of each Parquet file generated
   */
  automaticSchema?: boolean | undefined;
  /**
   * To add a new schema, navigate to Processing > Knowledge > Parquet Schemas
   */
  parquetSchema?: string | undefined;
  /**
   * Determines which data types are supported and how they are represented
   */
  parquetVersion?: models.ParquetVersionOptions | undefined;
  /**
   * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
   */
  parquetDataPageVersion?: models.DataPageVersionOptions | undefined;
  /**
   * The number of rows that every group will contain. The final group can contain a smaller number of rows.
   */
  parquetRowGroupLength?: number | undefined;
  /**
   * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
   */
  parquetPageSize?: string | undefined;
  /**
   * Log up to 3 rows that @{product} skips due to data mismatch
   */
  shouldLogInvalidRows?: boolean | undefined;
  /**
   * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
   */
  keyValueMetadata?: Array<models.ItemsTypeKeyValueMetadata> | undefined;
  /**
   * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
   */
  enableStatistics?: boolean | undefined;
  /**
   * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
   */
  enableWritePageIndex?: boolean | undefined;
  /**
   * Parquet tools can use the checksum of a Parquet page to verify data integrity
   */
  enablePageChecksum?: boolean | undefined;
  /**
   * Remove empty staging directories after moving files
   */
  removeEmptyDirs?: boolean | undefined;
  /**
   * How frequently, in seconds, to clean up empty directories
   */
  emptyDirCleanupSec?: number | undefined;
  /**
   * Number of directories to process in each batch during cleanup of empty directories. Minimum is 10, maximum is 10000. Higher values may require more memory.
   */
  directoryBatchSize?: number | undefined;
  /**
   * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors
   */
  deadletterEnabled?: boolean | undefined;
  /**
   * Storage location for files that fail to reach their final destination after maximum retries are exceeded
   */
  deadletterPath?: string | undefined;
  /**
   * The maximum number of times a file will attempt to move to its final destination before being dead-lettered
   */
  maxRetryNum?: number | undefined;
  /**
   * Send a JSON mapping object instead of specifying an existing named data mapping
   */
  isMappingObj?: boolean | undefined;
  /**
   * Enter a JSON object that defines your desired data mapping
   */
  mappingObj?: string | undefined;
  /**
   * Enter the name of a data mapping associated with your target table. Or, if incoming event and target table fields match exactly, you can leave the field empty.
   */
  mappingRef?: string | undefined;
  /**
   * The ingestion service URI for your cluster. Typically, `https://ingest-<cluster>.<region>.kusto.windows.net`.
   */
  ingestUrl?: string | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: models.BackpressureBehaviorOptions | undefined;
  /**
   * Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage.
   */
  stagePath?: string | undefined;
  /**
   * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
   */
  fileNameSuffix?: string | undefined;
  /**
   * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
   */
  maxFileSizeMB?: number | undefined;
  /**
   * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileOpenTimeSec?: number | undefined;
  /**
   * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileIdleTimeSec?: number | undefined;
  /**
   * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
   */
  maxOpenFiles?: number | undefined;
  /**
   * Maximum number of parts to upload in parallel per file
   */
  maxConcurrentFileParts?: number | undefined;
  /**
   * How to handle events when disk space is below the global 'Min free disk space' limit
   */
  onDiskFullBackpressure?: models.DiskSpaceProtectionOptions | undefined;
  /**
   * Add the Output ID value to staging location
   */
  addIdToStagePath?: boolean | undefined;
  retrySettings?: models.RetrySettingsType | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Bypass the data management service's aggregation mechanism
   */
  flushImmediately?: boolean | undefined;
  /**
   * Prevent blob deletion after ingestion is complete
   */
  retainBlobOnSuccess?: boolean | undefined;
  /**
   * Strings or tags associated with the extent (ingested data shard)
   */
  extentTags?: Array<ExtentTag> | undefined;
  /**
   * Prevents duplicate ingestion by verifying whether an extent with the specified ingest-by tag already exists
   */
  ingestIfNotExists?: Array<IngestIfNotExist> | undefined;
  /**
   * Level of ingestion status reporting. Defaults to FailuresOnly.
   */
  reportLevel?: ReportLevel | undefined;
  /**
   * Target of the ingestion status reporting. Defaults to Queue.
   */
  reportMethod?: ReportMethod | undefined;
  /**
   * Optionally, enter additional configuration properties to send to the ingestion service
   */
  additionalProperties?: Array<AdditionalProperty> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<models.ItemsTypeResponseRetrySettings>
    | undefined;
  timeoutRetrySettings?: models.TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: models.ModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: models.CompressionOptionsPq | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: models.QueueFullBehaviorOptions | undefined;
  pqControls?: PqControlsAzureDataExplorer | undefined;
};

export const BlobAccessTier = {
  /**
   * Default account access tier
   */
  Inferred: "Inferred",
  /**
   * Hot tier
   */
  Hot: "Hot",
  /**
   * Cool tier
   */
  Cool: "Cool",
  /**
   * Cold tier
   */
  Cold: "Cold",
  /**
   * Archive tier
   */
  Archive: "Archive",
} as const;
export type BlobAccessTier = OpenEnum<typeof BlobAccessTier>;

export type OutputAzureBlob = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: "azure_blob";
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env["CRIBL_WORKER_ID"]}`.
   */
  containerName: string;
  /**
   * Create the configured container in Azure Blob Storage if it does not already exist
   */
  createContainer?: boolean | undefined;
  /**
   * Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env["CRIBL_WORKER_ID"]}`.
   */
  destPath?: string | undefined;
  /**
   * Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage.
   */
  stagePath: string;
  /**
   * Add the Output ID value to staging location
   */
  addIdToStagePath?: boolean | undefined;
  /**
   * Maximum number of parts to upload in parallel per file
   */
  maxConcurrentFileParts?: number | undefined;
  /**
   * Remove empty staging directories after moving files
   */
  removeEmptyDirs?: boolean | undefined;
  /**
   * JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory.
   */
  partitionExpr?: string | undefined;
  /**
   * Format of the output data
   */
  format?: models.DataFormatOptions | undefined;
  /**
   * JavaScript expression to define the output filename prefix (can be constant)
   */
  baseFileName?: string | undefined;
  /**
   * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
   */
  fileNameSuffix?: string | undefined;
  /**
   * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
   */
  maxFileSizeMB?: number | undefined;
  /**
   * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileOpenTimeSec?: number | undefined;
  /**
   * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileIdleTimeSec?: number | undefined;
  /**
   * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
   */
  maxOpenFiles?: number | undefined;
  /**
   * If set, this line will be written to the beginning of each output file
   */
  headerLine?: string | undefined;
  /**
   * Buffer size used to write to a file
   */
  writeHighWaterMark?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: models.BackpressureBehaviorOptions1 | undefined;
  /**
   * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors
   */
  deadletterEnabled?: boolean | undefined;
  /**
   * How to handle events when disk space is below the global 'Min free disk space' limit
   */
  onDiskFullBackpressure?: models.DiskSpaceProtectionOptions | undefined;
  /**
   * Force all staged files to close during an orderly Node shutdown. This triggers immediate upload of in-progress data — regardless of idle time, file age, or size thresholds — to minimize data loss.
   */
  forceCloseOnShutdown?: boolean | undefined;
  retrySettings?: models.RetrySettingsType | undefined;
  authType?: models.AuthenticationMethodOptions | undefined;
  storageClass?: BlobAccessTier | undefined;
  description?: string | undefined;
  /**
   * Data compression format to apply to HTTP content before it is delivered
   */
  compress?: models.CompressionOptions2 | undefined;
  /**
   * Compression level to apply before moving files to final destination
   */
  compressionLevel?: models.CompressionLevelOptions | undefined;
  /**
   * Automatically calculate the schema based on the events of each Parquet file generated
   */
  automaticSchema?: boolean | undefined;
  /**
   * To add a new schema, navigate to Processing > Knowledge > Parquet Schemas
   */
  parquetSchema?: string | undefined;
  /**
   * Determines which data types are supported and how they are represented
   */
  parquetVersion?: models.ParquetVersionOptions | undefined;
  /**
   * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
   */
  parquetDataPageVersion?: models.DataPageVersionOptions | undefined;
  /**
   * The number of rows that every group will contain. The final group can contain a smaller number of rows.
   */
  parquetRowGroupLength?: number | undefined;
  /**
   * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
   */
  parquetPageSize?: string | undefined;
  /**
   * Log up to 3 rows that @{product} skips due to data mismatch
   */
  shouldLogInvalidRows?: boolean | undefined;
  /**
   * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
   */
  keyValueMetadata?: Array<models.ItemsTypeKeyValueMetadata> | undefined;
  /**
   * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
   */
  enableStatistics?: boolean | undefined;
  /**
   * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
   */
  enableWritePageIndex?: boolean | undefined;
  /**
   * Parquet tools can use the checksum of a Parquet page to verify data integrity
   */
  enablePageChecksum?: boolean | undefined;
  /**
   * How frequently, in seconds, to clean up empty directories
   */
  emptyDirCleanupSec?: number | undefined;
  /**
   * Number of directories to process in each batch during cleanup of empty directories. Minimum is 10, maximum is 10000. Higher values may require more memory.
   */
  directoryBatchSize?: number | undefined;
  /**
   * Storage location for files that fail to reach their final destination after maximum retries are exceeded
   */
  deadletterPath?: string | undefined;
  /**
   * The maximum number of times a file will attempt to move to its final destination before being dead-lettered
   */
  maxRetryNum?: number | undefined;
  /**
   * Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING.
   */
  connectionString?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * The name of your Azure storage account
   */
  storageAccountName?: string | undefined;
  /**
   * The service principal's tenant ID
   */
  tenantId?: string | undefined;
  /**
   * The service principal's client ID
   */
  clientId?: string | undefined;
  /**
   * The Azure cloud to use. Defaults to Azure Public Cloud.
   */
  azureCloud?: string | undefined;
  /**
   * Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net.
   */
  endpointSuffix?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  clientTextSecret?: string | undefined;
  certificate?: models.CertificateTypeAzureBlobAuthTypeClientCert | undefined;
};

export type OutputS3 = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: "s3";
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Name of the destination S3 bucket. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`
   */
  bucket: string;
  /**
   * Region where the S3 bucket is located
   */
  region?: string | undefined;
  /**
   * Secret key. This value can be a constant or a JavaScript expression. Example: `${C.env.SOME_SECRET}`)
   */
  awsSecretKey?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: models.SignatureVersionOptionsS3CollectorConf | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant and stable storage.
   */
  stagePath: string;
  /**
   * Add the Output ID value to staging location
   */
  addIdToStagePath?: boolean | undefined;
  /**
   * Prefix to prepend to files before uploading. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myKeyPrefix-${C.vars.myVar}`
   */
  destPath?: string | undefined;
  /**
   * Object ACL to assign to uploaded objects
   */
  objectACL?: models.ObjectAclOptions | undefined;
  /**
   * Storage class to select for uploaded objects
   */
  storageClass?: models.StorageClassOptions | undefined;
  serverSideEncryption?:
    | models.ServerSideEncryptionForUploadedObjectsOptions
    | undefined;
  /**
   * ID or ARN of the KMS customer-managed key to use for encryption
   */
  kmsKeyId?: string | undefined;
  /**
   * Remove empty staging directories after moving files
   */
  removeEmptyDirs?: boolean | undefined;
  /**
   * JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory.
   */
  partitionExpr?: string | undefined;
  /**
   * Format of the output data
   */
  format?: models.DataFormatOptions | undefined;
  /**
   * JavaScript expression to define the output filename prefix (can be constant)
   */
  baseFileName?: string | undefined;
  /**
   * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
   */
  fileNameSuffix?: string | undefined;
  /**
   * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
   */
  maxFileSizeMB?: number | undefined;
  /**
   * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
   */
  maxOpenFiles?: number | undefined;
  /**
   * If set, this line will be written to the beginning of each output file
   */
  headerLine?: string | undefined;
  /**
   * Buffer size used to write to a file
   */
  writeHighWaterMark?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: models.BackpressureBehaviorOptions1 | undefined;
  /**
   * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors
   */
  deadletterEnabled?: boolean | undefined;
  /**
   * How to handle events when disk space is below the global 'Min free disk space' limit
   */
  onDiskFullBackpressure?: models.DiskSpaceProtectionOptions | undefined;
  /**
   * Force all staged files to close during an orderly Node shutdown. This triggers immediate upload of in-progress data — regardless of idle time, file age, or size thresholds — to minimize data loss.
   */
  forceCloseOnShutdown?: boolean | undefined;
  retrySettings?: models.RetrySettingsType | undefined;
  /**
   * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileOpenTimeSec?: number | undefined;
  /**
   * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileIdleTimeSec?: number | undefined;
  /**
   * Maximum number of parts to upload in parallel per file. Minimum part size is 5MB.
   */
  maxConcurrentFileParts?: number | undefined;
  /**
   * Disable if you can access files within the bucket but not the bucket itself
   */
  verifyPermissions?: boolean | undefined;
  /**
   * Maximum number of files that can be waiting for upload before backpressure is applied
   */
  maxClosingFilesToBackpressure?: number | undefined;
  description?: string | undefined;
  /**
   * This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)
   */
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Data compression format to apply to HTTP content before it is delivered
   */
  compress?: models.CompressionOptions2 | undefined;
  /**
   * Compression level to apply before moving files to final destination
   */
  compressionLevel?: models.CompressionLevelOptions | undefined;
  /**
   * Automatically calculate the schema based on the events of each Parquet file generated
   */
  automaticSchema?: boolean | undefined;
  /**
   * To add a new schema, navigate to Processing > Knowledge > Parquet Schemas
   */
  parquetSchema?: string | undefined;
  /**
   * Determines which data types are supported and how they are represented
   */
  parquetVersion?: models.ParquetVersionOptions | undefined;
  /**
   * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
   */
  parquetDataPageVersion?: models.DataPageVersionOptions | undefined;
  /**
   * The number of rows that every group will contain. The final group can contain a smaller number of rows.
   */
  parquetRowGroupLength?: number | undefined;
  /**
   * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
   */
  parquetPageSize?: string | undefined;
  /**
   * Log up to 3 rows that @{product} skips due to data mismatch
   */
  shouldLogInvalidRows?: boolean | undefined;
  /**
   * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
   */
  keyValueMetadata?: Array<models.ItemsTypeKeyValueMetadata> | undefined;
  /**
   * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
   */
  enableStatistics?: boolean | undefined;
  /**
   * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
   */
  enableWritePageIndex?: boolean | undefined;
  /**
   * Parquet tools can use the checksum of a Parquet page to verify data integrity
   */
  enablePageChecksum?: boolean | undefined;
  /**
   * How frequently, in seconds, to clean up empty directories
   */
  emptyDirCleanupSec?: number | undefined;
  /**
   * Number of directories to process in each batch during cleanup of empty directories. Minimum is 10, maximum is 10000. Higher values may require more memory.
   */
  directoryBatchSize?: number | undefined;
  /**
   * Storage location for files that fail to reach their final destination after maximum retries are exceeded
   */
  deadletterPath?: string | undefined;
  /**
   * The maximum number of times a file will attempt to move to its final destination before being dead-lettered
   */
  maxRetryNum?: number | undefined;
};

export type OutputFilesystem = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: "filesystem";
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Final destination for the output files
   */
  destPath: string;
  /**
   * Filesystem location in which to buffer files before compressing and moving to final destination. Use performant, stable storage.
   */
  stagePath?: string | undefined;
  /**
   * Add the Output ID value to staging location
   */
  addIdToStagePath?: boolean | undefined;
  /**
   * Remove empty staging directories after moving files
   */
  removeEmptyDirs?: boolean | undefined;
  /**
   * JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory.
   */
  partitionExpr?: string | undefined;
  /**
   * Format of the output data
   */
  format?: models.DataFormatOptions | undefined;
  /**
   * JavaScript expression to define the output filename prefix (can be constant)
   */
  baseFileName?: string | undefined;
  /**
   * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
   */
  fileNameSuffix?: string | undefined;
  /**
   * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
   */
  maxFileSizeMB?: number | undefined;
  /**
   * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileOpenTimeSec?: number | undefined;
  /**
   * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
   */
  maxFileIdleTimeSec?: number | undefined;
  /**
   * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
   */
  maxOpenFiles?: number | undefined;
  /**
   * If set, this line will be written to the beginning of each output file
   */
  headerLine?: string | undefined;
  /**
   * Buffer size used to write to a file
   */
  writeHighWaterMark?: number | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: models.BackpressureBehaviorOptions1 | undefined;
  /**
   * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors
   */
  deadletterEnabled?: boolean | undefined;
  /**
   * How to handle events when disk space is below the global 'Min free disk space' limit
   */
  onDiskFullBackpressure?: models.DiskSpaceProtectionOptions | undefined;
  /**
   * Force all staged files to close during an orderly Node shutdown. This triggers immediate upload of in-progress data — regardless of idle time, file age, or size thresholds — to minimize data loss.
   */
  forceCloseOnShutdown?: boolean | undefined;
  retrySettings?: models.RetrySettingsType | undefined;
  description?: string | undefined;
  /**
   * Data compression format to apply to HTTP content before it is delivered
   */
  compress?: models.CompressionOptions2 | undefined;
  /**
   * Compression level to apply before moving files to final destination
   */
  compressionLevel?: models.CompressionLevelOptions | undefined;
  /**
   * Automatically calculate the schema based on the events of each Parquet file generated
   */
  automaticSchema?: boolean | undefined;
  /**
   * To add a new schema, navigate to Processing > Knowledge > Parquet Schemas
   */
  parquetSchema?: string | undefined;
  /**
   * Determines which data types are supported and how they are represented
   */
  parquetVersion?: models.ParquetVersionOptions | undefined;
  /**
   * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
   */
  parquetDataPageVersion?: models.DataPageVersionOptions | undefined;
  /**
   * The number of rows that every group will contain. The final group can contain a smaller number of rows.
   */
  parquetRowGroupLength?: number | undefined;
  /**
   * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
   */
  parquetPageSize?: string | undefined;
  /**
   * Log up to 3 rows that @{product} skips due to data mismatch
   */
  shouldLogInvalidRows?: boolean | undefined;
  /**
   * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
   */
  keyValueMetadata?: Array<models.ItemsTypeKeyValueMetadata> | undefined;
  /**
   * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
   */
  enableStatistics?: boolean | undefined;
  /**
   * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
   */
  enableWritePageIndex?: boolean | undefined;
  /**
   * Parquet tools can use the checksum of a Parquet page to verify data integrity
   */
  enablePageChecksum?: boolean | undefined;
  /**
   * How frequently, in seconds, to clean up empty directories
   */
  emptyDirCleanupSec?: number | undefined;
  /**
   * Number of directories to process in each batch during cleanup of empty directories. Minimum is 10, maximum is 10000. Higher values may require more memory.
   */
  directoryBatchSize?: number | undefined;
  /**
   * Storage location for files that fail to reach their final destination after maximum retries are exceeded
   */
  deadletterPath?: string | undefined;
  /**
   * The maximum number of times a file will attempt to move to its final destination before being dead-lettered
   */
  maxRetryNum?: number | undefined;
};

export type PqControlsSignalfx = {};

export type OutputSignalfx = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: "signalfx";
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: models.AuthenticationMethodOptionsAuthTokensItems | undefined;
  /**
   * SignalFx realm name, e.g. "us0". For a complete list of available SignalFx realm names, please check [here](https://docs.splunk.com/observability/en/get-started/service-description.html#sd-regions).
   */
  realm: string;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<models.ItemsTypeExtraHttpHeaders> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: models.FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<models.ItemsTypeResponseRetrySettings>
    | undefined;
  timeoutRetrySettings?: models.TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: models.BackpressureBehaviorOptions | undefined;
  description?: string | undefined;
  /**
   * SignalFx API access token (see [here](https://docs.signalfx.com/en/latest/admin-guide/tokens.html#working-with-access-tokens))
   */
  token?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: models.ModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: models.CompressionOptionsPq | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: models.QueueFullBehaviorOptions | undefined;
  pqControls?: PqControlsSignalfx | undefined;
};

export type PqControlsWavefront = {};

export type OutputWavefront = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: "wavefront";
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: models.AuthenticationMethodOptionsAuthTokensItems | undefined;
  /**
   * WaveFront domain name, e.g. "longboard"
   */
  domain: string;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<models.ItemsTypeExtraHttpHeaders> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: models.FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<models.ItemsTypeResponseRetrySettings>
    | undefined;
  timeoutRetrySettings?: models.TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: models.BackpressureBehaviorOptions | undefined;
  description?: string | undefined;
  /**
   * WaveFront API authentication token (see [here](https://docs.wavefront.com/wavefront_api.html#generating-an-api-token))
   */
  token?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: models.ModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: models.CompressionOptionsPq | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: models.QueueFullBehaviorOptions | undefined;
  pqControls?: PqControlsWavefront | undefined;
};

export type PqControlsTcpjson = {};

export type OutputTcpjson = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: "tcpjson";
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Use load-balanced destinations
   */
  loadBalanced?: boolean | undefined;
  /**
   * Codec to use to compress the data before sending
   */
  compression?: models.CompressionOptions1 | undefined;
  /**
   * Use to troubleshoot issues with sending data
   */
  logFailedRequests?: boolean | undefined;
  /**
   * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
   */
  throttleRatePerSec?: string | undefined;
  tls?: models.TlsSettingsClientSideTypeKafkaSchemaRegistry | undefined;
  /**
   * Amount of time (milliseconds) to wait for the connection to establish before retrying
   */
  connectionTimeout?: number | undefined;
  /**
   * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
   */
  writeTimeout?: number | undefined;
  /**
   * The number of minutes before the internally generated authentication token expires, valid values between 1 and 60
   */
  tokenTTLMinutes?: number | undefined;
  /**
   * Upon connection, send a header-like record containing the auth token and other metadata.This record will not contain an actual event – only subsequent records will.
   */
  sendHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: models.BackpressureBehaviorOptions | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: models.AuthenticationMethodOptionsAuthTokensItems | undefined;
  description?: string | undefined;
  /**
   * The hostname of the receiver
   */
  host?: string | undefined;
  /**
   * The port to connect to on the provided host
   */
  port?: number | undefined;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  /**
   * Set of hosts to load-balance data to
   */
  hosts?: Array<models.ItemsTypeHosts> | undefined;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
  /**
   * Maximum number of concurrent connections (per Worker Process). A random set of IPs will be picked on every DNS resolution period. Use 0 for unlimited.
   */
  maxConcurrentSenders?: number | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: models.ModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: models.CompressionOptionsPq | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: models.QueueFullBehaviorOptions | undefined;
  pqControls?: PqControlsTcpjson | undefined;
  /**
   * Optional authentication token to include as part of the connection header
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type PqControlsWizHec = {};

export type OutputWizHec = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: "wiz_hec";
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  loadBalanced?: any | undefined;
  /**
   * In the Splunk app, define which Splunk processing queue to send the events after HEC processing.
   */
  nextQueue?: string | undefined;
  /**
   * In the Splunk app, set the value of _TCP_ROUTING for events that do not have _ctrl._TCP_ROUTING set.
   */
  tcpRouting?: string | undefined;
  tls?: models.TlsSettingsClientSideType1 | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<models.ItemsTypeExtraHttpHeaders> | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: models.FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  enableMultiMetrics?: any | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: models.AuthenticationMethodOptionsAuthTokensItems | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<models.ItemsTypeResponseRetrySettings>
    | undefined;
  timeoutRetrySettings?: models.TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: models.BackpressureBehaviorOptions | undefined;
  /**
   * The unique identifier for the specific Cribl connector defined in your Wiz Settings. This is used to cross-validate the bearer token and ensure traffic is originating from the authorized integration.
   */
  wiz_connector_id: string;
  /**
   * Your Wiz deployment environment.
   */
  wiz_environment: string;
  /**
   * Your Wiz deployment data center (e.g., us1, us8, eu1). From Tenant Info → Data Center and Regions → Tenant Data Center in your Wiz console.
   */
  data_center: string;
  wiz_sourcetype: string;
  description?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: models.ModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: models.CompressionOptionsPq | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: models.QueueFullBehaviorOptions | undefined;
  pqControls?: PqControlsWizHec | undefined;
  /**
   * Wiz Defend Auth token
   */
  token?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type UrlSplunkHec = {
  /**
   * URL to a Splunk HEC endpoint to send events to, e.g., http://localhost:8088/services/collector/event
   */
  url: string;
  /**
   * Assign a weight (>0) to each endpoint to indicate its traffic-handling capability
   */
  weight?: number | undefined;
};

export type PqControlsSplunkHec = {};

export type OutputSplunkHec = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: "splunk_hec";
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
   */
  loadBalanced?: boolean | undefined;
  /**
   * In the Splunk app, define which Splunk processing queue to send the events after HEC processing.
   */
  nextQueue?: string | undefined;
  /**
   * In the Splunk app, set the value of _TCP_ROUTING for events that do not have _ctrl._TCP_ROUTING set.
   */
  tcpRouting?: string | undefined;
  tls?: models.TlsSettingsClientSideType1 | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<models.ItemsTypeExtraHttpHeaders> | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: models.FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Output metrics in multiple-metric format, supported in Splunk 8.0 and above to allow multiple metrics in a single event.
   */
  enableMultiMetrics?: boolean | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: models.AuthenticationMethodOptionsAuthTokensItems | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<models.ItemsTypeResponseRetrySettings>
    | undefined;
  timeoutRetrySettings?: models.TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: models.BackpressureBehaviorOptions | undefined;
  description?: string | undefined;
  /**
   * URL to a Splunk HEC endpoint to send events to, e.g., http://localhost:8088/services/collector/event
   */
  url?: string | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  urls?: Array<UrlSplunkHec> | undefined;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
  /**
   * Splunk HEC authentication token
   */
  token?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: models.ModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: models.CompressionOptionsPq | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: models.QueueFullBehaviorOptions | undefined;
  pqControls?: PqControlsSplunkHec | undefined;
};

export type CreateOutputAuthToken = {
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: models.AuthenticationMethodOptionsAuthTokensItems | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

/**
 * List of configurations to set up indexer discovery in Splunk Indexer clustering environment.
 */
export type IndexerDiscoveryConfigs = {
  /**
   * Clustering site of the indexers from where indexers need to be discovered. In case of single site cluster, it defaults to 'default' site.
   */
  site: string;
  /**
   * Full URI of Splunk cluster manager (scheme://host:port). Example: https://managerAddress:8089
   */
  masterUri: string;
  /**
   * Time interval, in seconds, between two consecutive indexer list fetches from cluster manager
   */
  refreshIntervalSec: number;
  /**
   * During indexer discovery, reject cluster manager certificates that are not authorized by the system's CA. Disable to allow untrusted (for example, self-signed) certificates.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Tokens required to authenticate to cluster manager for indexer discovery
   */
  authTokens?: Array<CreateOutputAuthToken> | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: models.AuthenticationMethodOptionsAuthTokensItems | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type PqControlsSplunkLb = {};

export type OutputSplunkLb = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: "splunk_lb";
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
  /**
   * Maximum number of concurrent connections (per Worker Process). A random set of IPs will be picked on every DNS resolution period. Use 0 for unlimited.
   */
  maxConcurrentSenders?: number | undefined;
  /**
   * How to serialize nested fields into index-time fields
   */
  nestedFields?: models.NestedFieldSerializationOptions | undefined;
  /**
   * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
   */
  throttleRatePerSec?: string | undefined;
  /**
   * Amount of time (milliseconds) to wait for the connection to establish before retrying
   */
  connectionTimeout?: number | undefined;
  /**
   * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
   */
  writeTimeout?: number | undefined;
  tls?: models.TlsSettingsClientSideTypeKafkaSchemaRegistry | undefined;
  /**
   * Output metrics in multiple-metric format in a single event. Supported in Splunk 8.0 and above.
   */
  enableMultiMetrics?: boolean | undefined;
  /**
   * Check if indexer is shutting down and stop sending data. This helps minimize data loss during shutdown.
   */
  enableACK?: boolean | undefined;
  /**
   * Use to troubleshoot issues with sending data
   */
  logFailedRequests?: boolean | undefined;
  /**
   * The highest S2S protocol version to advertise during handshake
   */
  maxS2Sversion?: models.MaxS2SVersionOptions | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: models.BackpressureBehaviorOptions | undefined;
  /**
   * Automatically discover indexers in indexer clustering environment.
   */
  indexerDiscovery?: boolean | undefined;
  /**
   * How long (in milliseconds) each LB endpoint can report blocked before the Destination reports unhealthy, blocking the sender. (Grace period for fluctuations.) Use 0 to disable; max 1 minute.
   */
  senderUnhealthyTimeAllowance?: number | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: models.AuthenticationMethodOptionsAuthTokensItems | undefined;
  description?: string | undefined;
  /**
   * Maximum number of times healthcheck can fail before we close connection. If set to 0 (disabled), and the connection to Splunk is forcibly closed, some data loss might occur.
   */
  maxFailedHealthChecks?: number | undefined;
  /**
   * Controls whether the sender should send compressed data to the server. Select 'Disabled' to reject compressed connections or 'Always' to ignore server's configuration and send compressed data.
   */
  compress?: models.CompressionOptions | undefined;
  /**
   * List of configurations to set up indexer discovery in Splunk Indexer clustering environment.
   */
  indexerDiscoveryConfigs?: IndexerDiscoveryConfigs | undefined;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  /**
   * Set of Splunk indexers to load-balance data to.
   */
  hosts: Array<models.ItemsTypeHosts>;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: models.ModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: models.CompressionOptionsPq | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: models.QueueFullBehaviorOptions | undefined;
  pqControls?: PqControlsSplunkLb | undefined;
  /**
   * Shared secret token to use when establishing a connection to a Splunk indexer.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type PqControlsSplunk = {};

export type OutputSplunk = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: "splunk";
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The hostname of the receiver
   */
  host: string;
  /**
   * The port to connect to on the provided host
   */
  port: number;
  /**
   * How to serialize nested fields into index-time fields
   */
  nestedFields?: models.NestedFieldSerializationOptions | undefined;
  /**
   * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
   */
  throttleRatePerSec?: string | undefined;
  /**
   * Amount of time (milliseconds) to wait for the connection to establish before retrying
   */
  connectionTimeout?: number | undefined;
  /**
   * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
   */
  writeTimeout?: number | undefined;
  tls?: models.TlsSettingsClientSideTypeKafkaSchemaRegistry | undefined;
  /**
   * Output metrics in multiple-metric format in a single event. Supported in Splunk 8.0 and above.
   */
  enableMultiMetrics?: boolean | undefined;
  /**
   * Check if indexer is shutting down and stop sending data. This helps minimize data loss during shutdown.
   */
  enableACK?: boolean | undefined;
  /**
   * Use to troubleshoot issues with sending data
   */
  logFailedRequests?: boolean | undefined;
  /**
   * The highest S2S protocol version to advertise during handshake
   */
  maxS2Sversion?: models.MaxS2SVersionOptions | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: models.BackpressureBehaviorOptions | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: models.AuthenticationMethodOptionsAuthTokensItems | undefined;
  description?: string | undefined;
  /**
   * Maximum number of times healthcheck can fail before we close connection. If set to 0 (disabled), and the connection to Splunk is forcibly closed, some data loss might occur.
   */
  maxFailedHealthChecks?: number | undefined;
  /**
   * Controls whether the sender should send compressed data to the server. Select 'Disabled' to reject compressed connections or 'Always' to ignore server's configuration and send compressed data.
   */
  compress?: models.CompressionOptions | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: models.ModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: models.CompressionOptionsPq | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: models.QueueFullBehaviorOptions | undefined;
  pqControls?: PqControlsSplunk | undefined;
  /**
   * Shared secret token to use when establishing a connection to a Splunk indexer.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

/**
 * The network protocol to use for sending out syslog messages
 */
export const ProtocolSyslog = {
  /**
   * TCP
   */
  Tcp: "tcp",
  /**
   * UDP
   */
  Udp: "udp",
} as const;
/**
 * The network protocol to use for sending out syslog messages
 */
export type ProtocolSyslog = OpenEnum<typeof ProtocolSyslog>;

/**
 * Default value for message facility. Will be overwritten by value of __facility if set. Defaults to user.
 */
export const Facility = {
  Zero: 0,
  One: 1,
  Two: 2,
  Three: 3,
  Four: 4,
  Five: 5,
  Six: 6,
  Seven: 7,
  Eight: 8,
  Nine: 9,
  Ten: 10,
  Eleven: 11,
  Twelve: 12,
  Thirteen: 13,
  Fourteen: 14,
  Fifteen: 15,
  Sixteen: 16,
  Seventeen: 17,
  Eighteen: 18,
  Nineteen: 19,
  Twenty: 20,
  TwentyOne: 21,
} as const;
/**
 * Default value for message facility. Will be overwritten by value of __facility if set. Defaults to user.
 */
export type Facility = OpenEnum<typeof Facility>;

/**
 * Default value for message severity. Will be overwritten by value of __severity if set. Defaults to notice.
 */
export const SeveritySyslog = {
  /**
   * emergency
   */
  Zero: 0,
  /**
   * alert
   */
  One: 1,
  /**
   * critical
   */
  Two: 2,
  /**
   * error
   */
  Three: 3,
  /**
   * warning
   */
  Four: 4,
  /**
   * notice
   */
  Five: 5,
  /**
   * info
   */
  Six: 6,
  /**
   * debug
   */
  Seven: 7,
} as const;
/**
 * Default value for message severity. Will be overwritten by value of __severity if set. Defaults to notice.
 */
export type SeveritySyslog = OpenEnum<typeof SeveritySyslog>;

/**
 * The syslog message format depending on the receiver's support
 */
export const MessageFormat = {
  /**
   * RFC3164
   */
  Rfc3164: "rfc3164",
  /**
   * RFC5424
   */
  Rfc5424: "rfc5424",
} as const;
/**
 * The syslog message format depending on the receiver's support
 */
export type MessageFormat = OpenEnum<typeof MessageFormat>;

/**
 * Timestamp format to use when serializing event's time field
 */
export const TimestampFormat = {
  /**
   * Syslog
   */
  Syslog: "syslog",
  /**
   * ISO8601
   */
  Iso8601: "iso8601",
} as const;
/**
 * Timestamp format to use when serializing event's time field
 */
export type TimestampFormat = OpenEnum<typeof TimestampFormat>;

export type PqControlsSyslog = {};

export type OutputSyslog = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: "syslog";
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The network protocol to use for sending out syslog messages
   */
  protocol?: ProtocolSyslog | undefined;
  /**
   * Default value for message facility. Will be overwritten by value of __facility if set. Defaults to user.
   */
  facility?: Facility | undefined;
  /**
   * Default value for message severity. Will be overwritten by value of __severity if set. Defaults to notice.
   */
  severity?: SeveritySyslog | undefined;
  /**
   * Default name for device or application that originated the message. Defaults to Cribl, but will be overwritten by value of __appname if set.
   */
  appName?: string | undefined;
  /**
   * The syslog message format depending on the receiver's support
   */
  messageFormat?: MessageFormat | undefined;
  /**
   * Timestamp format to use when serializing event's time field
   */
  timestampFormat?: TimestampFormat | undefined;
  /**
   * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
   */
  throttleRatePerSec?: string | undefined;
  /**
   * Prefix messages with the byte count of the message. If disabled, no prefix will be set, and the message will be appended with a \n.
   */
  octetCountFraming?: boolean | undefined;
  /**
   * Use to troubleshoot issues with sending data
   */
  logFailedRequests?: boolean | undefined;
  description?: string | undefined;
  /**
   * For optimal performance, enable load balancing even if you have one hostname, as it can expand to multiple IPs.  If this setting is disabled, consider enabling round-robin DNS.
   */
  loadBalanced?: boolean | undefined;
  /**
   * The hostname of the receiver
   */
  host?: string | undefined;
  /**
   * The port to connect to on the provided host
   */
  port?: number | undefined;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  /**
   * Set of hosts to load-balance data to
   */
  hosts?: Array<models.ItemsTypeHosts> | undefined;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
  /**
   * Maximum number of concurrent connections (per Worker Process). A random set of IPs will be picked on every DNS resolution period. Use 0 for unlimited.
   */
  maxConcurrentSenders?: number | undefined;
  /**
   * Amount of time (milliseconds) to wait for the connection to establish before retrying
   */
  connectionTimeout?: number | undefined;
  /**
   * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
   */
  writeTimeout?: number | undefined;
  tls?: models.TlsSettingsClientSideTypeKafkaSchemaRegistry | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: models.BackpressureBehaviorOptions | undefined;
  /**
   * Maximum size of syslog messages. Make sure this value is less than or equal to the MTU to avoid UDP packet fragmentation.
   */
  maxRecordSize?: number | undefined;
  /**
   * How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every message sent will incur a DNS lookup.
   */
  udpDnsResolvePeriodSec?: number | undefined;
  /**
   * Send Syslog traffic using the original event's Source IP and port. To enable this, you must install the external `udp-sender` helper binary at `/usr/bin/udp-sender` on all Worker Nodes and grant it the `CAP_NET_RAW` capability.
   */
  enableIpSpoofing?: boolean | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: models.ModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: models.CompressionOptionsPq | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: models.QueueFullBehaviorOptions | undefined;
  pqControls?: PqControlsSyslog | undefined;
};

export type OutputDevnull = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: "devnull";
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
};

export const AuthType = {
  Oauth: "oauth",
} as const;
export type AuthType = OpenEnum<typeof AuthType>;

/**
 * Enter the data collection endpoint URL or the individual ID
 */
export const EndpointConfiguration = {
  /**
   * URL
   */
  Url: "url",
  /**
   * ID
   */
  Id: "ID",
} as const;
/**
 * Enter the data collection endpoint URL or the individual ID
 */
export type EndpointConfiguration = OpenEnum<typeof EndpointConfiguration>;

export const FormatSentinel = {
  Ndjson: "ndjson",
  JsonArray: "json_array",
  Custom: "custom",
  Advanced: "advanced",
} as const;
export type FormatSentinel = OpenEnum<typeof FormatSentinel>;

export type PqControlsSentinel = {};

export type OutputSentinel = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: "sentinel";
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size (KB) of the request body (defaults to the API's maximum limit of 1000 KB)
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
   */
  extraHttpHeaders?: Array<models.ItemsTypeExtraHttpHeaders> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: models.FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<models.ItemsTypeResponseRetrySettings>
    | undefined;
  timeoutRetrySettings?: models.TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: models.BackpressureBehaviorOptions | undefined;
  authType?: AuthType | undefined;
  /**
   * URL for OAuth
   */
  loginUrl: string;
  /**
   * Secret parameter value to pass in request body
   */
  secret: string;
  /**
   * JavaScript expression to compute the Client ID for the Azure application. Can be a constant.
   */
  client_id: string;
  /**
   * Scope to pass in the OAuth request
   */
  scope?: string | undefined;
  /**
   * Enter the data collection endpoint URL or the individual ID
   */
  endpointURLConfiguration: EndpointConfiguration;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  format?: FormatSentinel | undefined;
  /**
   * Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON.
   */
  customSourceExpression?: string | undefined;
  /**
   * Whether to drop events when the source expression evaluates to null
   */
  customDropWhenNull?: boolean | undefined;
  /**
   * Delimiter string to insert between individual events. Defaults to newline character.
   */
  customEventDelimiter?: string | undefined;
  /**
   * Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry.
   */
  customContentType?: string | undefined;
  /**
   * Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object.
   */
  customPayloadExpression?: string | undefined;
  /**
   * HTTP content-type header value
   */
  advancedContentType?: string | undefined;
  /**
   * Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatEventCode?: string | undefined;
  /**
   * Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatPayloadCode?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: models.ModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: models.CompressionOptionsPq | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: models.QueueFullBehaviorOptions | undefined;
  pqControls?: PqControlsSentinel | undefined;
  /**
   * URL to send events to. Can be overwritten by an event's __url field.
   */
  url?: string | undefined;
  /**
   * Immutable ID for the Data Collection Rule (DCR)
   */
  dcrID?: string | undefined;
  /**
   * Data collection endpoint (DCE) URL. In the format: `https://<Endpoint-Name>-<Identifier>.<Region>.ingest.monitor.azure.com`
   */
  dceEndpoint?: string | undefined;
  /**
   * The name of the stream (Sentinel table) in which to store the events
   */
  streamName?: string | undefined;
};

/**
 * How to format events before sending out
 */
export const FormatWebhook = {
  /**
   * NDJSON (Newline Delimited JSON)
   */
  Ndjson: "ndjson",
  /**
   * JSON Array
   */
  JsonArray: "json_array",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Advanced
   */
  Advanced: "advanced",
} as const;
/**
 * How to format events before sending out
 */
export type FormatWebhook = OpenEnum<typeof FormatWebhook>;

/**
 * Authentication method to use for the HTTP request
 */
export const AuthenticationTypeWebhook = {
  /**
   * None
   */
  None: "none",
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * Basic (credentials secret)
   */
  CredentialsSecret: "credentialsSecret",
  /**
   * Token
   */
  Token: "token",
  /**
   * Token (text secret)
   */
  TextSecret: "textSecret",
  /**
   * OAuth
   */
  Oauth: "oauth",
} as const;
/**
 * Authentication method to use for the HTTP request
 */
export type AuthenticationTypeWebhook = OpenEnum<
  typeof AuthenticationTypeWebhook
>;

export type PqControlsWebhook = {};

export type UrlWebhook = {
  /**
   * URL of a webhook endpoint to send events to, such as http://localhost:10200
   */
  url: string;
  /**
   * Assign a weight (>0) to each endpoint to indicate its traffic-handling capability
   */
  weight?: number | undefined;
};

export type OutputWebhook = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: "webhook";
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * The method to use when sending events
   */
  method?: models.MethodOptions | undefined;
  /**
   * How to format events before sending out
   */
  format?: FormatWebhook | undefined;
  /**
   * Disable to close the connection immediately after sending the outgoing request
   */
  keepAlive?: boolean | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
   */
  extraHttpHeaders?: Array<models.ItemsTypeExtraHttpHeaders> | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: models.FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?:
    | Array<models.ItemsTypeResponseRetrySettings>
    | undefined;
  timeoutRetrySettings?: models.TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: models.BackpressureBehaviorOptions | undefined;
  /**
   * Authentication method to use for the HTTP request
   */
  authType?: AuthenticationTypeWebhook | undefined;
  tls?: models.TlsSettingsClientSideType1 | undefined;
  /**
   * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
   */
  totalMemoryLimitKB?: number | undefined;
  /**
   * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
   */
  loadBalanced?: boolean | undefined;
  description?: string | undefined;
  /**
   * Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON.
   */
  customSourceExpression?: string | undefined;
  /**
   * Whether to drop events when the source expression evaluates to null
   */
  customDropWhenNull?: boolean | undefined;
  /**
   * Delimiter string to insert between individual events. Defaults to newline character.
   */
  customEventDelimiter?: string | undefined;
  /**
   * Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry.
   */
  customContentType?: string | undefined;
  /**
   * Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object.
   */
  customPayloadExpression?: string | undefined;
  /**
   * HTTP content-type header value
   */
  advancedContentType?: string | undefined;
  /**
   * Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatEventCode?: string | undefined;
  /**
   * Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
   */
  formatPayloadCode?: string | undefined;
  /**
   * Use FIFO (first in, first out) processing. Disable to forward new events to receivers before queue is flushed.
   */
  pqStrictOrdering?: boolean | undefined;
  /**
   * Throttling rate (in events per second) to impose while writing to Destinations from PQ. Defaults to 0, which disables throttling.
   */
  pqRatePerSec?: number | undefined;
  /**
   * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem.
   */
  pqMode?: models.ModeOptions | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  pqMaxBufferSize?: number | undefined;
  /**
   * How long (in seconds) to wait for backpressure to resolve before engaging the queue
   */
  pqMaxBackpressureSec?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.)
   */
  pqMaxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  pqMaxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
   */
  pqPath?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  pqCompress?: models.CompressionOptionsPq | undefined;
  /**
   * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
   */
  pqOnBackpressure?: models.QueueFullBehaviorOptions | undefined;
  pqControls?: PqControlsWebhook | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<models.ItemsTypeOauthParams> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders> | undefined;
  /**
   * URL of a webhook endpoint to send events to, such as http://localhost:10200
   */
  url?: string | undefined;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  urls?: Array<UrlWebhook> | undefined;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
};

export type OutputDefault = {
  /**
   * Unique ID for this output
   */
  id: string;
  type: "default";
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * ID of the default output. This will be used whenever a nonexistent/deleted output is referenced.
   */
  defaultId: string;
};

/**
 * Output object
 */
export type CreateOutputRequest =
  | OutputDefault
  | OutputWebhook
  | OutputSentinel
  | OutputDevnull
  | OutputSyslog
  | OutputSplunk
  | OutputSplunkLb
  | OutputSplunkHec
  | OutputWizHec
  | OutputTcpjson
  | OutputWavefront
  | OutputSignalfx
  | OutputFilesystem
  | OutputS3
  | OutputAzureBlob
  | OutputAzureDataExplorer
  | OutputAzureLogs
  | OutputKinesis
  | OutputHoneycomb
  | OutputAzureEventhub
  | OutputGoogleChronicle
  | OutputGoogleCloudStorage
  | OutputGoogleCloudLogging
  | OutputGooglePubsub
  | OutputExabeam
  | OutputKafka
  | OutputConfluentCloud
  | OutputMsk
  | OutputElastic
  | OutputElasticCloud
  | OutputNewrelic
  | OutputNewrelicEvents
  | OutputInfluxdb
  | OutputCloudwatch
  | OutputMinio
  | OutputStatsd
  | OutputStatsdExt
  | OutputGraphite
  | OutputRouter
  | OutputSns
  | OutputSqs
  | OutputSnmp
  | OutputSumoLogic
  | OutputDatadog
  | (OutputGrafanaCloud & { type: "grafana_cloud" })
  | OutputLoki
  | OutputPrometheus
  | OutputRing
  | OutputOpenTelemetry
  | OutputServiceNow
  | OutputDataset
  | OutputCriblTcp
  | OutputCriblHttp
  | OutputCriblSearchEngine
  | OutputHumioHec
  | OutputCrowdstrikeNextGenSiem
  | OutputDlS3
  | OutputSecurityLake
  | OutputCriblLake
  | OutputDiskSpool
  | OutputClickHouse
  | OutputXsiam
  | OutputNetflow
  | OutputDynatraceHttp
  | OutputDynatraceOtlp
  | OutputSentinelOneAiSiem
  | OutputChronicle
  | OutputDatabricks
  | OutputMicrosoftFabric
  | OutputCloudflareR2;

/** @internal */
export type OutputAzureLogs$Outbound = {
  id: string;
  type: "azure_logs";
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  logType: string;
  resourceId?: string | undefined;
  concurrency?: number | undefined;
  maxPayloadSizeKB?: number | undefined;
  maxPayloadEvents?: number | undefined;
  compress?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  timeoutSec?: number | undefined;
  flushPeriodSec?: number | undefined;
  extraHttpHeaders?:
    | Array<models.ItemsTypeExtraHttpHeaders$Outbound>
    | undefined;
  useRoundRobinDns?: boolean | undefined;
  failedRequestLoggingMode?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  apiUrl?: string | undefined;
  responseRetrySettings?:
    | Array<models.ItemsTypeResponseRetrySettings$Outbound>
    | undefined;
  timeoutRetrySettings?: models.TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader?: boolean | undefined;
  onBackpressure?: string | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  pqStrictOrdering?: boolean | undefined;
  pqRatePerSec?: number | undefined;
  pqMode?: string | undefined;
  pqMaxBufferSize?: number | undefined;
  pqMaxBackpressureSec?: number | undefined;
  pqMaxFileSize?: string | undefined;
  pqMaxSize?: string | undefined;
  pqPath?: string | undefined;
  pqCompress?: string | undefined;
  pqOnBackpressure?: string | undefined;
  pqControls?: PqControlsAzureLogs$Outbound | undefined;
  workspaceId?: string | undefined;
  workspaceKey?: string | undefined;
  keypairSecret?: string | undefined;
};

/** @internal */
export const OutputAzureLogs$outboundSchema: z.ZodType<
  OutputAzureLogs$Outbound,
  z.ZodTypeDef,
  OutputAzureLogs
> = z.object({
  id: z.string(),
  type: z.literal("azure_logs"),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  logType: z.string(),
  resourceId: z.string().optional(),
  concurrency: z.number().optional(),
  maxPayloadSizeKB: z.number().optional(),
  maxPayloadEvents: z.number().optional(),
  compress: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  timeoutSec: z.number().optional(),
  flushPeriodSec: z.number().optional(),
  extraHttpHeaders: z.array(models.ItemsTypeExtraHttpHeaders$outboundSchema)
    .optional(),
  useRoundRobinDns: z.boolean().optional(),
  failedRequestLoggingMode: models
    .FailedRequestLoggingModeOptions$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  apiUrl: z.string().optional(),
  responseRetrySettings: z.array(
    models.ItemsTypeResponseRetrySettings$outboundSchema,
  ).optional(),
  timeoutRetrySettings: models.TimeoutRetrySettingsType$outboundSchema
    .optional(),
  responseHonorRetryAfterHeader: z.boolean().optional(),
  onBackpressure: models.BackpressureBehaviorOptions$outboundSchema.optional(),
  authType: AuthenticationMethodAzureLogs$outboundSchema.optional(),
  description: z.string().optional(),
  pqStrictOrdering: z.boolean().optional(),
  pqRatePerSec: z.number().optional(),
  pqMode: models.ModeOptions$outboundSchema.optional(),
  pqMaxBufferSize: z.number().optional(),
  pqMaxBackpressureSec: z.number().optional(),
  pqMaxFileSize: z.string().optional(),
  pqMaxSize: z.string().optional(),
  pqPath: z.string().optional(),
  pqCompress: models.CompressionOptionsPq$outboundSchema.optional(),
  pqOnBackpressure: models.QueueFullBehaviorOptions$outboundSchema.optional(),
  pqControls: PqControlsAzureLogs$outboundSchema.optional(),
  workspaceId: z.string().optional(),
  workspaceKey: z.string().optional(),
  keypairSecret: z.string().optional(),
});

export function outputAzureLogsToJSON(
  outputAzureLogs: OutputAzureLogs,
): string {
  return JSON.stringify(OutputAzureLogs$outboundSchema.parse(outputAzureLogs));
}

/** @internal */
export const IngestionMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  IngestionMode
> = openEnums.outboundSchema(IngestionMode);

/** @internal */
export const OauthTypeAuthenticationMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  OauthTypeAuthenticationMethod
> = openEnums.outboundSchema(OauthTypeAuthenticationMethod);

/** @internal */
export type Certificate$Outbound = {
  certificateName?: string | undefined;
};

/** @internal */
export const Certificate$outboundSchema: z.ZodType<
  Certificate$Outbound,
  z.ZodTypeDef,
  Certificate
> = z.object({
  certificateName: z.string().optional(),
});

export function certificateToJSON(certificate: Certificate): string {
  return JSON.stringify(Certificate$outboundSchema.parse(certificate));
}

/** @internal */
export const PrefixOptional$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  PrefixOptional
> = openEnums.outboundSchema(PrefixOptional);

/** @internal */
export type ExtentTag$Outbound = {
  prefix?: string | undefined;
  value: string;
};

/** @internal */
export const ExtentTag$outboundSchema: z.ZodType<
  ExtentTag$Outbound,
  z.ZodTypeDef,
  ExtentTag
> = z.object({
  prefix: PrefixOptional$outboundSchema.optional(),
  value: z.string(),
});

export function extentTagToJSON(extentTag: ExtentTag): string {
  return JSON.stringify(ExtentTag$outboundSchema.parse(extentTag));
}

/** @internal */
export type IngestIfNotExist$Outbound = {
  value: string;
};

/** @internal */
export const IngestIfNotExist$outboundSchema: z.ZodType<
  IngestIfNotExist$Outbound,
  z.ZodTypeDef,
  IngestIfNotExist
> = z.object({
  value: z.string(),
});

export function ingestIfNotExistToJSON(
  ingestIfNotExist: IngestIfNotExist,
): string {
  return JSON.stringify(
    IngestIfNotExist$outboundSchema.parse(ingestIfNotExist),
  );
}

/** @internal */
export const ReportLevel$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  ReportLevel
> = openEnums.outboundSchema(ReportLevel);

/** @internal */
export const ReportMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  ReportMethod
> = openEnums.outboundSchema(ReportMethod);

/** @internal */
export type AdditionalProperty$Outbound = {
  key: string;
  value: string;
};

/** @internal */
export const AdditionalProperty$outboundSchema: z.ZodType<
  AdditionalProperty$Outbound,
  z.ZodTypeDef,
  AdditionalProperty
> = z.object({
  key: z.string(),
  value: z.string(),
});

export function additionalPropertyToJSON(
  additionalProperty: AdditionalProperty,
): string {
  return JSON.stringify(
    AdditionalProperty$outboundSchema.parse(additionalProperty),
  );
}

/** @internal */
export type PqControlsAzureDataExplorer$Outbound = {};

/** @internal */
export const PqControlsAzureDataExplorer$outboundSchema: z.ZodType<
  PqControlsAzureDataExplorer$Outbound,
  z.ZodTypeDef,
  PqControlsAzureDataExplorer
> = z.object({});

export function pqControlsAzureDataExplorerToJSON(
  pqControlsAzureDataExplorer: PqControlsAzureDataExplorer,
): string {
  return JSON.stringify(
    PqControlsAzureDataExplorer$outboundSchema.parse(
      pqControlsAzureDataExplorer,
    ),
  );
}

/** @internal */
export type OutputAzureDataExplorer$Outbound = {
  id: string;
  type: "azure_data_explorer";
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  clusterUrl: string;
  database: string;
  table: string;
  validateDatabaseSettings?: boolean | undefined;
  ingestMode?: string | undefined;
  oauthEndpoint: string;
  tenantId: string;
  clientId: string;
  scope: string;
  oauthType: string;
  description?: string | undefined;
  clientSecret?: string | undefined;
  textSecret?: string | undefined;
  certificate?: Certificate$Outbound | undefined;
  format?: string | undefined;
  compress: string;
  compressionLevel?: string | undefined;
  automaticSchema?: boolean | undefined;
  parquetSchema?: string | undefined;
  parquetVersion?: string | undefined;
  parquetDataPageVersion?: string | undefined;
  parquetRowGroupLength?: number | undefined;
  parquetPageSize?: string | undefined;
  shouldLogInvalidRows?: boolean | undefined;
  keyValueMetadata?:
    | Array<models.ItemsTypeKeyValueMetadata$Outbound>
    | undefined;
  enableStatistics?: boolean | undefined;
  enableWritePageIndex?: boolean | undefined;
  enablePageChecksum?: boolean | undefined;
  removeEmptyDirs?: boolean | undefined;
  emptyDirCleanupSec?: number | undefined;
  directoryBatchSize?: number | undefined;
  deadletterEnabled?: boolean | undefined;
  deadletterPath?: string | undefined;
  maxRetryNum?: number | undefined;
  isMappingObj?: boolean | undefined;
  mappingObj?: string | undefined;
  mappingRef?: string | undefined;
  ingestUrl?: string | undefined;
  onBackpressure?: string | undefined;
  stagePath?: string | undefined;
  fileNameSuffix?: string | undefined;
  maxFileSizeMB?: number | undefined;
  maxFileOpenTimeSec?: number | undefined;
  maxFileIdleTimeSec?: number | undefined;
  maxOpenFiles?: number | undefined;
  maxConcurrentFileParts?: number | undefined;
  onDiskFullBackpressure?: string | undefined;
  addIdToStagePath?: boolean | undefined;
  retrySettings?: models.RetrySettingsType$Outbound | undefined;
  timeoutSec?: number | undefined;
  flushImmediately?: boolean | undefined;
  retainBlobOnSuccess?: boolean | undefined;
  extentTags?: Array<ExtentTag$Outbound> | undefined;
  ingestIfNotExists?: Array<IngestIfNotExist$Outbound> | undefined;
  reportLevel?: string | undefined;
  reportMethod?: string | undefined;
  additionalProperties?: Array<AdditionalProperty$Outbound> | undefined;
  responseRetrySettings?:
    | Array<models.ItemsTypeResponseRetrySettings$Outbound>
    | undefined;
  timeoutRetrySettings?: models.TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader?: boolean | undefined;
  concurrency?: number | undefined;
  maxPayloadSizeKB?: number | undefined;
  maxPayloadEvents?: number | undefined;
  flushPeriodSec?: number | undefined;
  rejectUnauthorized?: boolean | undefined;
  useRoundRobinDns?: boolean | undefined;
  keepAlive?: boolean | undefined;
  pqStrictOrdering?: boolean | undefined;
  pqRatePerSec?: number | undefined;
  pqMode?: string | undefined;
  pqMaxBufferSize?: number | undefined;
  pqMaxBackpressureSec?: number | undefined;
  pqMaxFileSize?: string | undefined;
  pqMaxSize?: string | undefined;
  pqPath?: string | undefined;
  pqCompress?: string | undefined;
  pqOnBackpressure?: string | undefined;
  pqControls?: PqControlsAzureDataExplorer$Outbound | undefined;
};

/** @internal */
export const OutputAzureDataExplorer$outboundSchema: z.ZodType<
  OutputAzureDataExplorer$Outbound,
  z.ZodTypeDef,
  OutputAzureDataExplorer
> = z.object({
  id: z.string(),
  type: z.literal("azure_data_explorer"),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  clusterUrl: z.string(),
  database: z.string(),
  table: z.string(),
  validateDatabaseSettings: z.boolean().optional(),
  ingestMode: IngestionMode$outboundSchema.optional(),
  oauthEndpoint:
    models.MicrosoftEntraIdAuthenticationEndpointOptionsSasl$outboundSchema,
  tenantId: z.string(),
  clientId: z.string(),
  scope: z.string(),
  oauthType: OauthTypeAuthenticationMethod$outboundSchema,
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
  certificate: z.lazy(() => Certificate$outboundSchema).optional(),
  format: models.DataFormatOptions$outboundSchema.optional(),
  compress: models.CompressionOptions2$outboundSchema,
  compressionLevel: models.CompressionLevelOptions$outboundSchema.optional(),
  automaticSchema: z.boolean().optional(),
  parquetSchema: z.string().optional(),
  parquetVersion: models.ParquetVersionOptions$outboundSchema.optional(),
  parquetDataPageVersion: models.DataPageVersionOptions$outboundSchema
    .optional(),
  parquetRowGroupLength: z.number().optional(),
  parquetPageSize: z.string().optional(),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(models.ItemsTypeKeyValueMetadata$outboundSchema)
    .optional(),
  enableStatistics: z.boolean().optional(),
  enableWritePageIndex: z.boolean().optional(),
  enablePageChecksum: z.boolean().optional(),
  removeEmptyDirs: z.boolean().optional(),
  emptyDirCleanupSec: z.number().optional(),
  directoryBatchSize: z.number().optional(),
  deadletterEnabled: z.boolean().optional(),
  deadletterPath: z.string().optional(),
  maxRetryNum: z.number().optional(),
  isMappingObj: z.boolean().optional(),
  mappingObj: z.string().optional(),
  mappingRef: z.string().optional(),
  ingestUrl: z.string().optional(),
  onBackpressure: models.BackpressureBehaviorOptions$outboundSchema.optional(),
  stagePath: z.string().optional(),
  fileNameSuffix: z.string().optional(),
  maxFileSizeMB: z.number().optional(),
  maxFileOpenTimeSec: z.number().optional(),
  maxFileIdleTimeSec: z.number().optional(),
  maxOpenFiles: z.number().optional(),
  maxConcurrentFileParts: z.number().optional(),
  onDiskFullBackpressure: models.DiskSpaceProtectionOptions$outboundSchema
    .optional(),
  addIdToStagePath: z.boolean().optional(),
  retrySettings: models.RetrySettingsType$outboundSchema.optional(),
  timeoutSec: z.number().optional(),
  flushImmediately: z.boolean().optional(),
  retainBlobOnSuccess: z.boolean().optional(),
  extentTags: z.array(z.lazy(() => ExtentTag$outboundSchema)).optional(),
  ingestIfNotExists: z.array(z.lazy(() => IngestIfNotExist$outboundSchema))
    .optional(),
  reportLevel: ReportLevel$outboundSchema.optional(),
  reportMethod: ReportMethod$outboundSchema.optional(),
  additionalProperties: z.array(z.lazy(() => AdditionalProperty$outboundSchema))
    .optional(),
  responseRetrySettings: z.array(
    models.ItemsTypeResponseRetrySettings$outboundSchema,
  ).optional(),
  timeoutRetrySettings: models.TimeoutRetrySettingsType$outboundSchema
    .optional(),
  responseHonorRetryAfterHeader: z.boolean().optional(),
  concurrency: z.number().optional(),
  maxPayloadSizeKB: z.number().optional(),
  maxPayloadEvents: z.number().optional(),
  flushPeriodSec: z.number().optional(),
  rejectUnauthorized: z.boolean().optional(),
  useRoundRobinDns: z.boolean().optional(),
  keepAlive: z.boolean().optional(),
  pqStrictOrdering: z.boolean().optional(),
  pqRatePerSec: z.number().optional(),
  pqMode: models.ModeOptions$outboundSchema.optional(),
  pqMaxBufferSize: z.number().optional(),
  pqMaxBackpressureSec: z.number().optional(),
  pqMaxFileSize: z.string().optional(),
  pqMaxSize: z.string().optional(),
  pqPath: z.string().optional(),
  pqCompress: models.CompressionOptionsPq$outboundSchema.optional(),
  pqOnBackpressure: models.QueueFullBehaviorOptions$outboundSchema.optional(),
  pqControls: z.lazy(() => PqControlsAzureDataExplorer$outboundSchema)
    .optional(),
});

export function outputAzureDataExplorerToJSON(
  outputAzureDataExplorer: OutputAzureDataExplorer,
): string {
  return JSON.stringify(
    OutputAzureDataExplorer$outboundSchema.parse(outputAzureDataExplorer),
  );
}

/** @internal */
export const BlobAccessTier$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  BlobAccessTier
> = openEnums.outboundSchema(BlobAccessTier);

/** @internal */
export type OutputAzureBlob$Outbound = {
  id: string;
  type: "azure_blob";
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  containerName: string;
  createContainer?: boolean | undefined;
  destPath?: string | undefined;
  stagePath: string;
  addIdToStagePath?: boolean | undefined;
  maxConcurrentFileParts?: number | undefined;
  removeEmptyDirs?: boolean | undefined;
  partitionExpr?: string | undefined;
  format?: string | undefined;
  baseFileName?: string | undefined;
  fileNameSuffix?: string | undefined;
  maxFileSizeMB?: number | undefined;
  maxFileOpenTimeSec?: number | undefined;
  maxFileIdleTimeSec?: number | undefined;
  maxOpenFiles?: number | undefined;
  headerLine?: string | undefined;
  writeHighWaterMark?: number | undefined;
  onBackpressure?: string | undefined;
  deadletterEnabled?: boolean | undefined;
  onDiskFullBackpressure?: string | undefined;
  forceCloseOnShutdown?: boolean | undefined;
  retrySettings?: models.RetrySettingsType$Outbound | undefined;
  authType?: string | undefined;
  storageClass?: string | undefined;
  description?: string | undefined;
  compress?: string | undefined;
  compressionLevel?: string | undefined;
  automaticSchema?: boolean | undefined;
  parquetSchema?: string | undefined;
  parquetVersion?: string | undefined;
  parquetDataPageVersion?: string | undefined;
  parquetRowGroupLength?: number | undefined;
  parquetPageSize?: string | undefined;
  shouldLogInvalidRows?: boolean | undefined;
  keyValueMetadata?:
    | Array<models.ItemsTypeKeyValueMetadata$Outbound>
    | undefined;
  enableStatistics?: boolean | undefined;
  enableWritePageIndex?: boolean | undefined;
  enablePageChecksum?: boolean | undefined;
  emptyDirCleanupSec?: number | undefined;
  directoryBatchSize?: number | undefined;
  deadletterPath?: string | undefined;
  maxRetryNum?: number | undefined;
  connectionString?: string | undefined;
  textSecret?: string | undefined;
  storageAccountName?: string | undefined;
  tenantId?: string | undefined;
  clientId?: string | undefined;
  azureCloud?: string | undefined;
  endpointSuffix?: string | undefined;
  clientTextSecret?: string | undefined;
  certificate?:
    | models.CertificateTypeAzureBlobAuthTypeClientCert$Outbound
    | undefined;
};

/** @internal */
export const OutputAzureBlob$outboundSchema: z.ZodType<
  OutputAzureBlob$Outbound,
  z.ZodTypeDef,
  OutputAzureBlob
> = z.object({
  id: z.string(),
  type: z.literal("azure_blob"),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  containerName: z.string(),
  createContainer: z.boolean().optional(),
  destPath: z.string().optional(),
  stagePath: z.string(),
  addIdToStagePath: z.boolean().optional(),
  maxConcurrentFileParts: z.number().optional(),
  removeEmptyDirs: z.boolean().optional(),
  partitionExpr: z.string().optional(),
  format: models.DataFormatOptions$outboundSchema.optional(),
  baseFileName: z.string().optional(),
  fileNameSuffix: z.string().optional(),
  maxFileSizeMB: z.number().optional(),
  maxFileOpenTimeSec: z.number().optional(),
  maxFileIdleTimeSec: z.number().optional(),
  maxOpenFiles: z.number().optional(),
  headerLine: z.string().optional(),
  writeHighWaterMark: z.number().optional(),
  onBackpressure: models.BackpressureBehaviorOptions1$outboundSchema.optional(),
  deadletterEnabled: z.boolean().optional(),
  onDiskFullBackpressure: models.DiskSpaceProtectionOptions$outboundSchema
    .optional(),
  forceCloseOnShutdown: z.boolean().optional(),
  retrySettings: models.RetrySettingsType$outboundSchema.optional(),
  authType: models.AuthenticationMethodOptions$outboundSchema.optional(),
  storageClass: BlobAccessTier$outboundSchema.optional(),
  description: z.string().optional(),
  compress: models.CompressionOptions2$outboundSchema.optional(),
  compressionLevel: models.CompressionLevelOptions$outboundSchema.optional(),
  automaticSchema: z.boolean().optional(),
  parquetSchema: z.string().optional(),
  parquetVersion: models.ParquetVersionOptions$outboundSchema.optional(),
  parquetDataPageVersion: models.DataPageVersionOptions$outboundSchema
    .optional(),
  parquetRowGroupLength: z.number().optional(),
  parquetPageSize: z.string().optional(),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(models.ItemsTypeKeyValueMetadata$outboundSchema)
    .optional(),
  enableStatistics: z.boolean().optional(),
  enableWritePageIndex: z.boolean().optional(),
  enablePageChecksum: z.boolean().optional(),
  emptyDirCleanupSec: z.number().optional(),
  directoryBatchSize: z.number().optional(),
  deadletterPath: z.string().optional(),
  maxRetryNum: z.number().optional(),
  connectionString: z.string().optional(),
  textSecret: z.string().optional(),
  storageAccountName: z.string().optional(),
  tenantId: z.string().optional(),
  clientId: z.string().optional(),
  azureCloud: z.string().optional(),
  endpointSuffix: z.string().optional(),
  clientTextSecret: z.string().optional(),
  certificate: models.CertificateTypeAzureBlobAuthTypeClientCert$outboundSchema
    .optional(),
});

export function outputAzureBlobToJSON(
  outputAzureBlob: OutputAzureBlob,
): string {
  return JSON.stringify(OutputAzureBlob$outboundSchema.parse(outputAzureBlob));
}

/** @internal */
export type OutputS3$Outbound = {
  id: string;
  type: "s3";
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  bucket: string;
  region?: string | undefined;
  awsSecretKey?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  stagePath: string;
  addIdToStagePath?: boolean | undefined;
  destPath?: string | undefined;
  objectACL?: string | undefined;
  storageClass?: string | undefined;
  serverSideEncryption?: string | undefined;
  kmsKeyId?: string | undefined;
  removeEmptyDirs?: boolean | undefined;
  partitionExpr?: string | undefined;
  format?: string | undefined;
  baseFileName?: string | undefined;
  fileNameSuffix?: string | undefined;
  maxFileSizeMB?: number | undefined;
  maxOpenFiles?: number | undefined;
  headerLine?: string | undefined;
  writeHighWaterMark?: number | undefined;
  onBackpressure?: string | undefined;
  deadletterEnabled?: boolean | undefined;
  onDiskFullBackpressure?: string | undefined;
  forceCloseOnShutdown?: boolean | undefined;
  retrySettings?: models.RetrySettingsType$Outbound | undefined;
  maxFileOpenTimeSec?: number | undefined;
  maxFileIdleTimeSec?: number | undefined;
  maxConcurrentFileParts?: number | undefined;
  verifyPermissions?: boolean | undefined;
  maxClosingFilesToBackpressure?: number | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  compress?: string | undefined;
  compressionLevel?: string | undefined;
  automaticSchema?: boolean | undefined;
  parquetSchema?: string | undefined;
  parquetVersion?: string | undefined;
  parquetDataPageVersion?: string | undefined;
  parquetRowGroupLength?: number | undefined;
  parquetPageSize?: string | undefined;
  shouldLogInvalidRows?: boolean | undefined;
  keyValueMetadata?:
    | Array<models.ItemsTypeKeyValueMetadata$Outbound>
    | undefined;
  enableStatistics?: boolean | undefined;
  enableWritePageIndex?: boolean | undefined;
  enablePageChecksum?: boolean | undefined;
  emptyDirCleanupSec?: number | undefined;
  directoryBatchSize?: number | undefined;
  deadletterPath?: string | undefined;
  maxRetryNum?: number | undefined;
};

/** @internal */
export const OutputS3$outboundSchema: z.ZodType<
  OutputS3$Outbound,
  z.ZodTypeDef,
  OutputS3
> = z.object({
  id: z.string(),
  type: z.literal("s3"),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  bucket: z.string(),
  region: z.string().optional(),
  awsSecretKey: z.string().optional(),
  awsAuthenticationMethod: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: models.SignatureVersionOptionsS3CollectorConf$outboundSchema
    .optional(),
  reuseConnections: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  enableAssumeRole: z.boolean().optional(),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().optional(),
  stagePath: z.string(),
  addIdToStagePath: z.boolean().optional(),
  destPath: z.string().optional(),
  objectACL: models.ObjectAclOptions$outboundSchema.optional(),
  storageClass: models.StorageClassOptions$outboundSchema.optional(),
  serverSideEncryption: models
    .ServerSideEncryptionForUploadedObjectsOptions$outboundSchema.optional(),
  kmsKeyId: z.string().optional(),
  removeEmptyDirs: z.boolean().optional(),
  partitionExpr: z.string().optional(),
  format: models.DataFormatOptions$outboundSchema.optional(),
  baseFileName: z.string().optional(),
  fileNameSuffix: z.string().optional(),
  maxFileSizeMB: z.number().optional(),
  maxOpenFiles: z.number().optional(),
  headerLine: z.string().optional(),
  writeHighWaterMark: z.number().optional(),
  onBackpressure: models.BackpressureBehaviorOptions1$outboundSchema.optional(),
  deadletterEnabled: z.boolean().optional(),
  onDiskFullBackpressure: models.DiskSpaceProtectionOptions$outboundSchema
    .optional(),
  forceCloseOnShutdown: z.boolean().optional(),
  retrySettings: models.RetrySettingsType$outboundSchema.optional(),
  maxFileOpenTimeSec: z.number().optional(),
  maxFileIdleTimeSec: z.number().optional(),
  maxConcurrentFileParts: z.number().optional(),
  verifyPermissions: z.boolean().optional(),
  maxClosingFilesToBackpressure: z.number().optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  compress: models.CompressionOptions2$outboundSchema.optional(),
  compressionLevel: models.CompressionLevelOptions$outboundSchema.optional(),
  automaticSchema: z.boolean().optional(),
  parquetSchema: z.string().optional(),
  parquetVersion: models.ParquetVersionOptions$outboundSchema.optional(),
  parquetDataPageVersion: models.DataPageVersionOptions$outboundSchema
    .optional(),
  parquetRowGroupLength: z.number().optional(),
  parquetPageSize: z.string().optional(),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(models.ItemsTypeKeyValueMetadata$outboundSchema)
    .optional(),
  enableStatistics: z.boolean().optional(),
  enableWritePageIndex: z.boolean().optional(),
  enablePageChecksum: z.boolean().optional(),
  emptyDirCleanupSec: z.number().optional(),
  directoryBatchSize: z.number().optional(),
  deadletterPath: z.string().optional(),
  maxRetryNum: z.number().optional(),
});

export function outputS3ToJSON(outputS3: OutputS3): string {
  return JSON.stringify(OutputS3$outboundSchema.parse(outputS3));
}

/** @internal */
export type OutputFilesystem$Outbound = {
  id: string;
  type: "filesystem";
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  destPath: string;
  stagePath?: string | undefined;
  addIdToStagePath?: boolean | undefined;
  removeEmptyDirs?: boolean | undefined;
  partitionExpr?: string | undefined;
  format?: string | undefined;
  baseFileName?: string | undefined;
  fileNameSuffix?: string | undefined;
  maxFileSizeMB?: number | undefined;
  maxFileOpenTimeSec?: number | undefined;
  maxFileIdleTimeSec?: number | undefined;
  maxOpenFiles?: number | undefined;
  headerLine?: string | undefined;
  writeHighWaterMark?: number | undefined;
  onBackpressure?: string | undefined;
  deadletterEnabled?: boolean | undefined;
  onDiskFullBackpressure?: string | undefined;
  forceCloseOnShutdown?: boolean | undefined;
  retrySettings?: models.RetrySettingsType$Outbound | undefined;
  description?: string | undefined;
  compress?: string | undefined;
  compressionLevel?: string | undefined;
  automaticSchema?: boolean | undefined;
  parquetSchema?: string | undefined;
  parquetVersion?: string | undefined;
  parquetDataPageVersion?: string | undefined;
  parquetRowGroupLength?: number | undefined;
  parquetPageSize?: string | undefined;
  shouldLogInvalidRows?: boolean | undefined;
  keyValueMetadata?:
    | Array<models.ItemsTypeKeyValueMetadata$Outbound>
    | undefined;
  enableStatistics?: boolean | undefined;
  enableWritePageIndex?: boolean | undefined;
  enablePageChecksum?: boolean | undefined;
  emptyDirCleanupSec?: number | undefined;
  directoryBatchSize?: number | undefined;
  deadletterPath?: string | undefined;
  maxRetryNum?: number | undefined;
};

/** @internal */
export const OutputFilesystem$outboundSchema: z.ZodType<
  OutputFilesystem$Outbound,
  z.ZodTypeDef,
  OutputFilesystem
> = z.object({
  id: z.string(),
  type: z.literal("filesystem"),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  destPath: z.string(),
  stagePath: z.string().optional(),
  addIdToStagePath: z.boolean().optional(),
  removeEmptyDirs: z.boolean().optional(),
  partitionExpr: z.string().optional(),
  format: models.DataFormatOptions$outboundSchema.optional(),
  baseFileName: z.string().optional(),
  fileNameSuffix: z.string().optional(),
  maxFileSizeMB: z.number().optional(),
  maxFileOpenTimeSec: z.number().optional(),
  maxFileIdleTimeSec: z.number().optional(),
  maxOpenFiles: z.number().optional(),
  headerLine: z.string().optional(),
  writeHighWaterMark: z.number().optional(),
  onBackpressure: models.BackpressureBehaviorOptions1$outboundSchema.optional(),
  deadletterEnabled: z.boolean().optional(),
  onDiskFullBackpressure: models.DiskSpaceProtectionOptions$outboundSchema
    .optional(),
  forceCloseOnShutdown: z.boolean().optional(),
  retrySettings: models.RetrySettingsType$outboundSchema.optional(),
  description: z.string().optional(),
  compress: models.CompressionOptions2$outboundSchema.optional(),
  compressionLevel: models.CompressionLevelOptions$outboundSchema.optional(),
  automaticSchema: z.boolean().optional(),
  parquetSchema: z.string().optional(),
  parquetVersion: models.ParquetVersionOptions$outboundSchema.optional(),
  parquetDataPageVersion: models.DataPageVersionOptions$outboundSchema
    .optional(),
  parquetRowGroupLength: z.number().optional(),
  parquetPageSize: z.string().optional(),
  shouldLogInvalidRows: z.boolean().optional(),
  keyValueMetadata: z.array(models.ItemsTypeKeyValueMetadata$outboundSchema)
    .optional(),
  enableStatistics: z.boolean().optional(),
  enableWritePageIndex: z.boolean().optional(),
  enablePageChecksum: z.boolean().optional(),
  emptyDirCleanupSec: z.number().optional(),
  directoryBatchSize: z.number().optional(),
  deadletterPath: z.string().optional(),
  maxRetryNum: z.number().optional(),
});

export function outputFilesystemToJSON(
  outputFilesystem: OutputFilesystem,
): string {
  return JSON.stringify(
    OutputFilesystem$outboundSchema.parse(outputFilesystem),
  );
}

/** @internal */
export type PqControlsSignalfx$Outbound = {};

/** @internal */
export const PqControlsSignalfx$outboundSchema: z.ZodType<
  PqControlsSignalfx$Outbound,
  z.ZodTypeDef,
  PqControlsSignalfx
> = z.object({});

export function pqControlsSignalfxToJSON(
  pqControlsSignalfx: PqControlsSignalfx,
): string {
  return JSON.stringify(
    PqControlsSignalfx$outboundSchema.parse(pqControlsSignalfx),
  );
}

/** @internal */
export type OutputSignalfx$Outbound = {
  id: string;
  type: "signalfx";
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  authType?: string | undefined;
  realm: string;
  concurrency?: number | undefined;
  maxPayloadSizeKB?: number | undefined;
  maxPayloadEvents?: number | undefined;
  compress?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  timeoutSec?: number | undefined;
  flushPeriodSec?: number | undefined;
  extraHttpHeaders?:
    | Array<models.ItemsTypeExtraHttpHeaders$Outbound>
    | undefined;
  useRoundRobinDns?: boolean | undefined;
  failedRequestLoggingMode?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<models.ItemsTypeResponseRetrySettings$Outbound>
    | undefined;
  timeoutRetrySettings?: models.TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader?: boolean | undefined;
  onBackpressure?: string | undefined;
  description?: string | undefined;
  token?: string | undefined;
  textSecret?: string | undefined;
  pqStrictOrdering?: boolean | undefined;
  pqRatePerSec?: number | undefined;
  pqMode?: string | undefined;
  pqMaxBufferSize?: number | undefined;
  pqMaxBackpressureSec?: number | undefined;
  pqMaxFileSize?: string | undefined;
  pqMaxSize?: string | undefined;
  pqPath?: string | undefined;
  pqCompress?: string | undefined;
  pqOnBackpressure?: string | undefined;
  pqControls?: PqControlsSignalfx$Outbound | undefined;
};

/** @internal */
export const OutputSignalfx$outboundSchema: z.ZodType<
  OutputSignalfx$Outbound,
  z.ZodTypeDef,
  OutputSignalfx
> = z.object({
  id: z.string(),
  type: z.literal("signalfx"),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  authType: models.AuthenticationMethodOptionsAuthTokensItems$outboundSchema
    .optional(),
  realm: z.string(),
  concurrency: z.number().optional(),
  maxPayloadSizeKB: z.number().optional(),
  maxPayloadEvents: z.number().optional(),
  compress: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  timeoutSec: z.number().optional(),
  flushPeriodSec: z.number().optional(),
  extraHttpHeaders: z.array(models.ItemsTypeExtraHttpHeaders$outboundSchema)
    .optional(),
  useRoundRobinDns: z.boolean().optional(),
  failedRequestLoggingMode: models
    .FailedRequestLoggingModeOptions$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    models.ItemsTypeResponseRetrySettings$outboundSchema,
  ).optional(),
  timeoutRetrySettings: models.TimeoutRetrySettingsType$outboundSchema
    .optional(),
  responseHonorRetryAfterHeader: z.boolean().optional(),
  onBackpressure: models.BackpressureBehaviorOptions$outboundSchema.optional(),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  pqStrictOrdering: z.boolean().optional(),
  pqRatePerSec: z.number().optional(),
  pqMode: models.ModeOptions$outboundSchema.optional(),
  pqMaxBufferSize: z.number().optional(),
  pqMaxBackpressureSec: z.number().optional(),
  pqMaxFileSize: z.string().optional(),
  pqMaxSize: z.string().optional(),
  pqPath: z.string().optional(),
  pqCompress: models.CompressionOptionsPq$outboundSchema.optional(),
  pqOnBackpressure: models.QueueFullBehaviorOptions$outboundSchema.optional(),
  pqControls: z.lazy(() => PqControlsSignalfx$outboundSchema).optional(),
});

export function outputSignalfxToJSON(outputSignalfx: OutputSignalfx): string {
  return JSON.stringify(OutputSignalfx$outboundSchema.parse(outputSignalfx));
}

/** @internal */
export type PqControlsWavefront$Outbound = {};

/** @internal */
export const PqControlsWavefront$outboundSchema: z.ZodType<
  PqControlsWavefront$Outbound,
  z.ZodTypeDef,
  PqControlsWavefront
> = z.object({});

export function pqControlsWavefrontToJSON(
  pqControlsWavefront: PqControlsWavefront,
): string {
  return JSON.stringify(
    PqControlsWavefront$outboundSchema.parse(pqControlsWavefront),
  );
}

/** @internal */
export type OutputWavefront$Outbound = {
  id: string;
  type: "wavefront";
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  authType?: string | undefined;
  domain: string;
  concurrency?: number | undefined;
  maxPayloadSizeKB?: number | undefined;
  maxPayloadEvents?: number | undefined;
  compress?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  timeoutSec?: number | undefined;
  flushPeriodSec?: number | undefined;
  extraHttpHeaders?:
    | Array<models.ItemsTypeExtraHttpHeaders$Outbound>
    | undefined;
  useRoundRobinDns?: boolean | undefined;
  failedRequestLoggingMode?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<models.ItemsTypeResponseRetrySettings$Outbound>
    | undefined;
  timeoutRetrySettings?: models.TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader?: boolean | undefined;
  onBackpressure?: string | undefined;
  description?: string | undefined;
  token?: string | undefined;
  textSecret?: string | undefined;
  pqStrictOrdering?: boolean | undefined;
  pqRatePerSec?: number | undefined;
  pqMode?: string | undefined;
  pqMaxBufferSize?: number | undefined;
  pqMaxBackpressureSec?: number | undefined;
  pqMaxFileSize?: string | undefined;
  pqMaxSize?: string | undefined;
  pqPath?: string | undefined;
  pqCompress?: string | undefined;
  pqOnBackpressure?: string | undefined;
  pqControls?: PqControlsWavefront$Outbound | undefined;
};

/** @internal */
export const OutputWavefront$outboundSchema: z.ZodType<
  OutputWavefront$Outbound,
  z.ZodTypeDef,
  OutputWavefront
> = z.object({
  id: z.string(),
  type: z.literal("wavefront"),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  authType: models.AuthenticationMethodOptionsAuthTokensItems$outboundSchema
    .optional(),
  domain: z.string(),
  concurrency: z.number().optional(),
  maxPayloadSizeKB: z.number().optional(),
  maxPayloadEvents: z.number().optional(),
  compress: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  timeoutSec: z.number().optional(),
  flushPeriodSec: z.number().optional(),
  extraHttpHeaders: z.array(models.ItemsTypeExtraHttpHeaders$outboundSchema)
    .optional(),
  useRoundRobinDns: z.boolean().optional(),
  failedRequestLoggingMode: models
    .FailedRequestLoggingModeOptions$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    models.ItemsTypeResponseRetrySettings$outboundSchema,
  ).optional(),
  timeoutRetrySettings: models.TimeoutRetrySettingsType$outboundSchema
    .optional(),
  responseHonorRetryAfterHeader: z.boolean().optional(),
  onBackpressure: models.BackpressureBehaviorOptions$outboundSchema.optional(),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  pqStrictOrdering: z.boolean().optional(),
  pqRatePerSec: z.number().optional(),
  pqMode: models.ModeOptions$outboundSchema.optional(),
  pqMaxBufferSize: z.number().optional(),
  pqMaxBackpressureSec: z.number().optional(),
  pqMaxFileSize: z.string().optional(),
  pqMaxSize: z.string().optional(),
  pqPath: z.string().optional(),
  pqCompress: models.CompressionOptionsPq$outboundSchema.optional(),
  pqOnBackpressure: models.QueueFullBehaviorOptions$outboundSchema.optional(),
  pqControls: z.lazy(() => PqControlsWavefront$outboundSchema).optional(),
});

export function outputWavefrontToJSON(
  outputWavefront: OutputWavefront,
): string {
  return JSON.stringify(OutputWavefront$outboundSchema.parse(outputWavefront));
}

/** @internal */
export type PqControlsTcpjson$Outbound = {};

/** @internal */
export const PqControlsTcpjson$outboundSchema: z.ZodType<
  PqControlsTcpjson$Outbound,
  z.ZodTypeDef,
  PqControlsTcpjson
> = z.object({});

export function pqControlsTcpjsonToJSON(
  pqControlsTcpjson: PqControlsTcpjson,
): string {
  return JSON.stringify(
    PqControlsTcpjson$outboundSchema.parse(pqControlsTcpjson),
  );
}

/** @internal */
export type OutputTcpjson$Outbound = {
  id: string;
  type: "tcpjson";
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  loadBalanced?: boolean | undefined;
  compression?: string | undefined;
  logFailedRequests?: boolean | undefined;
  throttleRatePerSec?: string | undefined;
  tls?:
    | models.TlsSettingsClientSideTypeKafkaSchemaRegistry$Outbound
    | undefined;
  connectionTimeout?: number | undefined;
  writeTimeout?: number | undefined;
  tokenTTLMinutes?: number | undefined;
  sendHeader?: boolean | undefined;
  onBackpressure?: string | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  host?: string | undefined;
  port?: number | undefined;
  excludeSelf?: boolean | undefined;
  hosts?: Array<models.ItemsTypeHosts$Outbound> | undefined;
  dnsResolvePeriodSec?: number | undefined;
  loadBalanceStatsPeriodSec?: number | undefined;
  maxConcurrentSenders?: number | undefined;
  pqStrictOrdering?: boolean | undefined;
  pqRatePerSec?: number | undefined;
  pqMode?: string | undefined;
  pqMaxBufferSize?: number | undefined;
  pqMaxBackpressureSec?: number | undefined;
  pqMaxFileSize?: string | undefined;
  pqMaxSize?: string | undefined;
  pqPath?: string | undefined;
  pqCompress?: string | undefined;
  pqOnBackpressure?: string | undefined;
  pqControls?: PqControlsTcpjson$Outbound | undefined;
  authToken?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const OutputTcpjson$outboundSchema: z.ZodType<
  OutputTcpjson$Outbound,
  z.ZodTypeDef,
  OutputTcpjson
> = z.object({
  id: z.string(),
  type: z.literal("tcpjson"),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  loadBalanced: z.boolean().optional(),
  compression: models.CompressionOptions1$outboundSchema.optional(),
  logFailedRequests: z.boolean().optional(),
  throttleRatePerSec: z.string().optional(),
  tls: models.TlsSettingsClientSideTypeKafkaSchemaRegistry$outboundSchema
    .optional(),
  connectionTimeout: z.number().optional(),
  writeTimeout: z.number().optional(),
  tokenTTLMinutes: z.number().optional(),
  sendHeader: z.boolean().optional(),
  onBackpressure: models.BackpressureBehaviorOptions$outboundSchema.optional(),
  authType: models.AuthenticationMethodOptionsAuthTokensItems$outboundSchema
    .optional(),
  description: z.string().optional(),
  host: z.string().optional(),
  port: z.number().optional(),
  excludeSelf: z.boolean().optional(),
  hosts: z.array(models.ItemsTypeHosts$outboundSchema).optional(),
  dnsResolvePeriodSec: z.number().optional(),
  loadBalanceStatsPeriodSec: z.number().optional(),
  maxConcurrentSenders: z.number().optional(),
  pqStrictOrdering: z.boolean().optional(),
  pqRatePerSec: z.number().optional(),
  pqMode: models.ModeOptions$outboundSchema.optional(),
  pqMaxBufferSize: z.number().optional(),
  pqMaxBackpressureSec: z.number().optional(),
  pqMaxFileSize: z.string().optional(),
  pqMaxSize: z.string().optional(),
  pqPath: z.string().optional(),
  pqCompress: models.CompressionOptionsPq$outboundSchema.optional(),
  pqOnBackpressure: models.QueueFullBehaviorOptions$outboundSchema.optional(),
  pqControls: z.lazy(() => PqControlsTcpjson$outboundSchema).optional(),
  authToken: z.string().optional(),
  textSecret: z.string().optional(),
});

export function outputTcpjsonToJSON(outputTcpjson: OutputTcpjson): string {
  return JSON.stringify(OutputTcpjson$outboundSchema.parse(outputTcpjson));
}

/** @internal */
export type PqControlsWizHec$Outbound = {};

/** @internal */
export const PqControlsWizHec$outboundSchema: z.ZodType<
  PqControlsWizHec$Outbound,
  z.ZodTypeDef,
  PqControlsWizHec
> = z.object({});

export function pqControlsWizHecToJSON(
  pqControlsWizHec: PqControlsWizHec,
): string {
  return JSON.stringify(
    PqControlsWizHec$outboundSchema.parse(pqControlsWizHec),
  );
}

/** @internal */
export type OutputWizHec$Outbound = {
  id: string;
  type: "wiz_hec";
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  loadBalanced?: any | undefined;
  nextQueue?: string | undefined;
  tcpRouting?: string | undefined;
  tls?: models.TlsSettingsClientSideType1$Outbound | undefined;
  concurrency?: number | undefined;
  maxPayloadSizeKB?: number | undefined;
  maxPayloadEvents?: number | undefined;
  compress?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  timeoutSec?: number | undefined;
  flushPeriodSec?: number | undefined;
  extraHttpHeaders?:
    | Array<models.ItemsTypeExtraHttpHeaders$Outbound>
    | undefined;
  failedRequestLoggingMode?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  enableMultiMetrics?: any | undefined;
  authType?: string | undefined;
  responseRetrySettings?:
    | Array<models.ItemsTypeResponseRetrySettings$Outbound>
    | undefined;
  timeoutRetrySettings?: models.TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader?: boolean | undefined;
  onBackpressure?: string | undefined;
  wiz_connector_id: string;
  wiz_environment: string;
  data_center: string;
  wiz_sourcetype: string;
  description?: string | undefined;
  pqStrictOrdering?: boolean | undefined;
  pqRatePerSec?: number | undefined;
  pqMode?: string | undefined;
  pqMaxBufferSize?: number | undefined;
  pqMaxBackpressureSec?: number | undefined;
  pqMaxFileSize?: string | undefined;
  pqMaxSize?: string | undefined;
  pqPath?: string | undefined;
  pqCompress?: string | undefined;
  pqOnBackpressure?: string | undefined;
  pqControls?: PqControlsWizHec$Outbound | undefined;
  token?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const OutputWizHec$outboundSchema: z.ZodType<
  OutputWizHec$Outbound,
  z.ZodTypeDef,
  OutputWizHec
> = z.object({
  id: z.string(),
  type: z.literal("wiz_hec"),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  loadBalanced: z.any().optional(),
  nextQueue: z.string().optional(),
  tcpRouting: z.string().optional(),
  tls: models.TlsSettingsClientSideType1$outboundSchema.optional(),
  concurrency: z.number().optional(),
  maxPayloadSizeKB: z.number().optional(),
  maxPayloadEvents: z.number().optional(),
  compress: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  timeoutSec: z.number().optional(),
  flushPeriodSec: z.number().optional(),
  extraHttpHeaders: z.array(models.ItemsTypeExtraHttpHeaders$outboundSchema)
    .optional(),
  failedRequestLoggingMode: models
    .FailedRequestLoggingModeOptions$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  enableMultiMetrics: z.any().optional(),
  authType: models.AuthenticationMethodOptionsAuthTokensItems$outboundSchema
    .optional(),
  responseRetrySettings: z.array(
    models.ItemsTypeResponseRetrySettings$outboundSchema,
  ).optional(),
  timeoutRetrySettings: models.TimeoutRetrySettingsType$outboundSchema
    .optional(),
  responseHonorRetryAfterHeader: z.boolean().optional(),
  onBackpressure: models.BackpressureBehaviorOptions$outboundSchema.optional(),
  wiz_connector_id: z.string(),
  wiz_environment: z.string(),
  data_center: z.string(),
  wiz_sourcetype: z.string(),
  description: z.string().optional(),
  pqStrictOrdering: z.boolean().optional(),
  pqRatePerSec: z.number().optional(),
  pqMode: models.ModeOptions$outboundSchema.optional(),
  pqMaxBufferSize: z.number().optional(),
  pqMaxBackpressureSec: z.number().optional(),
  pqMaxFileSize: z.string().optional(),
  pqMaxSize: z.string().optional(),
  pqPath: z.string().optional(),
  pqCompress: models.CompressionOptionsPq$outboundSchema.optional(),
  pqOnBackpressure: models.QueueFullBehaviorOptions$outboundSchema.optional(),
  pqControls: z.lazy(() => PqControlsWizHec$outboundSchema).optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
});

export function outputWizHecToJSON(outputWizHec: OutputWizHec): string {
  return JSON.stringify(OutputWizHec$outboundSchema.parse(outputWizHec));
}

/** @internal */
export type UrlSplunkHec$Outbound = {
  url: string;
  weight?: number | undefined;
};

/** @internal */
export const UrlSplunkHec$outboundSchema: z.ZodType<
  UrlSplunkHec$Outbound,
  z.ZodTypeDef,
  UrlSplunkHec
> = z.object({
  url: z.string(),
  weight: z.number().optional(),
});

export function urlSplunkHecToJSON(urlSplunkHec: UrlSplunkHec): string {
  return JSON.stringify(UrlSplunkHec$outboundSchema.parse(urlSplunkHec));
}

/** @internal */
export type PqControlsSplunkHec$Outbound = {};

/** @internal */
export const PqControlsSplunkHec$outboundSchema: z.ZodType<
  PqControlsSplunkHec$Outbound,
  z.ZodTypeDef,
  PqControlsSplunkHec
> = z.object({});

export function pqControlsSplunkHecToJSON(
  pqControlsSplunkHec: PqControlsSplunkHec,
): string {
  return JSON.stringify(
    PqControlsSplunkHec$outboundSchema.parse(pqControlsSplunkHec),
  );
}

/** @internal */
export type OutputSplunkHec$Outbound = {
  id: string;
  type: "splunk_hec";
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  loadBalanced?: boolean | undefined;
  nextQueue?: string | undefined;
  tcpRouting?: string | undefined;
  tls?: models.TlsSettingsClientSideType1$Outbound | undefined;
  concurrency?: number | undefined;
  maxPayloadSizeKB?: number | undefined;
  maxPayloadEvents?: number | undefined;
  compress?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  timeoutSec?: number | undefined;
  flushPeriodSec?: number | undefined;
  extraHttpHeaders?:
    | Array<models.ItemsTypeExtraHttpHeaders$Outbound>
    | undefined;
  failedRequestLoggingMode?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  enableMultiMetrics?: boolean | undefined;
  authType?: string | undefined;
  responseRetrySettings?:
    | Array<models.ItemsTypeResponseRetrySettings$Outbound>
    | undefined;
  timeoutRetrySettings?: models.TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader?: boolean | undefined;
  onBackpressure?: string | undefined;
  description?: string | undefined;
  url?: string | undefined;
  useRoundRobinDns?: boolean | undefined;
  excludeSelf?: boolean | undefined;
  urls?: Array<UrlSplunkHec$Outbound> | undefined;
  dnsResolvePeriodSec?: number | undefined;
  loadBalanceStatsPeriodSec?: number | undefined;
  token?: string | undefined;
  textSecret?: string | undefined;
  pqStrictOrdering?: boolean | undefined;
  pqRatePerSec?: number | undefined;
  pqMode?: string | undefined;
  pqMaxBufferSize?: number | undefined;
  pqMaxBackpressureSec?: number | undefined;
  pqMaxFileSize?: string | undefined;
  pqMaxSize?: string | undefined;
  pqPath?: string | undefined;
  pqCompress?: string | undefined;
  pqOnBackpressure?: string | undefined;
  pqControls?: PqControlsSplunkHec$Outbound | undefined;
};

/** @internal */
export const OutputSplunkHec$outboundSchema: z.ZodType<
  OutputSplunkHec$Outbound,
  z.ZodTypeDef,
  OutputSplunkHec
> = z.object({
  id: z.string(),
  type: z.literal("splunk_hec"),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  loadBalanced: z.boolean().optional(),
  nextQueue: z.string().optional(),
  tcpRouting: z.string().optional(),
  tls: models.TlsSettingsClientSideType1$outboundSchema.optional(),
  concurrency: z.number().optional(),
  maxPayloadSizeKB: z.number().optional(),
  maxPayloadEvents: z.number().optional(),
  compress: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  timeoutSec: z.number().optional(),
  flushPeriodSec: z.number().optional(),
  extraHttpHeaders: z.array(models.ItemsTypeExtraHttpHeaders$outboundSchema)
    .optional(),
  failedRequestLoggingMode: models
    .FailedRequestLoggingModeOptions$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  enableMultiMetrics: z.boolean().optional(),
  authType: models.AuthenticationMethodOptionsAuthTokensItems$outboundSchema
    .optional(),
  responseRetrySettings: z.array(
    models.ItemsTypeResponseRetrySettings$outboundSchema,
  ).optional(),
  timeoutRetrySettings: models.TimeoutRetrySettingsType$outboundSchema
    .optional(),
  responseHonorRetryAfterHeader: z.boolean().optional(),
  onBackpressure: models.BackpressureBehaviorOptions$outboundSchema.optional(),
  description: z.string().optional(),
  url: z.string().optional(),
  useRoundRobinDns: z.boolean().optional(),
  excludeSelf: z.boolean().optional(),
  urls: z.array(z.lazy(() => UrlSplunkHec$outboundSchema)).optional(),
  dnsResolvePeriodSec: z.number().optional(),
  loadBalanceStatsPeriodSec: z.number().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  pqStrictOrdering: z.boolean().optional(),
  pqRatePerSec: z.number().optional(),
  pqMode: models.ModeOptions$outboundSchema.optional(),
  pqMaxBufferSize: z.number().optional(),
  pqMaxBackpressureSec: z.number().optional(),
  pqMaxFileSize: z.string().optional(),
  pqMaxSize: z.string().optional(),
  pqPath: z.string().optional(),
  pqCompress: models.CompressionOptionsPq$outboundSchema.optional(),
  pqOnBackpressure: models.QueueFullBehaviorOptions$outboundSchema.optional(),
  pqControls: z.lazy(() => PqControlsSplunkHec$outboundSchema).optional(),
});

export function outputSplunkHecToJSON(
  outputSplunkHec: OutputSplunkHec,
): string {
  return JSON.stringify(OutputSplunkHec$outboundSchema.parse(outputSplunkHec));
}

/** @internal */
export type CreateOutputAuthToken$Outbound = {
  authType?: string | undefined;
  authToken?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const CreateOutputAuthToken$outboundSchema: z.ZodType<
  CreateOutputAuthToken$Outbound,
  z.ZodTypeDef,
  CreateOutputAuthToken
> = z.object({
  authType: models.AuthenticationMethodOptionsAuthTokensItems$outboundSchema
    .optional(),
  authToken: z.string().optional(),
  textSecret: z.string().optional(),
});

export function createOutputAuthTokenToJSON(
  createOutputAuthToken: CreateOutputAuthToken,
): string {
  return JSON.stringify(
    CreateOutputAuthToken$outboundSchema.parse(createOutputAuthToken),
  );
}

/** @internal */
export type IndexerDiscoveryConfigs$Outbound = {
  site: string;
  masterUri: string;
  refreshIntervalSec: number;
  rejectUnauthorized?: boolean | undefined;
  authTokens?: Array<CreateOutputAuthToken$Outbound> | undefined;
  authType?: string | undefined;
  authToken?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const IndexerDiscoveryConfigs$outboundSchema: z.ZodType<
  IndexerDiscoveryConfigs$Outbound,
  z.ZodTypeDef,
  IndexerDiscoveryConfigs
> = z.object({
  site: z.string(),
  masterUri: z.string(),
  refreshIntervalSec: z.number(),
  rejectUnauthorized: z.boolean().optional(),
  authTokens: z.array(z.lazy(() => CreateOutputAuthToken$outboundSchema))
    .optional(),
  authType: models.AuthenticationMethodOptionsAuthTokensItems$outboundSchema
    .optional(),
  authToken: z.string().optional(),
  textSecret: z.string().optional(),
});

export function indexerDiscoveryConfigsToJSON(
  indexerDiscoveryConfigs: IndexerDiscoveryConfigs,
): string {
  return JSON.stringify(
    IndexerDiscoveryConfigs$outboundSchema.parse(indexerDiscoveryConfigs),
  );
}

/** @internal */
export type PqControlsSplunkLb$Outbound = {};

/** @internal */
export const PqControlsSplunkLb$outboundSchema: z.ZodType<
  PqControlsSplunkLb$Outbound,
  z.ZodTypeDef,
  PqControlsSplunkLb
> = z.object({});

export function pqControlsSplunkLbToJSON(
  pqControlsSplunkLb: PqControlsSplunkLb,
): string {
  return JSON.stringify(
    PqControlsSplunkLb$outboundSchema.parse(pqControlsSplunkLb),
  );
}

/** @internal */
export type OutputSplunkLb$Outbound = {
  id: string;
  type: "splunk_lb";
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  dnsResolvePeriodSec?: number | undefined;
  loadBalanceStatsPeriodSec?: number | undefined;
  maxConcurrentSenders?: number | undefined;
  nestedFields?: string | undefined;
  throttleRatePerSec?: string | undefined;
  connectionTimeout?: number | undefined;
  writeTimeout?: number | undefined;
  tls?:
    | models.TlsSettingsClientSideTypeKafkaSchemaRegistry$Outbound
    | undefined;
  enableMultiMetrics?: boolean | undefined;
  enableACK?: boolean | undefined;
  logFailedRequests?: boolean | undefined;
  maxS2Sversion?: string | undefined;
  onBackpressure?: string | undefined;
  indexerDiscovery?: boolean | undefined;
  senderUnhealthyTimeAllowance?: number | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  maxFailedHealthChecks?: number | undefined;
  compress?: string | undefined;
  indexerDiscoveryConfigs?: IndexerDiscoveryConfigs$Outbound | undefined;
  excludeSelf?: boolean | undefined;
  hosts: Array<models.ItemsTypeHosts$Outbound>;
  pqStrictOrdering?: boolean | undefined;
  pqRatePerSec?: number | undefined;
  pqMode?: string | undefined;
  pqMaxBufferSize?: number | undefined;
  pqMaxBackpressureSec?: number | undefined;
  pqMaxFileSize?: string | undefined;
  pqMaxSize?: string | undefined;
  pqPath?: string | undefined;
  pqCompress?: string | undefined;
  pqOnBackpressure?: string | undefined;
  pqControls?: PqControlsSplunkLb$Outbound | undefined;
  authToken?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const OutputSplunkLb$outboundSchema: z.ZodType<
  OutputSplunkLb$Outbound,
  z.ZodTypeDef,
  OutputSplunkLb
> = z.object({
  id: z.string(),
  type: z.literal("splunk_lb"),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  dnsResolvePeriodSec: z.number().optional(),
  loadBalanceStatsPeriodSec: z.number().optional(),
  maxConcurrentSenders: z.number().optional(),
  nestedFields: models.NestedFieldSerializationOptions$outboundSchema
    .optional(),
  throttleRatePerSec: z.string().optional(),
  connectionTimeout: z.number().optional(),
  writeTimeout: z.number().optional(),
  tls: models.TlsSettingsClientSideTypeKafkaSchemaRegistry$outboundSchema
    .optional(),
  enableMultiMetrics: z.boolean().optional(),
  enableACK: z.boolean().optional(),
  logFailedRequests: z.boolean().optional(),
  maxS2Sversion: models.MaxS2SVersionOptions$outboundSchema.optional(),
  onBackpressure: models.BackpressureBehaviorOptions$outboundSchema.optional(),
  indexerDiscovery: z.boolean().optional(),
  senderUnhealthyTimeAllowance: z.number().optional(),
  authType: models.AuthenticationMethodOptionsAuthTokensItems$outboundSchema
    .optional(),
  description: z.string().optional(),
  maxFailedHealthChecks: z.number().optional(),
  compress: models.CompressionOptions$outboundSchema.optional(),
  indexerDiscoveryConfigs: z.lazy(() => IndexerDiscoveryConfigs$outboundSchema)
    .optional(),
  excludeSelf: z.boolean().optional(),
  hosts: z.array(models.ItemsTypeHosts$outboundSchema),
  pqStrictOrdering: z.boolean().optional(),
  pqRatePerSec: z.number().optional(),
  pqMode: models.ModeOptions$outboundSchema.optional(),
  pqMaxBufferSize: z.number().optional(),
  pqMaxBackpressureSec: z.number().optional(),
  pqMaxFileSize: z.string().optional(),
  pqMaxSize: z.string().optional(),
  pqPath: z.string().optional(),
  pqCompress: models.CompressionOptionsPq$outboundSchema.optional(),
  pqOnBackpressure: models.QueueFullBehaviorOptions$outboundSchema.optional(),
  pqControls: z.lazy(() => PqControlsSplunkLb$outboundSchema).optional(),
  authToken: z.string().optional(),
  textSecret: z.string().optional(),
});

export function outputSplunkLbToJSON(outputSplunkLb: OutputSplunkLb): string {
  return JSON.stringify(OutputSplunkLb$outboundSchema.parse(outputSplunkLb));
}

/** @internal */
export type PqControlsSplunk$Outbound = {};

/** @internal */
export const PqControlsSplunk$outboundSchema: z.ZodType<
  PqControlsSplunk$Outbound,
  z.ZodTypeDef,
  PqControlsSplunk
> = z.object({});

export function pqControlsSplunkToJSON(
  pqControlsSplunk: PqControlsSplunk,
): string {
  return JSON.stringify(
    PqControlsSplunk$outboundSchema.parse(pqControlsSplunk),
  );
}

/** @internal */
export type OutputSplunk$Outbound = {
  id: string;
  type: "splunk";
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  host: string;
  port: number;
  nestedFields?: string | undefined;
  throttleRatePerSec?: string | undefined;
  connectionTimeout?: number | undefined;
  writeTimeout?: number | undefined;
  tls?:
    | models.TlsSettingsClientSideTypeKafkaSchemaRegistry$Outbound
    | undefined;
  enableMultiMetrics?: boolean | undefined;
  enableACK?: boolean | undefined;
  logFailedRequests?: boolean | undefined;
  maxS2Sversion?: string | undefined;
  onBackpressure?: string | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  maxFailedHealthChecks?: number | undefined;
  compress?: string | undefined;
  pqStrictOrdering?: boolean | undefined;
  pqRatePerSec?: number | undefined;
  pqMode?: string | undefined;
  pqMaxBufferSize?: number | undefined;
  pqMaxBackpressureSec?: number | undefined;
  pqMaxFileSize?: string | undefined;
  pqMaxSize?: string | undefined;
  pqPath?: string | undefined;
  pqCompress?: string | undefined;
  pqOnBackpressure?: string | undefined;
  pqControls?: PqControlsSplunk$Outbound | undefined;
  authToken?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const OutputSplunk$outboundSchema: z.ZodType<
  OutputSplunk$Outbound,
  z.ZodTypeDef,
  OutputSplunk
> = z.object({
  id: z.string(),
  type: z.literal("splunk"),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  host: z.string(),
  port: z.number(),
  nestedFields: models.NestedFieldSerializationOptions$outboundSchema
    .optional(),
  throttleRatePerSec: z.string().optional(),
  connectionTimeout: z.number().optional(),
  writeTimeout: z.number().optional(),
  tls: models.TlsSettingsClientSideTypeKafkaSchemaRegistry$outboundSchema
    .optional(),
  enableMultiMetrics: z.boolean().optional(),
  enableACK: z.boolean().optional(),
  logFailedRequests: z.boolean().optional(),
  maxS2Sversion: models.MaxS2SVersionOptions$outboundSchema.optional(),
  onBackpressure: models.BackpressureBehaviorOptions$outboundSchema.optional(),
  authType: models.AuthenticationMethodOptionsAuthTokensItems$outboundSchema
    .optional(),
  description: z.string().optional(),
  maxFailedHealthChecks: z.number().optional(),
  compress: models.CompressionOptions$outboundSchema.optional(),
  pqStrictOrdering: z.boolean().optional(),
  pqRatePerSec: z.number().optional(),
  pqMode: models.ModeOptions$outboundSchema.optional(),
  pqMaxBufferSize: z.number().optional(),
  pqMaxBackpressureSec: z.number().optional(),
  pqMaxFileSize: z.string().optional(),
  pqMaxSize: z.string().optional(),
  pqPath: z.string().optional(),
  pqCompress: models.CompressionOptionsPq$outboundSchema.optional(),
  pqOnBackpressure: models.QueueFullBehaviorOptions$outboundSchema.optional(),
  pqControls: z.lazy(() => PqControlsSplunk$outboundSchema).optional(),
  authToken: z.string().optional(),
  textSecret: z.string().optional(),
});

export function outputSplunkToJSON(outputSplunk: OutputSplunk): string {
  return JSON.stringify(OutputSplunk$outboundSchema.parse(outputSplunk));
}

/** @internal */
export const ProtocolSyslog$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  ProtocolSyslog
> = openEnums.outboundSchema(ProtocolSyslog);

/** @internal */
export const Facility$outboundSchema: z.ZodType<
  number,
  z.ZodTypeDef,
  Facility
> = openEnums.outboundSchemaInt(Facility);

/** @internal */
export const SeveritySyslog$outboundSchema: z.ZodType<
  number,
  z.ZodTypeDef,
  SeveritySyslog
> = openEnums.outboundSchemaInt(SeveritySyslog);

/** @internal */
export const MessageFormat$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  MessageFormat
> = openEnums.outboundSchema(MessageFormat);

/** @internal */
export const TimestampFormat$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  TimestampFormat
> = openEnums.outboundSchema(TimestampFormat);

/** @internal */
export type PqControlsSyslog$Outbound = {};

/** @internal */
export const PqControlsSyslog$outboundSchema: z.ZodType<
  PqControlsSyslog$Outbound,
  z.ZodTypeDef,
  PqControlsSyslog
> = z.object({});

export function pqControlsSyslogToJSON(
  pqControlsSyslog: PqControlsSyslog,
): string {
  return JSON.stringify(
    PqControlsSyslog$outboundSchema.parse(pqControlsSyslog),
  );
}

/** @internal */
export type OutputSyslog$Outbound = {
  id: string;
  type: "syslog";
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  protocol?: string | undefined;
  facility?: number | undefined;
  severity?: number | undefined;
  appName?: string | undefined;
  messageFormat?: string | undefined;
  timestampFormat?: string | undefined;
  throttleRatePerSec?: string | undefined;
  octetCountFraming?: boolean | undefined;
  logFailedRequests?: boolean | undefined;
  description?: string | undefined;
  loadBalanced?: boolean | undefined;
  host?: string | undefined;
  port?: number | undefined;
  excludeSelf?: boolean | undefined;
  hosts?: Array<models.ItemsTypeHosts$Outbound> | undefined;
  dnsResolvePeriodSec?: number | undefined;
  loadBalanceStatsPeriodSec?: number | undefined;
  maxConcurrentSenders?: number | undefined;
  connectionTimeout?: number | undefined;
  writeTimeout?: number | undefined;
  tls?:
    | models.TlsSettingsClientSideTypeKafkaSchemaRegistry$Outbound
    | undefined;
  onBackpressure?: string | undefined;
  maxRecordSize?: number | undefined;
  udpDnsResolvePeriodSec?: number | undefined;
  enableIpSpoofing?: boolean | undefined;
  pqStrictOrdering?: boolean | undefined;
  pqRatePerSec?: number | undefined;
  pqMode?: string | undefined;
  pqMaxBufferSize?: number | undefined;
  pqMaxBackpressureSec?: number | undefined;
  pqMaxFileSize?: string | undefined;
  pqMaxSize?: string | undefined;
  pqPath?: string | undefined;
  pqCompress?: string | undefined;
  pqOnBackpressure?: string | undefined;
  pqControls?: PqControlsSyslog$Outbound | undefined;
};

/** @internal */
export const OutputSyslog$outboundSchema: z.ZodType<
  OutputSyslog$Outbound,
  z.ZodTypeDef,
  OutputSyslog
> = z.object({
  id: z.string(),
  type: z.literal("syslog"),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  protocol: ProtocolSyslog$outboundSchema.optional(),
  facility: Facility$outboundSchema.optional(),
  severity: SeveritySyslog$outboundSchema.optional(),
  appName: z.string().optional(),
  messageFormat: MessageFormat$outboundSchema.optional(),
  timestampFormat: TimestampFormat$outboundSchema.optional(),
  throttleRatePerSec: z.string().optional(),
  octetCountFraming: z.boolean().optional(),
  logFailedRequests: z.boolean().optional(),
  description: z.string().optional(),
  loadBalanced: z.boolean().optional(),
  host: z.string().optional(),
  port: z.number().optional(),
  excludeSelf: z.boolean().optional(),
  hosts: z.array(models.ItemsTypeHosts$outboundSchema).optional(),
  dnsResolvePeriodSec: z.number().optional(),
  loadBalanceStatsPeriodSec: z.number().optional(),
  maxConcurrentSenders: z.number().optional(),
  connectionTimeout: z.number().optional(),
  writeTimeout: z.number().optional(),
  tls: models.TlsSettingsClientSideTypeKafkaSchemaRegistry$outboundSchema
    .optional(),
  onBackpressure: models.BackpressureBehaviorOptions$outboundSchema.optional(),
  maxRecordSize: z.number().optional(),
  udpDnsResolvePeriodSec: z.number().optional(),
  enableIpSpoofing: z.boolean().optional(),
  pqStrictOrdering: z.boolean().optional(),
  pqRatePerSec: z.number().optional(),
  pqMode: models.ModeOptions$outboundSchema.optional(),
  pqMaxBufferSize: z.number().optional(),
  pqMaxBackpressureSec: z.number().optional(),
  pqMaxFileSize: z.string().optional(),
  pqMaxSize: z.string().optional(),
  pqPath: z.string().optional(),
  pqCompress: models.CompressionOptionsPq$outboundSchema.optional(),
  pqOnBackpressure: models.QueueFullBehaviorOptions$outboundSchema.optional(),
  pqControls: z.lazy(() => PqControlsSyslog$outboundSchema).optional(),
});

export function outputSyslogToJSON(outputSyslog: OutputSyslog): string {
  return JSON.stringify(OutputSyslog$outboundSchema.parse(outputSyslog));
}

/** @internal */
export type OutputDevnull$Outbound = {
  id: string;
  type: "devnull";
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
};

/** @internal */
export const OutputDevnull$outboundSchema: z.ZodType<
  OutputDevnull$Outbound,
  z.ZodTypeDef,
  OutputDevnull
> = z.object({
  id: z.string(),
  type: z.literal("devnull"),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
});

export function outputDevnullToJSON(outputDevnull: OutputDevnull): string {
  return JSON.stringify(OutputDevnull$outboundSchema.parse(outputDevnull));
}

/** @internal */
export const AuthType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  AuthType
> = openEnums.outboundSchema(AuthType);

/** @internal */
export const EndpointConfiguration$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  EndpointConfiguration
> = openEnums.outboundSchema(EndpointConfiguration);

/** @internal */
export const FormatSentinel$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  FormatSentinel
> = openEnums.outboundSchema(FormatSentinel);

/** @internal */
export type PqControlsSentinel$Outbound = {};

/** @internal */
export const PqControlsSentinel$outboundSchema: z.ZodType<
  PqControlsSentinel$Outbound,
  z.ZodTypeDef,
  PqControlsSentinel
> = z.object({});

export function pqControlsSentinelToJSON(
  pqControlsSentinel: PqControlsSentinel,
): string {
  return JSON.stringify(
    PqControlsSentinel$outboundSchema.parse(pqControlsSentinel),
  );
}

/** @internal */
export type OutputSentinel$Outbound = {
  id: string;
  type: "sentinel";
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  keepAlive?: boolean | undefined;
  concurrency?: number | undefined;
  maxPayloadSizeKB?: number | undefined;
  maxPayloadEvents?: number | undefined;
  compress?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  timeoutSec?: number | undefined;
  flushPeriodSec?: number | undefined;
  extraHttpHeaders?:
    | Array<models.ItemsTypeExtraHttpHeaders$Outbound>
    | undefined;
  useRoundRobinDns?: boolean | undefined;
  failedRequestLoggingMode?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<models.ItemsTypeResponseRetrySettings$Outbound>
    | undefined;
  timeoutRetrySettings?: models.TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader?: boolean | undefined;
  onBackpressure?: string | undefined;
  authType?: string | undefined;
  loginUrl: string;
  secret: string;
  client_id: string;
  scope?: string | undefined;
  endpointURLConfiguration: string;
  totalMemoryLimitKB?: number | undefined;
  description?: string | undefined;
  format?: string | undefined;
  customSourceExpression?: string | undefined;
  customDropWhenNull?: boolean | undefined;
  customEventDelimiter?: string | undefined;
  customContentType?: string | undefined;
  customPayloadExpression?: string | undefined;
  advancedContentType?: string | undefined;
  formatEventCode?: string | undefined;
  formatPayloadCode?: string | undefined;
  pqStrictOrdering?: boolean | undefined;
  pqRatePerSec?: number | undefined;
  pqMode?: string | undefined;
  pqMaxBufferSize?: number | undefined;
  pqMaxBackpressureSec?: number | undefined;
  pqMaxFileSize?: string | undefined;
  pqMaxSize?: string | undefined;
  pqPath?: string | undefined;
  pqCompress?: string | undefined;
  pqOnBackpressure?: string | undefined;
  pqControls?: PqControlsSentinel$Outbound | undefined;
  url?: string | undefined;
  dcrID?: string | undefined;
  dceEndpoint?: string | undefined;
  streamName?: string | undefined;
};

/** @internal */
export const OutputSentinel$outboundSchema: z.ZodType<
  OutputSentinel$Outbound,
  z.ZodTypeDef,
  OutputSentinel
> = z.object({
  id: z.string(),
  type: z.literal("sentinel"),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  keepAlive: z.boolean().optional(),
  concurrency: z.number().optional(),
  maxPayloadSizeKB: z.number().optional(),
  maxPayloadEvents: z.number().optional(),
  compress: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  timeoutSec: z.number().optional(),
  flushPeriodSec: z.number().optional(),
  extraHttpHeaders: z.array(models.ItemsTypeExtraHttpHeaders$outboundSchema)
    .optional(),
  useRoundRobinDns: z.boolean().optional(),
  failedRequestLoggingMode: models
    .FailedRequestLoggingModeOptions$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    models.ItemsTypeResponseRetrySettings$outboundSchema,
  ).optional(),
  timeoutRetrySettings: models.TimeoutRetrySettingsType$outboundSchema
    .optional(),
  responseHonorRetryAfterHeader: z.boolean().optional(),
  onBackpressure: models.BackpressureBehaviorOptions$outboundSchema.optional(),
  authType: AuthType$outboundSchema.optional(),
  loginUrl: z.string(),
  secret: z.string(),
  client_id: z.string(),
  scope: z.string().optional(),
  endpointURLConfiguration: EndpointConfiguration$outboundSchema,
  totalMemoryLimitKB: z.number().optional(),
  description: z.string().optional(),
  format: FormatSentinel$outboundSchema.optional(),
  customSourceExpression: z.string().optional(),
  customDropWhenNull: z.boolean().optional(),
  customEventDelimiter: z.string().optional(),
  customContentType: z.string().optional(),
  customPayloadExpression: z.string().optional(),
  advancedContentType: z.string().optional(),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().optional(),
  pqRatePerSec: z.number().optional(),
  pqMode: models.ModeOptions$outboundSchema.optional(),
  pqMaxBufferSize: z.number().optional(),
  pqMaxBackpressureSec: z.number().optional(),
  pqMaxFileSize: z.string().optional(),
  pqMaxSize: z.string().optional(),
  pqPath: z.string().optional(),
  pqCompress: models.CompressionOptionsPq$outboundSchema.optional(),
  pqOnBackpressure: models.QueueFullBehaviorOptions$outboundSchema.optional(),
  pqControls: z.lazy(() => PqControlsSentinel$outboundSchema).optional(),
  url: z.string().optional(),
  dcrID: z.string().optional(),
  dceEndpoint: z.string().optional(),
  streamName: z.string().optional(),
});

export function outputSentinelToJSON(outputSentinel: OutputSentinel): string {
  return JSON.stringify(OutputSentinel$outboundSchema.parse(outputSentinel));
}

/** @internal */
export const FormatWebhook$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  FormatWebhook
> = openEnums.outboundSchema(FormatWebhook);

/** @internal */
export const AuthenticationTypeWebhook$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  AuthenticationTypeWebhook
> = openEnums.outboundSchema(AuthenticationTypeWebhook);

/** @internal */
export type PqControlsWebhook$Outbound = {};

/** @internal */
export const PqControlsWebhook$outboundSchema: z.ZodType<
  PqControlsWebhook$Outbound,
  z.ZodTypeDef,
  PqControlsWebhook
> = z.object({});

export function pqControlsWebhookToJSON(
  pqControlsWebhook: PqControlsWebhook,
): string {
  return JSON.stringify(
    PqControlsWebhook$outboundSchema.parse(pqControlsWebhook),
  );
}

/** @internal */
export type UrlWebhook$Outbound = {
  url: string;
  weight?: number | undefined;
};

/** @internal */
export const UrlWebhook$outboundSchema: z.ZodType<
  UrlWebhook$Outbound,
  z.ZodTypeDef,
  UrlWebhook
> = z.object({
  url: z.string(),
  weight: z.number().optional(),
});

export function urlWebhookToJSON(urlWebhook: UrlWebhook): string {
  return JSON.stringify(UrlWebhook$outboundSchema.parse(urlWebhook));
}

/** @internal */
export type OutputWebhook$Outbound = {
  id: string;
  type: "webhook";
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  method?: string | undefined;
  format?: string | undefined;
  keepAlive?: boolean | undefined;
  concurrency?: number | undefined;
  maxPayloadSizeKB?: number | undefined;
  maxPayloadEvents?: number | undefined;
  compress?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  timeoutSec?: number | undefined;
  flushPeriodSec?: number | undefined;
  extraHttpHeaders?:
    | Array<models.ItemsTypeExtraHttpHeaders$Outbound>
    | undefined;
  useRoundRobinDns?: boolean | undefined;
  failedRequestLoggingMode?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  responseRetrySettings?:
    | Array<models.ItemsTypeResponseRetrySettings$Outbound>
    | undefined;
  timeoutRetrySettings?: models.TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader?: boolean | undefined;
  onBackpressure?: string | undefined;
  authType?: string | undefined;
  tls?: models.TlsSettingsClientSideType1$Outbound | undefined;
  totalMemoryLimitKB?: number | undefined;
  loadBalanced?: boolean | undefined;
  description?: string | undefined;
  customSourceExpression?: string | undefined;
  customDropWhenNull?: boolean | undefined;
  customEventDelimiter?: string | undefined;
  customContentType?: string | undefined;
  customPayloadExpression?: string | undefined;
  advancedContentType?: string | undefined;
  formatEventCode?: string | undefined;
  formatPayloadCode?: string | undefined;
  pqStrictOrdering?: boolean | undefined;
  pqRatePerSec?: number | undefined;
  pqMode?: string | undefined;
  pqMaxBufferSize?: number | undefined;
  pqMaxBackpressureSec?: number | undefined;
  pqMaxFileSize?: string | undefined;
  pqMaxSize?: string | undefined;
  pqPath?: string | undefined;
  pqCompress?: string | undefined;
  pqOnBackpressure?: string | undefined;
  pqControls?: PqControlsWebhook$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr?: string | undefined;
  tokenTimeoutSecs?: number | undefined;
  oauthParams?: Array<models.ItemsTypeOauthParams$Outbound> | undefined;
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders$Outbound> | undefined;
  url?: string | undefined;
  excludeSelf?: boolean | undefined;
  urls?: Array<UrlWebhook$Outbound> | undefined;
  dnsResolvePeriodSec?: number | undefined;
  loadBalanceStatsPeriodSec?: number | undefined;
};

/** @internal */
export const OutputWebhook$outboundSchema: z.ZodType<
  OutputWebhook$Outbound,
  z.ZodTypeDef,
  OutputWebhook
> = z.object({
  id: z.string(),
  type: z.literal("webhook"),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  method: models.MethodOptions$outboundSchema.optional(),
  format: FormatWebhook$outboundSchema.optional(),
  keepAlive: z.boolean().optional(),
  concurrency: z.number().optional(),
  maxPayloadSizeKB: z.number().optional(),
  maxPayloadEvents: z.number().optional(),
  compress: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  timeoutSec: z.number().optional(),
  flushPeriodSec: z.number().optional(),
  extraHttpHeaders: z.array(models.ItemsTypeExtraHttpHeaders$outboundSchema)
    .optional(),
  useRoundRobinDns: z.boolean().optional(),
  failedRequestLoggingMode: models
    .FailedRequestLoggingModeOptions$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  responseRetrySettings: z.array(
    models.ItemsTypeResponseRetrySettings$outboundSchema,
  ).optional(),
  timeoutRetrySettings: models.TimeoutRetrySettingsType$outboundSchema
    .optional(),
  responseHonorRetryAfterHeader: z.boolean().optional(),
  onBackpressure: models.BackpressureBehaviorOptions$outboundSchema.optional(),
  authType: AuthenticationTypeWebhook$outboundSchema.optional(),
  tls: models.TlsSettingsClientSideType1$outboundSchema.optional(),
  totalMemoryLimitKB: z.number().optional(),
  loadBalanced: z.boolean().optional(),
  description: z.string().optional(),
  customSourceExpression: z.string().optional(),
  customDropWhenNull: z.boolean().optional(),
  customEventDelimiter: z.string().optional(),
  customContentType: z.string().optional(),
  customPayloadExpression: z.string().optional(),
  advancedContentType: z.string().optional(),
  formatEventCode: z.string().optional(),
  formatPayloadCode: z.string().optional(),
  pqStrictOrdering: z.boolean().optional(),
  pqRatePerSec: z.number().optional(),
  pqMode: models.ModeOptions$outboundSchema.optional(),
  pqMaxBufferSize: z.number().optional(),
  pqMaxBackpressureSec: z.number().optional(),
  pqMaxFileSize: z.string().optional(),
  pqMaxSize: z.string().optional(),
  pqPath: z.string().optional(),
  pqCompress: models.CompressionOptionsPq$outboundSchema.optional(),
  pqOnBackpressure: models.QueueFullBehaviorOptions$outboundSchema.optional(),
  pqControls: z.lazy(() => PqControlsWebhook$outboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().optional(),
  tokenTimeoutSecs: z.number().optional(),
  oauthParams: z.array(models.ItemsTypeOauthParams$outboundSchema).optional(),
  oauthHeaders: z.array(models.ItemsTypeOauthHeaders$outboundSchema).optional(),
  url: z.string().optional(),
  excludeSelf: z.boolean().optional(),
  urls: z.array(z.lazy(() => UrlWebhook$outboundSchema)).optional(),
  dnsResolvePeriodSec: z.number().optional(),
  loadBalanceStatsPeriodSec: z.number().optional(),
});

export function outputWebhookToJSON(outputWebhook: OutputWebhook): string {
  return JSON.stringify(OutputWebhook$outboundSchema.parse(outputWebhook));
}

/** @internal */
export type OutputDefault$Outbound = {
  id: string;
  type: "default";
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  defaultId: string;
};

/** @internal */
export const OutputDefault$outboundSchema: z.ZodType<
  OutputDefault$Outbound,
  z.ZodTypeDef,
  OutputDefault
> = z.object({
  id: z.string(),
  type: z.literal("default"),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  defaultId: z.string(),
});

export function outputDefaultToJSON(outputDefault: OutputDefault): string {
  return JSON.stringify(OutputDefault$outboundSchema.parse(outputDefault));
}

/** @internal */
export type CreateOutputRequest$Outbound =
  | OutputDefault$Outbound
  | OutputWebhook$Outbound
  | OutputSentinel$Outbound
  | OutputDevnull$Outbound
  | OutputSyslog$Outbound
  | OutputSplunk$Outbound
  | OutputSplunkLb$Outbound
  | OutputSplunkHec$Outbound
  | OutputWizHec$Outbound
  | OutputTcpjson$Outbound
  | OutputWavefront$Outbound
  | OutputSignalfx$Outbound
  | OutputFilesystem$Outbound
  | OutputS3$Outbound
  | OutputAzureBlob$Outbound
  | OutputAzureDataExplorer$Outbound
  | OutputAzureLogs$Outbound
  | OutputKinesis$Outbound
  | OutputHoneycomb$Outbound
  | OutputAzureEventhub$Outbound
  | OutputGoogleChronicle$Outbound
  | OutputGoogleCloudStorage$Outbound
  | OutputGoogleCloudLogging$Outbound
  | OutputGooglePubsub$Outbound
  | OutputExabeam$Outbound
  | OutputKafka$Outbound
  | OutputConfluentCloud$Outbound
  | OutputMsk$Outbound
  | OutputElastic$Outbound
  | OutputElasticCloud$Outbound
  | OutputNewrelic$Outbound
  | OutputNewrelicEvents$Outbound
  | OutputInfluxdb$Outbound
  | OutputCloudwatch$Outbound
  | OutputMinio$Outbound
  | OutputStatsd$Outbound
  | OutputStatsdExt$Outbound
  | OutputGraphite$Outbound
  | OutputRouter$Outbound
  | OutputSns$Outbound
  | OutputSqs$Outbound
  | OutputSnmp$Outbound
  | OutputSumoLogic$Outbound
  | OutputDatadog$Outbound
  | (OutputGrafanaCloud$Outbound & { type: "grafana_cloud" })
  | OutputLoki$Outbound
  | OutputPrometheus$Outbound
  | OutputRing$Outbound
  | OutputOpenTelemetry$Outbound
  | OutputServiceNow$Outbound
  | OutputDataset$Outbound
  | OutputCriblTcp$Outbound
  | OutputCriblHttp$Outbound
  | OutputCriblSearchEngine$Outbound
  | OutputHumioHec$Outbound
  | OutputCrowdstrikeNextGenSiem$Outbound
  | OutputDlS3$Outbound
  | OutputSecurityLake$Outbound
  | OutputCriblLake$Outbound
  | OutputDiskSpool$Outbound
  | OutputClickHouse$Outbound
  | OutputXsiam$Outbound
  | OutputNetflow$Outbound
  | OutputDynatraceHttp$Outbound
  | OutputDynatraceOtlp$Outbound
  | OutputSentinelOneAiSiem$Outbound
  | OutputChronicle$Outbound
  | OutputDatabricks$Outbound
  | OutputMicrosoftFabric$Outbound
  | OutputCloudflareR2$Outbound;

/** @internal */
export const CreateOutputRequest$outboundSchema: z.ZodType<
  CreateOutputRequest$Outbound,
  z.ZodTypeDef,
  CreateOutputRequest
> = z.union([
  z.lazy(() => OutputDefault$outboundSchema),
  z.lazy(() => OutputWebhook$outboundSchema),
  z.lazy(() => OutputSentinel$outboundSchema),
  z.lazy(() => OutputDevnull$outboundSchema),
  z.lazy(() => OutputSyslog$outboundSchema),
  z.lazy(() => OutputSplunk$outboundSchema),
  z.lazy(() => OutputSplunkLb$outboundSchema),
  z.lazy(() => OutputSplunkHec$outboundSchema),
  z.lazy(() => OutputWizHec$outboundSchema),
  z.lazy(() => OutputTcpjson$outboundSchema),
  z.lazy(() => OutputWavefront$outboundSchema),
  z.lazy(() => OutputSignalfx$outboundSchema),
  z.lazy(() => OutputFilesystem$outboundSchema),
  z.lazy(() => OutputS3$outboundSchema),
  z.lazy(() => OutputAzureBlob$outboundSchema),
  z.lazy(() => OutputAzureDataExplorer$outboundSchema),
  z.lazy(() => OutputAzureLogs$outboundSchema),
  OutputKinesis$outboundSchema,
  OutputHoneycomb$outboundSchema,
  OutputAzureEventhub$outboundSchema,
  OutputGoogleChronicle$outboundSchema,
  OutputGoogleCloudStorage$outboundSchema,
  OutputGoogleCloudLogging$outboundSchema,
  OutputGooglePubsub$outboundSchema,
  OutputExabeam$outboundSchema,
  OutputKafka$outboundSchema,
  OutputConfluentCloud$outboundSchema,
  OutputMsk$outboundSchema,
  OutputElastic$outboundSchema,
  OutputElasticCloud$outboundSchema,
  OutputNewrelic$outboundSchema,
  OutputNewrelicEvents$outboundSchema,
  OutputInfluxdb$outboundSchema,
  OutputCloudwatch$outboundSchema,
  OutputMinio$outboundSchema,
  OutputStatsd$outboundSchema,
  OutputStatsdExt$outboundSchema,
  OutputGraphite$outboundSchema,
  OutputRouter$outboundSchema,
  OutputSns$outboundSchema,
  OutputSqs$outboundSchema,
  OutputSnmp$outboundSchema,
  OutputSumoLogic$outboundSchema,
  OutputDatadog$outboundSchema,
  OutputGrafanaCloud$outboundSchema.and(
    z.object({ type: z.literal("grafana_cloud") }),
  ),
  OutputLoki$outboundSchema,
  OutputPrometheus$outboundSchema,
  OutputRing$outboundSchema,
  OutputOpenTelemetry$outboundSchema,
  OutputServiceNow$outboundSchema,
  OutputDataset$outboundSchema,
  OutputCriblTcp$outboundSchema,
  OutputCriblHttp$outboundSchema,
  OutputCriblSearchEngine$outboundSchema,
  OutputHumioHec$outboundSchema,
  OutputCrowdstrikeNextGenSiem$outboundSchema,
  OutputDlS3$outboundSchema,
  OutputSecurityLake$outboundSchema,
  OutputCriblLake$outboundSchema,
  OutputDiskSpool$outboundSchema,
  OutputClickHouse$outboundSchema,
  OutputXsiam$outboundSchema,
  OutputNetflow$outboundSchema,
  OutputDynatraceHttp$outboundSchema,
  OutputDynatraceOtlp$outboundSchema,
  OutputSentinelOneAiSiem$outboundSchema,
  OutputChronicle$outboundSchema,
  OutputDatabricks$outboundSchema,
  OutputMicrosoftFabric$outboundSchema,
  OutputCloudflareR2$outboundSchema,
]);

export function createOutputRequestToJSON(
  createOutputRequest: CreateOutputRequest,
): string {
  return JSON.stringify(
    CreateOutputRequest$outboundSchema.parse(createOutputRequest),
  );
}
