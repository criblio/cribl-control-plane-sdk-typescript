/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

export const TypeZscalerHec = {
  ZscalerHec: "zscaler_hec",
} as const;
export type TypeZscalerHec = ClosedEnum<typeof TypeZscalerHec>;

export type ConnectionZscalerHec = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeZscalerHec = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeZscalerHec = ClosedEnum<typeof ModeZscalerHec>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionZscalerHec = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionZscalerHec = ClosedEnum<typeof CompressionZscalerHec>;

export type PqZscalerHec = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeZscalerHec | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionZscalerHec | undefined;
};

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const AuthenticationMethodZscalerHec = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type AuthenticationMethodZscalerHec = ClosedEnum<
  typeof AuthenticationMethodZscalerHec
>;

export type AuthTokenMetadatumZscalerHec = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type AuthTokenZscalerHec = {
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: AuthenticationMethodZscalerHec | undefined;
  tokenSecret?: any | undefined;
  token?: any | undefined;
  enabled?: boolean | undefined;
  description?: string | undefined;
  /**
   * Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.
   */
  allowedIndexesAtToken?: Array<string> | undefined;
  /**
   * Fields to add to events referencing this token
   */
  metadata?: Array<AuthTokenMetadatumZscalerHec> | undefined;
};

export const MinimumTLSVersionZscalerHec = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MinimumTLSVersionZscalerHec = ClosedEnum<
  typeof MinimumTLSVersionZscalerHec
>;

export const MaximumTLSVersionZscalerHec = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MaximumTLSVersionZscalerHec = ClosedEnum<
  typeof MaximumTLSVersionZscalerHec
>;

export type TLSSettingsServerSideZscalerHec = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: MinimumTLSVersionZscalerHec | undefined;
  maxVersion?: MaximumTLSVersionZscalerHec | undefined;
};

export type MetadatumZscalerHec = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputZscalerHec = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: TypeZscalerHec | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionZscalerHec> | undefined;
  pq?: PqZscalerHec | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<AuthTokenZscalerHec> | undefined;
  tls?: TLSSettingsServerSideZscalerHec | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Zscaler HTTP Event Collector API requests. This input supports the /event endpoint.
   */
  hecAPI?: string | undefined;
  /**
   * Fields to add to every event. May be overridden by fields added at the token or request level.
   */
  metadata?: Array<MetadatumZscalerHec> | undefined;
  /**
   * List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
   */
  allowedIndexes?: Array<string> | undefined;
  /**
   * Whether to enable Zscaler HEC acknowledgements
   */
  hecAcks?: boolean | undefined;
  /**
   * Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
   */
  accessControlAllowOrigin?: Array<string> | undefined;
  /**
   * Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
   */
  accessControlAllowHeaders?: Array<string> | undefined;
  /**
   * Enable to emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
   */
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

export const CreateInputTypeSecurityLake = {
  SecurityLake: "security_lake",
} as const;
export type CreateInputTypeSecurityLake = ClosedEnum<
  typeof CreateInputTypeSecurityLake
>;

export type ConnectionSecurityLake = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeSecurityLake = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeSecurityLake = ClosedEnum<typeof ModeSecurityLake>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionSecurityLake = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionSecurityLake = ClosedEnum<
  typeof CompressionSecurityLake
>;

export type PqSecurityLake = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeSecurityLake | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionSecurityLake | undefined;
};

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const CreateInputAuthenticationMethodSecurityLake = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type CreateInputAuthenticationMethodSecurityLake = ClosedEnum<
  typeof CreateInputAuthenticationMethodSecurityLake
>;

/**
 * Signature version to use for signing S3 requests
 */
export const CreateInputSignatureVersionSecurityLake = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing S3 requests
 */
export type CreateInputSignatureVersionSecurityLake = ClosedEnum<
  typeof CreateInputSignatureVersionSecurityLake
>;

export type PreprocessSecurityLake = {
  disabled?: boolean | undefined;
  /**
   * Command to feed the data through (via stdin) and process its output (stdout)
   */
  command?: string | undefined;
  /**
   * Arguments to be added to the custom command
   */
  args?: Array<string> | undefined;
};

export type MetadatumSecurityLake = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type CheckpointingSecurityLake = {
  /**
   * Resume processing files after an interruption
   */
  enabled?: boolean | undefined;
  /**
   * The number of times to retry processing when a processing error occurs. If Skip file on error is enabled, this setting is ignored.
   */
  retries?: number | undefined;
};

export const TagAfterProcessingSecurityLake = {
  False: "false",
  True: "true",
} as const;
export type TagAfterProcessingSecurityLake = ClosedEnum<
  typeof TagAfterProcessingSecurityLake
>;

export type InputSecurityLake = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: CreateInputTypeSecurityLake;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionSecurityLake> | undefined;
  pq?: PqSecurityLake | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?:
    | CreateInputAuthenticationMethodSecurityLake
    | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: CreateInputSignatureVersionSecurityLake | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: PreprocessSecurityLake | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumSecurityLake> | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: CheckpointingSecurityLake | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  tagAfterProcessing?: TagAfterProcessingSecurityLake | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export const CreateInputTypeNetflow = {
  Netflow: "netflow",
} as const;
export type CreateInputTypeNetflow = ClosedEnum<typeof CreateInputTypeNetflow>;

export type ConnectionNetflow = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeNetflow = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeNetflow = ClosedEnum<typeof ModeNetflow>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionNetflow = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionNetflow = ClosedEnum<typeof CompressionNetflow>;

export type PqNetflow = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeNetflow | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionNetflow | undefined;
};

export type MetadatumNetflow = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputNetflow = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: CreateInputTypeNetflow | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionNetflow> | undefined;
  pq?: PqNetflow | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port?: number | undefined;
  /**
   * Allow forwarding of events to a NetFlow destination. Enabling this feature will generate an extra event containing __netflowRaw which can be routed to a NetFlow destination. Note that these events will not count against ingest quota.
   */
  enablePassThrough?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist.
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * Specifies how many minutes NetFlow v9 templates are cached before being discarded if not refreshed. Adjust based on your network's template update frequency to optimize performance and memory usage.
   */
  templateCacheMinutes?: number | undefined;
  /**
   * Accept messages in Netflow V5 format.
   */
  v5Enabled?: boolean | undefined;
  /**
   * Accept messages in Netflow V9 format.
   */
  v9Enabled?: boolean | undefined;
  /**
   * Accept messages in IPFIX format.
   */
  ipfixEnabled?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumNetflow> | undefined;
  description?: string | undefined;
};

export const TypeWiz = {
  Wiz: "wiz",
} as const;
export type TypeWiz = ClosedEnum<typeof TypeWiz>;

export type ConnectionWiz = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeWiz = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeWiz = ClosedEnum<typeof ModeWiz>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionWiz = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionWiz = ClosedEnum<typeof CompressionWiz>;

export type PqWiz = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeWiz | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionWiz | undefined;
};

export type ContentConfigWiz = {
  /**
   * The name of the Wiz query
   */
  contentType: string;
  contentDescription?: string | undefined;
  enabled?: boolean | undefined;
};

export type MetadatumWiz = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * The algorithm to use when performing HTTP retries
 */
export const RetryTypeWiz = {
  None: "none",
  Backoff: "backoff",
  Static: "static",
} as const;
/**
 * The algorithm to use when performing HTTP retries
 */
export type RetryTypeWiz = ClosedEnum<typeof RetryTypeWiz>;

export type RetryRulesWiz = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeWiz | undefined;
  /**
   * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * The maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
   */
  multiplier?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

/**
 * Enter client secret directly, or select a stored secret
 */
export const AuthenticationMethodWiz = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Enter client secret directly, or select a stored secret
 */
export type AuthenticationMethodWiz = ClosedEnum<
  typeof AuthenticationMethodWiz
>;

export type InputWiz = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: TypeWiz | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionWiz> | undefined;
  pq?: PqWiz | undefined;
  /**
   * The Wiz GraphQL API endpoint. Example: https://api.us1.app.wiz.io/graphql
   */
  endpoint?: string | undefined;
  /**
   * The authentication URL to generate an OAuth token
   */
  authUrl: string;
  /**
   * The audience to use when requesting an OAuth token for a custom auth URL. When not specified, `wiz-api` will be used.
   */
  authAudienceOverride?: string | undefined;
  /**
   * The client ID of the Wiz application
   */
  clientId: string;
  contentConfig: Array<ContentConfigWiz>;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumWiz> | undefined;
  retryRules?: RetryRulesWiz | undefined;
  /**
   * Enter client secret directly, or select a stored secret
   */
  authType?: AuthenticationMethodWiz | undefined;
  description?: string | undefined;
  /**
   * The client secret of the Wiz application
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const InputJournalFilesType = {
  JournalFiles: "journal_files",
} as const;
export type InputJournalFilesType = ClosedEnum<typeof InputJournalFilesType>;

export type InputJournalFilesConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputJournalFilesMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputJournalFilesMode = ClosedEnum<typeof InputJournalFilesMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputJournalFilesCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputJournalFilesCompression = ClosedEnum<
  typeof InputJournalFilesCompression
>;

export type InputJournalFilesPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputJournalFilesMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputJournalFilesCompression | undefined;
};

export type CreateInputRule = {
  /**
   * JavaScript expression applied to Journal objects. Return 'true' to include it.
   */
  filter: string;
  /**
   * Optional description of this rule's purpose
   */
  description?: string | undefined;
};

export type InputJournalFilesMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputJournalFiles = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputJournalFilesType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputJournalFilesConnection> | undefined;
  pq?: InputJournalFilesPq | undefined;
  /**
   * Directory path to search for journals. Environment variables will be resolved, e.g. $CRIBL_EDGE_FS_ROOT/var/log/journal/$MACHINE_ID.
   */
  path: string;
  /**
   * Time, in seconds, between scanning for journals.
   */
  interval?: number | undefined;
  /**
   * The full path of discovered journals are matched against this wildcard list.
   */
  journals: Array<string>;
  /**
   * Add rules to decide which journal objects to allow. Events are generated if no rules are given or if all the rules' expressions evaluate to true.
   */
  rules?: Array<CreateInputRule> | undefined;
  /**
   * Skip log messages that are not part of the current boot session.
   */
  currentBoot?: boolean | undefined;
  /**
   * The maximum log message age, in duration form (e.g,: 60s, 4h, 3d, 1w).  Default of no value will apply no max age filters.
   */
  maxAgeDur?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputJournalFilesMetadatum> | undefined;
  description?: string | undefined;
};

export const TypeRawUDP = {
  RawUdp: "raw_udp",
} as const;
export type TypeRawUDP = ClosedEnum<typeof TypeRawUDP>;

export type ConnectionRawUDP = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeRawUDP = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeRawUDP = ClosedEnum<typeof ModeRawUDP>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionRawUDP = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionRawUDP = ClosedEnum<typeof CompressionRawUDP>;

export type PqRawUDP = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeRawUDP | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionRawUDP | undefined;
};

export type MetadatumRawUDP = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputRawUdp = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: TypeRawUDP | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionRawUDP> | undefined;
  pq?: PqRawUDP | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Maximum number of events to buffer when downstream is blocking.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * If true, each UDP packet is assumed to contain a single message. If false, each UDP packet is assumed to contain multiple messages, separated by newlines.
   */
  singleMsgUdpPackets?: boolean | undefined;
  /**
   * If true, a __rawBytes field will be added to each event containing the raw bytes of the datagram.
   */
  ingestRawBytes?: boolean | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumRawUDP> | undefined;
  description?: string | undefined;
};

export const TypeWinEventLogs = {
  WinEventLogs: "win_event_logs",
} as const;
export type TypeWinEventLogs = ClosedEnum<typeof TypeWinEventLogs>;

export type ConnectionWinEventLogs = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeWinEventLogs = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeWinEventLogs = ClosedEnum<typeof ModeWinEventLogs>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionWinEventLogs = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionWinEventLogs = ClosedEnum<
  typeof CompressionWinEventLogs
>;

export type PqWinEventLogs = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeWinEventLogs | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionWinEventLogs | undefined;
};

/**
 * Read all stored and future event logs, or only future events
 */
export const ReadMode = {
  Oldest: "oldest",
  Newest: "newest",
} as const;
/**
 * Read all stored and future event logs, or only future events
 */
export type ReadMode = ClosedEnum<typeof ReadMode>;

/**
 * Format of individual events
 */
export const EventFormat = {
  Json: "json",
  Xml: "xml",
} as const;
/**
 * Format of individual events
 */
export type EventFormat = ClosedEnum<typeof EventFormat>;

export type MetadatumWinEventLogs = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputWinEventLogs = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: TypeWinEventLogs;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionWinEventLogs> | undefined;
  pq?: PqWinEventLogs | undefined;
  /**
   * Enter the event logs to collect. Run "Get-WinEvent -ListLog *" in PowerShell to see the available logs.
   */
  logNames: Array<string>;
  /**
   * Read all stored and future event logs, or only future events
   */
  readMode?: ReadMode | undefined;
  /**
   * Format of individual events
   */
  eventFormat?: EventFormat | undefined;
  /**
   * Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings)
   */
  disableNativeModule?: boolean | undefined;
  /**
   * Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  interval?: number | undefined;
  /**
   * The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  batchSize?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumWinEventLogs> | undefined;
  /**
   * The maximum number of bytes in an event before it is flushed to the pipelines
   */
  maxEventBytes?: number | undefined;
  description?: string | undefined;
};

export const TypeWef = {
  Wef: "wef",
} as const;
export type TypeWef = ClosedEnum<typeof TypeWef>;

export type ConnectionWef = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeWef = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeWef = ClosedEnum<typeof ModeWef>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionWef = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionWef = ClosedEnum<typeof CompressionWef>;

export type PqWef = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeWef | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionWef | undefined;
};

/**
 * How to authenticate incoming client connections
 */
export const AuthMethodAuthenticationMethod = {
  ClientCert: "clientCert",
  Kerberos: "kerberos",
} as const;
/**
 * How to authenticate incoming client connections
 */
export type AuthMethodAuthenticationMethod = ClosedEnum<
  typeof AuthMethodAuthenticationMethod
>;

export const MinimumTLSVersionWef = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MinimumTLSVersionWef = ClosedEnum<typeof MinimumTLSVersionWef>;

export const MaximumTLSVersionWef = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MaximumTLSVersionWef = ClosedEnum<typeof MaximumTLSVersionWef>;

export type MTLSSettings = {
  /**
   * Enable TLS
   */
  disabled?: boolean | undefined;
  /**
   * Required for WEF certificate authentication
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Required for WEF certificate authentication
   */
  requestCert?: boolean | undefined;
  /**
   * Name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath: string;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath: string;
  /**
   * Server path containing CA certificates (in PEM format) to use. Can reference $ENV_VARS. If multiple certificates are present in a .pem, each must directly certify the one preceding it.
   */
  caPath: string;
  /**
   * Regex matching allowable common names in peer certificates' subject attribute
   */
  commonNameRegex?: string | undefined;
  minVersion?: MinimumTLSVersionWef | undefined;
  maxVersion?: MaximumTLSVersionWef | undefined;
  /**
   * Enable OCSP check of certificate
   */
  ocspCheck?: boolean | undefined;
  keytab?: any | undefined;
  principal?: any | undefined;
  /**
   * If enabled, checks will fail on any OCSP error. Otherwise, checks will fail only when a certificate is revoked, ignoring other errors.
   */
  ocspCheckFailClose?: boolean | undefined;
};

/**
 * Content format in which the endpoint should deliver events
 */
export const CreateInputFormat = {
  Raw: "Raw",
  RenderedText: "RenderedText",
} as const;
/**
 * Content format in which the endpoint should deliver events
 */
export type CreateInputFormat = ClosedEnum<typeof CreateInputFormat>;

export const QueryBuilderMode = {
  Simple: "simple",
  Xml: "xml",
} as const;
export type QueryBuilderMode = ClosedEnum<typeof QueryBuilderMode>;

export type SubscriptionMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type Subscription = {
  subscriptionName: string;
  /**
   * Version UUID for this subscription. If any subscription parameters are modified, this value will change.
   */
  version?: string | undefined;
  /**
   * Content format in which the endpoint should deliver events
   */
  contentFormat?: CreateInputFormat | undefined;
  /**
   * Maximum time (in seconds) between endpoint checkins before considering it unavailable
   */
  heartbeatInterval?: number | undefined;
  /**
   * Interval (in seconds) over which the endpoint should collect events before sending them to Stream
   */
  batchTimeout?: number | undefined;
  /**
   * Newly subscribed endpoints will send previously existing events. Disable to receive new events only.
   */
  readExistingEvents?: boolean | undefined;
  /**
   * Keep track of which events have been received, resuming from that point after a re-subscription. This setting takes precedence over 'Read existing events'. See [Cribl Docs](https://docs.cribl.io/stream/sources-wef/#subscriptions) for more details.
   */
  sendBookmarks?: boolean | undefined;
  /**
   * Receive compressed events from the source
   */
  compress?: boolean | undefined;
  /**
   * The DNS names of the endpoints that should forward these events. You may use wildcards, such as *.mydomain.com
   */
  targets: Array<string>;
  /**
   * The RFC-3066 locale the Windows clients should use when sending events. Defaults to "en-US".
   */
  locale?: string | undefined;
  querySelector?: QueryBuilderMode | undefined;
  /**
   * Fields to add to events ingested under this subscription
   */
  metadata?: Array<SubscriptionMetadatum> | undefined;
};

export type MetadatumWef = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputWef = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: TypeWef | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionWef> | undefined;
  pq?: PqWef | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port?: number | undefined;
  /**
   * How to authenticate incoming client connections
   */
  authMethod?: AuthMethodAuthenticationMethod | undefined;
  tls?: MTLSSettings | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Preserve the clients original IP address in the __srcIpPort field when connecting through an HTTP proxy that supports the X-Forwarded-For header. This does not apply to TCP-layer Proxy Protocol v1/v2.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * SHA1 fingerprint expected by the client, if it does not match the first certificate in the configured CA chain
   */
  caFingerprint?: string | undefined;
  /**
   * Path to the keytab file containing the service principal credentials. @{product} will use `/etc/krb5.keytab` if not provided.
   */
  keytab?: string | undefined;
  /**
   * Kerberos principal used for authentication, typically in the form HTTP/<hostname>@<REALM>
   */
  principal?: string | undefined;
  /**
   * Allow events to be ingested even if their MachineID does not match the client certificate CN
   */
  allowMachineIdMismatch?: boolean | undefined;
  /**
   * Subscriptions to events on forwarding endpoints
   */
  subscriptions: Array<Subscription>;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumWef> | undefined;
  description?: string | undefined;
  /**
   * Log a warning if the client certificate authority (CA) fingerprint does not match the expected value. A mismatch prevents Cribl from receiving events from the Windows Event Forwarder.
   */
  logFingerprintMismatch?: boolean | undefined;
};

export const TypeTCP = {
  Tcp: "tcp",
} as const;
export type TypeTCP = ClosedEnum<typeof TypeTCP>;

export type ConnectionTCP = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeTCP = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeTCP = ClosedEnum<typeof ModeTCP>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionTCP = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionTCP = ClosedEnum<typeof CompressionTCP>;

export type PqTCP = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeTCP | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionTCP | undefined;
};

export const MinimumTLSVersionTCP = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MinimumTLSVersionTCP = ClosedEnum<typeof MinimumTLSVersionTCP>;

export const MaximumTLSVersionTCP = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MaximumTLSVersionTCP = ClosedEnum<typeof MaximumTLSVersionTCP>;

export type TLSSettingsServerSideTCP = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: MinimumTLSVersionTCP | undefined;
  maxVersion?: MaximumTLSVersionTCP | undefined;
};

export type MetadatumTCP = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type PreprocessTCP = {
  disabled?: boolean | undefined;
  /**
   * Command to feed the data through (via stdin) and process its output (stdout)
   */
  command?: string | undefined;
  /**
   * Arguments to be added to the custom command
   */
  args?: Array<string> | undefined;
};

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const AuthenticationMethodTCP = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type AuthenticationMethodTCP = ClosedEnum<
  typeof AuthenticationMethodTCP
>;

export type InputTcp = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: TypeTCP | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionTCP> | undefined;
  pq?: PqTCP | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: TLSSettingsServerSideTCP | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumTCP> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { "authToken" : "myToken", "fields": { "field1": "value1", "field2": "value2" } }
   */
  enableHeader?: boolean | undefined;
  preprocess?: PreprocessTCP | undefined;
  description?: string | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: AuthenticationMethodTCP | undefined;
};

export const InputSyslogType2 = {
  Syslog: "syslog",
} as const;
export type InputSyslogType2 = ClosedEnum<typeof InputSyslogType2>;

export type InputSyslogConnection2 = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputSyslogMode2 = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputSyslogMode2 = ClosedEnum<typeof InputSyslogMode2>;

/**
 * Codec to use to compress the persisted data
 */
export const InputSyslogCompression2 = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputSyslogCompression2 = ClosedEnum<
  typeof InputSyslogCompression2
>;

export type InputSyslogPq2 = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputSyslogMode2 | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputSyslogCompression2 | undefined;
};

export const InputSyslogMinimumTLSVersion2 = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputSyslogMinimumTLSVersion2 = ClosedEnum<
  typeof InputSyslogMinimumTLSVersion2
>;

export const InputSyslogMaximumTLSVersion2 = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputSyslogMaximumTLSVersion2 = ClosedEnum<
  typeof InputSyslogMaximumTLSVersion2
>;

export type InputSyslogTLSSettingsServerSide2 = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputSyslogMinimumTLSVersion2 | undefined;
  maxVersion?: InputSyslogMaximumTLSVersion2 | undefined;
};

export type InputSyslogMetadatum2 = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputSyslogSyslog2 = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSyslogType2;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputSyslogConnection2> | undefined;
  pq?: InputSyslogPq2 | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host?: string | undefined;
  /**
   * Enter UDP port number to listen on. Not required if listening on TCP.
   */
  udpPort?: number | undefined;
  /**
   * Enter TCP port number to listen on. Not required if listening on UDP.
   */
  tcpPort: number;
  /**
   * Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Timezone to assign to timestamps without timezone info
   */
  timestampTimezone?: string | undefined;
  /**
   * Treat UDP packet data received as full syslog message
   */
  singleMsgUdpPackets?: boolean | undefined;
  /**
   * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Wildcard list of fields to keep from source data; * = ALL (default)
   */
  keepFieldsList?: Array<string> | undefined;
  /**
   * Enable if incoming messages use octet counting per RFC 6587.
   */
  octetCounting?: boolean | undefined;
  /**
   * Enable if we should infer the syslog framing of the incoming messages.
   */
  inferFraming?: boolean | undefined;
  /**
   * Enable if we should infer octet counting only if the messages comply with RFC 5424.
   */
  strictlyInferOctetCounting?: boolean | undefined;
  /**
   * Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages.
   */
  allowNonStandardAppName?: boolean | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process for TCP connections. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  tls?: InputSyslogTLSSettingsServerSide2 | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputSyslogMetadatum2> | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * Load balance traffic across all Worker Processes
   */
  enableLoadBalancing?: boolean | undefined;
  description?: string | undefined;
  /**
   * When enabled, parses PROXY protocol headers during the TLS handshake. Disable if compatibility issues arise.
   */
  enableEnhancedProxyHeaderParsing?: boolean | undefined;
};

export const InputSyslogType1 = {
  Syslog: "syslog",
} as const;
export type InputSyslogType1 = ClosedEnum<typeof InputSyslogType1>;

export type InputSyslogConnection1 = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputSyslogMode1 = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputSyslogMode1 = ClosedEnum<typeof InputSyslogMode1>;

/**
 * Codec to use to compress the persisted data
 */
export const InputSyslogCompression1 = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputSyslogCompression1 = ClosedEnum<
  typeof InputSyslogCompression1
>;

export type InputSyslogPq1 = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputSyslogMode1 | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputSyslogCompression1 | undefined;
};

export const InputSyslogMinimumTLSVersion1 = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputSyslogMinimumTLSVersion1 = ClosedEnum<
  typeof InputSyslogMinimumTLSVersion1
>;

export const InputSyslogMaximumTLSVersion1 = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputSyslogMaximumTLSVersion1 = ClosedEnum<
  typeof InputSyslogMaximumTLSVersion1
>;

export type InputSyslogTLSSettingsServerSide1 = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputSyslogMinimumTLSVersion1 | undefined;
  maxVersion?: InputSyslogMaximumTLSVersion1 | undefined;
};

export type InputSyslogMetadatum1 = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputSyslogSyslog1 = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSyslogType1;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputSyslogConnection1> | undefined;
  pq?: InputSyslogPq1 | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host?: string | undefined;
  /**
   * Enter UDP port number to listen on. Not required if listening on TCP.
   */
  udpPort: number;
  /**
   * Enter TCP port number to listen on. Not required if listening on UDP.
   */
  tcpPort?: number | undefined;
  /**
   * Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Timezone to assign to timestamps without timezone info
   */
  timestampTimezone?: string | undefined;
  /**
   * Treat UDP packet data received as full syslog message
   */
  singleMsgUdpPackets?: boolean | undefined;
  /**
   * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Wildcard list of fields to keep from source data; * = ALL (default)
   */
  keepFieldsList?: Array<string> | undefined;
  /**
   * Enable if incoming messages use octet counting per RFC 6587.
   */
  octetCounting?: boolean | undefined;
  /**
   * Enable if we should infer the syslog framing of the incoming messages.
   */
  inferFraming?: boolean | undefined;
  /**
   * Enable if we should infer octet counting only if the messages comply with RFC 5424.
   */
  strictlyInferOctetCounting?: boolean | undefined;
  /**
   * Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages.
   */
  allowNonStandardAppName?: boolean | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process for TCP connections. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  tls?: InputSyslogTLSSettingsServerSide1 | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputSyslogMetadatum1> | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * Load balance traffic across all Worker Processes
   */
  enableLoadBalancing?: boolean | undefined;
  description?: string | undefined;
  /**
   * When enabled, parses PROXY protocol headers during the TLS handshake. Disable if compatibility issues arise.
   */
  enableEnhancedProxyHeaderParsing?: boolean | undefined;
};

export type InputSyslog = InputSyslogSyslog1 | InputSyslogSyslog2;

export const CreateInputTypeSqs = {
  Sqs: "sqs",
} as const;
export type CreateInputTypeSqs = ClosedEnum<typeof CreateInputTypeSqs>;

export type ConnectionSqs = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const CreateInputModeSqs = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type CreateInputModeSqs = ClosedEnum<typeof CreateInputModeSqs>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressionSqs = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressionSqs = ClosedEnum<typeof PqCompressionSqs>;

export type PqSqs = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: CreateInputModeSqs | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: PqCompressionSqs | undefined;
};

/**
 * The queue type used (or created)
 */
export const CreateInputQueueType = {
  Standard: "standard",
  Fifo: "fifo",
} as const;
/**
 * The queue type used (or created)
 */
export type CreateInputQueueType = ClosedEnum<typeof CreateInputQueueType>;

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const CreateInputAuthenticationMethodSqs = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type CreateInputAuthenticationMethodSqs = ClosedEnum<
  typeof CreateInputAuthenticationMethodSqs
>;

/**
 * Signature version to use for signing SQS requests
 */
export const CreateInputSignatureVersionSqs = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing SQS requests
 */
export type CreateInputSignatureVersionSqs = ClosedEnum<
  typeof CreateInputSignatureVersionSqs
>;

export type MetadatumSqs = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputSqs = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: CreateInputTypeSqs | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionSqs> | undefined;
  pq?: PqSqs | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read events from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can only be evaluated at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * The queue type used (or created)
   */
  queueType?: CreateInputQueueType | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * Create queue if it does not exist
   */
  createQueue?: boolean | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: CreateInputAuthenticationMethodSqs | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * SQS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing SQS requests
   */
  signatureVersion?: CreateInputSignatureVersionSqs | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access SQS
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumSqs> | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
};

export const TypeModelDrivenTelemetry = {
  ModelDrivenTelemetry: "model_driven_telemetry",
} as const;
export type TypeModelDrivenTelemetry = ClosedEnum<
  typeof TypeModelDrivenTelemetry
>;

export type ConnectionModelDrivenTelemetry = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeModelDrivenTelemetry = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeModelDrivenTelemetry = ClosedEnum<
  typeof ModeModelDrivenTelemetry
>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionModelDrivenTelemetry = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionModelDrivenTelemetry = ClosedEnum<
  typeof CompressionModelDrivenTelemetry
>;

export type PqModelDrivenTelemetry = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeModelDrivenTelemetry | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionModelDrivenTelemetry | undefined;
};

export const MinimumTLSVersionModelDrivenTelemetry = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MinimumTLSVersionModelDrivenTelemetry = ClosedEnum<
  typeof MinimumTLSVersionModelDrivenTelemetry
>;

export const MaximumTLSVersionModelDrivenTelemetry = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MaximumTLSVersionModelDrivenTelemetry = ClosedEnum<
  typeof MaximumTLSVersionModelDrivenTelemetry
>;

export type TLSSettingsServerSideModelDrivenTelemetry = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: MinimumTLSVersionModelDrivenTelemetry | undefined;
  maxVersion?: MaximumTLSVersionModelDrivenTelemetry | undefined;
};

export type MetadatumModelDrivenTelemetry = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputModelDrivenTelemetry = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: TypeModelDrivenTelemetry | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionModelDrivenTelemetry> | undefined;
  pq?: PqModelDrivenTelemetry | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port?: number | undefined;
  tls?: TLSSettingsServerSideModelDrivenTelemetry | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumModelDrivenTelemetry> | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * Time in milliseconds to allow the server to shutdown gracefully before forcing shutdown. Defaults to 5000.
   */
  shutdownTimeoutMs?: number | undefined;
  description?: string | undefined;
};

export const CreateInputTypeOpenTelemetry = {
  OpenTelemetry: "open_telemetry",
} as const;
export type CreateInputTypeOpenTelemetry = ClosedEnum<
  typeof CreateInputTypeOpenTelemetry
>;

export type ConnectionOpenTelemetry = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const CreateInputModeOpenTelemetry = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type CreateInputModeOpenTelemetry = ClosedEnum<
  typeof CreateInputModeOpenTelemetry
>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressionOpenTelemetry = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressionOpenTelemetry = ClosedEnum<
  typeof PqCompressionOpenTelemetry
>;

export type PqOpenTelemetry = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: CreateInputModeOpenTelemetry | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: PqCompressionOpenTelemetry | undefined;
};

export const CreateInputMinimumTLSVersionOpenTelemetry = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateInputMinimumTLSVersionOpenTelemetry = ClosedEnum<
  typeof CreateInputMinimumTLSVersionOpenTelemetry
>;

export const CreateInputMaximumTLSVersionOpenTelemetry = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateInputMaximumTLSVersionOpenTelemetry = ClosedEnum<
  typeof CreateInputMaximumTLSVersionOpenTelemetry
>;

export type TLSSettingsServerSideOpenTelemetry = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: CreateInputMinimumTLSVersionOpenTelemetry | undefined;
  maxVersion?: CreateInputMaximumTLSVersionOpenTelemetry | undefined;
};

/**
 * Select whether to leverage gRPC or HTTP for OpenTelemetry
 */
export const CreateInputProtocolOpenTelemetry = {
  Grpc: "grpc",
  Http: "http",
} as const;
/**
 * Select whether to leverage gRPC or HTTP for OpenTelemetry
 */
export type CreateInputProtocolOpenTelemetry = ClosedEnum<
  typeof CreateInputProtocolOpenTelemetry
>;

/**
 * The version of OTLP Protobuf definitions to use when interpreting received data
 */
export const CreateInputOTLPVersion = {
  ZeroDot10Dot0: "0.10.0",
  OneDot3Dot1: "1.3.1",
} as const;
/**
 * The version of OTLP Protobuf definitions to use when interpreting received data
 */
export type CreateInputOTLPVersion = ClosedEnum<typeof CreateInputOTLPVersion>;

/**
 * OpenTelemetry authentication type
 */
export const CreateInputAuthenticationTypeOpenTelemetry = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * OpenTelemetry authentication type
 */
export type CreateInputAuthenticationTypeOpenTelemetry = ClosedEnum<
  typeof CreateInputAuthenticationTypeOpenTelemetry
>;

export type CreateInputMetadatumOpenTelemetry = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type CreateInputOauthParamOpenTelemetry = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type CreateInputOauthHeaderOpenTelemetry = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type InputOpenTelemetry = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: CreateInputTypeOpenTelemetry | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionOpenTelemetry> | undefined;
  pq?: PqOpenTelemetry | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port?: number | undefined;
  tls?: TLSSettingsServerSideOpenTelemetry | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: any | undefined;
  captureHeaders?: any | undefined;
  activityLogSampleRate?: any | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist.
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Select whether to leverage gRPC or HTTP for OpenTelemetry
   */
  protocol?: CreateInputProtocolOpenTelemetry | undefined;
  /**
   * Enable to extract each incoming span to a separate event
   */
  extractSpans?: boolean | undefined;
  /**
   * Enable to extract each incoming Gauge or IntGauge metric to multiple events, one per data point
   */
  extractMetrics?: boolean | undefined;
  /**
   * The version of OTLP Protobuf definitions to use when interpreting received data
   */
  otlpVersion?: CreateInputOTLPVersion | undefined;
  /**
   * OpenTelemetry authentication type
   */
  authType?: CreateInputAuthenticationTypeOpenTelemetry | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<CreateInputMetadatumOpenTelemetry> | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<CreateInputOauthParamOpenTelemetry> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<CreateInputOauthHeaderOpenTelemetry> | undefined;
  /**
   * Enable to extract each incoming log record to a separate event
   */
  extractLogs?: boolean | undefined;
};

export const CreateInputTypeSnmp = {
  Snmp: "snmp",
} as const;
export type CreateInputTypeSnmp = ClosedEnum<typeof CreateInputTypeSnmp>;

export type ConnectionSnmp = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeSnmp = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeSnmp = ClosedEnum<typeof ModeSnmp>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionSnmp = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionSnmp = ClosedEnum<typeof CompressionSnmp>;

export type PqSnmp = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeSnmp | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionSnmp | undefined;
};

export const AuthenticationProtocol = {
  None: "none",
  Md5: "md5",
  Sha: "sha",
  Sha224: "sha224",
  Sha256: "sha256",
  Sha384: "sha384",
  Sha512: "sha512",
} as const;
export type AuthenticationProtocol = ClosedEnum<typeof AuthenticationProtocol>;

export type V3User = {
  name: string;
  authProtocol?: AuthenticationProtocol | undefined;
  authKey?: any | undefined;
  privProtocol?: string | undefined;
};

/**
 * Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues.
 */
export type SNMPv3Authentication = {
  v3AuthEnabled?: boolean | undefined;
  /**
   * Pass through traps that don't match any of the configured users. @{product} will not attempt to decrypt these traps.
   */
  allowUnmatchedTrap?: boolean | undefined;
  /**
   * User credentials for receiving v3 traps
   */
  v3Users?: Array<V3User> | undefined;
};

export type MetadatumSnmp = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputSnmp = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: CreateInputTypeSnmp | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionSnmp> | undefined;
  pq?: PqSnmp | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host?: string | undefined;
  /**
   * UDP port to receive SNMP traps on. Defaults to 162.
   */
  port?: number | undefined;
  /**
   * Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues.
   */
  snmpV3Auth?: SNMPv3Authentication | undefined;
  /**
   * Maximum number of events to buffer when downstream is blocking.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumSnmp> | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * If enabled, parses varbinds as an array of objects that include OID, value, and type
   */
  varbindsWithTypes?: boolean | undefined;
  /**
   * If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods
   */
  bestEffortParsing?: boolean | undefined;
  description?: string | undefined;
};

export const TypeS3Inventory = {
  S3Inventory: "s3_inventory",
} as const;
export type TypeS3Inventory = ClosedEnum<typeof TypeS3Inventory>;

export type ConnectionS3Inventory = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeS3Inventory = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeS3Inventory = ClosedEnum<typeof ModeS3Inventory>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionS3Inventory = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionS3Inventory = ClosedEnum<typeof CompressionS3Inventory>;

export type PqS3Inventory = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeS3Inventory | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionS3Inventory | undefined;
};

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const AuthenticationMethodS3Inventory = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type AuthenticationMethodS3Inventory = ClosedEnum<
  typeof AuthenticationMethodS3Inventory
>;

/**
 * Signature version to use for signing S3 requests
 */
export const SignatureVersionS3Inventory = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing S3 requests
 */
export type SignatureVersionS3Inventory = ClosedEnum<
  typeof SignatureVersionS3Inventory
>;

export type PreprocessS3Inventory = {
  disabled?: boolean | undefined;
  /**
   * Command to feed the data through (via stdin) and process its output (stdout)
   */
  command?: string | undefined;
  /**
   * Arguments to be added to the custom command
   */
  args?: Array<string> | undefined;
};

export type MetadatumS3Inventory = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type CheckpointingS3Inventory = {
  /**
   * Resume processing files after an interruption
   */
  enabled?: boolean | undefined;
  /**
   * The number of times to retry processing when a processing error occurs. If Skip file on error is enabled, this setting is ignored.
   */
  retries?: number | undefined;
};

export const TagAfterProcessingS3Inventory = {
  False: "false",
  True: "true",
} as const;
export type TagAfterProcessingS3Inventory = ClosedEnum<
  typeof TagAfterProcessingS3Inventory
>;

export type InputS3Inventory = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: TypeS3Inventory;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionS3Inventory> | undefined;
  pq?: PqS3Inventory | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: AuthenticationMethodS3Inventory | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: SignatureVersionS3Inventory | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: PreprocessS3Inventory | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumS3Inventory> | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: CheckpointingS3Inventory | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Filename suffix of the manifest checksum file. If a filename matching this suffix is received        in the queue, the matching manifest file will be downloaded and validated against its value. Defaults to "checksum"
   */
  checksumSuffix?: string | undefined;
  /**
   * Maximum download size (KB) of each manifest or checksum file. Manifest files larger than this size will not be read.        Defaults to 4096.
   */
  maxManifestSizeKB?: number | undefined;
  /**
   * If set to Yes, each inventory file in the manifest will be validated against its checksum. Defaults to false
   */
  validateInventoryFiles?: boolean | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  tagAfterProcessing?: TagAfterProcessingS3Inventory | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export const CreateInputTypeS3 = {
  S3: "s3",
} as const;
export type CreateInputTypeS3 = ClosedEnum<typeof CreateInputTypeS3>;

export type ConnectionS3 = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeS3 = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeS3 = ClosedEnum<typeof ModeS3>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressionS3 = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressionS3 = ClosedEnum<typeof PqCompressionS3>;

export type PqS3 = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeS3 | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: PqCompressionS3 | undefined;
};

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const CreateInputAuthenticationMethodS3 = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type CreateInputAuthenticationMethodS3 = ClosedEnum<
  typeof CreateInputAuthenticationMethodS3
>;

/**
 * Signature version to use for signing S3 requests
 */
export const CreateInputSignatureVersionS3 = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing S3 requests
 */
export type CreateInputSignatureVersionS3 = ClosedEnum<
  typeof CreateInputSignatureVersionS3
>;

export type PreprocessS3 = {
  disabled?: boolean | undefined;
  /**
   * Command to feed the data through (via stdin) and process its output (stdout)
   */
  command?: string | undefined;
  /**
   * Arguments to be added to the custom command
   */
  args?: Array<string> | undefined;
};

export type MetadatumS3 = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type CheckpointingS3 = {
  /**
   * Resume processing files after an interruption
   */
  enabled?: boolean | undefined;
  /**
   * The number of times to retry processing when a processing error occurs. If Skip file on error is enabled, this setting is ignored.
   */
  retries?: number | undefined;
};

export type InputS3 = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: CreateInputTypeS3;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionS3> | undefined;
  pq?: PqS3 | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: CreateInputAuthenticationMethodS3 | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: CreateInputSignatureVersionS3 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: PreprocessS3 | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumS3> | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: CheckpointingS3 | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * Add a tag to processed S3 objects. Requires s3:GetObjectTagging and s3:PutObjectTagging AWS permissions.
   */
  tagAfterProcessing?: boolean | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export const TypeMetrics = {
  Metrics: "metrics",
} as const;
export type TypeMetrics = ClosedEnum<typeof TypeMetrics>;

export type ConnectionMetrics = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeMetrics = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeMetrics = ClosedEnum<typeof ModeMetrics>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionMetrics = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionMetrics = ClosedEnum<typeof CompressionMetrics>;

export type PqMetrics = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeMetrics | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionMetrics | undefined;
};

export const MinimumTLSVersionMetrics = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MinimumTLSVersionMetrics = ClosedEnum<
  typeof MinimumTLSVersionMetrics
>;

export const MaximumTLSVersionMetrics = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MaximumTLSVersionMetrics = ClosedEnum<
  typeof MaximumTLSVersionMetrics
>;

export type TLSSettingsServerSideMetrics = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: MinimumTLSVersionMetrics | undefined;
  maxVersion?: MaximumTLSVersionMetrics | undefined;
};

export type MetadatumMetrics = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputMetrics = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: TypeMetrics;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionMetrics> | undefined;
  pq?: PqMetrics | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host?: string | undefined;
  /**
   * Enter UDP port number to listen on. Not required if listening on TCP.
   */
  udpPort?: number | undefined;
  /**
   * Enter TCP port number to listen on. Not required if listening on UDP.
   */
  tcpPort?: number | undefined;
  /**
   * Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
   */
  enableProxyHeader?: boolean | undefined;
  tls?: TLSSettingsServerSideMetrics | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumMetrics> | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  description?: string | undefined;
};

export const CreateInputTypeKinesis = {
  Kinesis: "kinesis",
} as const;
export type CreateInputTypeKinesis = ClosedEnum<typeof CreateInputTypeKinesis>;

export type ConnectionKinesis = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const CreateInputModeKinesis = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type CreateInputModeKinesis = ClosedEnum<typeof CreateInputModeKinesis>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressionKinesis = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressionKinesis = ClosedEnum<typeof PqCompressionKinesis>;

export type PqKinesis = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: CreateInputModeKinesis | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: PqCompressionKinesis | undefined;
};

/**
 * Location at which to start reading a shard for the first time
 */
export const ShardIteratorStart = {
  TrimHorizon: "TRIM_HORIZON",
  Latest: "LATEST",
} as const;
/**
 * Location at which to start reading a shard for the first time
 */
export type ShardIteratorStart = ClosedEnum<typeof ShardIteratorStart>;

/**
 * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
 */
export const CreateInputRecordDataFormat = {
  Cribl: "cribl",
  Ndjson: "ndjson",
  Cloudwatch: "cloudwatch",
  Line: "line",
} as const;
/**
 * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
 */
export type CreateInputRecordDataFormat = ClosedEnum<
  typeof CreateInputRecordDataFormat
>;

/**
 * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
 */
export const ShardLoadBalancing = {
  ConsistentHashing: "ConsistentHashing",
  RoundRobin: "RoundRobin",
} as const;
/**
 * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
 */
export type ShardLoadBalancing = ClosedEnum<typeof ShardLoadBalancing>;

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const CreateInputAuthenticationMethodKinesis = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type CreateInputAuthenticationMethodKinesis = ClosedEnum<
  typeof CreateInputAuthenticationMethodKinesis
>;

/**
 * Signature version to use for signing Kinesis stream requests
 */
export const CreateInputSignatureVersionKinesis = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing Kinesis stream requests
 */
export type CreateInputSignatureVersionKinesis = ClosedEnum<
  typeof CreateInputSignatureVersionKinesis
>;

export type MetadatumKinesis = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputKinesis = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: CreateInputTypeKinesis | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionKinesis> | undefined;
  pq?: PqKinesis | undefined;
  /**
   * Kinesis Data Stream to read data from
   */
  streamName: string;
  /**
   * Time interval in minutes between consecutive service calls
   */
  serviceInterval?: number | undefined;
  /**
   * A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
   */
  shardExpr?: string | undefined;
  /**
   * Location at which to start reading a shard for the first time
   */
  shardIteratorType?: ShardIteratorStart | undefined;
  /**
   * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
   */
  payloadFormat?: CreateInputRecordDataFormat | undefined;
  /**
   * Maximum number of records per getRecords call
   */
  getRecordsLimit?: number | undefined;
  /**
   * Maximum number of records, across all shards, to pull down at once per Worker Process
   */
  getRecordsLimitTotal?: number | undefined;
  /**
   * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
   */
  loadBalancingAlgorithm?: ShardLoadBalancing | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: CreateInputAuthenticationMethodKinesis | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the Kinesis stream is located
   */
  region: string;
  /**
   * Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing Kinesis stream requests
   */
  signatureVersion?: CreateInputSignatureVersionKinesis | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Kinesis stream
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Verify Kinesis Producer Library (KPL) event checksums
   */
  verifyKPLCheckSums?: boolean | undefined;
  /**
   * When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
   */
  avoidDuplicates?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumKinesis> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
};

export const TypeHTTPRaw = {
  HttpRaw: "http_raw",
} as const;
export type TypeHTTPRaw = ClosedEnum<typeof TypeHTTPRaw>;

export type ConnectionHTTPRaw = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeHTTPRaw = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeHTTPRaw = ClosedEnum<typeof ModeHTTPRaw>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionHTTPRaw = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionHTTPRaw = ClosedEnum<typeof CompressionHTTPRaw>;

export type PqHTTPRaw = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeHTTPRaw | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionHTTPRaw | undefined;
};

export const MinimumTLSVersionHTTPRaw = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MinimumTLSVersionHTTPRaw = ClosedEnum<
  typeof MinimumTLSVersionHTTPRaw
>;

export const MaximumTLSVersionHTTPRaw = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MaximumTLSVersionHTTPRaw = ClosedEnum<
  typeof MaximumTLSVersionHTTPRaw
>;

export type TLSSettingsServerSideHTTPRaw = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: MinimumTLSVersionHTTPRaw | undefined;
  maxVersion?: MaximumTLSVersionHTTPRaw | undefined;
};

export type MetadatumHTTPRaw = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type AuthTokensExtMetadatumHTTPRaw = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type AuthTokensExtHTTPRaw = {
  /**
   * Shared secret to be provided by any client (Authorization: <token>)
   */
  token: string;
  description?: string | undefined;
  /**
   * Fields to add to events referencing this token
   */
  metadata?: Array<AuthTokensExtMetadatumHTTPRaw> | undefined;
};

export type InputHttpRaw = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: TypeHTTPRaw | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionHTTPRaw> | undefined;
  pq?: PqHTTPRaw | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: TLSSettingsServerSideHTTPRaw | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumHTTPRaw> | undefined;
  /**
   * List of URI paths accepted by this input, wildcards are supported, e.g /api/v* /hook. Defaults to allow all.
   */
  allowedPaths?: Array<string> | undefined;
  /**
   * List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all.
   */
  allowedMethods?: Array<string> | undefined;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokensExt?: Array<AuthTokensExtHTTPRaw> | undefined;
  description?: string | undefined;
};

export const TypeDatagen = {
  Datagen: "datagen",
} as const;
export type TypeDatagen = ClosedEnum<typeof TypeDatagen>;

export type ConnectionDatagen = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeDatagen = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeDatagen = ClosedEnum<typeof ModeDatagen>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionDatagen = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionDatagen = ClosedEnum<typeof CompressionDatagen>;

export type PqDatagen = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeDatagen | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionDatagen | undefined;
};

export type Sample = {
  sample: string;
  /**
   * Maximum number of events to generate per second per Worker Node. Defaults to 10.
   */
  eventsPerSec?: number | undefined;
};

export type MetadatumDatagen = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputDatagen = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: TypeDatagen;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionDatagen> | undefined;
  pq?: PqDatagen | undefined;
  samples: Array<Sample>;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumDatagen> | undefined;
  description?: string | undefined;
};

export const TypeDatadogAgent = {
  DatadogAgent: "datadog_agent",
} as const;
export type TypeDatadogAgent = ClosedEnum<typeof TypeDatadogAgent>;

export type ConnectionDatadogAgent = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeDatadogAgent = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeDatadogAgent = ClosedEnum<typeof ModeDatadogAgent>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionDatadogAgent = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionDatadogAgent = ClosedEnum<
  typeof CompressionDatadogAgent
>;

export type PqDatadogAgent = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeDatadogAgent | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionDatadogAgent | undefined;
};

export const MinimumTLSVersionDatadogAgent = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MinimumTLSVersionDatadogAgent = ClosedEnum<
  typeof MinimumTLSVersionDatadogAgent
>;

export const MaximumTLSVersionDatadogAgent = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MaximumTLSVersionDatadogAgent = ClosedEnum<
  typeof MaximumTLSVersionDatadogAgent
>;

export type TLSSettingsServerSideDatadogAgent = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: MinimumTLSVersionDatadogAgent | undefined;
  maxVersion?: MaximumTLSVersionDatadogAgent | undefined;
};

export type MetadatumDatadogAgent = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type ProxyModeDatadogAgent = {
  /**
   * Toggle to Yes to send key validation requests from Datadog Agent to the Datadog API. If toggled to No (the default), Stream handles key validation requests by always responding that the key is valid.
   */
  enabled?: boolean | undefined;
  /**
   * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
   */
  rejectUnauthorized?: boolean | undefined;
};

export type InputDatadogAgent = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: TypeDatadogAgent | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionDatadogAgent> | undefined;
  pq?: PqDatadogAgent | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: TLSSettingsServerSideDatadogAgent | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Toggle to Yes to extract each incoming metric to multiple events, one per data point. This works well when sending metrics to a statsd-type output. If sending metrics to DatadogHQ or any destination that accepts arbitrary JSON, leave toggled to No (the default).
   */
  extractMetrics?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumDatadogAgent> | undefined;
  proxyMode?: ProxyModeDatadogAgent | undefined;
  description?: string | undefined;
};

export const TypeCrowdstrike = {
  Crowdstrike: "crowdstrike",
} as const;
export type TypeCrowdstrike = ClosedEnum<typeof TypeCrowdstrike>;

export type ConnectionCrowdstrike = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeCrowdstrike = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeCrowdstrike = ClosedEnum<typeof ModeCrowdstrike>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionCrowdstrike = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionCrowdstrike = ClosedEnum<typeof CompressionCrowdstrike>;

export type PqCrowdstrike = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeCrowdstrike | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionCrowdstrike | undefined;
};

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const AuthenticationMethodCrowdstrike = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type AuthenticationMethodCrowdstrike = ClosedEnum<
  typeof AuthenticationMethodCrowdstrike
>;

/**
 * Signature version to use for signing S3 requests
 */
export const SignatureVersionCrowdstrike = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing S3 requests
 */
export type SignatureVersionCrowdstrike = ClosedEnum<
  typeof SignatureVersionCrowdstrike
>;

export type PreprocessCrowdstrike = {
  disabled?: boolean | undefined;
  /**
   * Command to feed the data through (via stdin) and process its output (stdout)
   */
  command?: string | undefined;
  /**
   * Arguments to be added to the custom command
   */
  args?: Array<string> | undefined;
};

export type MetadatumCrowdstrike = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type CheckpointingCrowdstrike = {
  /**
   * Resume processing files after an interruption
   */
  enabled?: boolean | undefined;
  /**
   * The number of times to retry processing when a processing error occurs. If Skip file on error is enabled, this setting is ignored.
   */
  retries?: number | undefined;
};

export const TagAfterProcessingCrowdstrike = {
  False: "false",
  True: "true",
} as const;
export type TagAfterProcessingCrowdstrike = ClosedEnum<
  typeof TagAfterProcessingCrowdstrike
>;

export type InputCrowdstrike = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: TypeCrowdstrike;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionCrowdstrike> | undefined;
  pq?: PqCrowdstrike | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: AuthenticationMethodCrowdstrike | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: SignatureVersionCrowdstrike | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: PreprocessCrowdstrike | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumCrowdstrike> | undefined;
  checkpointing?: CheckpointingCrowdstrike | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  tagAfterProcessing?: TagAfterProcessingCrowdstrike | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export const TypeTcpjson = {
  Tcpjson: "tcpjson",
} as const;
export type TypeTcpjson = ClosedEnum<typeof TypeTcpjson>;

export type ConnectionTcpjson = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeTcpjson = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeTcpjson = ClosedEnum<typeof ModeTcpjson>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionTcpjson = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionTcpjson = ClosedEnum<typeof CompressionTcpjson>;

export type PqTcpjson = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeTcpjson | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionTcpjson | undefined;
};

export const MinimumTLSVersionTcpjson = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MinimumTLSVersionTcpjson = ClosedEnum<
  typeof MinimumTLSVersionTcpjson
>;

export const MaximumTLSVersionTcpjson = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MaximumTLSVersionTcpjson = ClosedEnum<
  typeof MaximumTLSVersionTcpjson
>;

export type TLSSettingsServerSideTcpjson = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: MinimumTLSVersionTcpjson | undefined;
  maxVersion?: MaximumTLSVersionTcpjson | undefined;
};

export type MetadatumTcpjson = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const AuthenticationMethodTcpjson = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type AuthenticationMethodTcpjson = ClosedEnum<
  typeof AuthenticationMethodTcpjson
>;

export type InputTcpjson = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: TypeTcpjson | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionTcpjson> | undefined;
  pq?: PqTcpjson | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: TLSSettingsServerSideTcpjson | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumTcpjson> | undefined;
  /**
   * Load balance traffic across all Worker Processes
   */
  enableLoadBalancing?: boolean | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: AuthenticationMethodTcpjson | undefined;
  description?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const TypeCriblLakeHTTP = {
  CriblLakeHttp: "cribl_lake_http",
} as const;
export type TypeCriblLakeHTTP = ClosedEnum<typeof TypeCriblLakeHTTP>;

export type ConnectionCriblLakeHTTP = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeCriblLakeHTTP = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeCriblLakeHTTP = ClosedEnum<typeof ModeCriblLakeHTTP>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionCriblLakeHTTP = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionCriblLakeHTTP = ClosedEnum<
  typeof CompressionCriblLakeHTTP
>;

export type PqCriblLakeHTTP = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeCriblLakeHTTP | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionCriblLakeHTTP | undefined;
};

export const MinimumTLSVersionCriblLakeHTTP = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MinimumTLSVersionCriblLakeHTTP = ClosedEnum<
  typeof MinimumTLSVersionCriblLakeHTTP
>;

export const MaximumTLSVersionCriblLakeHTTP = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MaximumTLSVersionCriblLakeHTTP = ClosedEnum<
  typeof MaximumTLSVersionCriblLakeHTTP
>;

export type TLSSettingsServerSideCriblLakeHTTP = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: MinimumTLSVersionCriblLakeHTTP | undefined;
  maxVersion?: MaximumTLSVersionCriblLakeHTTP | undefined;
};

export type MetadatumCriblLakeHTTP = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputCriblLakeHttp = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: TypeCriblLakeHTTP | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionCriblLakeHTTP> | undefined;
  pq?: PqCriblLakeHTTP | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: TLSSettingsServerSideCriblLakeHTTP | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumCriblLakeHTTP> | undefined;
  description?: string | undefined;
};

export const TypeCriblHTTP = {
  CriblHttp: "cribl_http",
} as const;
export type TypeCriblHTTP = ClosedEnum<typeof TypeCriblHTTP>;

export type ConnectionCriblHTTP = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeCriblHTTP = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeCriblHTTP = ClosedEnum<typeof ModeCriblHTTP>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionCriblHTTP = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionCriblHTTP = ClosedEnum<typeof CompressionCriblHTTP>;

export type PqCriblHTTP = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeCriblHTTP | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionCriblHTTP | undefined;
};

export const MinimumTLSVersionCriblHTTP = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MinimumTLSVersionCriblHTTP = ClosedEnum<
  typeof MinimumTLSVersionCriblHTTP
>;

export const MaximumTLSVersionCriblHTTP = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MaximumTLSVersionCriblHTTP = ClosedEnum<
  typeof MaximumTLSVersionCriblHTTP
>;

export type TLSSettingsServerSideCriblHTTP = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: MinimumTLSVersionCriblHTTP | undefined;
  maxVersion?: MaximumTLSVersionCriblHTTP | undefined;
};

export type MetadatumCriblHTTP = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputCriblHttp = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: TypeCriblHTTP | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionCriblHTTP> | undefined;
  pq?: PqCriblHTTP | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: TLSSettingsServerSideCriblHTTP | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumCriblHTTP> | undefined;
  description?: string | undefined;
};

export const TypeCriblTCP = {
  CriblTcp: "cribl_tcp",
} as const;
export type TypeCriblTCP = ClosedEnum<typeof TypeCriblTCP>;

export type ConnectionCriblTCP = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeCriblTCP = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeCriblTCP = ClosedEnum<typeof ModeCriblTCP>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionCriblTCP = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionCriblTCP = ClosedEnum<typeof CompressionCriblTCP>;

export type PqCriblTCP = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeCriblTCP | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionCriblTCP | undefined;
};

export const MinimumTLSVersionCriblTCP = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MinimumTLSVersionCriblTCP = ClosedEnum<
  typeof MinimumTLSVersionCriblTCP
>;

export const MaximumTLSVersionCriblTCP = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MaximumTLSVersionCriblTCP = ClosedEnum<
  typeof MaximumTLSVersionCriblTCP
>;

export type TLSSettingsServerSideCriblTCP = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: MinimumTLSVersionCriblTCP | undefined;
  maxVersion?: MaximumTLSVersionCriblTCP | undefined;
};

export type MetadatumCriblTCP = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputCriblTcp = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: TypeCriblTCP | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionCriblTCP> | undefined;
  pq?: PqCriblTCP | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: TLSSettingsServerSideCriblTCP | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumCriblTCP> | undefined;
  /**
   * Load balance traffic across all Worker Processes
   */
  enableLoadBalancing?: boolean | undefined;
  description?: string | undefined;
};

export const CreateInputTypeGooglePubsub = {
  GooglePubsub: "google_pubsub",
} as const;
export type CreateInputTypeGooglePubsub = ClosedEnum<
  typeof CreateInputTypeGooglePubsub
>;

export type ConnectionGooglePubsub = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const CreateInputModeGooglePubsub = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type CreateInputModeGooglePubsub = ClosedEnum<
  typeof CreateInputModeGooglePubsub
>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressionGooglePubsub = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressionGooglePubsub = ClosedEnum<
  typeof PqCompressionGooglePubsub
>;

export type PqGooglePubsub = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: CreateInputModeGooglePubsub | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: PqCompressionGooglePubsub | undefined;
};

/**
 * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
 */
export const CreateInputGoogleAuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
 */
export type CreateInputGoogleAuthenticationMethod = ClosedEnum<
  typeof CreateInputGoogleAuthenticationMethod
>;

export type MetadatumGooglePubsub = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputGooglePubsub = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: CreateInputTypeGooglePubsub | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionGooglePubsub> | undefined;
  pq?: PqGooglePubsub | undefined;
  /**
   * ID of the topic to receive events from
   */
  topicName: string;
  /**
   * ID of the subscription to use when receiving events
   */
  subscriptionName: string;
  /**
   * Create topic if it does not exist
   */
  createTopic?: boolean | undefined;
  /**
   * Create subscription if it does not exist
   */
  createSubscription?: boolean | undefined;
  /**
   * Region to retrieve messages from. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.
   */
  region?: string | undefined;
  /**
   * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
   */
  googleAuthMethod?: CreateInputGoogleAuthenticationMethod | undefined;
  /**
   * Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  secret?: string | undefined;
  /**
   * If Destination exerts backpressure, this setting limits how many inbound events Stream will queue for processing before it stops retrieving events
   */
  maxBacklog?: number | undefined;
  /**
   * How many streams to pull messages from at one time. Doubling the value doubles the number of messages this Source pulls from the topic (if available), while consuming more CPU and memory. Defaults to 5.
   */
  concurrency?: number | undefined;
  /**
   * Pull request timeout, in milliseconds
   */
  requestTimeout?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumGooglePubsub> | undefined;
  description?: string | undefined;
  /**
   * Receive events in the order they were added to the queue. The process sending events must have ordering enabled.
   */
  orderedDelivery?: boolean | undefined;
};

export const TypeFirehose = {
  Firehose: "firehose",
} as const;
export type TypeFirehose = ClosedEnum<typeof TypeFirehose>;

export type ConnectionFirehose = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeFirehose = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeFirehose = ClosedEnum<typeof ModeFirehose>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionFirehose = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionFirehose = ClosedEnum<typeof CompressionFirehose>;

export type PqFirehose = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeFirehose | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionFirehose | undefined;
};

export const MinimumTLSVersionFirehose = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MinimumTLSVersionFirehose = ClosedEnum<
  typeof MinimumTLSVersionFirehose
>;

export const MaximumTLSVersionFirehose = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MaximumTLSVersionFirehose = ClosedEnum<
  typeof MaximumTLSVersionFirehose
>;

export type TLSSettingsServerSideFirehose = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: MinimumTLSVersionFirehose | undefined;
  maxVersion?: MaximumTLSVersionFirehose | undefined;
};

export type MetadatumFirehose = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputFirehose = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: TypeFirehose | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionFirehose> | undefined;
  pq?: PqFirehose | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: TLSSettingsServerSideFirehose | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumFirehose> | undefined;
  description?: string | undefined;
};

export const InputExecType = {
  Exec: "exec",
} as const;
export type InputExecType = ClosedEnum<typeof InputExecType>;

export type InputExecConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputExecMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputExecMode = ClosedEnum<typeof InputExecMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputExecCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputExecCompression = ClosedEnum<typeof InputExecCompression>;

export type InputExecPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputExecMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputExecCompression | undefined;
};

/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export const ScheduleType = {
  Interval: "interval",
  CronSchedule: "cronSchedule",
} as const;
/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export type ScheduleType = ClosedEnum<typeof ScheduleType>;

export type InputExecMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputExec = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputExecType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputExecConnection> | undefined;
  pq?: InputExecPq | undefined;
  /**
   * Command to execute; supports Bourne shell (or CMD on Windows) syntax
   */
  command: string;
  /**
   * Maximum number of retry attempts in the event that the command fails
   */
  retries?: number | undefined;
  /**
   * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
   */
  scheduleType?: ScheduleType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputExecMetadatum> | undefined;
  description?: string | undefined;
  /**
   * Interval between command executions in seconds.
   */
  interval?: number | undefined;
  /**
   * Cron schedule to execute the command on.
   */
  cronSchedule?: string | undefined;
};

export const TypeEventhub = {
  Eventhub: "eventhub",
} as const;
export type TypeEventhub = ClosedEnum<typeof TypeEventhub>;

export type ConnectionEventhub = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeEventhub = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeEventhub = ClosedEnum<typeof ModeEventhub>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionEventhub = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionEventhub = ClosedEnum<typeof CompressionEventhub>;

export type PqEventhub = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeEventhub | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionEventhub | undefined;
};

export const SASLMechanismEventhub = {
  Plain: "plain",
  Oauthbearer: "oauthbearer",
} as const;
export type SASLMechanismEventhub = ClosedEnum<typeof SASLMechanismEventhub>;

/**
 * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
 */
export type AuthenticationEventhub = {
  disabled?: boolean | undefined;
  mechanism?: SASLMechanismEventhub | undefined;
};

export type TLSSettingsClientSideEventhub = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another trusted CA (such as the system's)
   */
  rejectUnauthorized?: boolean | undefined;
};

export type MetadatumEventhub = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputEventhub = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: TypeEventhub | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionEventhub> | undefined;
  pq?: PqEventhub | undefined;
  /**
   * List of Event Hubs Kafka brokers to connect to (example: yourdomain.servicebus.windows.net:9093). The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.
   */
  brokers: Array<string>;
  /**
   * The name of the Event Hub (Kafka topic) to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Event Hubs Source to only a single topic.
   */
  topics: Array<string>;
  /**
   * The consumer group this instance belongs to. Default is 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Start reading from earliest available data; relevant only during initial subscription
   */
  fromBeginning?: boolean | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: AuthenticationEventhub | undefined;
  tls?: TLSSettingsClientSideEventhub | undefined;
  /**
   *       Timeout (session.timeout.ms in Kafka domain) used to detect client failures when using Kafka's group-management facilities.
   *
   * @remarks
   *       If the client sends no heartbeats to the broker before the timeout expires, the broker will remove the client from the group and initiate a rebalance.
   *       Value must be lower than rebalanceTimeout.
   *       See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time (rebalance.timeout.ms in Kafka domain) for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time (heartbeat.interval.ms in Kafka domain) between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
   */
  heartbeatInterval?: number | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  /**
   * Minimize duplicate events by starting only one consumer for each topic partition
   */
  minimizeDuplicates?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumEventhub> | undefined;
  description?: string | undefined;
};

export const TypeOffice365MsgTrace = {
  Office365MsgTrace: "office365_msg_trace",
} as const;
export type TypeOffice365MsgTrace = ClosedEnum<typeof TypeOffice365MsgTrace>;

export type ConnectionOffice365MsgTrace = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeOffice365MsgTrace = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeOffice365MsgTrace = ClosedEnum<typeof ModeOffice365MsgTrace>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionOffice365MsgTrace = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionOffice365MsgTrace = ClosedEnum<
  typeof CompressionOffice365MsgTrace
>;

export type PqOffice365MsgTrace = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeOffice365MsgTrace | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionOffice365MsgTrace | undefined;
};

/**
 * Select authentication method.
 */
export const AuthenticationMethodOffice365MsgTrace = {
  Manual: "manual",
  Secret: "secret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  OauthCert: "oauthCert",
} as const;
/**
 * Select authentication method.
 */
export type AuthenticationMethodOffice365MsgTrace = ClosedEnum<
  typeof AuthenticationMethodOffice365MsgTrace
>;

/**
 * Log Level (verbosity) for collection runtime behavior.
 */
export const LogLevelOffice365MsgTrace = {
  Error: "error",
  Warn: "warn",
  Info: "info",
  Debug: "debug",
  Silly: "silly",
} as const;
/**
 * Log Level (verbosity) for collection runtime behavior.
 */
export type LogLevelOffice365MsgTrace = ClosedEnum<
  typeof LogLevelOffice365MsgTrace
>;

export type MetadatumOffice365MsgTrace = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * The algorithm to use when performing HTTP retries
 */
export const RetryTypeOffice365MsgTrace = {
  None: "none",
  Backoff: "backoff",
  Static: "static",
} as const;
/**
 * The algorithm to use when performing HTTP retries
 */
export type RetryTypeOffice365MsgTrace = ClosedEnum<
  typeof RetryTypeOffice365MsgTrace
>;

export type RetryRulesOffice365MsgTrace = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOffice365MsgTrace | undefined;
  /**
   * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * The maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
   */
  multiplier?: number | undefined;
  /**
   * List of http codes that trigger a retry. Leave empty to use the default list of 429, 500, and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

/**
 * Office 365 subscription plan for your organization, typically Office 365 Enterprise
 */
export const SubscriptionPlanOffice365MsgTrace = {
  EnterpriseGcc: "enterprise_gcc",
  Gcc: "gcc",
  GccHigh: "gcc_high",
  Dod: "dod",
} as const;
/**
 * Office 365 subscription plan for your organization, typically Office 365 Enterprise
 */
export type SubscriptionPlanOffice365MsgTrace = ClosedEnum<
  typeof SubscriptionPlanOffice365MsgTrace
>;

export type CertOptions = {
  /**
   * The name of the predefined certificate.
   */
  certificateName?: string | undefined;
  /**
   * Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS.
   */
  privKeyPath: string;
  /**
   * Passphrase to use to decrypt the private key.
   */
  passphrase?: string | undefined;
  /**
   * Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS.
   */
  certPath: string;
};

export type InputOffice365MsgTrace = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: TypeOffice365MsgTrace | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionOffice365MsgTrace> | undefined;
  pq?: PqOffice365MsgTrace | undefined;
  /**
   * URL to use when retrieving report data.
   */
  url?: string | undefined;
  /**
   * How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail.
   */
  interval?: number | undefined;
  /**
   * Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps.
   */
  startDate?: string | undefined;
  /**
   * Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps.
   */
  endDate?: string | undefined;
  /**
   * HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely.
   */
  timeout?: number | undefined;
  /**
   * Disables time filtering of events when a date range is specified.
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Select authentication method.
   */
  authType?: AuthenticationMethodOffice365MsgTrace | undefined;
  /**
   * Reschedule tasks that failed with non-fatal errors
   */
  rescheduleDroppedTasks?: boolean | undefined;
  /**
   * Maximum number of times a task can be rescheduled
   */
  maxTaskReschedule?: number | undefined;
  /**
   * Log Level (verbosity) for collection runtime behavior.
   */
  logLevel?: LogLevelOffice365MsgTrace | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumOffice365MsgTrace> | undefined;
  retryRules?: RetryRulesOffice365MsgTrace | undefined;
  description?: string | undefined;
  /**
   * Username to run Message Trace API call.
   */
  username?: string | undefined;
  /**
   * Password to run Message Trace API call.
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials.
   */
  credentialsSecret?: string | undefined;
  /**
   * client_secret to pass in the OAuth request parameter.
   */
  clientSecret?: string | undefined;
  /**
   * Directory ID (tenant identifier) in Azure Active Directory.
   */
  tenantId?: string | undefined;
  /**
   * client_id to pass in the OAuth request parameter.
   */
  clientId?: string | undefined;
  /**
   * Resource to pass in the OAuth request parameter.
   */
  resource?: string | undefined;
  /**
   * Office 365 subscription plan for your organization, typically Office 365 Enterprise
   */
  planType?: SubscriptionPlanOffice365MsgTrace | undefined;
  /**
   * Select or create a secret that references your client_secret to pass in the OAuth request parameter.
   */
  textSecret?: string | undefined;
  certOptions?: CertOptions | undefined;
};

export const TypeOffice365Service = {
  Office365Service: "office365_service",
} as const;
export type TypeOffice365Service = ClosedEnum<typeof TypeOffice365Service>;

export type ConnectionOffice365Service = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeOffice365Service = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeOffice365Service = ClosedEnum<typeof ModeOffice365Service>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionOffice365Service = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionOffice365Service = ClosedEnum<
  typeof CompressionOffice365Service
>;

export type PqOffice365Service = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeOffice365Service | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionOffice365Service | undefined;
};

/**
 * Office 365 subscription plan for your organization, typically Office 365 Enterprise
 */
export const SubscriptionPlanOffice365Service = {
  EnterpriseGcc: "enterprise_gcc",
  Gcc: "gcc",
  GccHigh: "gcc_high",
  Dod: "dod",
} as const;
/**
 * Office 365 subscription plan for your organization, typically Office 365 Enterprise
 */
export type SubscriptionPlanOffice365Service = ClosedEnum<
  typeof SubscriptionPlanOffice365Service
>;

export type MetadatumOffice365Service = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * Collector runtime Log Level
 */
export const LogLevelOffice365Service = {
  Error: "error",
  Warn: "warn",
  Info: "info",
  Debug: "debug",
} as const;
/**
 * Collector runtime Log Level
 */
export type LogLevelOffice365Service = ClosedEnum<
  typeof LogLevelOffice365Service
>;

export type ContentConfigOffice365Service = {
  /**
   * Office 365 Services API Content Type
   */
  contentType?: string | undefined;
  /**
   * If interval type is minutes the value entered must evenly divisible by 60 or save will fail
   */
  description?: string | undefined;
  interval?: number | undefined;
  /**
   * Collector runtime Log Level
   */
  logLevel?: LogLevelOffice365Service | undefined;
  enabled?: boolean | undefined;
};

/**
 * The algorithm to use when performing HTTP retries
 */
export const RetryTypeOffice365Service = {
  None: "none",
  Backoff: "backoff",
  Static: "static",
} as const;
/**
 * The algorithm to use when performing HTTP retries
 */
export type RetryTypeOffice365Service = ClosedEnum<
  typeof RetryTypeOffice365Service
>;

export type RetryRulesOffice365Service = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOffice365Service | undefined;
  /**
   * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * The maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
   */
  multiplier?: number | undefined;
  /**
   * List of http codes that trigger a retry. Leave empty to use the default list of 429, 500, and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

/**
 * Enter client secret directly, or select a stored secret
 */
export const AuthenticationMethodOffice365Service = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Enter client secret directly, or select a stored secret
 */
export type AuthenticationMethodOffice365Service = ClosedEnum<
  typeof AuthenticationMethodOffice365Service
>;

export type InputOffice365Service = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: TypeOffice365Service | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionOffice365Service> | undefined;
  pq?: PqOffice365Service | undefined;
  /**
   * Office 365 subscription plan for your organization, typically Office 365 Enterprise
   */
  planType?: SubscriptionPlanOffice365Service | undefined;
  /**
   * Office 365 Azure Tenant ID
   */
  tenantId: string;
  /**
   * Office 365 Azure Application ID
   */
  appId: string;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumOffice365Service> | undefined;
  /**
   * Enable Office 365 Service Communication API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: * /${interval} * * * *. Because of this, intervals entered for current and historical status must be evenly divisible by 60 to give a predictable schedule.
   */
  contentConfig?: Array<ContentConfigOffice365Service> | undefined;
  retryRules?: RetryRulesOffice365Service | undefined;
  /**
   * Enter client secret directly, or select a stored secret
   */
  authType?: AuthenticationMethodOffice365Service | undefined;
  description?: string | undefined;
  /**
   * Office 365 Azure client secret
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const TypeOffice365Mgmt = {
  Office365Mgmt: "office365_mgmt",
} as const;
export type TypeOffice365Mgmt = ClosedEnum<typeof TypeOffice365Mgmt>;

export type ConnectionOffice365Mgmt = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeOffice365Mgmt = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeOffice365Mgmt = ClosedEnum<typeof ModeOffice365Mgmt>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionOffice365Mgmt = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionOffice365Mgmt = ClosedEnum<
  typeof CompressionOffice365Mgmt
>;

export type PqOffice365Mgmt = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeOffice365Mgmt | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionOffice365Mgmt | undefined;
};

/**
 * Office 365 subscription plan for your organization, typically Office 365 Enterprise
 */
export const SubscriptionPlanOffice365Mgmt = {
  EnterpriseGcc: "enterprise_gcc",
  Gcc: "gcc",
  GccHigh: "gcc_high",
  Dod: "dod",
} as const;
/**
 * Office 365 subscription plan for your organization, typically Office 365 Enterprise
 */
export type SubscriptionPlanOffice365Mgmt = ClosedEnum<
  typeof SubscriptionPlanOffice365Mgmt
>;

export type MetadatumOffice365Mgmt = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * Collector runtime Log Level
 */
export const LogLevelOffice365Mgmt = {
  Error: "error",
  Warn: "warn",
  Info: "info",
  Debug: "debug",
} as const;
/**
 * Collector runtime Log Level
 */
export type LogLevelOffice365Mgmt = ClosedEnum<typeof LogLevelOffice365Mgmt>;

export type ContentConfigOffice365Mgmt = {
  /**
   * Office 365 Management Activity API Content Type
   */
  contentType?: string | undefined;
  /**
   * If interval type is minutes the value entered must evenly divisible by 60 or save will fail
   */
  description?: string | undefined;
  interval?: number | undefined;
  /**
   * Collector runtime Log Level
   */
  logLevel?: LogLevelOffice365Mgmt | undefined;
  enabled?: boolean | undefined;
};

/**
 * The algorithm to use when performing HTTP retries
 */
export const RetryTypeOffice365Mgmt = {
  None: "none",
  Backoff: "backoff",
  Static: "static",
} as const;
/**
 * The algorithm to use when performing HTTP retries
 */
export type RetryTypeOffice365Mgmt = ClosedEnum<typeof RetryTypeOffice365Mgmt>;

export type RetryRulesOffice365Mgmt = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOffice365Mgmt | undefined;
  /**
   * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * The maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
   */
  multiplier?: number | undefined;
  /**
   * List of http codes that trigger a retry. Leave empty to use the default list of 429, 500, and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

/**
 * Enter client secret directly, or select a stored secret
 */
export const AuthenticationMethodOffice365Mgmt = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Enter client secret directly, or select a stored secret
 */
export type AuthenticationMethodOffice365Mgmt = ClosedEnum<
  typeof AuthenticationMethodOffice365Mgmt
>;

export type InputOffice365Mgmt = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: TypeOffice365Mgmt | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionOffice365Mgmt> | undefined;
  pq?: PqOffice365Mgmt | undefined;
  /**
   * Office 365 subscription plan for your organization, typically Office 365 Enterprise
   */
  planType?: SubscriptionPlanOffice365Mgmt | undefined;
  /**
   * Office 365 Azure Tenant ID
   */
  tenantId: string;
  /**
   * Office 365 Azure Application ID
   */
  appId: string;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumOffice365Mgmt> | undefined;
  /**
   * Optional Publisher Identifier to use in API requests, defaults to tenant id if not defined. For more information see [here](https://docs.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-reference#start-a-subscription)
   */
  publisherIdentifier?: string | undefined;
  /**
   * Enable Office 365 Management Activity API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: * /${interval} * * * *. Because of this, intervals entered must be evenly divisible by 60 to give a predictable schedule.
   */
  contentConfig?: Array<ContentConfigOffice365Mgmt> | undefined;
  /**
   * Use this setting to account for ingestion lag. This is necessary because there can be a lag of 60 - 90 minutes (or longer) before Office 365 events are available for retrieval.
   */
  ingestionLag?: number | undefined;
  retryRules?: RetryRulesOffice365Mgmt | undefined;
  /**
   * Enter client secret directly, or select a stored secret
   */
  authType?: AuthenticationMethodOffice365Mgmt | undefined;
  description?: string | undefined;
  /**
   * Office 365 Azure client secret
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const TypeEdgePrometheus = {
  EdgePrometheus: "edge_prometheus",
} as const;
export type TypeEdgePrometheus = ClosedEnum<typeof TypeEdgePrometheus>;

export type ConnectionEdgePrometheus = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeEdgePrometheus = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeEdgePrometheus = ClosedEnum<typeof ModeEdgePrometheus>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressionEdgePrometheus = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressionEdgePrometheus = ClosedEnum<
  typeof PqCompressionEdgePrometheus
>;

export type PqEdgePrometheus = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeEdgePrometheus | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: PqCompressionEdgePrometheus | undefined;
};

/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export const DiscoveryTypeEdgePrometheus = {
  Static: "static",
  Dns: "dns",
  Ec2: "ec2",
  K8sNode: "k8s-node",
  K8sPods: "k8s-pods",
} as const;
/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export type DiscoveryTypeEdgePrometheus = ClosedEnum<
  typeof DiscoveryTypeEdgePrometheus
>;

/**
 * Data compression format. Default is gzip.
 */
export const PersistenceCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Data compression format. Default is gzip.
 */
export type PersistenceCompression = ClosedEnum<typeof PersistenceCompression>;

export type DiskSpooling = {
  /**
   * Spool events on disk for Cribl Edge and Search. Default is disabled.
   */
  enable?: boolean | undefined;
  /**
   * Time period for grouping spooled events. Default is 10m.
   */
  timeWindow?: string | undefined;
  /**
   * Maximum disk space that can be consumed before older buckets are deleted. Examples: 420MB, 4GB. Default is 1GB.
   */
  maxDataSize?: string | undefined;
  /**
   * Maximum amount of time to retain data before older buckets are deleted. Examples: 2h, 4d. Default is 24h.
   */
  maxDataTime?: string | undefined;
  /**
   * Data compression format. Default is gzip.
   */
  compress?: PersistenceCompression | undefined;
};

export type MetadatumEdgePrometheus = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * Enter credentials directly, or select a stored secret
 */
export const AuthTypeAuthenticationMethodEdgePrometheus = {
  Manual: "manual",
  Secret: "secret",
  Kubernetes: "kubernetes",
} as const;
/**
 * Enter credentials directly, or select a stored secret
 */
export type AuthTypeAuthenticationMethodEdgePrometheus = ClosedEnum<
  typeof AuthTypeAuthenticationMethodEdgePrometheus
>;

/**
 * Protocol to use when collecting metrics
 */
export const TargetProtocol = {
  Http: "http",
  Https: "https",
} as const;
/**
 * Protocol to use when collecting metrics
 */
export type TargetProtocol = ClosedEnum<typeof TargetProtocol>;

export type Target = {
  /**
   * Protocol to use when collecting metrics
   */
  protocol?: TargetProtocol | undefined;
  /**
   * Name of host from which to pull metrics.
   */
  host: string;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  port?: number | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  path?: string | undefined;
};

/**
 * DNS Record type to resolve
 */
export const RecordTypeEdgePrometheus = {
  Srv: "SRV",
  A: "A",
  Aaaa: "AAAA",
} as const;
/**
 * DNS Record type to resolve
 */
export type RecordTypeEdgePrometheus = ClosedEnum<
  typeof RecordTypeEdgePrometheus
>;

/**
 * Protocol to use when collecting metrics
 */
export const ScrapeProtocolProtocol = {
  Http: "http",
  Https: "https",
} as const;
/**
 * Protocol to use when collecting metrics
 */
export type ScrapeProtocolProtocol = ClosedEnum<typeof ScrapeProtocolProtocol>;

export type SearchFilterEdgePrometheus = {
  /**
   * Search filter attribute name, see: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html for more information. Attributes can be manually entered if not present in the drop down list
   */
  name: string;
  /**
   * Search Filter Values, if empty only "running" EC2 instances will be returned
   */
  values: Array<string>;
};

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const AwsAuthenticationMethodAuthenticationMethodEdgePrometheus = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type AwsAuthenticationMethodAuthenticationMethodEdgePrometheus =
  ClosedEnum<typeof AwsAuthenticationMethodAuthenticationMethodEdgePrometheus>;

/**
 * Signature version to use for signing EC2 requests
 */
export const SignatureVersionEdgePrometheus = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing EC2 requests
 */
export type SignatureVersionEdgePrometheus = ClosedEnum<
  typeof SignatureVersionEdgePrometheus
>;

export type PodFilter = {
  /**
   * JavaScript expression applied to pods objects. Return 'true' to include it.
   */
  filter: string;
  /**
   * Optional description of this rule's purpose
   */
  description?: string | undefined;
};

export type InputEdgePrometheus = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: TypeEdgePrometheus | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionEdgePrometheus> | undefined;
  pq?: PqEdgePrometheus | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType?: DiscoveryTypeEdgePrometheus | undefined;
  /**
   * How often in seconds to scrape targets for metrics.
   */
  interval?: number | undefined;
  /**
   * Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable
   */
  timeout?: number | undefined;
  persistence?: DiskSpooling | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumEdgePrometheus> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthTypeAuthenticationMethodEdgePrometheus | undefined;
  description?: string | undefined;
  targets?: Array<Target> | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * DNS Record type to resolve
   */
  recordType?: RecordTypeEdgePrometheus | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: ScrapeProtocolProtocol | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * Use public IP address for discovered targets. Set to false if the private IP address should be used.
   */
  usePublicIp?: boolean | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePort?: number | undefined;
  /**
   * EC2 Instance Search Filter
   */
  searchFilter?: Array<SearchFilterEdgePrometheus> | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?:
    | AwsAuthenticationMethodAuthenticationMethodEdgePrometheus
    | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing EC2 requests
   */
  signatureVersion?: SignatureVersionEdgePrometheus | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocolExpr?: string | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePortExpr?: string | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePathExpr?: string | undefined;
  /**
   *   Add rules to decide which pods to discover for metrics.
   *
   * @remarks
   *   Pods are searched if no rules are given or of all the rules'
   *   expressions evaluate to true.
   */
  podFilter?: Array<PodFilter> | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export const CreateInputTypePrometheus = {
  Prometheus: "prometheus",
} as const;
export type CreateInputTypePrometheus = ClosedEnum<
  typeof CreateInputTypePrometheus
>;

export type ConnectionPrometheus = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const CreateInputModePrometheus = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type CreateInputModePrometheus = ClosedEnum<
  typeof CreateInputModePrometheus
>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressionPrometheus = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressionPrometheus = ClosedEnum<
  typeof PqCompressionPrometheus
>;

export type PqPrometheus = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: CreateInputModePrometheus | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: PqCompressionPrometheus | undefined;
};

/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export const DiscoveryTypePrometheus = {
  Static: "static",
  Dns: "dns",
  Ec2: "ec2",
} as const;
/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export type DiscoveryTypePrometheus = ClosedEnum<
  typeof DiscoveryTypePrometheus
>;

/**
 * Collector runtime Log Level
 */
export const LogLevelPrometheus = {
  Error: "error",
  Warn: "warn",
  Info: "info",
  Debug: "debug",
} as const;
/**
 * Collector runtime Log Level
 */
export type LogLevelPrometheus = ClosedEnum<typeof LogLevelPrometheus>;

export type MetadatumPrometheus = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * Enter credentials directly, or select a stored secret
 */
export const AuthTypeAuthenticationMethodPrometheus = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Enter credentials directly, or select a stored secret
 */
export type AuthTypeAuthenticationMethodPrometheus = ClosedEnum<
  typeof AuthTypeAuthenticationMethodPrometheus
>;

/**
 * DNS Record type to resolve
 */
export const RecordTypePrometheus = {
  Srv: "SRV",
  A: "A",
  Aaaa: "AAAA",
} as const;
/**
 * DNS Record type to resolve
 */
export type RecordTypePrometheus = ClosedEnum<typeof RecordTypePrometheus>;

/**
 * Protocol to use when collecting metrics
 */
export const MetricsProtocol = {
  Http: "http",
  Https: "https",
} as const;
/**
 * Protocol to use when collecting metrics
 */
export type MetricsProtocol = ClosedEnum<typeof MetricsProtocol>;

export type SearchFilterPrometheus = {
  /**
   * Search filter attribute name, see: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html for more information. Attributes can be manually entered if not present in the drop down list
   */
  name: string;
  /**
   * Search Filter Values, if empty only "running" EC2 instances will be returned
   */
  values: Array<string>;
};

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const AwsAuthenticationMethodAuthenticationMethodPrometheus = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type AwsAuthenticationMethodAuthenticationMethodPrometheus = ClosedEnum<
  typeof AwsAuthenticationMethodAuthenticationMethodPrometheus
>;

/**
 * Signature version to use for signing EC2 requests
 */
export const SignatureVersionPrometheus = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing EC2 requests
 */
export type SignatureVersionPrometheus = ClosedEnum<
  typeof SignatureVersionPrometheus
>;

export type InputPrometheus = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: CreateInputTypePrometheus | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionPrometheus> | undefined;
  pq?: PqPrometheus | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType?: DiscoveryTypePrometheus | undefined;
  /**
   * How often in minutes to scrape targets for metrics, 60 must be evenly divisible by the value or save will fail.
   */
  interval?: number | undefined;
  /**
   * Collector runtime Log Level
   */
  logLevel?: LogLevelPrometheus | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumPrometheus> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthTypeAuthenticationMethodPrometheus | undefined;
  description?: string | undefined;
  /**
   * List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
   */
  targetList?: Array<string> | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * DNS Record type to resolve
   */
  recordType?: RecordTypePrometheus | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: MetricsProtocol | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * Use public IP address for discovered targets. Set to false if the private IP address should be used.
   */
  usePublicIp?: boolean | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePort?: number | undefined;
  /**
   * EC2 Instance Search Filter
   */
  searchFilter?: Array<SearchFilterPrometheus> | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?:
    | AwsAuthenticationMethodAuthenticationMethodPrometheus
    | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing EC2 requests
   */
  signatureVersion?: SignatureVersionPrometheus | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export const TypePrometheusRw = {
  PrometheusRw: "prometheus_rw",
} as const;
export type TypePrometheusRw = ClosedEnum<typeof TypePrometheusRw>;

export type ConnectionPrometheusRw = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModePrometheusRw = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModePrometheusRw = ClosedEnum<typeof ModePrometheusRw>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionPrometheusRw = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionPrometheusRw = ClosedEnum<
  typeof CompressionPrometheusRw
>;

export type PqPrometheusRw = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModePrometheusRw | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionPrometheusRw | undefined;
};

export const MinimumTLSVersionPrometheusRw = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MinimumTLSVersionPrometheusRw = ClosedEnum<
  typeof MinimumTLSVersionPrometheusRw
>;

export const MaximumTLSVersionPrometheusRw = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MaximumTLSVersionPrometheusRw = ClosedEnum<
  typeof MaximumTLSVersionPrometheusRw
>;

export type TLSSettingsServerSidePrometheusRw = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: MinimumTLSVersionPrometheusRw | undefined;
  maxVersion?: MaximumTLSVersionPrometheusRw | undefined;
};

/**
 * Remote Write authentication type
 */
export const AuthenticationTypePrometheusRw = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * Remote Write authentication type
 */
export type AuthenticationTypePrometheusRw = ClosedEnum<
  typeof AuthenticationTypePrometheusRw
>;

export type MetadatumPrometheusRw = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type OauthParamPrometheusRw = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type OauthHeaderPrometheusRw = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type InputPrometheusRw = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: TypePrometheusRw | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionPrometheusRw> | undefined;
  pq?: PqPrometheusRw | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: TLSSettingsServerSidePrometheusRw | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Prometheus requests. Defaults to /write, which will expand as: http://<yourupstreamURL>:<yourport>/write.
   */
  prometheusAPI?: string | undefined;
  /**
   * Remote Write authentication type
   */
  authType?: AuthenticationTypePrometheusRw | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumPrometheusRw> | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<OauthParamPrometheusRw> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<OauthHeaderPrometheusRw> | undefined;
};

export const CreateInputTypeLoki = {
  Loki: "loki",
} as const;
export type CreateInputTypeLoki = ClosedEnum<typeof CreateInputTypeLoki>;

export type ConnectionLoki = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const CreateInputModeLoki = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type CreateInputModeLoki = ClosedEnum<typeof CreateInputModeLoki>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressionLoki = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressionLoki = ClosedEnum<typeof PqCompressionLoki>;

export type PqLoki = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: CreateInputModeLoki | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: PqCompressionLoki | undefined;
};

export const MinimumTLSVersionLoki = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MinimumTLSVersionLoki = ClosedEnum<typeof MinimumTLSVersionLoki>;

export const MaximumTLSVersionLoki = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MaximumTLSVersionLoki = ClosedEnum<typeof MaximumTLSVersionLoki>;

export type TLSSettingsServerSideLoki = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: MinimumTLSVersionLoki | undefined;
  maxVersion?: MaximumTLSVersionLoki | undefined;
};

/**
 * Loki logs authentication type
 */
export const CreateInputAuthenticationTypeLoki = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * Loki logs authentication type
 */
export type CreateInputAuthenticationTypeLoki = ClosedEnum<
  typeof CreateInputAuthenticationTypeLoki
>;

export type MetadatumLoki = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type OauthParamLoki = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type OauthHeaderLoki = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type InputLoki = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: CreateInputTypeLoki | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionLoki> | undefined;
  pq?: PqLoki | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: TLSSettingsServerSideLoki | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'.
   */
  lokiAPI?: string | undefined;
  /**
   * Loki logs authentication type
   */
  authType?: CreateInputAuthenticationTypeLoki | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumLoki> | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<OauthParamLoki> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<OauthHeaderLoki> | undefined;
};

export const InputGrafanaType2 = {
  Grafana: "grafana",
} as const;
export type InputGrafanaType2 = ClosedEnum<typeof InputGrafanaType2>;

export type InputGrafanaConnection2 = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputGrafanaMode2 = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputGrafanaMode2 = ClosedEnum<typeof InputGrafanaMode2>;

/**
 * Codec to use to compress the persisted data
 */
export const InputGrafanaCompression2 = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputGrafanaCompression2 = ClosedEnum<
  typeof InputGrafanaCompression2
>;

export type InputGrafanaPq2 = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputGrafanaMode2 | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputGrafanaCompression2 | undefined;
};

export const InputGrafanaMinimumTLSVersion2 = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputGrafanaMinimumTLSVersion2 = ClosedEnum<
  typeof InputGrafanaMinimumTLSVersion2
>;

export const InputGrafanaMaximumTLSVersion2 = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputGrafanaMaximumTLSVersion2 = ClosedEnum<
  typeof InputGrafanaMaximumTLSVersion2
>;

export type InputGrafanaTLSSettingsServerSide2 = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputGrafanaMinimumTLSVersion2 | undefined;
  maxVersion?: InputGrafanaMaximumTLSVersion2 | undefined;
};

/**
 * Remote Write authentication type
 */
export const PrometheusAuthAuthenticationType2 = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * Remote Write authentication type
 */
export type PrometheusAuthAuthenticationType2 = ClosedEnum<
  typeof PrometheusAuthAuthenticationType2
>;

export type PrometheusAuthOauthParam2 = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type PrometheusAuthOauthHeader2 = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type PrometheusAuth2 = {
  /**
   * Remote Write authentication type
   */
  authType?: PrometheusAuthAuthenticationType2 | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<PrometheusAuthOauthParam2> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<PrometheusAuthOauthHeader2> | undefined;
};

/**
 * Loki logs authentication type
 */
export const LokiAuthAuthenticationType2 = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * Loki logs authentication type
 */
export type LokiAuthAuthenticationType2 = ClosedEnum<
  typeof LokiAuthAuthenticationType2
>;

export type LokiAuthOauthParam2 = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type LokiAuthOauthHeader2 = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type LokiAuth2 = {
  /**
   * Loki logs authentication type
   */
  authType?: LokiAuthAuthenticationType2 | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<LokiAuthOauthParam2> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<LokiAuthOauthHeader2> | undefined;
};

export type InputGrafanaMetadatum2 = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputGrafanaGrafana2 = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputGrafanaType2 | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputGrafanaConnection2> | undefined;
  pq?: InputGrafanaPq2 | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: InputGrafanaTLSSettingsServerSide2 | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes.
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: 'http://<yourupstreamURL>:<yourport>/api/prom/push'. Either this field or 'Logs API endpoint' must be configured.
   */
  prometheusAPI?: string | undefined;
  /**
   * Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'. Either this field or 'Remote Write API endpoint' must be configured.
   */
  lokiAPI?: string | undefined;
  prometheusAuth?: PrometheusAuth2 | undefined;
  lokiAuth?: LokiAuth2 | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputGrafanaMetadatum2> | undefined;
  description?: string | undefined;
};

export const InputGrafanaType1 = {
  Grafana: "grafana",
} as const;
export type InputGrafanaType1 = ClosedEnum<typeof InputGrafanaType1>;

export type InputGrafanaConnection1 = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputGrafanaMode1 = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputGrafanaMode1 = ClosedEnum<typeof InputGrafanaMode1>;

/**
 * Codec to use to compress the persisted data
 */
export const InputGrafanaCompression1 = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputGrafanaCompression1 = ClosedEnum<
  typeof InputGrafanaCompression1
>;

export type InputGrafanaPq1 = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputGrafanaMode1 | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputGrafanaCompression1 | undefined;
};

export const InputGrafanaMinimumTLSVersion1 = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputGrafanaMinimumTLSVersion1 = ClosedEnum<
  typeof InputGrafanaMinimumTLSVersion1
>;

export const InputGrafanaMaximumTLSVersion1 = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputGrafanaMaximumTLSVersion1 = ClosedEnum<
  typeof InputGrafanaMaximumTLSVersion1
>;

export type InputGrafanaTLSSettingsServerSide1 = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputGrafanaMinimumTLSVersion1 | undefined;
  maxVersion?: InputGrafanaMaximumTLSVersion1 | undefined;
};

/**
 * Remote Write authentication type
 */
export const PrometheusAuthAuthenticationType1 = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * Remote Write authentication type
 */
export type PrometheusAuthAuthenticationType1 = ClosedEnum<
  typeof PrometheusAuthAuthenticationType1
>;

export type PrometheusAuthOauthParam1 = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type PrometheusAuthOauthHeader1 = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type PrometheusAuth1 = {
  /**
   * Remote Write authentication type
   */
  authType?: PrometheusAuthAuthenticationType1 | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<PrometheusAuthOauthParam1> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<PrometheusAuthOauthHeader1> | undefined;
};

/**
 * Loki logs authentication type
 */
export const LokiAuthAuthenticationType1 = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * Loki logs authentication type
 */
export type LokiAuthAuthenticationType1 = ClosedEnum<
  typeof LokiAuthAuthenticationType1
>;

export type LokiAuthOauthParam1 = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type LokiAuthOauthHeader1 = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type LokiAuth1 = {
  /**
   * Loki logs authentication type
   */
  authType?: LokiAuthAuthenticationType1 | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<LokiAuthOauthParam1> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<LokiAuthOauthHeader1> | undefined;
};

export type InputGrafanaMetadatum1 = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputGrafanaGrafana1 = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputGrafanaType1 | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputGrafanaConnection1> | undefined;
  pq?: InputGrafanaPq1 | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: InputGrafanaTLSSettingsServerSide1 | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes.
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: 'http://<yourupstreamURL>:<yourport>/api/prom/push'. Either this field or 'Logs API endpoint' must be configured.
   */
  prometheusAPI?: string | undefined;
  /**
   * Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'. Either this field or 'Remote Write API endpoint' must be configured.
   */
  lokiAPI?: string | undefined;
  prometheusAuth?: PrometheusAuth1 | undefined;
  lokiAuth?: LokiAuth1 | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputGrafanaMetadatum1> | undefined;
  description?: string | undefined;
};

export type InputGrafana = InputGrafanaGrafana1 | InputGrafanaGrafana2;

export const CreateInputTypeConfluentCloud = {
  ConfluentCloud: "confluent_cloud",
} as const;
export type CreateInputTypeConfluentCloud = ClosedEnum<
  typeof CreateInputTypeConfluentCloud
>;

export type ConnectionConfluentCloud = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const CreateInputModeConfluentCloud = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type CreateInputModeConfluentCloud = ClosedEnum<
  typeof CreateInputModeConfluentCloud
>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressionConfluentCloud = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressionConfluentCloud = ClosedEnum<
  typeof PqCompressionConfluentCloud
>;

export type PqConfluentCloud = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: CreateInputModeConfluentCloud | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: PqCompressionConfluentCloud | undefined;
};

export const CreateInputMinimumTLSVersionConfluentCloud = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateInputMinimumTLSVersionConfluentCloud = ClosedEnum<
  typeof CreateInputMinimumTLSVersionConfluentCloud
>;

export const CreateInputMaximumTLSVersionConfluentCloud = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateInputMaximumTLSVersionConfluentCloud = ClosedEnum<
  typeof CreateInputMaximumTLSVersionConfluentCloud
>;

export type CreateInputTLSSettingsClientSideConfluentCloud = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: CreateInputMinimumTLSVersionConfluentCloud | undefined;
  maxVersion?: CreateInputMaximumTLSVersionConfluentCloud | undefined;
};

/**
 * Credentials to use when authenticating with the schema registry using basic HTTP authentication
 */
export type CreateInputAuthConfluentCloud = {
  disabled?: boolean | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export const CreateInputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateInputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud =
  ClosedEnum<
    typeof CreateInputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud
  >;

export const CreateInputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateInputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud =
  ClosedEnum<
    typeof CreateInputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud
  >;

export type CreateInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud =
  {
    disabled?: boolean | undefined;
    /**
     * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
     *
     * @remarks
     *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
     */
    rejectUnauthorized?: boolean | undefined;
    /**
     * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
     */
    servername?: string | undefined;
    /**
     * The name of the predefined certificate
     */
    certificateName?: string | undefined;
    /**
     * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
     */
    caPath?: string | undefined;
    /**
     * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
     */
    privKeyPath?: string | undefined;
    /**
     * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
     */
    certPath?: string | undefined;
    /**
     * Passphrase to use to decrypt private key
     */
    passphrase?: string | undefined;
    minVersion?:
      | CreateInputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud
      | undefined;
    maxVersion?:
      | CreateInputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud
      | undefined;
  };

export type CreateInputKafkaSchemaRegistryAuthenticationConfluentCloud = {
  disabled?: boolean | undefined;
  /**
   * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http.
   */
  schemaRegistryURL?: string | undefined;
  /**
   * Maximum time to wait for a Schema Registry connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for the Schema Registry to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * Maximum number of times to try fetching schemas from the Schema Registry
   */
  maxRetries?: number | undefined;
  /**
   * Credentials to use when authenticating with the schema registry using basic HTTP authentication
   */
  auth?: CreateInputAuthConfluentCloud | undefined;
  tls?:
    | CreateInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud
    | undefined;
};

export const CreateInputSASLMechanismConfluentCloud = {
  Plain: "plain",
  ScramSha256: "scram-sha-256",
  ScramSha512: "scram-sha-512",
  Kerberos: "kerberos",
} as const;
export type CreateInputSASLMechanismConfluentCloud = ClosedEnum<
  typeof CreateInputSASLMechanismConfluentCloud
>;

/**
 * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
 */
export type CreateInputAuthenticationConfluentCloud = {
  disabled?: boolean | undefined;
  mechanism?: CreateInputSASLMechanismConfluentCloud | undefined;
};

export type MetadatumConfluentCloud = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputConfluentCloud = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: CreateInputTypeConfluentCloud | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionConfluentCloud> | undefined;
  pq?: PqConfluentCloud | undefined;
  /**
   * List of Confluent Cloud bootstrap servers to use, such as yourAccount.confluent.cloud:9092
   */
  brokers: Array<string>;
  tls?: CreateInputTLSSettingsClientSideConfluentCloud | undefined;
  /**
   * Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
   */
  topics: Array<string>;
  /**
   * The consumer group to which this instance belongs. Defaults to 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
   */
  fromBeginning?: boolean | undefined;
  kafkaSchemaRegistry?:
    | CreateInputKafkaSchemaRegistryAuthenticationConfluentCloud
    | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: CreateInputAuthenticationConfluentCloud | undefined;
  /**
   *       Timeout used to detect client failures when using Kafka's group-management facilities.
   *
   * @remarks
   *       If the client sends no heartbeats to the broker before the timeout expires,
   *       the broker will remove the client from the group and initiate a rebalance.
   *       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
   */
  heartbeatInterval?: number | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumConfluentCloud> | undefined;
  description?: string | undefined;
};

export const CreateInputTypeElastic = {
  Elastic: "elastic",
} as const;
export type CreateInputTypeElastic = ClosedEnum<typeof CreateInputTypeElastic>;

export type ConnectionElastic = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const CreateInputModeElastic = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type CreateInputModeElastic = ClosedEnum<typeof CreateInputModeElastic>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressionElastic = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressionElastic = ClosedEnum<typeof PqCompressionElastic>;

export type PqElastic = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: CreateInputModeElastic | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: PqCompressionElastic | undefined;
};

export const MinimumTLSVersionElastic = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MinimumTLSVersionElastic = ClosedEnum<
  typeof MinimumTLSVersionElastic
>;

export const MaximumTLSVersionElastic = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MaximumTLSVersionElastic = ClosedEnum<
  typeof MaximumTLSVersionElastic
>;

export type TLSSettingsServerSideElastic = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: MinimumTLSVersionElastic | undefined;
  maxVersion?: MaximumTLSVersionElastic | undefined;
};

export const AuthenticationTypeElastic = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  AuthTokens: "authTokens",
} as const;
export type AuthenticationTypeElastic = ClosedEnum<
  typeof AuthenticationTypeElastic
>;

/**
 * The API version to use for communicating with the server
 */
export const CreateInputAPIVersion = {
  SixDot8Dot4: "6.8.4",
  EightDot3Dot2: "8.3.2",
  Custom: "custom",
} as const;
/**
 * The API version to use for communicating with the server
 */
export type CreateInputAPIVersion = ClosedEnum<typeof CreateInputAPIVersion>;

export type CreateInputExtraHttpHeader = {
  name?: string | undefined;
  value: string;
};

export type MetadatumElastic = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * Enter credentials directly, or select a stored secret
 */
export const ProxyModeAuthenticationMethod = {
  None: "none",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Enter credentials directly, or select a stored secret
 */
export type ProxyModeAuthenticationMethod = ClosedEnum<
  typeof ProxyModeAuthenticationMethod
>;

export type ProxyModeElastic = {
  /**
   * Enable proxying of non-bulk API requests to an external Elastic server. Enable this only if you understand the implications. See [Cribl Docs](https://docs.cribl.io/stream/sources-elastic/#proxy-mode) for more details.
   */
  enabled?: boolean | undefined;
  /**
   * URL of the Elastic server to proxy non-bulk requests to, such as http://elastic:9200
   */
  url?: string | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * List of headers to remove from the request to proxy
   */
  removeHeaders?: Array<string> | undefined;
  /**
   * Amount of time, in seconds, to wait for a proxy request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: ProxyModeAuthenticationMethod | undefined;
};

export type InputElastic = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: CreateInputTypeElastic | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionElastic> | undefined;
  pq?: PqElastic | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: TLSSettingsServerSideElastic | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Elasticsearch API requests. Defaults to /. _bulk will be appended automatically. For example, /myPath becomes /myPath/_bulk. Requests can then be made to either /myPath/_bulk or /myPath/<myIndexName>/_bulk. Other entries are faked as success.
   */
  elasticAPI?: string | undefined;
  authType?: AuthenticationTypeElastic | undefined;
  /**
   * The API version to use for communicating with the server
   */
  apiVersion?: CreateInputAPIVersion | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<CreateInputExtraHttpHeader> | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumElastic> | undefined;
  proxyMode?: ProxyModeElastic | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Bearer tokens to include in the authorization header
   */
  authTokens?: Array<string> | undefined;
  /**
   * Custom version information to respond to requests
   */
  customAPIVersion?: string | undefined;
};

export const CreateInputTypeAzureBlob = {
  AzureBlob: "azure_blob",
} as const;
export type CreateInputTypeAzureBlob = ClosedEnum<
  typeof CreateInputTypeAzureBlob
>;

export type ConnectionAzureBlob = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeAzureBlob = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeAzureBlob = ClosedEnum<typeof ModeAzureBlob>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressionAzureBlob = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressionAzureBlob = ClosedEnum<typeof PqCompressionAzureBlob>;

export type PqAzureBlob = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeAzureBlob | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: PqCompressionAzureBlob | undefined;
};

export type MetadatumAzureBlob = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export const CreateInputAuthenticationMethodAzureBlob = {
  Manual: "manual",
  Secret: "secret",
  ClientSecret: "clientSecret",
  ClientCert: "clientCert",
} as const;
export type CreateInputAuthenticationMethodAzureBlob = ClosedEnum<
  typeof CreateInputAuthenticationMethodAzureBlob
>;

export type CreateInputCertificate = {
  /**
   * The certificate you registered as credentials for your app in the Azure portal
   */
  certificateName: string;
};

export type InputAzureBlob = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: CreateInputTypeAzureBlob;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionAzureBlob> | undefined;
  pq?: PqAzureBlob | undefined;
  /**
   * The storage account queue name blob notifications will be read from. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myQueue-${C.vars.myVar}`
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request.
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * The maximum number of messages to return in a poll request. Azure storage queues never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 32.
   */
  maxMessages?: number | undefined;
  /**
   * The duration (in seconds) which pollers should be validated and restarted if exited
   */
  servicePeriodSecs?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumAzureBlob> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  authType?: CreateInputAuthenticationMethodAzureBlob | undefined;
  description?: string | undefined;
  /**
   * Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING.
   */
  connectionString?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * The name of your Azure storage account
   */
  storageAccountName?: string | undefined;
  /**
   * The service principal's tenant ID
   */
  tenantId?: string | undefined;
  /**
   * The service principal's client ID
   */
  clientId?: string | undefined;
  /**
   * The Azure cloud to use. Defaults to Azure Public Cloud.
   */
  azureCloud?: string | undefined;
  /**
   * Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net.
   */
  endpointSuffix?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  clientTextSecret?: string | undefined;
  certificate?: CreateInputCertificate | undefined;
};

export const TypeSplunkHec = {
  SplunkHec: "splunk_hec",
} as const;
export type TypeSplunkHec = ClosedEnum<typeof TypeSplunkHec>;

export type ConnectionSplunkHec = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeSplunkHec = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeSplunkHec = ClosedEnum<typeof ModeSplunkHec>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionSplunkHec = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionSplunkHec = ClosedEnum<typeof CompressionSplunkHec>;

export type PqSplunkHec = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeSplunkHec | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionSplunkHec | undefined;
};

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const AuthenticationMethodSplunkHec = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type AuthenticationMethodSplunkHec = ClosedEnum<
  typeof AuthenticationMethodSplunkHec
>;

export type AuthTokenMetadatumSplunkHec = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type AuthTokenSplunkHec = {
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: AuthenticationMethodSplunkHec | undefined;
  tokenSecret?: any | undefined;
  token?: any | undefined;
  enabled?: boolean | undefined;
  /**
   * Optional token description
   */
  description?: string | undefined;
  /**
   * Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.
   */
  allowedIndexesAtToken?: Array<string> | undefined;
  /**
   * Fields to add to events referencing this token
   */
  metadata?: Array<AuthTokenMetadatumSplunkHec> | undefined;
};

export const MinimumTLSVersionSplunkHec = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MinimumTLSVersionSplunkHec = ClosedEnum<
  typeof MinimumTLSVersionSplunkHec
>;

export const MaximumTLSVersionSplunkHec = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MaximumTLSVersionSplunkHec = ClosedEnum<
  typeof MaximumTLSVersionSplunkHec
>;

export type TLSSettingsServerSideSplunkHec = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: MinimumTLSVersionSplunkHec | undefined;
  maxVersion?: MaximumTLSVersionSplunkHec | undefined;
};

export type MetadatumSplunkHec = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputSplunkHec = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: TypeSplunkHec | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionSplunkHec> | undefined;
  pq?: PqSplunkHec | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<AuthTokenSplunkHec> | undefined;
  tls?: TLSSettingsServerSideSplunkHec | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Splunk HTTP Event Collector API requests. This input supports the /event, /raw and /s2s endpoints.
   */
  splunkHecAPI?: string | undefined;
  /**
   * Fields to add to every event. Overrides fields added at the token or request level. See [the Source documentation](https://docs.cribl.io/stream/sources-splunk-hec/#fields) for more info.
   */
  metadata?: Array<MetadatumSplunkHec> | undefined;
  /**
   * List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
   */
  allowedIndexes?: Array<string> | undefined;
  /**
   * Enable Splunk HEC acknowledgements
   */
  splunkHecAcks?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
   */
  useFwdTimezone?: boolean | undefined;
  /**
   * Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
   */
  dropControlFields?: boolean | undefined;
  /**
   * Extract and process Splunk-generated metrics as Cribl metrics
   */
  extractMetrics?: boolean | undefined;
  /**
   * Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
   */
  accessControlAllowOrigin?: Array<string> | undefined;
  /**
   * Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
   */
  accessControlAllowHeaders?: Array<string> | undefined;
  /**
   * Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
   */
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

export const TypeSplunkSearch = {
  SplunkSearch: "splunk_search",
} as const;
export type TypeSplunkSearch = ClosedEnum<typeof TypeSplunkSearch>;

export type ConnectionSplunkSearch = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const ModeSplunkSearch = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type ModeSplunkSearch = ClosedEnum<typeof ModeSplunkSearch>;

/**
 * Codec to use to compress the persisted data
 */
export const CompressionSplunkSearch = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type CompressionSplunkSearch = ClosedEnum<
  typeof CompressionSplunkSearch
>;

export type PqSplunkSearch = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: ModeSplunkSearch | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: CompressionSplunkSearch | undefined;
};

/**
 * Format of the returned output
 */
export const OutputMode = {
  Csv: "csv",
  Json: "json",
} as const;
/**
 * Format of the returned output
 */
export type OutputMode = ClosedEnum<typeof OutputMode>;

export type EndpointParam = {
  name: string;
  /**
   * JavaScript expression to compute the parameter's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings.
   */
  value: string;
};

export type EndpointHeader = {
  name: string;
  /**
   * JavaScript expression to compute the header's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings.
   */
  value: string;
};

/**
 * Collector runtime log level (verbosity)
 */
export const LogLevelSplunkSearch = {
  Error: "error",
  Warn: "warn",
  Info: "info",
  Debug: "debug",
} as const;
/**
 * Collector runtime log level (verbosity)
 */
export type LogLevelSplunkSearch = ClosedEnum<typeof LogLevelSplunkSearch>;

export type MetadatumSplunkSearch = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * The algorithm to use when performing HTTP retries
 */
export const RetryTypeSplunkSearch = {
  None: "none",
  Backoff: "backoff",
  Static: "static",
} as const;
/**
 * The algorithm to use when performing HTTP retries
 */
export type RetryTypeSplunkSearch = ClosedEnum<typeof RetryTypeSplunkSearch>;

export type RetryRulesSplunkSearch = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeSplunkSearch | undefined;
  /**
   * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * The maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
   */
  multiplier?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

/**
 * Splunk Search authentication type
 */
export const AuthenticationTypeSplunkSearch = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * Splunk Search authentication type
 */
export type AuthenticationTypeSplunkSearch = ClosedEnum<
  typeof AuthenticationTypeSplunkSearch
>;

export type OauthParamSplunkSearch = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type OauthHeaderSplunkSearch = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type InputSplunkSearch = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: TypeSplunkSearch | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionSplunkSearch> | undefined;
  pq?: PqSplunkSearch | undefined;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead?: string | undefined;
  /**
   * Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * A cron schedule on which to run this job
   */
  cronSchedule?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint?: string | undefined;
  /**
   * Format of the returned output
   */
  outputMode?: OutputMode | undefined;
  /**
   * Optional request parameters to send to the endpoint
   */
  endpointParams?: Array<EndpointParam> | undefined;
  /**
   * Optional request headers to send to the endpoint
   */
  endpointHeaders?: Array<EndpointHeader> | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel?: LogLevelSplunkSearch | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  requestTimeout?: number | undefined;
  /**
   * When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumSplunkSearch> | undefined;
  retryRules?: RetryRulesSplunkSearch | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: AuthenticationTypeSplunkSearch | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<OauthParamSplunkSearch> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<OauthHeaderSplunkSearch> | undefined;
};

export const CreateInputTypeSplunk = {
  Splunk: "splunk",
} as const;
export type CreateInputTypeSplunk = ClosedEnum<typeof CreateInputTypeSplunk>;

export type ConnectionSplunk = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const CreateInputModeSplunk = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type CreateInputModeSplunk = ClosedEnum<typeof CreateInputModeSplunk>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressionSplunk = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressionSplunk = ClosedEnum<typeof PqCompressionSplunk>;

export type PqSplunk = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: CreateInputModeSplunk | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: PqCompressionSplunk | undefined;
};

export const CreateInputMinimumTLSVersionSplunk = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateInputMinimumTLSVersionSplunk = ClosedEnum<
  typeof CreateInputMinimumTLSVersionSplunk
>;

export const CreateInputMaximumTLSVersionSplunk = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateInputMaximumTLSVersionSplunk = ClosedEnum<
  typeof CreateInputMaximumTLSVersionSplunk
>;

export type TLSSettingsServerSideSplunk = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: CreateInputMinimumTLSVersionSplunk | undefined;
  maxVersion?: CreateInputMaximumTLSVersionSplunk | undefined;
};

export type MetadatumSplunk = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type AuthTokenSplunk = {
  /**
   * Shared secrets to be provided by any Splunk forwarder. If empty, unauthorized access is permitted.
   */
  token: string;
  description?: string | undefined;
};

/**
 * The highest S2S protocol version to advertise during handshake
 */
export const CreateInputMaxS2SVersion = {
  V3: "v3",
  V4: "v4",
} as const;
/**
 * The highest S2S protocol version to advertise during handshake
 */
export type CreateInputMaxS2SVersion = ClosedEnum<
  typeof CreateInputMaxS2SVersion
>;

/**
 * Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections.
 */
export const CreateInputCompressionSplunk = {
  Disabled: "disabled",
  Auto: "auto",
  Always: "always",
} as const;
/**
 * Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections.
 */
export type CreateInputCompressionSplunk = ClosedEnum<
  typeof CreateInputCompressionSplunk
>;

export type InputSplunk = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: CreateInputTypeSplunk | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionSplunk> | undefined;
  pq?: PqSplunk | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: TLSSettingsServerSideSplunk | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumSplunk> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Shared secrets to be provided by any Splunk forwarder. If empty, unauthorized access is permitted.
   */
  authTokens?: Array<AuthTokenSplunk> | undefined;
  /**
   * The highest S2S protocol version to advertise during handshake
   */
  maxS2Sversion?: CreateInputMaxS2SVersion | undefined;
  description?: string | undefined;
  /**
   * Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
   */
  useFwdTimezone?: boolean | undefined;
  /**
   * Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
   */
  dropControlFields?: boolean | undefined;
  /**
   * Extract and process Splunk-generated metrics as Cribl metrics
   */
  extractMetrics?: boolean | undefined;
  /**
   * Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections.
   */
  compress?: CreateInputCompressionSplunk | undefined;
};

export const CreateInputTypeHTTP = {
  Http: "http",
} as const;
export type CreateInputTypeHTTP = ClosedEnum<typeof CreateInputTypeHTTP>;

export type ConnectionHTTP = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const CreateInputModeHTTP = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type CreateInputModeHTTP = ClosedEnum<typeof CreateInputModeHTTP>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressionHTTP = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressionHTTP = ClosedEnum<typeof PqCompressionHTTP>;

export type PqHTTP = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: CreateInputModeHTTP | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: PqCompressionHTTP | undefined;
};

export const MinimumTLSVersionHTTP = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MinimumTLSVersionHTTP = ClosedEnum<typeof MinimumTLSVersionHTTP>;

export const MaximumTLSVersionHTTP = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type MaximumTLSVersionHTTP = ClosedEnum<typeof MaximumTLSVersionHTTP>;

export type TLSSettingsServerSideHTTP = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: MinimumTLSVersionHTTP | undefined;
  maxVersion?: MaximumTLSVersionHTTP | undefined;
};

export type CreateInputMetadatumHTTP = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type AuthTokensExtMetadatumHTTP = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type AuthTokensExtHTTP = {
  /**
   * Shared secret to be provided by any client (Authorization: <token>)
   */
  token: string;
  description?: string | undefined;
  /**
   * Fields to add to events referencing this token
   */
  metadata?: Array<AuthTokensExtMetadatumHTTP> | undefined;
};

export type InputHttp = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: CreateInputTypeHTTP | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionHTTP> | undefined;
  pq?: PqHTTP | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: TLSSettingsServerSideHTTP | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
   */
  criblAPI?: string | undefined;
  /**
   * Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable.
   */
  elasticAPI?: string | undefined;
  /**
   * Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
   */
  splunkHecAPI?: string | undefined;
  splunkHecAcks?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<CreateInputMetadatumHTTP> | undefined;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokensExt?: Array<AuthTokensExtHTTP> | undefined;
  description?: string | undefined;
};

export const CreateInputTypeMsk = {
  Msk: "msk",
} as const;
export type CreateInputTypeMsk = ClosedEnum<typeof CreateInputTypeMsk>;

export type ConnectionMsk = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const CreateInputModeMsk = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type CreateInputModeMsk = ClosedEnum<typeof CreateInputModeMsk>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressionMsk = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressionMsk = ClosedEnum<typeof PqCompressionMsk>;

export type PqMsk = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: CreateInputModeMsk | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: PqCompressionMsk | undefined;
};

export type MetadatumMsk = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * Credentials to use when authenticating with the schema registry using basic HTTP authentication
 */
export type CreateInputAuthMsk = {
  disabled?: boolean | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export const CreateInputKafkaSchemaRegistryMinimumTLSVersionMsk = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateInputKafkaSchemaRegistryMinimumTLSVersionMsk = ClosedEnum<
  typeof CreateInputKafkaSchemaRegistryMinimumTLSVersionMsk
>;

export const CreateInputKafkaSchemaRegistryMaximumTLSVersionMsk = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateInputKafkaSchemaRegistryMaximumTLSVersionMsk = ClosedEnum<
  typeof CreateInputKafkaSchemaRegistryMaximumTLSVersionMsk
>;

export type CreateInputKafkaSchemaRegistryTLSSettingsClientSideMsk = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: CreateInputKafkaSchemaRegistryMinimumTLSVersionMsk | undefined;
  maxVersion?: CreateInputKafkaSchemaRegistryMaximumTLSVersionMsk | undefined;
};

export type CreateInputKafkaSchemaRegistryAuthenticationMsk = {
  disabled?: boolean | undefined;
  /**
   * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http.
   */
  schemaRegistryURL?: string | undefined;
  /**
   * Maximum time to wait for a Schema Registry connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for the Schema Registry to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * Maximum number of times to try fetching schemas from the Schema Registry
   */
  maxRetries?: number | undefined;
  /**
   * Credentials to use when authenticating with the schema registry using basic HTTP authentication
   */
  auth?: CreateInputAuthMsk | undefined;
  tls?: CreateInputKafkaSchemaRegistryTLSSettingsClientSideMsk | undefined;
};

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const CreateInputAuthenticationMethodMsk = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type CreateInputAuthenticationMethodMsk = ClosedEnum<
  typeof CreateInputAuthenticationMethodMsk
>;

/**
 * Signature version to use for signing MSK cluster requests
 */
export const CreateInputSignatureVersionMsk = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing MSK cluster requests
 */
export type CreateInputSignatureVersionMsk = ClosedEnum<
  typeof CreateInputSignatureVersionMsk
>;

export const CreateInputMinimumTLSVersionMsk = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateInputMinimumTLSVersionMsk = ClosedEnum<
  typeof CreateInputMinimumTLSVersionMsk
>;

export const CreateInputMaximumTLSVersionMsk = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateInputMaximumTLSVersionMsk = ClosedEnum<
  typeof CreateInputMaximumTLSVersionMsk
>;

export type CreateInputTLSSettingsClientSideMsk = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: CreateInputMinimumTLSVersionMsk | undefined;
  maxVersion?: CreateInputMaximumTLSVersionMsk | undefined;
};

export type InputMsk = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: CreateInputTypeMsk | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionMsk> | undefined;
  pq?: PqMsk | undefined;
  /**
   * Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
   */
  brokers: Array<string>;
  /**
   * Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
   */
  topics: Array<string>;
  /**
   * The consumer group to which this instance belongs. Defaults to 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
   */
  fromBeginning?: boolean | undefined;
  /**
   *       Timeout used to detect client failures when using Kafka's group-management facilities.
   *
   * @remarks
   *       If the client sends no heartbeats to the broker before the timeout expires,
   *       the broker will remove the client from the group and initiate a rebalance.
   *       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
   */
  heartbeatInterval?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumMsk> | undefined;
  kafkaSchemaRegistry?:
    | CreateInputKafkaSchemaRegistryAuthenticationMsk
    | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: CreateInputAuthenticationMethodMsk | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the MSK cluster is located
   */
  region: string;
  /**
   * MSK cluster service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: CreateInputSignatureVersionMsk | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access MSK
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  tls?: CreateInputTLSSettingsClientSideMsk | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
};

export const CreateInputTypeKafka = {
  Kafka: "kafka",
} as const;
export type CreateInputTypeKafka = ClosedEnum<typeof CreateInputTypeKafka>;

export type ConnectionKafka = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const CreateInputModeKafka = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type CreateInputModeKafka = ClosedEnum<typeof CreateInputModeKafka>;

/**
 * Codec to use to compress the persisted data
 */
export const PqCompressionKafka = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type PqCompressionKafka = ClosedEnum<typeof PqCompressionKafka>;

export type PqKafka = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: CreateInputModeKafka | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: PqCompressionKafka | undefined;
};

/**
 * Credentials to use when authenticating with the schema registry using basic HTTP authentication
 */
export type CreateInputAuthKafka = {
  disabled?: boolean | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export const CreateInputKafkaSchemaRegistryMinimumTLSVersionKafka = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateInputKafkaSchemaRegistryMinimumTLSVersionKafka = ClosedEnum<
  typeof CreateInputKafkaSchemaRegistryMinimumTLSVersionKafka
>;

export const CreateInputKafkaSchemaRegistryMaximumTLSVersionKafka = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateInputKafkaSchemaRegistryMaximumTLSVersionKafka = ClosedEnum<
  typeof CreateInputKafkaSchemaRegistryMaximumTLSVersionKafka
>;

export type CreateInputKafkaSchemaRegistryTLSSettingsClientSideKafka = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: CreateInputKafkaSchemaRegistryMinimumTLSVersionKafka | undefined;
  maxVersion?: CreateInputKafkaSchemaRegistryMaximumTLSVersionKafka | undefined;
};

export type CreateInputKafkaSchemaRegistryAuthenticationKafka = {
  disabled?: boolean | undefined;
  /**
   * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http.
   */
  schemaRegistryURL?: string | undefined;
  /**
   * Maximum time to wait for a Schema Registry connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for the Schema Registry to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * Maximum number of times to try fetching schemas from the Schema Registry
   */
  maxRetries?: number | undefined;
  /**
   * Credentials to use when authenticating with the schema registry using basic HTTP authentication
   */
  auth?: CreateInputAuthKafka | undefined;
  tls?: CreateInputKafkaSchemaRegistryTLSSettingsClientSideKafka | undefined;
};

export const CreateInputSASLMechanismKafka = {
  Plain: "plain",
  ScramSha256: "scram-sha-256",
  ScramSha512: "scram-sha-512",
  Kerberos: "kerberos",
} as const;
export type CreateInputSASLMechanismKafka = ClosedEnum<
  typeof CreateInputSASLMechanismKafka
>;

/**
 * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
 */
export type CreateInputAuthenticationKafka = {
  disabled?: boolean | undefined;
  mechanism?: CreateInputSASLMechanismKafka | undefined;
};

export const CreateInputMinimumTLSVersionKafka = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateInputMinimumTLSVersionKafka = ClosedEnum<
  typeof CreateInputMinimumTLSVersionKafka
>;

export const CreateInputMaximumTLSVersionKafka = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type CreateInputMaximumTLSVersionKafka = ClosedEnum<
  typeof CreateInputMaximumTLSVersionKafka
>;

export type CreateInputTLSSettingsClientSideKafka = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: CreateInputMinimumTLSVersionKafka | undefined;
  maxVersion?: CreateInputMaximumTLSVersionKafka | undefined;
};

export type MetadatumKafka = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputKafka = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: CreateInputTypeKafka | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionKafka> | undefined;
  pq?: PqKafka | undefined;
  /**
   * Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
   */
  brokers: Array<string>;
  /**
   * Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
   */
  topics: Array<string>;
  /**
   * The consumer group to which this instance belongs. Defaults to 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
   */
  fromBeginning?: boolean | undefined;
  kafkaSchemaRegistry?:
    | CreateInputKafkaSchemaRegistryAuthenticationKafka
    | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: CreateInputAuthenticationKafka | undefined;
  tls?: CreateInputTLSSettingsClientSideKafka | undefined;
  /**
   *       Timeout used to detect client failures when using Kafka's group-management facilities.
   *
   * @remarks
   *       If the client sends no heartbeats to the broker before the timeout expires,
   *       the broker will remove the client from the group and initiate a rebalance.
   *       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
   */
  heartbeatInterval?: number | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<MetadatumKafka> | undefined;
  description?: string | undefined;
};

/**
 * New Source object
 */
export type CreateInputRequest =
  | InputMsk
  | InputWiz
  | InputKafka
  | InputAzureBlob
  | InputConfluentCloud
  | InputOffice365Mgmt
  | InputOffice365Service
  | InputEventhub
  | InputExec
  | InputGooglePubsub
  | InputCrowdstrike
  | InputDatagen
  | InputKinesis
  | InputS3
  | InputS3Inventory
  | InputWinEventLogs
  | InputJournalFiles
  | InputSecurityLake
  | InputHttp
  | InputSplunk
  | InputSplunkSearch
  | InputSplunkHec
  | InputElastic
  | InputLoki
  | InputPrometheusRw
  | InputFirehose
  | models.InputCribl
  | InputCriblTcp
  | InputCriblHttp
  | InputCriblLakeHttp
  | InputTcpjson
  | models.InputSystemMetrics
  | models.InputSystemState
  | models.InputKubeMetrics
  | models.InputKubeLogs
  | models.InputKubeEvents
  | models.InputWindowsMetrics
  | InputDatadogAgent
  | InputHttpRaw
  | models.InputCriblmetrics
  | InputMetrics
  | InputSqs
  | models.InputFile
  | InputTcp
  | models.InputAppscope
  | InputWef
  | InputRawUdp
  | InputZscalerHec
  | models.InputCollection
  | InputPrometheus
  | InputEdgePrometheus
  | InputOffice365MsgTrace
  | InputSnmp
  | InputOpenTelemetry
  | InputModelDrivenTelemetry
  | InputNetflow
  | InputGrafanaGrafana1
  | InputGrafanaGrafana2
  | InputSyslogSyslog1
  | InputSyslogSyslog2;

/**
 * a list of Source objects
 */
export type CreateInputResponse = {
  /**
   * number of items present in the items array
   */
  count?: number | undefined;
  items?: Array<models.Input> | undefined;
};

/** @internal */
export const TypeZscalerHec$inboundSchema: z.ZodNativeEnum<
  typeof TypeZscalerHec
> = z.nativeEnum(TypeZscalerHec);

/** @internal */
export const TypeZscalerHec$outboundSchema: z.ZodNativeEnum<
  typeof TypeZscalerHec
> = TypeZscalerHec$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeZscalerHec$ {
  /** @deprecated use `TypeZscalerHec$inboundSchema` instead. */
  export const inboundSchema = TypeZscalerHec$inboundSchema;
  /** @deprecated use `TypeZscalerHec$outboundSchema` instead. */
  export const outboundSchema = TypeZscalerHec$outboundSchema;
}

/** @internal */
export const ConnectionZscalerHec$inboundSchema: z.ZodType<
  ConnectionZscalerHec,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionZscalerHec$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionZscalerHec$outboundSchema: z.ZodType<
  ConnectionZscalerHec$Outbound,
  z.ZodTypeDef,
  ConnectionZscalerHec
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionZscalerHec$ {
  /** @deprecated use `ConnectionZscalerHec$inboundSchema` instead. */
  export const inboundSchema = ConnectionZscalerHec$inboundSchema;
  /** @deprecated use `ConnectionZscalerHec$outboundSchema` instead. */
  export const outboundSchema = ConnectionZscalerHec$outboundSchema;
  /** @deprecated use `ConnectionZscalerHec$Outbound` instead. */
  export type Outbound = ConnectionZscalerHec$Outbound;
}

export function connectionZscalerHecToJSON(
  connectionZscalerHec: ConnectionZscalerHec,
): string {
  return JSON.stringify(
    ConnectionZscalerHec$outboundSchema.parse(connectionZscalerHec),
  );
}

export function connectionZscalerHecFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionZscalerHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionZscalerHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionZscalerHec' from JSON`,
  );
}

/** @internal */
export const ModeZscalerHec$inboundSchema: z.ZodNativeEnum<
  typeof ModeZscalerHec
> = z.nativeEnum(ModeZscalerHec);

/** @internal */
export const ModeZscalerHec$outboundSchema: z.ZodNativeEnum<
  typeof ModeZscalerHec
> = ModeZscalerHec$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeZscalerHec$ {
  /** @deprecated use `ModeZscalerHec$inboundSchema` instead. */
  export const inboundSchema = ModeZscalerHec$inboundSchema;
  /** @deprecated use `ModeZscalerHec$outboundSchema` instead. */
  export const outboundSchema = ModeZscalerHec$outboundSchema;
}

/** @internal */
export const CompressionZscalerHec$inboundSchema: z.ZodNativeEnum<
  typeof CompressionZscalerHec
> = z.nativeEnum(CompressionZscalerHec);

/** @internal */
export const CompressionZscalerHec$outboundSchema: z.ZodNativeEnum<
  typeof CompressionZscalerHec
> = CompressionZscalerHec$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionZscalerHec$ {
  /** @deprecated use `CompressionZscalerHec$inboundSchema` instead. */
  export const inboundSchema = CompressionZscalerHec$inboundSchema;
  /** @deprecated use `CompressionZscalerHec$outboundSchema` instead. */
  export const outboundSchema = CompressionZscalerHec$outboundSchema;
}

/** @internal */
export const PqZscalerHec$inboundSchema: z.ZodType<
  PqZscalerHec,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeZscalerHec$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionZscalerHec$inboundSchema.default("none"),
});

/** @internal */
export type PqZscalerHec$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqZscalerHec$outboundSchema: z.ZodType<
  PqZscalerHec$Outbound,
  z.ZodTypeDef,
  PqZscalerHec
> = z.object({
  mode: ModeZscalerHec$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionZscalerHec$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqZscalerHec$ {
  /** @deprecated use `PqZscalerHec$inboundSchema` instead. */
  export const inboundSchema = PqZscalerHec$inboundSchema;
  /** @deprecated use `PqZscalerHec$outboundSchema` instead. */
  export const outboundSchema = PqZscalerHec$outboundSchema;
  /** @deprecated use `PqZscalerHec$Outbound` instead. */
  export type Outbound = PqZscalerHec$Outbound;
}

export function pqZscalerHecToJSON(pqZscalerHec: PqZscalerHec): string {
  return JSON.stringify(PqZscalerHec$outboundSchema.parse(pqZscalerHec));
}

export function pqZscalerHecFromJSON(
  jsonString: string,
): SafeParseResult<PqZscalerHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqZscalerHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqZscalerHec' from JSON`,
  );
}

/** @internal */
export const AuthenticationMethodZscalerHec$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodZscalerHec
> = z.nativeEnum(AuthenticationMethodZscalerHec);

/** @internal */
export const AuthenticationMethodZscalerHec$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodZscalerHec
> = AuthenticationMethodZscalerHec$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodZscalerHec$ {
  /** @deprecated use `AuthenticationMethodZscalerHec$inboundSchema` instead. */
  export const inboundSchema = AuthenticationMethodZscalerHec$inboundSchema;
  /** @deprecated use `AuthenticationMethodZscalerHec$outboundSchema` instead. */
  export const outboundSchema = AuthenticationMethodZscalerHec$outboundSchema;
}

/** @internal */
export const AuthTokenMetadatumZscalerHec$inboundSchema: z.ZodType<
  AuthTokenMetadatumZscalerHec,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type AuthTokenMetadatumZscalerHec$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const AuthTokenMetadatumZscalerHec$outboundSchema: z.ZodType<
  AuthTokenMetadatumZscalerHec$Outbound,
  z.ZodTypeDef,
  AuthTokenMetadatumZscalerHec
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenMetadatumZscalerHec$ {
  /** @deprecated use `AuthTokenMetadatumZscalerHec$inboundSchema` instead. */
  export const inboundSchema = AuthTokenMetadatumZscalerHec$inboundSchema;
  /** @deprecated use `AuthTokenMetadatumZscalerHec$outboundSchema` instead. */
  export const outboundSchema = AuthTokenMetadatumZscalerHec$outboundSchema;
  /** @deprecated use `AuthTokenMetadatumZscalerHec$Outbound` instead. */
  export type Outbound = AuthTokenMetadatumZscalerHec$Outbound;
}

export function authTokenMetadatumZscalerHecToJSON(
  authTokenMetadatumZscalerHec: AuthTokenMetadatumZscalerHec,
): string {
  return JSON.stringify(
    AuthTokenMetadatumZscalerHec$outboundSchema.parse(
      authTokenMetadatumZscalerHec,
    ),
  );
}

export function authTokenMetadatumZscalerHecFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokenMetadatumZscalerHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthTokenMetadatumZscalerHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokenMetadatumZscalerHec' from JSON`,
  );
}

/** @internal */
export const AuthTokenZscalerHec$inboundSchema: z.ZodType<
  AuthTokenZscalerHec,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthenticationMethodZscalerHec$inboundSchema.default("manual"),
  tokenSecret: z.any().optional(),
  token: z.any().optional(),
  enabled: z.boolean().default(true),
  description: z.string().optional(),
  allowedIndexesAtToken: z.array(z.string()).optional(),
  metadata: z.array(z.lazy(() => AuthTokenMetadatumZscalerHec$inboundSchema))
    .optional(),
});

/** @internal */
export type AuthTokenZscalerHec$Outbound = {
  authType: string;
  tokenSecret?: any | undefined;
  token?: any | undefined;
  enabled: boolean;
  description?: string | undefined;
  allowedIndexesAtToken?: Array<string> | undefined;
  metadata?: Array<AuthTokenMetadatumZscalerHec$Outbound> | undefined;
};

/** @internal */
export const AuthTokenZscalerHec$outboundSchema: z.ZodType<
  AuthTokenZscalerHec$Outbound,
  z.ZodTypeDef,
  AuthTokenZscalerHec
> = z.object({
  authType: AuthenticationMethodZscalerHec$outboundSchema.default("manual"),
  tokenSecret: z.any().optional(),
  token: z.any().optional(),
  enabled: z.boolean().default(true),
  description: z.string().optional(),
  allowedIndexesAtToken: z.array(z.string()).optional(),
  metadata: z.array(z.lazy(() => AuthTokenMetadatumZscalerHec$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenZscalerHec$ {
  /** @deprecated use `AuthTokenZscalerHec$inboundSchema` instead. */
  export const inboundSchema = AuthTokenZscalerHec$inboundSchema;
  /** @deprecated use `AuthTokenZscalerHec$outboundSchema` instead. */
  export const outboundSchema = AuthTokenZscalerHec$outboundSchema;
  /** @deprecated use `AuthTokenZscalerHec$Outbound` instead. */
  export type Outbound = AuthTokenZscalerHec$Outbound;
}

export function authTokenZscalerHecToJSON(
  authTokenZscalerHec: AuthTokenZscalerHec,
): string {
  return JSON.stringify(
    AuthTokenZscalerHec$outboundSchema.parse(authTokenZscalerHec),
  );
}

export function authTokenZscalerHecFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokenZscalerHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthTokenZscalerHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokenZscalerHec' from JSON`,
  );
}

/** @internal */
export const MinimumTLSVersionZscalerHec$inboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionZscalerHec
> = z.nativeEnum(MinimumTLSVersionZscalerHec);

/** @internal */
export const MinimumTLSVersionZscalerHec$outboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionZscalerHec
> = MinimumTLSVersionZscalerHec$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MinimumTLSVersionZscalerHec$ {
  /** @deprecated use `MinimumTLSVersionZscalerHec$inboundSchema` instead. */
  export const inboundSchema = MinimumTLSVersionZscalerHec$inboundSchema;
  /** @deprecated use `MinimumTLSVersionZscalerHec$outboundSchema` instead. */
  export const outboundSchema = MinimumTLSVersionZscalerHec$outboundSchema;
}

/** @internal */
export const MaximumTLSVersionZscalerHec$inboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionZscalerHec
> = z.nativeEnum(MaximumTLSVersionZscalerHec);

/** @internal */
export const MaximumTLSVersionZscalerHec$outboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionZscalerHec
> = MaximumTLSVersionZscalerHec$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaximumTLSVersionZscalerHec$ {
  /** @deprecated use `MaximumTLSVersionZscalerHec$inboundSchema` instead. */
  export const inboundSchema = MaximumTLSVersionZscalerHec$inboundSchema;
  /** @deprecated use `MaximumTLSVersionZscalerHec$outboundSchema` instead. */
  export const outboundSchema = MaximumTLSVersionZscalerHec$outboundSchema;
}

/** @internal */
export const TLSSettingsServerSideZscalerHec$inboundSchema: z.ZodType<
  TLSSettingsServerSideZscalerHec,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionZscalerHec$inboundSchema.optional(),
  maxVersion: MaximumTLSVersionZscalerHec$inboundSchema.optional(),
});

/** @internal */
export type TLSSettingsServerSideZscalerHec$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TLSSettingsServerSideZscalerHec$outboundSchema: z.ZodType<
  TLSSettingsServerSideZscalerHec$Outbound,
  z.ZodTypeDef,
  TLSSettingsServerSideZscalerHec
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionZscalerHec$outboundSchema.optional(),
  maxVersion: MaximumTLSVersionZscalerHec$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsServerSideZscalerHec$ {
  /** @deprecated use `TLSSettingsServerSideZscalerHec$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsServerSideZscalerHec$inboundSchema;
  /** @deprecated use `TLSSettingsServerSideZscalerHec$outboundSchema` instead. */
  export const outboundSchema = TLSSettingsServerSideZscalerHec$outboundSchema;
  /** @deprecated use `TLSSettingsServerSideZscalerHec$Outbound` instead. */
  export type Outbound = TLSSettingsServerSideZscalerHec$Outbound;
}

export function tlsSettingsServerSideZscalerHecToJSON(
  tlsSettingsServerSideZscalerHec: TLSSettingsServerSideZscalerHec,
): string {
  return JSON.stringify(
    TLSSettingsServerSideZscalerHec$outboundSchema.parse(
      tlsSettingsServerSideZscalerHec,
    ),
  );
}

export function tlsSettingsServerSideZscalerHecFromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsServerSideZscalerHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TLSSettingsServerSideZscalerHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsServerSideZscalerHec' from JSON`,
  );
}

/** @internal */
export const MetadatumZscalerHec$inboundSchema: z.ZodType<
  MetadatumZscalerHec,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumZscalerHec$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumZscalerHec$outboundSchema: z.ZodType<
  MetadatumZscalerHec$Outbound,
  z.ZodTypeDef,
  MetadatumZscalerHec
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumZscalerHec$ {
  /** @deprecated use `MetadatumZscalerHec$inboundSchema` instead. */
  export const inboundSchema = MetadatumZscalerHec$inboundSchema;
  /** @deprecated use `MetadatumZscalerHec$outboundSchema` instead. */
  export const outboundSchema = MetadatumZscalerHec$outboundSchema;
  /** @deprecated use `MetadatumZscalerHec$Outbound` instead. */
  export type Outbound = MetadatumZscalerHec$Outbound;
}

export function metadatumZscalerHecToJSON(
  metadatumZscalerHec: MetadatumZscalerHec,
): string {
  return JSON.stringify(
    MetadatumZscalerHec$outboundSchema.parse(metadatumZscalerHec),
  );
}

export function metadatumZscalerHecFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumZscalerHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumZscalerHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumZscalerHec' from JSON`,
  );
}

/** @internal */
export const InputZscalerHec$inboundSchema: z.ZodType<
  InputZscalerHec,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeZscalerHec$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionZscalerHec$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqZscalerHec$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.lazy(() => AuthTokenZscalerHec$inboundSchema))
    .optional(),
  tls: z.lazy(() => TLSSettingsServerSideZscalerHec$inboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.any().optional(),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  hecAPI: z.string().default("/services/collector"),
  metadata: z.array(z.lazy(() => MetadatumZscalerHec$inboundSchema)).optional(),
  allowedIndexes: z.array(z.string()).optional(),
  hecAcks: z.boolean().default(false),
  accessControlAllowOrigin: z.array(z.string()).optional(),
  accessControlAllowHeaders: z.array(z.string()).optional(),
  emitTokenMetrics: z.boolean().default(false),
  description: z.string().optional(),
});

/** @internal */
export type InputZscalerHec$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionZscalerHec$Outbound> | undefined;
  pq?: PqZscalerHec$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<AuthTokenZscalerHec$Outbound> | undefined;
  tls?: TLSSettingsServerSideZscalerHec$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck?: any | undefined;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  hecAPI: string;
  metadata?: Array<MetadatumZscalerHec$Outbound> | undefined;
  allowedIndexes?: Array<string> | undefined;
  hecAcks: boolean;
  accessControlAllowOrigin?: Array<string> | undefined;
  accessControlAllowHeaders?: Array<string> | undefined;
  emitTokenMetrics: boolean;
  description?: string | undefined;
};

/** @internal */
export const InputZscalerHec$outboundSchema: z.ZodType<
  InputZscalerHec$Outbound,
  z.ZodTypeDef,
  InputZscalerHec
> = z.object({
  id: z.string(),
  type: TypeZscalerHec$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionZscalerHec$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqZscalerHec$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.lazy(() => AuthTokenZscalerHec$outboundSchema))
    .optional(),
  tls: z.lazy(() => TLSSettingsServerSideZscalerHec$outboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.any().optional(),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  hecAPI: z.string().default("/services/collector"),
  metadata: z.array(z.lazy(() => MetadatumZscalerHec$outboundSchema))
    .optional(),
  allowedIndexes: z.array(z.string()).optional(),
  hecAcks: z.boolean().default(false),
  accessControlAllowOrigin: z.array(z.string()).optional(),
  accessControlAllowHeaders: z.array(z.string()).optional(),
  emitTokenMetrics: z.boolean().default(false),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputZscalerHec$ {
  /** @deprecated use `InputZscalerHec$inboundSchema` instead. */
  export const inboundSchema = InputZscalerHec$inboundSchema;
  /** @deprecated use `InputZscalerHec$outboundSchema` instead. */
  export const outboundSchema = InputZscalerHec$outboundSchema;
  /** @deprecated use `InputZscalerHec$Outbound` instead. */
  export type Outbound = InputZscalerHec$Outbound;
}

export function inputZscalerHecToJSON(
  inputZscalerHec: InputZscalerHec,
): string {
  return JSON.stringify(InputZscalerHec$outboundSchema.parse(inputZscalerHec));
}

export function inputZscalerHecFromJSON(
  jsonString: string,
): SafeParseResult<InputZscalerHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputZscalerHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputZscalerHec' from JSON`,
  );
}

/** @internal */
export const CreateInputTypeSecurityLake$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeSecurityLake
> = z.nativeEnum(CreateInputTypeSecurityLake);

/** @internal */
export const CreateInputTypeSecurityLake$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeSecurityLake
> = CreateInputTypeSecurityLake$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputTypeSecurityLake$ {
  /** @deprecated use `CreateInputTypeSecurityLake$inboundSchema` instead. */
  export const inboundSchema = CreateInputTypeSecurityLake$inboundSchema;
  /** @deprecated use `CreateInputTypeSecurityLake$outboundSchema` instead. */
  export const outboundSchema = CreateInputTypeSecurityLake$outboundSchema;
}

/** @internal */
export const ConnectionSecurityLake$inboundSchema: z.ZodType<
  ConnectionSecurityLake,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionSecurityLake$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionSecurityLake$outboundSchema: z.ZodType<
  ConnectionSecurityLake$Outbound,
  z.ZodTypeDef,
  ConnectionSecurityLake
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionSecurityLake$ {
  /** @deprecated use `ConnectionSecurityLake$inboundSchema` instead. */
  export const inboundSchema = ConnectionSecurityLake$inboundSchema;
  /** @deprecated use `ConnectionSecurityLake$outboundSchema` instead. */
  export const outboundSchema = ConnectionSecurityLake$outboundSchema;
  /** @deprecated use `ConnectionSecurityLake$Outbound` instead. */
  export type Outbound = ConnectionSecurityLake$Outbound;
}

export function connectionSecurityLakeToJSON(
  connectionSecurityLake: ConnectionSecurityLake,
): string {
  return JSON.stringify(
    ConnectionSecurityLake$outboundSchema.parse(connectionSecurityLake),
  );
}

export function connectionSecurityLakeFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionSecurityLake, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionSecurityLake$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionSecurityLake' from JSON`,
  );
}

/** @internal */
export const ModeSecurityLake$inboundSchema: z.ZodNativeEnum<
  typeof ModeSecurityLake
> = z.nativeEnum(ModeSecurityLake);

/** @internal */
export const ModeSecurityLake$outboundSchema: z.ZodNativeEnum<
  typeof ModeSecurityLake
> = ModeSecurityLake$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeSecurityLake$ {
  /** @deprecated use `ModeSecurityLake$inboundSchema` instead. */
  export const inboundSchema = ModeSecurityLake$inboundSchema;
  /** @deprecated use `ModeSecurityLake$outboundSchema` instead. */
  export const outboundSchema = ModeSecurityLake$outboundSchema;
}

/** @internal */
export const CompressionSecurityLake$inboundSchema: z.ZodNativeEnum<
  typeof CompressionSecurityLake
> = z.nativeEnum(CompressionSecurityLake);

/** @internal */
export const CompressionSecurityLake$outboundSchema: z.ZodNativeEnum<
  typeof CompressionSecurityLake
> = CompressionSecurityLake$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionSecurityLake$ {
  /** @deprecated use `CompressionSecurityLake$inboundSchema` instead. */
  export const inboundSchema = CompressionSecurityLake$inboundSchema;
  /** @deprecated use `CompressionSecurityLake$outboundSchema` instead. */
  export const outboundSchema = CompressionSecurityLake$outboundSchema;
}

/** @internal */
export const PqSecurityLake$inboundSchema: z.ZodType<
  PqSecurityLake,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeSecurityLake$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionSecurityLake$inboundSchema.default("none"),
});

/** @internal */
export type PqSecurityLake$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqSecurityLake$outboundSchema: z.ZodType<
  PqSecurityLake$Outbound,
  z.ZodTypeDef,
  PqSecurityLake
> = z.object({
  mode: ModeSecurityLake$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionSecurityLake$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqSecurityLake$ {
  /** @deprecated use `PqSecurityLake$inboundSchema` instead. */
  export const inboundSchema = PqSecurityLake$inboundSchema;
  /** @deprecated use `PqSecurityLake$outboundSchema` instead. */
  export const outboundSchema = PqSecurityLake$outboundSchema;
  /** @deprecated use `PqSecurityLake$Outbound` instead. */
  export type Outbound = PqSecurityLake$Outbound;
}

export function pqSecurityLakeToJSON(pqSecurityLake: PqSecurityLake): string {
  return JSON.stringify(PqSecurityLake$outboundSchema.parse(pqSecurityLake));
}

export function pqSecurityLakeFromJSON(
  jsonString: string,
): SafeParseResult<PqSecurityLake, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqSecurityLake$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqSecurityLake' from JSON`,
  );
}

/** @internal */
export const CreateInputAuthenticationMethodSecurityLake$inboundSchema:
  z.ZodNativeEnum<typeof CreateInputAuthenticationMethodSecurityLake> = z
    .nativeEnum(CreateInputAuthenticationMethodSecurityLake);

/** @internal */
export const CreateInputAuthenticationMethodSecurityLake$outboundSchema:
  z.ZodNativeEnum<typeof CreateInputAuthenticationMethodSecurityLake> =
    CreateInputAuthenticationMethodSecurityLake$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputAuthenticationMethodSecurityLake$ {
  /** @deprecated use `CreateInputAuthenticationMethodSecurityLake$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputAuthenticationMethodSecurityLake$inboundSchema;
  /** @deprecated use `CreateInputAuthenticationMethodSecurityLake$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputAuthenticationMethodSecurityLake$outboundSchema;
}

/** @internal */
export const CreateInputSignatureVersionSecurityLake$inboundSchema:
  z.ZodNativeEnum<typeof CreateInputSignatureVersionSecurityLake> = z
    .nativeEnum(CreateInputSignatureVersionSecurityLake);

/** @internal */
export const CreateInputSignatureVersionSecurityLake$outboundSchema:
  z.ZodNativeEnum<typeof CreateInputSignatureVersionSecurityLake> =
    CreateInputSignatureVersionSecurityLake$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputSignatureVersionSecurityLake$ {
  /** @deprecated use `CreateInputSignatureVersionSecurityLake$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputSignatureVersionSecurityLake$inboundSchema;
  /** @deprecated use `CreateInputSignatureVersionSecurityLake$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputSignatureVersionSecurityLake$outboundSchema;
}

/** @internal */
export const PreprocessSecurityLake$inboundSchema: z.ZodType<
  PreprocessSecurityLake,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  command: z.string().optional(),
  args: z.array(z.string()).optional(),
});

/** @internal */
export type PreprocessSecurityLake$Outbound = {
  disabled: boolean;
  command?: string | undefined;
  args?: Array<string> | undefined;
};

/** @internal */
export const PreprocessSecurityLake$outboundSchema: z.ZodType<
  PreprocessSecurityLake$Outbound,
  z.ZodTypeDef,
  PreprocessSecurityLake
> = z.object({
  disabled: z.boolean().default(true),
  command: z.string().optional(),
  args: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PreprocessSecurityLake$ {
  /** @deprecated use `PreprocessSecurityLake$inboundSchema` instead. */
  export const inboundSchema = PreprocessSecurityLake$inboundSchema;
  /** @deprecated use `PreprocessSecurityLake$outboundSchema` instead. */
  export const outboundSchema = PreprocessSecurityLake$outboundSchema;
  /** @deprecated use `PreprocessSecurityLake$Outbound` instead. */
  export type Outbound = PreprocessSecurityLake$Outbound;
}

export function preprocessSecurityLakeToJSON(
  preprocessSecurityLake: PreprocessSecurityLake,
): string {
  return JSON.stringify(
    PreprocessSecurityLake$outboundSchema.parse(preprocessSecurityLake),
  );
}

export function preprocessSecurityLakeFromJSON(
  jsonString: string,
): SafeParseResult<PreprocessSecurityLake, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreprocessSecurityLake$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreprocessSecurityLake' from JSON`,
  );
}

/** @internal */
export const MetadatumSecurityLake$inboundSchema: z.ZodType<
  MetadatumSecurityLake,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumSecurityLake$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumSecurityLake$outboundSchema: z.ZodType<
  MetadatumSecurityLake$Outbound,
  z.ZodTypeDef,
  MetadatumSecurityLake
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumSecurityLake$ {
  /** @deprecated use `MetadatumSecurityLake$inboundSchema` instead. */
  export const inboundSchema = MetadatumSecurityLake$inboundSchema;
  /** @deprecated use `MetadatumSecurityLake$outboundSchema` instead. */
  export const outboundSchema = MetadatumSecurityLake$outboundSchema;
  /** @deprecated use `MetadatumSecurityLake$Outbound` instead. */
  export type Outbound = MetadatumSecurityLake$Outbound;
}

export function metadatumSecurityLakeToJSON(
  metadatumSecurityLake: MetadatumSecurityLake,
): string {
  return JSON.stringify(
    MetadatumSecurityLake$outboundSchema.parse(metadatumSecurityLake),
  );
}

export function metadatumSecurityLakeFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumSecurityLake, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumSecurityLake$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumSecurityLake' from JSON`,
  );
}

/** @internal */
export const CheckpointingSecurityLake$inboundSchema: z.ZodType<
  CheckpointingSecurityLake,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().default(false),
  retries: z.number().default(5),
});

/** @internal */
export type CheckpointingSecurityLake$Outbound = {
  enabled: boolean;
  retries: number;
};

/** @internal */
export const CheckpointingSecurityLake$outboundSchema: z.ZodType<
  CheckpointingSecurityLake$Outbound,
  z.ZodTypeDef,
  CheckpointingSecurityLake
> = z.object({
  enabled: z.boolean().default(false),
  retries: z.number().default(5),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CheckpointingSecurityLake$ {
  /** @deprecated use `CheckpointingSecurityLake$inboundSchema` instead. */
  export const inboundSchema = CheckpointingSecurityLake$inboundSchema;
  /** @deprecated use `CheckpointingSecurityLake$outboundSchema` instead. */
  export const outboundSchema = CheckpointingSecurityLake$outboundSchema;
  /** @deprecated use `CheckpointingSecurityLake$Outbound` instead. */
  export type Outbound = CheckpointingSecurityLake$Outbound;
}

export function checkpointingSecurityLakeToJSON(
  checkpointingSecurityLake: CheckpointingSecurityLake,
): string {
  return JSON.stringify(
    CheckpointingSecurityLake$outboundSchema.parse(checkpointingSecurityLake),
  );
}

export function checkpointingSecurityLakeFromJSON(
  jsonString: string,
): SafeParseResult<CheckpointingSecurityLake, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckpointingSecurityLake$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckpointingSecurityLake' from JSON`,
  );
}

/** @internal */
export const TagAfterProcessingSecurityLake$inboundSchema: z.ZodNativeEnum<
  typeof TagAfterProcessingSecurityLake
> = z.nativeEnum(TagAfterProcessingSecurityLake);

/** @internal */
export const TagAfterProcessingSecurityLake$outboundSchema: z.ZodNativeEnum<
  typeof TagAfterProcessingSecurityLake
> = TagAfterProcessingSecurityLake$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TagAfterProcessingSecurityLake$ {
  /** @deprecated use `TagAfterProcessingSecurityLake$inboundSchema` instead. */
  export const inboundSchema = TagAfterProcessingSecurityLake$inboundSchema;
  /** @deprecated use `TagAfterProcessingSecurityLake$outboundSchema` instead. */
  export const outboundSchema = TagAfterProcessingSecurityLake$outboundSchema;
}

/** @internal */
export const InputSecurityLake$inboundSchema: z.ZodType<
  InputSecurityLake,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateInputTypeSecurityLake$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionSecurityLake$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqSecurityLake$inboundSchema).optional(),
  queueName: z.string(),
  fileFilter: z.string().default("/.*/"),
  awsAccountId: z.string().optional(),
  awsAuthenticationMethod:
    CreateInputAuthenticationMethodSecurityLake$inboundSchema.default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: CreateInputSignatureVersionSecurityLake$inboundSchema
    .default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  maxMessages: z.number().default(1),
  visibilityTimeout: z.number().default(600),
  numReceivers: z.number().default(1),
  socketTimeout: z.number().default(300),
  skipOnError: z.boolean().default(false),
  enableAssumeRole: z.boolean().default(true),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  enableSQSAssumeRole: z.boolean().default(false),
  preprocess: z.lazy(() => PreprocessSecurityLake$inboundSchema).optional(),
  metadata: z.array(z.lazy(() => MetadatumSecurityLake$inboundSchema))
    .optional(),
  parquetChunkSizeMB: z.number().default(5),
  parquetChunkDownloadTimeout: z.number().default(600),
  checkpointing: z.lazy(() => CheckpointingSecurityLake$inboundSchema)
    .optional(),
  pollTimeout: z.number().default(10),
  encoding: z.string().optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  tagAfterProcessing: TagAfterProcessingSecurityLake$inboundSchema.optional(),
  processedTagKey: z.string().optional(),
  processedTagValue: z.string().optional(),
});

/** @internal */
export type InputSecurityLake$Outbound = {
  id: string;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionSecurityLake$Outbound> | undefined;
  pq?: PqSecurityLake$Outbound | undefined;
  queueName: string;
  fileFilter: string;
  awsAccountId?: string | undefined;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  maxMessages: number;
  visibilityTimeout: number;
  numReceivers: number;
  socketTimeout: number;
  skipOnError: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  enableSQSAssumeRole: boolean;
  preprocess?: PreprocessSecurityLake$Outbound | undefined;
  metadata?: Array<MetadatumSecurityLake$Outbound> | undefined;
  parquetChunkSizeMB: number;
  parquetChunkDownloadTimeout: number;
  checkpointing?: CheckpointingSecurityLake$Outbound | undefined;
  pollTimeout: number;
  encoding?: string | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  tagAfterProcessing?: string | undefined;
  processedTagKey?: string | undefined;
  processedTagValue?: string | undefined;
};

/** @internal */
export const InputSecurityLake$outboundSchema: z.ZodType<
  InputSecurityLake$Outbound,
  z.ZodTypeDef,
  InputSecurityLake
> = z.object({
  id: z.string(),
  type: CreateInputTypeSecurityLake$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionSecurityLake$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqSecurityLake$outboundSchema).optional(),
  queueName: z.string(),
  fileFilter: z.string().default("/.*/"),
  awsAccountId: z.string().optional(),
  awsAuthenticationMethod:
    CreateInputAuthenticationMethodSecurityLake$outboundSchema.default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: CreateInputSignatureVersionSecurityLake$outboundSchema
    .default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  maxMessages: z.number().default(1),
  visibilityTimeout: z.number().default(600),
  numReceivers: z.number().default(1),
  socketTimeout: z.number().default(300),
  skipOnError: z.boolean().default(false),
  enableAssumeRole: z.boolean().default(true),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  enableSQSAssumeRole: z.boolean().default(false),
  preprocess: z.lazy(() => PreprocessSecurityLake$outboundSchema).optional(),
  metadata: z.array(z.lazy(() => MetadatumSecurityLake$outboundSchema))
    .optional(),
  parquetChunkSizeMB: z.number().default(5),
  parquetChunkDownloadTimeout: z.number().default(600),
  checkpointing: z.lazy(() => CheckpointingSecurityLake$outboundSchema)
    .optional(),
  pollTimeout: z.number().default(10),
  encoding: z.string().optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  tagAfterProcessing: TagAfterProcessingSecurityLake$outboundSchema.optional(),
  processedTagKey: z.string().optional(),
  processedTagValue: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSecurityLake$ {
  /** @deprecated use `InputSecurityLake$inboundSchema` instead. */
  export const inboundSchema = InputSecurityLake$inboundSchema;
  /** @deprecated use `InputSecurityLake$outboundSchema` instead. */
  export const outboundSchema = InputSecurityLake$outboundSchema;
  /** @deprecated use `InputSecurityLake$Outbound` instead. */
  export type Outbound = InputSecurityLake$Outbound;
}

export function inputSecurityLakeToJSON(
  inputSecurityLake: InputSecurityLake,
): string {
  return JSON.stringify(
    InputSecurityLake$outboundSchema.parse(inputSecurityLake),
  );
}

export function inputSecurityLakeFromJSON(
  jsonString: string,
): SafeParseResult<InputSecurityLake, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSecurityLake$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSecurityLake' from JSON`,
  );
}

/** @internal */
export const CreateInputTypeNetflow$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeNetflow
> = z.nativeEnum(CreateInputTypeNetflow);

/** @internal */
export const CreateInputTypeNetflow$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeNetflow
> = CreateInputTypeNetflow$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputTypeNetflow$ {
  /** @deprecated use `CreateInputTypeNetflow$inboundSchema` instead. */
  export const inboundSchema = CreateInputTypeNetflow$inboundSchema;
  /** @deprecated use `CreateInputTypeNetflow$outboundSchema` instead. */
  export const outboundSchema = CreateInputTypeNetflow$outboundSchema;
}

/** @internal */
export const ConnectionNetflow$inboundSchema: z.ZodType<
  ConnectionNetflow,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionNetflow$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionNetflow$outboundSchema: z.ZodType<
  ConnectionNetflow$Outbound,
  z.ZodTypeDef,
  ConnectionNetflow
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionNetflow$ {
  /** @deprecated use `ConnectionNetflow$inboundSchema` instead. */
  export const inboundSchema = ConnectionNetflow$inboundSchema;
  /** @deprecated use `ConnectionNetflow$outboundSchema` instead. */
  export const outboundSchema = ConnectionNetflow$outboundSchema;
  /** @deprecated use `ConnectionNetflow$Outbound` instead. */
  export type Outbound = ConnectionNetflow$Outbound;
}

export function connectionNetflowToJSON(
  connectionNetflow: ConnectionNetflow,
): string {
  return JSON.stringify(
    ConnectionNetflow$outboundSchema.parse(connectionNetflow),
  );
}

export function connectionNetflowFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionNetflow, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionNetflow$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionNetflow' from JSON`,
  );
}

/** @internal */
export const ModeNetflow$inboundSchema: z.ZodNativeEnum<typeof ModeNetflow> = z
  .nativeEnum(ModeNetflow);

/** @internal */
export const ModeNetflow$outboundSchema: z.ZodNativeEnum<typeof ModeNetflow> =
  ModeNetflow$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeNetflow$ {
  /** @deprecated use `ModeNetflow$inboundSchema` instead. */
  export const inboundSchema = ModeNetflow$inboundSchema;
  /** @deprecated use `ModeNetflow$outboundSchema` instead. */
  export const outboundSchema = ModeNetflow$outboundSchema;
}

/** @internal */
export const CompressionNetflow$inboundSchema: z.ZodNativeEnum<
  typeof CompressionNetflow
> = z.nativeEnum(CompressionNetflow);

/** @internal */
export const CompressionNetflow$outboundSchema: z.ZodNativeEnum<
  typeof CompressionNetflow
> = CompressionNetflow$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionNetflow$ {
  /** @deprecated use `CompressionNetflow$inboundSchema` instead. */
  export const inboundSchema = CompressionNetflow$inboundSchema;
  /** @deprecated use `CompressionNetflow$outboundSchema` instead. */
  export const outboundSchema = CompressionNetflow$outboundSchema;
}

/** @internal */
export const PqNetflow$inboundSchema: z.ZodType<
  PqNetflow,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeNetflow$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionNetflow$inboundSchema.default("none"),
});

/** @internal */
export type PqNetflow$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqNetflow$outboundSchema: z.ZodType<
  PqNetflow$Outbound,
  z.ZodTypeDef,
  PqNetflow
> = z.object({
  mode: ModeNetflow$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionNetflow$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqNetflow$ {
  /** @deprecated use `PqNetflow$inboundSchema` instead. */
  export const inboundSchema = PqNetflow$inboundSchema;
  /** @deprecated use `PqNetflow$outboundSchema` instead. */
  export const outboundSchema = PqNetflow$outboundSchema;
  /** @deprecated use `PqNetflow$Outbound` instead. */
  export type Outbound = PqNetflow$Outbound;
}

export function pqNetflowToJSON(pqNetflow: PqNetflow): string {
  return JSON.stringify(PqNetflow$outboundSchema.parse(pqNetflow));
}

export function pqNetflowFromJSON(
  jsonString: string,
): SafeParseResult<PqNetflow, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqNetflow$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqNetflow' from JSON`,
  );
}

/** @internal */
export const MetadatumNetflow$inboundSchema: z.ZodType<
  MetadatumNetflow,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumNetflow$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumNetflow$outboundSchema: z.ZodType<
  MetadatumNetflow$Outbound,
  z.ZodTypeDef,
  MetadatumNetflow
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumNetflow$ {
  /** @deprecated use `MetadatumNetflow$inboundSchema` instead. */
  export const inboundSchema = MetadatumNetflow$inboundSchema;
  /** @deprecated use `MetadatumNetflow$outboundSchema` instead. */
  export const outboundSchema = MetadatumNetflow$outboundSchema;
  /** @deprecated use `MetadatumNetflow$Outbound` instead. */
  export type Outbound = MetadatumNetflow$Outbound;
}

export function metadatumNetflowToJSON(
  metadatumNetflow: MetadatumNetflow,
): string {
  return JSON.stringify(
    MetadatumNetflow$outboundSchema.parse(metadatumNetflow),
  );
}

export function metadatumNetflowFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumNetflow, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumNetflow$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumNetflow' from JSON`,
  );
}

/** @internal */
export const InputNetflow$inboundSchema: z.ZodType<
  InputNetflow,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateInputTypeNetflow$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionNetflow$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqNetflow$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number().default(2055),
  enablePassThrough: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  udpSocketRxBufSize: z.number().optional(),
  templateCacheMinutes: z.number().default(30),
  v5Enabled: z.boolean().default(true),
  v9Enabled: z.boolean().default(true),
  ipfixEnabled: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumNetflow$inboundSchema)).optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputNetflow$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionNetflow$Outbound> | undefined;
  pq?: PqNetflow$Outbound | undefined;
  host: string;
  port: number;
  enablePassThrough: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  udpSocketRxBufSize?: number | undefined;
  templateCacheMinutes: number;
  v5Enabled: boolean;
  v9Enabled: boolean;
  ipfixEnabled: boolean;
  metadata?: Array<MetadatumNetflow$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputNetflow$outboundSchema: z.ZodType<
  InputNetflow$Outbound,
  z.ZodTypeDef,
  InputNetflow
> = z.object({
  id: z.string(),
  type: CreateInputTypeNetflow$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionNetflow$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqNetflow$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number().default(2055),
  enablePassThrough: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  udpSocketRxBufSize: z.number().optional(),
  templateCacheMinutes: z.number().default(30),
  v5Enabled: z.boolean().default(true),
  v9Enabled: z.boolean().default(true),
  ipfixEnabled: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumNetflow$outboundSchema)).optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputNetflow$ {
  /** @deprecated use `InputNetflow$inboundSchema` instead. */
  export const inboundSchema = InputNetflow$inboundSchema;
  /** @deprecated use `InputNetflow$outboundSchema` instead. */
  export const outboundSchema = InputNetflow$outboundSchema;
  /** @deprecated use `InputNetflow$Outbound` instead. */
  export type Outbound = InputNetflow$Outbound;
}

export function inputNetflowToJSON(inputNetflow: InputNetflow): string {
  return JSON.stringify(InputNetflow$outboundSchema.parse(inputNetflow));
}

export function inputNetflowFromJSON(
  jsonString: string,
): SafeParseResult<InputNetflow, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputNetflow$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputNetflow' from JSON`,
  );
}

/** @internal */
export const TypeWiz$inboundSchema: z.ZodNativeEnum<typeof TypeWiz> = z
  .nativeEnum(TypeWiz);

/** @internal */
export const TypeWiz$outboundSchema: z.ZodNativeEnum<typeof TypeWiz> =
  TypeWiz$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeWiz$ {
  /** @deprecated use `TypeWiz$inboundSchema` instead. */
  export const inboundSchema = TypeWiz$inboundSchema;
  /** @deprecated use `TypeWiz$outboundSchema` instead. */
  export const outboundSchema = TypeWiz$outboundSchema;
}

/** @internal */
export const ConnectionWiz$inboundSchema: z.ZodType<
  ConnectionWiz,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionWiz$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionWiz$outboundSchema: z.ZodType<
  ConnectionWiz$Outbound,
  z.ZodTypeDef,
  ConnectionWiz
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionWiz$ {
  /** @deprecated use `ConnectionWiz$inboundSchema` instead. */
  export const inboundSchema = ConnectionWiz$inboundSchema;
  /** @deprecated use `ConnectionWiz$outboundSchema` instead. */
  export const outboundSchema = ConnectionWiz$outboundSchema;
  /** @deprecated use `ConnectionWiz$Outbound` instead. */
  export type Outbound = ConnectionWiz$Outbound;
}

export function connectionWizToJSON(connectionWiz: ConnectionWiz): string {
  return JSON.stringify(ConnectionWiz$outboundSchema.parse(connectionWiz));
}

export function connectionWizFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionWiz, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionWiz$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionWiz' from JSON`,
  );
}

/** @internal */
export const ModeWiz$inboundSchema: z.ZodNativeEnum<typeof ModeWiz> = z
  .nativeEnum(ModeWiz);

/** @internal */
export const ModeWiz$outboundSchema: z.ZodNativeEnum<typeof ModeWiz> =
  ModeWiz$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeWiz$ {
  /** @deprecated use `ModeWiz$inboundSchema` instead. */
  export const inboundSchema = ModeWiz$inboundSchema;
  /** @deprecated use `ModeWiz$outboundSchema` instead. */
  export const outboundSchema = ModeWiz$outboundSchema;
}

/** @internal */
export const CompressionWiz$inboundSchema: z.ZodNativeEnum<
  typeof CompressionWiz
> = z.nativeEnum(CompressionWiz);

/** @internal */
export const CompressionWiz$outboundSchema: z.ZodNativeEnum<
  typeof CompressionWiz
> = CompressionWiz$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionWiz$ {
  /** @deprecated use `CompressionWiz$inboundSchema` instead. */
  export const inboundSchema = CompressionWiz$inboundSchema;
  /** @deprecated use `CompressionWiz$outboundSchema` instead. */
  export const outboundSchema = CompressionWiz$outboundSchema;
}

/** @internal */
export const PqWiz$inboundSchema: z.ZodType<PqWiz, z.ZodTypeDef, unknown> = z
  .object({
    mode: ModeWiz$inboundSchema.default("always"),
    maxBufferSize: z.number().default(1000),
    commitFrequency: z.number().default(42),
    maxFileSize: z.string().default("1 MB"),
    maxSize: z.string().default("5GB"),
    path: z.string().default("$CRIBL_HOME/state/queues"),
    compress: CompressionWiz$inboundSchema.default("none"),
  });

/** @internal */
export type PqWiz$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqWiz$outboundSchema: z.ZodType<
  PqWiz$Outbound,
  z.ZodTypeDef,
  PqWiz
> = z.object({
  mode: ModeWiz$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionWiz$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqWiz$ {
  /** @deprecated use `PqWiz$inboundSchema` instead. */
  export const inboundSchema = PqWiz$inboundSchema;
  /** @deprecated use `PqWiz$outboundSchema` instead. */
  export const outboundSchema = PqWiz$outboundSchema;
  /** @deprecated use `PqWiz$Outbound` instead. */
  export type Outbound = PqWiz$Outbound;
}

export function pqWizToJSON(pqWiz: PqWiz): string {
  return JSON.stringify(PqWiz$outboundSchema.parse(pqWiz));
}

export function pqWizFromJSON(
  jsonString: string,
): SafeParseResult<PqWiz, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqWiz$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqWiz' from JSON`,
  );
}

/** @internal */
export const ContentConfigWiz$inboundSchema: z.ZodType<
  ContentConfigWiz,
  z.ZodTypeDef,
  unknown
> = z.object({
  contentType: z.string(),
  contentDescription: z.string().optional(),
  enabled: z.boolean().default(false),
});

/** @internal */
export type ContentConfigWiz$Outbound = {
  contentType: string;
  contentDescription?: string | undefined;
  enabled: boolean;
};

/** @internal */
export const ContentConfigWiz$outboundSchema: z.ZodType<
  ContentConfigWiz$Outbound,
  z.ZodTypeDef,
  ContentConfigWiz
> = z.object({
  contentType: z.string(),
  contentDescription: z.string().optional(),
  enabled: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContentConfigWiz$ {
  /** @deprecated use `ContentConfigWiz$inboundSchema` instead. */
  export const inboundSchema = ContentConfigWiz$inboundSchema;
  /** @deprecated use `ContentConfigWiz$outboundSchema` instead. */
  export const outboundSchema = ContentConfigWiz$outboundSchema;
  /** @deprecated use `ContentConfigWiz$Outbound` instead. */
  export type Outbound = ContentConfigWiz$Outbound;
}

export function contentConfigWizToJSON(
  contentConfigWiz: ContentConfigWiz,
): string {
  return JSON.stringify(
    ContentConfigWiz$outboundSchema.parse(contentConfigWiz),
  );
}

export function contentConfigWizFromJSON(
  jsonString: string,
): SafeParseResult<ContentConfigWiz, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentConfigWiz$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentConfigWiz' from JSON`,
  );
}

/** @internal */
export const MetadatumWiz$inboundSchema: z.ZodType<
  MetadatumWiz,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumWiz$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumWiz$outboundSchema: z.ZodType<
  MetadatumWiz$Outbound,
  z.ZodTypeDef,
  MetadatumWiz
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumWiz$ {
  /** @deprecated use `MetadatumWiz$inboundSchema` instead. */
  export const inboundSchema = MetadatumWiz$inboundSchema;
  /** @deprecated use `MetadatumWiz$outboundSchema` instead. */
  export const outboundSchema = MetadatumWiz$outboundSchema;
  /** @deprecated use `MetadatumWiz$Outbound` instead. */
  export type Outbound = MetadatumWiz$Outbound;
}

export function metadatumWizToJSON(metadatumWiz: MetadatumWiz): string {
  return JSON.stringify(MetadatumWiz$outboundSchema.parse(metadatumWiz));
}

export function metadatumWizFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumWiz, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumWiz$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumWiz' from JSON`,
  );
}

/** @internal */
export const RetryTypeWiz$inboundSchema: z.ZodNativeEnum<typeof RetryTypeWiz> =
  z.nativeEnum(RetryTypeWiz);

/** @internal */
export const RetryTypeWiz$outboundSchema: z.ZodNativeEnum<typeof RetryTypeWiz> =
  RetryTypeWiz$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RetryTypeWiz$ {
  /** @deprecated use `RetryTypeWiz$inboundSchema` instead. */
  export const inboundSchema = RetryTypeWiz$inboundSchema;
  /** @deprecated use `RetryTypeWiz$outboundSchema` instead. */
  export const outboundSchema = RetryTypeWiz$outboundSchema;
}

/** @internal */
export const RetryRulesWiz$inboundSchema: z.ZodType<
  RetryRulesWiz,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeWiz$inboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/** @internal */
export type RetryRulesWiz$Outbound = {
  type: string;
  interval: number;
  limit: number;
  multiplier: number;
  codes?: Array<number> | undefined;
  enableHeader: boolean;
  retryConnectTimeout: boolean;
  retryConnectReset: boolean;
};

/** @internal */
export const RetryRulesWiz$outboundSchema: z.ZodType<
  RetryRulesWiz$Outbound,
  z.ZodTypeDef,
  RetryRulesWiz
> = z.object({
  type: RetryTypeWiz$outboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RetryRulesWiz$ {
  /** @deprecated use `RetryRulesWiz$inboundSchema` instead. */
  export const inboundSchema = RetryRulesWiz$inboundSchema;
  /** @deprecated use `RetryRulesWiz$outboundSchema` instead. */
  export const outboundSchema = RetryRulesWiz$outboundSchema;
  /** @deprecated use `RetryRulesWiz$Outbound` instead. */
  export type Outbound = RetryRulesWiz$Outbound;
}

export function retryRulesWizToJSON(retryRulesWiz: RetryRulesWiz): string {
  return JSON.stringify(RetryRulesWiz$outboundSchema.parse(retryRulesWiz));
}

export function retryRulesWizFromJSON(
  jsonString: string,
): SafeParseResult<RetryRulesWiz, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetryRulesWiz$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetryRulesWiz' from JSON`,
  );
}

/** @internal */
export const AuthenticationMethodWiz$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodWiz
> = z.nativeEnum(AuthenticationMethodWiz);

/** @internal */
export const AuthenticationMethodWiz$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodWiz
> = AuthenticationMethodWiz$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodWiz$ {
  /** @deprecated use `AuthenticationMethodWiz$inboundSchema` instead. */
  export const inboundSchema = AuthenticationMethodWiz$inboundSchema;
  /** @deprecated use `AuthenticationMethodWiz$outboundSchema` instead. */
  export const outboundSchema = AuthenticationMethodWiz$outboundSchema;
}

/** @internal */
export const InputWiz$inboundSchema: z.ZodType<
  InputWiz,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeWiz$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionWiz$inboundSchema)).optional(),
  pq: z.lazy(() => PqWiz$inboundSchema).optional(),
  endpoint: z.string().default("https://api.<region>.app.wiz.io/graphql"),
  authUrl: z.string(),
  authAudienceOverride: z.string().optional(),
  clientId: z.string(),
  contentConfig: z.array(z.lazy(() => ContentConfigWiz$inboundSchema)),
  requestTimeout: z.number().default(300),
  keepAliveTime: z.number().default(30),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumWiz$inboundSchema)).optional(),
  retryRules: z.lazy(() => RetryRulesWiz$inboundSchema).optional(),
  authType: AuthenticationMethodWiz$inboundSchema.default("manual"),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
});

/** @internal */
export type InputWiz$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionWiz$Outbound> | undefined;
  pq?: PqWiz$Outbound | undefined;
  endpoint: string;
  authUrl: string;
  authAudienceOverride?: string | undefined;
  clientId: string;
  contentConfig: Array<ContentConfigWiz$Outbound>;
  requestTimeout: number;
  keepAliveTime: number;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<MetadatumWiz$Outbound> | undefined;
  retryRules?: RetryRulesWiz$Outbound | undefined;
  authType: string;
  description?: string | undefined;
  clientSecret?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputWiz$outboundSchema: z.ZodType<
  InputWiz$Outbound,
  z.ZodTypeDef,
  InputWiz
> = z.object({
  id: z.string(),
  type: TypeWiz$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionWiz$outboundSchema)).optional(),
  pq: z.lazy(() => PqWiz$outboundSchema).optional(),
  endpoint: z.string().default("https://api.<region>.app.wiz.io/graphql"),
  authUrl: z.string(),
  authAudienceOverride: z.string().optional(),
  clientId: z.string(),
  contentConfig: z.array(z.lazy(() => ContentConfigWiz$outboundSchema)),
  requestTimeout: z.number().default(300),
  keepAliveTime: z.number().default(30),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumWiz$outboundSchema)).optional(),
  retryRules: z.lazy(() => RetryRulesWiz$outboundSchema).optional(),
  authType: AuthenticationMethodWiz$outboundSchema.default("manual"),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWiz$ {
  /** @deprecated use `InputWiz$inboundSchema` instead. */
  export const inboundSchema = InputWiz$inboundSchema;
  /** @deprecated use `InputWiz$outboundSchema` instead. */
  export const outboundSchema = InputWiz$outboundSchema;
  /** @deprecated use `InputWiz$Outbound` instead. */
  export type Outbound = InputWiz$Outbound;
}

export function inputWizToJSON(inputWiz: InputWiz): string {
  return JSON.stringify(InputWiz$outboundSchema.parse(inputWiz));
}

export function inputWizFromJSON(
  jsonString: string,
): SafeParseResult<InputWiz, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWiz$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWiz' from JSON`,
  );
}

/** @internal */
export const InputJournalFilesType$inboundSchema: z.ZodNativeEnum<
  typeof InputJournalFilesType
> = z.nativeEnum(InputJournalFilesType);

/** @internal */
export const InputJournalFilesType$outboundSchema: z.ZodNativeEnum<
  typeof InputJournalFilesType
> = InputJournalFilesType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputJournalFilesType$ {
  /** @deprecated use `InputJournalFilesType$inboundSchema` instead. */
  export const inboundSchema = InputJournalFilesType$inboundSchema;
  /** @deprecated use `InputJournalFilesType$outboundSchema` instead. */
  export const outboundSchema = InputJournalFilesType$outboundSchema;
}

/** @internal */
export const InputJournalFilesConnection$inboundSchema: z.ZodType<
  InputJournalFilesConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputJournalFilesConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputJournalFilesConnection$outboundSchema: z.ZodType<
  InputJournalFilesConnection$Outbound,
  z.ZodTypeDef,
  InputJournalFilesConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputJournalFilesConnection$ {
  /** @deprecated use `InputJournalFilesConnection$inboundSchema` instead. */
  export const inboundSchema = InputJournalFilesConnection$inboundSchema;
  /** @deprecated use `InputJournalFilesConnection$outboundSchema` instead. */
  export const outboundSchema = InputJournalFilesConnection$outboundSchema;
  /** @deprecated use `InputJournalFilesConnection$Outbound` instead. */
  export type Outbound = InputJournalFilesConnection$Outbound;
}

export function inputJournalFilesConnectionToJSON(
  inputJournalFilesConnection: InputJournalFilesConnection,
): string {
  return JSON.stringify(
    InputJournalFilesConnection$outboundSchema.parse(
      inputJournalFilesConnection,
    ),
  );
}

export function inputJournalFilesConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputJournalFilesConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputJournalFilesConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputJournalFilesConnection' from JSON`,
  );
}

/** @internal */
export const InputJournalFilesMode$inboundSchema: z.ZodNativeEnum<
  typeof InputJournalFilesMode
> = z.nativeEnum(InputJournalFilesMode);

/** @internal */
export const InputJournalFilesMode$outboundSchema: z.ZodNativeEnum<
  typeof InputJournalFilesMode
> = InputJournalFilesMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputJournalFilesMode$ {
  /** @deprecated use `InputJournalFilesMode$inboundSchema` instead. */
  export const inboundSchema = InputJournalFilesMode$inboundSchema;
  /** @deprecated use `InputJournalFilesMode$outboundSchema` instead. */
  export const outboundSchema = InputJournalFilesMode$outboundSchema;
}

/** @internal */
export const InputJournalFilesCompression$inboundSchema: z.ZodNativeEnum<
  typeof InputJournalFilesCompression
> = z.nativeEnum(InputJournalFilesCompression);

/** @internal */
export const InputJournalFilesCompression$outboundSchema: z.ZodNativeEnum<
  typeof InputJournalFilesCompression
> = InputJournalFilesCompression$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputJournalFilesCompression$ {
  /** @deprecated use `InputJournalFilesCompression$inboundSchema` instead. */
  export const inboundSchema = InputJournalFilesCompression$inboundSchema;
  /** @deprecated use `InputJournalFilesCompression$outboundSchema` instead. */
  export const outboundSchema = InputJournalFilesCompression$outboundSchema;
}

/** @internal */
export const InputJournalFilesPq$inboundSchema: z.ZodType<
  InputJournalFilesPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputJournalFilesMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputJournalFilesCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputJournalFilesPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputJournalFilesPq$outboundSchema: z.ZodType<
  InputJournalFilesPq$Outbound,
  z.ZodTypeDef,
  InputJournalFilesPq
> = z.object({
  mode: InputJournalFilesMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputJournalFilesCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputJournalFilesPq$ {
  /** @deprecated use `InputJournalFilesPq$inboundSchema` instead. */
  export const inboundSchema = InputJournalFilesPq$inboundSchema;
  /** @deprecated use `InputJournalFilesPq$outboundSchema` instead. */
  export const outboundSchema = InputJournalFilesPq$outboundSchema;
  /** @deprecated use `InputJournalFilesPq$Outbound` instead. */
  export type Outbound = InputJournalFilesPq$Outbound;
}

export function inputJournalFilesPqToJSON(
  inputJournalFilesPq: InputJournalFilesPq,
): string {
  return JSON.stringify(
    InputJournalFilesPq$outboundSchema.parse(inputJournalFilesPq),
  );
}

export function inputJournalFilesPqFromJSON(
  jsonString: string,
): SafeParseResult<InputJournalFilesPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputJournalFilesPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputJournalFilesPq' from JSON`,
  );
}

/** @internal */
export const CreateInputRule$inboundSchema: z.ZodType<
  CreateInputRule,
  z.ZodTypeDef,
  unknown
> = z.object({
  filter: z.string(),
  description: z.string().optional(),
});

/** @internal */
export type CreateInputRule$Outbound = {
  filter: string;
  description?: string | undefined;
};

/** @internal */
export const CreateInputRule$outboundSchema: z.ZodType<
  CreateInputRule$Outbound,
  z.ZodTypeDef,
  CreateInputRule
> = z.object({
  filter: z.string(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputRule$ {
  /** @deprecated use `CreateInputRule$inboundSchema` instead. */
  export const inboundSchema = CreateInputRule$inboundSchema;
  /** @deprecated use `CreateInputRule$outboundSchema` instead. */
  export const outboundSchema = CreateInputRule$outboundSchema;
  /** @deprecated use `CreateInputRule$Outbound` instead. */
  export type Outbound = CreateInputRule$Outbound;
}

export function createInputRuleToJSON(
  createInputRule: CreateInputRule,
): string {
  return JSON.stringify(CreateInputRule$outboundSchema.parse(createInputRule));
}

export function createInputRuleFromJSON(
  jsonString: string,
): SafeParseResult<CreateInputRule, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateInputRule$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateInputRule' from JSON`,
  );
}

/** @internal */
export const InputJournalFilesMetadatum$inboundSchema: z.ZodType<
  InputJournalFilesMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputJournalFilesMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputJournalFilesMetadatum$outboundSchema: z.ZodType<
  InputJournalFilesMetadatum$Outbound,
  z.ZodTypeDef,
  InputJournalFilesMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputJournalFilesMetadatum$ {
  /** @deprecated use `InputJournalFilesMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputJournalFilesMetadatum$inboundSchema;
  /** @deprecated use `InputJournalFilesMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputJournalFilesMetadatum$outboundSchema;
  /** @deprecated use `InputJournalFilesMetadatum$Outbound` instead. */
  export type Outbound = InputJournalFilesMetadatum$Outbound;
}

export function inputJournalFilesMetadatumToJSON(
  inputJournalFilesMetadatum: InputJournalFilesMetadatum,
): string {
  return JSON.stringify(
    InputJournalFilesMetadatum$outboundSchema.parse(inputJournalFilesMetadatum),
  );
}

export function inputJournalFilesMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputJournalFilesMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputJournalFilesMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputJournalFilesMetadatum' from JSON`,
  );
}

/** @internal */
export const InputJournalFiles$inboundSchema: z.ZodType<
  InputJournalFiles,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputJournalFilesType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputJournalFilesConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputJournalFilesPq$inboundSchema).optional(),
  path: z.string(),
  interval: z.number().default(10),
  journals: z.array(z.string()),
  rules: z.array(z.lazy(() => CreateInputRule$inboundSchema)).optional(),
  currentBoot: z.boolean().default(false),
  maxAgeDur: z.string().optional(),
  metadata: z.array(z.lazy(() => InputJournalFilesMetadatum$inboundSchema))
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputJournalFiles$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputJournalFilesConnection$Outbound> | undefined;
  pq?: InputJournalFilesPq$Outbound | undefined;
  path: string;
  interval: number;
  journals: Array<string>;
  rules?: Array<CreateInputRule$Outbound> | undefined;
  currentBoot: boolean;
  maxAgeDur?: string | undefined;
  metadata?: Array<InputJournalFilesMetadatum$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputJournalFiles$outboundSchema: z.ZodType<
  InputJournalFiles$Outbound,
  z.ZodTypeDef,
  InputJournalFiles
> = z.object({
  id: z.string(),
  type: InputJournalFilesType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputJournalFilesConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputJournalFilesPq$outboundSchema).optional(),
  path: z.string(),
  interval: z.number().default(10),
  journals: z.array(z.string()),
  rules: z.array(z.lazy(() => CreateInputRule$outboundSchema)).optional(),
  currentBoot: z.boolean().default(false),
  maxAgeDur: z.string().optional(),
  metadata: z.array(z.lazy(() => InputJournalFilesMetadatum$outboundSchema))
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputJournalFiles$ {
  /** @deprecated use `InputJournalFiles$inboundSchema` instead. */
  export const inboundSchema = InputJournalFiles$inboundSchema;
  /** @deprecated use `InputJournalFiles$outboundSchema` instead. */
  export const outboundSchema = InputJournalFiles$outboundSchema;
  /** @deprecated use `InputJournalFiles$Outbound` instead. */
  export type Outbound = InputJournalFiles$Outbound;
}

export function inputJournalFilesToJSON(
  inputJournalFiles: InputJournalFiles,
): string {
  return JSON.stringify(
    InputJournalFiles$outboundSchema.parse(inputJournalFiles),
  );
}

export function inputJournalFilesFromJSON(
  jsonString: string,
): SafeParseResult<InputJournalFiles, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputJournalFiles$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputJournalFiles' from JSON`,
  );
}

/** @internal */
export const TypeRawUDP$inboundSchema: z.ZodNativeEnum<typeof TypeRawUDP> = z
  .nativeEnum(TypeRawUDP);

/** @internal */
export const TypeRawUDP$outboundSchema: z.ZodNativeEnum<typeof TypeRawUDP> =
  TypeRawUDP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeRawUDP$ {
  /** @deprecated use `TypeRawUDP$inboundSchema` instead. */
  export const inboundSchema = TypeRawUDP$inboundSchema;
  /** @deprecated use `TypeRawUDP$outboundSchema` instead. */
  export const outboundSchema = TypeRawUDP$outboundSchema;
}

/** @internal */
export const ConnectionRawUDP$inboundSchema: z.ZodType<
  ConnectionRawUDP,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionRawUDP$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionRawUDP$outboundSchema: z.ZodType<
  ConnectionRawUDP$Outbound,
  z.ZodTypeDef,
  ConnectionRawUDP
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionRawUDP$ {
  /** @deprecated use `ConnectionRawUDP$inboundSchema` instead. */
  export const inboundSchema = ConnectionRawUDP$inboundSchema;
  /** @deprecated use `ConnectionRawUDP$outboundSchema` instead. */
  export const outboundSchema = ConnectionRawUDP$outboundSchema;
  /** @deprecated use `ConnectionRawUDP$Outbound` instead. */
  export type Outbound = ConnectionRawUDP$Outbound;
}

export function connectionRawUDPToJSON(
  connectionRawUDP: ConnectionRawUDP,
): string {
  return JSON.stringify(
    ConnectionRawUDP$outboundSchema.parse(connectionRawUDP),
  );
}

export function connectionRawUDPFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionRawUDP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionRawUDP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionRawUDP' from JSON`,
  );
}

/** @internal */
export const ModeRawUDP$inboundSchema: z.ZodNativeEnum<typeof ModeRawUDP> = z
  .nativeEnum(ModeRawUDP);

/** @internal */
export const ModeRawUDP$outboundSchema: z.ZodNativeEnum<typeof ModeRawUDP> =
  ModeRawUDP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeRawUDP$ {
  /** @deprecated use `ModeRawUDP$inboundSchema` instead. */
  export const inboundSchema = ModeRawUDP$inboundSchema;
  /** @deprecated use `ModeRawUDP$outboundSchema` instead. */
  export const outboundSchema = ModeRawUDP$outboundSchema;
}

/** @internal */
export const CompressionRawUDP$inboundSchema: z.ZodNativeEnum<
  typeof CompressionRawUDP
> = z.nativeEnum(CompressionRawUDP);

/** @internal */
export const CompressionRawUDP$outboundSchema: z.ZodNativeEnum<
  typeof CompressionRawUDP
> = CompressionRawUDP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionRawUDP$ {
  /** @deprecated use `CompressionRawUDP$inboundSchema` instead. */
  export const inboundSchema = CompressionRawUDP$inboundSchema;
  /** @deprecated use `CompressionRawUDP$outboundSchema` instead. */
  export const outboundSchema = CompressionRawUDP$outboundSchema;
}

/** @internal */
export const PqRawUDP$inboundSchema: z.ZodType<
  PqRawUDP,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeRawUDP$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionRawUDP$inboundSchema.default("none"),
});

/** @internal */
export type PqRawUDP$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqRawUDP$outboundSchema: z.ZodType<
  PqRawUDP$Outbound,
  z.ZodTypeDef,
  PqRawUDP
> = z.object({
  mode: ModeRawUDP$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionRawUDP$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqRawUDP$ {
  /** @deprecated use `PqRawUDP$inboundSchema` instead. */
  export const inboundSchema = PqRawUDP$inboundSchema;
  /** @deprecated use `PqRawUDP$outboundSchema` instead. */
  export const outboundSchema = PqRawUDP$outboundSchema;
  /** @deprecated use `PqRawUDP$Outbound` instead. */
  export type Outbound = PqRawUDP$Outbound;
}

export function pqRawUDPToJSON(pqRawUDP: PqRawUDP): string {
  return JSON.stringify(PqRawUDP$outboundSchema.parse(pqRawUDP));
}

export function pqRawUDPFromJSON(
  jsonString: string,
): SafeParseResult<PqRawUDP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqRawUDP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqRawUDP' from JSON`,
  );
}

/** @internal */
export const MetadatumRawUDP$inboundSchema: z.ZodType<
  MetadatumRawUDP,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumRawUDP$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumRawUDP$outboundSchema: z.ZodType<
  MetadatumRawUDP$Outbound,
  z.ZodTypeDef,
  MetadatumRawUDP
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumRawUDP$ {
  /** @deprecated use `MetadatumRawUDP$inboundSchema` instead. */
  export const inboundSchema = MetadatumRawUDP$inboundSchema;
  /** @deprecated use `MetadatumRawUDP$outboundSchema` instead. */
  export const outboundSchema = MetadatumRawUDP$outboundSchema;
  /** @deprecated use `MetadatumRawUDP$Outbound` instead. */
  export type Outbound = MetadatumRawUDP$Outbound;
}

export function metadatumRawUDPToJSON(
  metadatumRawUDP: MetadatumRawUDP,
): string {
  return JSON.stringify(MetadatumRawUDP$outboundSchema.parse(metadatumRawUDP));
}

export function metadatumRawUDPFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumRawUDP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumRawUDP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumRawUDP' from JSON`,
  );
}

/** @internal */
export const InputRawUdp$inboundSchema: z.ZodType<
  InputRawUdp,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeRawUDP$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionRawUDP$inboundSchema)).optional(),
  pq: z.lazy(() => PqRawUDP$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  singleMsgUdpPackets: z.boolean().default(false),
  ingestRawBytes: z.boolean().default(false),
  udpSocketRxBufSize: z.number().optional(),
  metadata: z.array(z.lazy(() => MetadatumRawUDP$inboundSchema)).optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputRawUdp$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionRawUDP$Outbound> | undefined;
  pq?: PqRawUDP$Outbound | undefined;
  host: string;
  port: number;
  maxBufferSize: number;
  ipWhitelistRegex: string;
  singleMsgUdpPackets: boolean;
  ingestRawBytes: boolean;
  udpSocketRxBufSize?: number | undefined;
  metadata?: Array<MetadatumRawUDP$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputRawUdp$outboundSchema: z.ZodType<
  InputRawUdp$Outbound,
  z.ZodTypeDef,
  InputRawUdp
> = z.object({
  id: z.string(),
  type: TypeRawUDP$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionRawUDP$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqRawUDP$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  singleMsgUdpPackets: z.boolean().default(false),
  ingestRawBytes: z.boolean().default(false),
  udpSocketRxBufSize: z.number().optional(),
  metadata: z.array(z.lazy(() => MetadatumRawUDP$outboundSchema)).optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputRawUdp$ {
  /** @deprecated use `InputRawUdp$inboundSchema` instead. */
  export const inboundSchema = InputRawUdp$inboundSchema;
  /** @deprecated use `InputRawUdp$outboundSchema` instead. */
  export const outboundSchema = InputRawUdp$outboundSchema;
  /** @deprecated use `InputRawUdp$Outbound` instead. */
  export type Outbound = InputRawUdp$Outbound;
}

export function inputRawUdpToJSON(inputRawUdp: InputRawUdp): string {
  return JSON.stringify(InputRawUdp$outboundSchema.parse(inputRawUdp));
}

export function inputRawUdpFromJSON(
  jsonString: string,
): SafeParseResult<InputRawUdp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputRawUdp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputRawUdp' from JSON`,
  );
}

/** @internal */
export const TypeWinEventLogs$inboundSchema: z.ZodNativeEnum<
  typeof TypeWinEventLogs
> = z.nativeEnum(TypeWinEventLogs);

/** @internal */
export const TypeWinEventLogs$outboundSchema: z.ZodNativeEnum<
  typeof TypeWinEventLogs
> = TypeWinEventLogs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeWinEventLogs$ {
  /** @deprecated use `TypeWinEventLogs$inboundSchema` instead. */
  export const inboundSchema = TypeWinEventLogs$inboundSchema;
  /** @deprecated use `TypeWinEventLogs$outboundSchema` instead. */
  export const outboundSchema = TypeWinEventLogs$outboundSchema;
}

/** @internal */
export const ConnectionWinEventLogs$inboundSchema: z.ZodType<
  ConnectionWinEventLogs,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionWinEventLogs$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionWinEventLogs$outboundSchema: z.ZodType<
  ConnectionWinEventLogs$Outbound,
  z.ZodTypeDef,
  ConnectionWinEventLogs
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionWinEventLogs$ {
  /** @deprecated use `ConnectionWinEventLogs$inboundSchema` instead. */
  export const inboundSchema = ConnectionWinEventLogs$inboundSchema;
  /** @deprecated use `ConnectionWinEventLogs$outboundSchema` instead. */
  export const outboundSchema = ConnectionWinEventLogs$outboundSchema;
  /** @deprecated use `ConnectionWinEventLogs$Outbound` instead. */
  export type Outbound = ConnectionWinEventLogs$Outbound;
}

export function connectionWinEventLogsToJSON(
  connectionWinEventLogs: ConnectionWinEventLogs,
): string {
  return JSON.stringify(
    ConnectionWinEventLogs$outboundSchema.parse(connectionWinEventLogs),
  );
}

export function connectionWinEventLogsFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionWinEventLogs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionWinEventLogs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionWinEventLogs' from JSON`,
  );
}

/** @internal */
export const ModeWinEventLogs$inboundSchema: z.ZodNativeEnum<
  typeof ModeWinEventLogs
> = z.nativeEnum(ModeWinEventLogs);

/** @internal */
export const ModeWinEventLogs$outboundSchema: z.ZodNativeEnum<
  typeof ModeWinEventLogs
> = ModeWinEventLogs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeWinEventLogs$ {
  /** @deprecated use `ModeWinEventLogs$inboundSchema` instead. */
  export const inboundSchema = ModeWinEventLogs$inboundSchema;
  /** @deprecated use `ModeWinEventLogs$outboundSchema` instead. */
  export const outboundSchema = ModeWinEventLogs$outboundSchema;
}

/** @internal */
export const CompressionWinEventLogs$inboundSchema: z.ZodNativeEnum<
  typeof CompressionWinEventLogs
> = z.nativeEnum(CompressionWinEventLogs);

/** @internal */
export const CompressionWinEventLogs$outboundSchema: z.ZodNativeEnum<
  typeof CompressionWinEventLogs
> = CompressionWinEventLogs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionWinEventLogs$ {
  /** @deprecated use `CompressionWinEventLogs$inboundSchema` instead. */
  export const inboundSchema = CompressionWinEventLogs$inboundSchema;
  /** @deprecated use `CompressionWinEventLogs$outboundSchema` instead. */
  export const outboundSchema = CompressionWinEventLogs$outboundSchema;
}

/** @internal */
export const PqWinEventLogs$inboundSchema: z.ZodType<
  PqWinEventLogs,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeWinEventLogs$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionWinEventLogs$inboundSchema.default("none"),
});

/** @internal */
export type PqWinEventLogs$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqWinEventLogs$outboundSchema: z.ZodType<
  PqWinEventLogs$Outbound,
  z.ZodTypeDef,
  PqWinEventLogs
> = z.object({
  mode: ModeWinEventLogs$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionWinEventLogs$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqWinEventLogs$ {
  /** @deprecated use `PqWinEventLogs$inboundSchema` instead. */
  export const inboundSchema = PqWinEventLogs$inboundSchema;
  /** @deprecated use `PqWinEventLogs$outboundSchema` instead. */
  export const outboundSchema = PqWinEventLogs$outboundSchema;
  /** @deprecated use `PqWinEventLogs$Outbound` instead. */
  export type Outbound = PqWinEventLogs$Outbound;
}

export function pqWinEventLogsToJSON(pqWinEventLogs: PqWinEventLogs): string {
  return JSON.stringify(PqWinEventLogs$outboundSchema.parse(pqWinEventLogs));
}

export function pqWinEventLogsFromJSON(
  jsonString: string,
): SafeParseResult<PqWinEventLogs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqWinEventLogs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqWinEventLogs' from JSON`,
  );
}

/** @internal */
export const ReadMode$inboundSchema: z.ZodNativeEnum<typeof ReadMode> = z
  .nativeEnum(ReadMode);

/** @internal */
export const ReadMode$outboundSchema: z.ZodNativeEnum<typeof ReadMode> =
  ReadMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ReadMode$ {
  /** @deprecated use `ReadMode$inboundSchema` instead. */
  export const inboundSchema = ReadMode$inboundSchema;
  /** @deprecated use `ReadMode$outboundSchema` instead. */
  export const outboundSchema = ReadMode$outboundSchema;
}

/** @internal */
export const EventFormat$inboundSchema: z.ZodNativeEnum<typeof EventFormat> = z
  .nativeEnum(EventFormat);

/** @internal */
export const EventFormat$outboundSchema: z.ZodNativeEnum<typeof EventFormat> =
  EventFormat$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventFormat$ {
  /** @deprecated use `EventFormat$inboundSchema` instead. */
  export const inboundSchema = EventFormat$inboundSchema;
  /** @deprecated use `EventFormat$outboundSchema` instead. */
  export const outboundSchema = EventFormat$outboundSchema;
}

/** @internal */
export const MetadatumWinEventLogs$inboundSchema: z.ZodType<
  MetadatumWinEventLogs,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumWinEventLogs$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumWinEventLogs$outboundSchema: z.ZodType<
  MetadatumWinEventLogs$Outbound,
  z.ZodTypeDef,
  MetadatumWinEventLogs
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumWinEventLogs$ {
  /** @deprecated use `MetadatumWinEventLogs$inboundSchema` instead. */
  export const inboundSchema = MetadatumWinEventLogs$inboundSchema;
  /** @deprecated use `MetadatumWinEventLogs$outboundSchema` instead. */
  export const outboundSchema = MetadatumWinEventLogs$outboundSchema;
  /** @deprecated use `MetadatumWinEventLogs$Outbound` instead. */
  export type Outbound = MetadatumWinEventLogs$Outbound;
}

export function metadatumWinEventLogsToJSON(
  metadatumWinEventLogs: MetadatumWinEventLogs,
): string {
  return JSON.stringify(
    MetadatumWinEventLogs$outboundSchema.parse(metadatumWinEventLogs),
  );
}

export function metadatumWinEventLogsFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumWinEventLogs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumWinEventLogs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumWinEventLogs' from JSON`,
  );
}

/** @internal */
export const InputWinEventLogs$inboundSchema: z.ZodType<
  InputWinEventLogs,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeWinEventLogs$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionWinEventLogs$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqWinEventLogs$inboundSchema).optional(),
  logNames: z.array(z.string()),
  readMode: ReadMode$inboundSchema.default("oldest"),
  eventFormat: EventFormat$inboundSchema.default("json"),
  disableNativeModule: z.boolean().default(false),
  interval: z.number().default(10),
  batchSize: z.number().default(500),
  metadata: z.array(z.lazy(() => MetadatumWinEventLogs$inboundSchema))
    .optional(),
  maxEventBytes: z.number().default(51200),
  description: z.string().optional(),
});

/** @internal */
export type InputWinEventLogs$Outbound = {
  id: string;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionWinEventLogs$Outbound> | undefined;
  pq?: PqWinEventLogs$Outbound | undefined;
  logNames: Array<string>;
  readMode: string;
  eventFormat: string;
  disableNativeModule: boolean;
  interval: number;
  batchSize: number;
  metadata?: Array<MetadatumWinEventLogs$Outbound> | undefined;
  maxEventBytes: number;
  description?: string | undefined;
};

/** @internal */
export const InputWinEventLogs$outboundSchema: z.ZodType<
  InputWinEventLogs$Outbound,
  z.ZodTypeDef,
  InputWinEventLogs
> = z.object({
  id: z.string(),
  type: TypeWinEventLogs$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionWinEventLogs$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqWinEventLogs$outboundSchema).optional(),
  logNames: z.array(z.string()),
  readMode: ReadMode$outboundSchema.default("oldest"),
  eventFormat: EventFormat$outboundSchema.default("json"),
  disableNativeModule: z.boolean().default(false),
  interval: z.number().default(10),
  batchSize: z.number().default(500),
  metadata: z.array(z.lazy(() => MetadatumWinEventLogs$outboundSchema))
    .optional(),
  maxEventBytes: z.number().default(51200),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWinEventLogs$ {
  /** @deprecated use `InputWinEventLogs$inboundSchema` instead. */
  export const inboundSchema = InputWinEventLogs$inboundSchema;
  /** @deprecated use `InputWinEventLogs$outboundSchema` instead. */
  export const outboundSchema = InputWinEventLogs$outboundSchema;
  /** @deprecated use `InputWinEventLogs$Outbound` instead. */
  export type Outbound = InputWinEventLogs$Outbound;
}

export function inputWinEventLogsToJSON(
  inputWinEventLogs: InputWinEventLogs,
): string {
  return JSON.stringify(
    InputWinEventLogs$outboundSchema.parse(inputWinEventLogs),
  );
}

export function inputWinEventLogsFromJSON(
  jsonString: string,
): SafeParseResult<InputWinEventLogs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWinEventLogs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWinEventLogs' from JSON`,
  );
}

/** @internal */
export const TypeWef$inboundSchema: z.ZodNativeEnum<typeof TypeWef> = z
  .nativeEnum(TypeWef);

/** @internal */
export const TypeWef$outboundSchema: z.ZodNativeEnum<typeof TypeWef> =
  TypeWef$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeWef$ {
  /** @deprecated use `TypeWef$inboundSchema` instead. */
  export const inboundSchema = TypeWef$inboundSchema;
  /** @deprecated use `TypeWef$outboundSchema` instead. */
  export const outboundSchema = TypeWef$outboundSchema;
}

/** @internal */
export const ConnectionWef$inboundSchema: z.ZodType<
  ConnectionWef,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionWef$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionWef$outboundSchema: z.ZodType<
  ConnectionWef$Outbound,
  z.ZodTypeDef,
  ConnectionWef
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionWef$ {
  /** @deprecated use `ConnectionWef$inboundSchema` instead. */
  export const inboundSchema = ConnectionWef$inboundSchema;
  /** @deprecated use `ConnectionWef$outboundSchema` instead. */
  export const outboundSchema = ConnectionWef$outboundSchema;
  /** @deprecated use `ConnectionWef$Outbound` instead. */
  export type Outbound = ConnectionWef$Outbound;
}

export function connectionWefToJSON(connectionWef: ConnectionWef): string {
  return JSON.stringify(ConnectionWef$outboundSchema.parse(connectionWef));
}

export function connectionWefFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionWef, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionWef$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionWef' from JSON`,
  );
}

/** @internal */
export const ModeWef$inboundSchema: z.ZodNativeEnum<typeof ModeWef> = z
  .nativeEnum(ModeWef);

/** @internal */
export const ModeWef$outboundSchema: z.ZodNativeEnum<typeof ModeWef> =
  ModeWef$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeWef$ {
  /** @deprecated use `ModeWef$inboundSchema` instead. */
  export const inboundSchema = ModeWef$inboundSchema;
  /** @deprecated use `ModeWef$outboundSchema` instead. */
  export const outboundSchema = ModeWef$outboundSchema;
}

/** @internal */
export const CompressionWef$inboundSchema: z.ZodNativeEnum<
  typeof CompressionWef
> = z.nativeEnum(CompressionWef);

/** @internal */
export const CompressionWef$outboundSchema: z.ZodNativeEnum<
  typeof CompressionWef
> = CompressionWef$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionWef$ {
  /** @deprecated use `CompressionWef$inboundSchema` instead. */
  export const inboundSchema = CompressionWef$inboundSchema;
  /** @deprecated use `CompressionWef$outboundSchema` instead. */
  export const outboundSchema = CompressionWef$outboundSchema;
}

/** @internal */
export const PqWef$inboundSchema: z.ZodType<PqWef, z.ZodTypeDef, unknown> = z
  .object({
    mode: ModeWef$inboundSchema.default("always"),
    maxBufferSize: z.number().default(1000),
    commitFrequency: z.number().default(42),
    maxFileSize: z.string().default("1 MB"),
    maxSize: z.string().default("5GB"),
    path: z.string().default("$CRIBL_HOME/state/queues"),
    compress: CompressionWef$inboundSchema.default("none"),
  });

/** @internal */
export type PqWef$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqWef$outboundSchema: z.ZodType<
  PqWef$Outbound,
  z.ZodTypeDef,
  PqWef
> = z.object({
  mode: ModeWef$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionWef$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqWef$ {
  /** @deprecated use `PqWef$inboundSchema` instead. */
  export const inboundSchema = PqWef$inboundSchema;
  /** @deprecated use `PqWef$outboundSchema` instead. */
  export const outboundSchema = PqWef$outboundSchema;
  /** @deprecated use `PqWef$Outbound` instead. */
  export type Outbound = PqWef$Outbound;
}

export function pqWefToJSON(pqWef: PqWef): string {
  return JSON.stringify(PqWef$outboundSchema.parse(pqWef));
}

export function pqWefFromJSON(
  jsonString: string,
): SafeParseResult<PqWef, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqWef$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqWef' from JSON`,
  );
}

/** @internal */
export const AuthMethodAuthenticationMethod$inboundSchema: z.ZodNativeEnum<
  typeof AuthMethodAuthenticationMethod
> = z.nativeEnum(AuthMethodAuthenticationMethod);

/** @internal */
export const AuthMethodAuthenticationMethod$outboundSchema: z.ZodNativeEnum<
  typeof AuthMethodAuthenticationMethod
> = AuthMethodAuthenticationMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthMethodAuthenticationMethod$ {
  /** @deprecated use `AuthMethodAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = AuthMethodAuthenticationMethod$inboundSchema;
  /** @deprecated use `AuthMethodAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema = AuthMethodAuthenticationMethod$outboundSchema;
}

/** @internal */
export const MinimumTLSVersionWef$inboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionWef
> = z.nativeEnum(MinimumTLSVersionWef);

/** @internal */
export const MinimumTLSVersionWef$outboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionWef
> = MinimumTLSVersionWef$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MinimumTLSVersionWef$ {
  /** @deprecated use `MinimumTLSVersionWef$inboundSchema` instead. */
  export const inboundSchema = MinimumTLSVersionWef$inboundSchema;
  /** @deprecated use `MinimumTLSVersionWef$outboundSchema` instead. */
  export const outboundSchema = MinimumTLSVersionWef$outboundSchema;
}

/** @internal */
export const MaximumTLSVersionWef$inboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionWef
> = z.nativeEnum(MaximumTLSVersionWef);

/** @internal */
export const MaximumTLSVersionWef$outboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionWef
> = MaximumTLSVersionWef$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaximumTLSVersionWef$ {
  /** @deprecated use `MaximumTLSVersionWef$inboundSchema` instead. */
  export const inboundSchema = MaximumTLSVersionWef$inboundSchema;
  /** @deprecated use `MaximumTLSVersionWef$outboundSchema` instead. */
  export const outboundSchema = MaximumTLSVersionWef$outboundSchema;
}

/** @internal */
export const MTLSSettings$inboundSchema: z.ZodType<
  MTLSSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
  requestCert: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string(),
  passphrase: z.string().optional(),
  certPath: z.string(),
  caPath: z.string(),
  commonNameRegex: z.string().default("/.*/"),
  minVersion: MinimumTLSVersionWef$inboundSchema.optional(),
  maxVersion: MaximumTLSVersionWef$inboundSchema.optional(),
  ocspCheck: z.boolean().default(false),
  keytab: z.any().optional(),
  principal: z.any().optional(),
  ocspCheckFailClose: z.boolean().default(false),
});

/** @internal */
export type MTLSSettings$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  requestCert: boolean;
  certificateName?: string | undefined;
  privKeyPath: string;
  passphrase?: string | undefined;
  certPath: string;
  caPath: string;
  commonNameRegex: string;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
  ocspCheck: boolean;
  keytab?: any | undefined;
  principal?: any | undefined;
  ocspCheckFailClose: boolean;
};

/** @internal */
export const MTLSSettings$outboundSchema: z.ZodType<
  MTLSSettings$Outbound,
  z.ZodTypeDef,
  MTLSSettings
> = z.object({
  disabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
  requestCert: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string(),
  passphrase: z.string().optional(),
  certPath: z.string(),
  caPath: z.string(),
  commonNameRegex: z.string().default("/.*/"),
  minVersion: MinimumTLSVersionWef$outboundSchema.optional(),
  maxVersion: MaximumTLSVersionWef$outboundSchema.optional(),
  ocspCheck: z.boolean().default(false),
  keytab: z.any().optional(),
  principal: z.any().optional(),
  ocspCheckFailClose: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MTLSSettings$ {
  /** @deprecated use `MTLSSettings$inboundSchema` instead. */
  export const inboundSchema = MTLSSettings$inboundSchema;
  /** @deprecated use `MTLSSettings$outboundSchema` instead. */
  export const outboundSchema = MTLSSettings$outboundSchema;
  /** @deprecated use `MTLSSettings$Outbound` instead. */
  export type Outbound = MTLSSettings$Outbound;
}

export function mTLSSettingsToJSON(mtlsSettings: MTLSSettings): string {
  return JSON.stringify(MTLSSettings$outboundSchema.parse(mtlsSettings));
}

export function mTLSSettingsFromJSON(
  jsonString: string,
): SafeParseResult<MTLSSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MTLSSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MTLSSettings' from JSON`,
  );
}

/** @internal */
export const CreateInputFormat$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputFormat
> = z.nativeEnum(CreateInputFormat);

/** @internal */
export const CreateInputFormat$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputFormat
> = CreateInputFormat$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputFormat$ {
  /** @deprecated use `CreateInputFormat$inboundSchema` instead. */
  export const inboundSchema = CreateInputFormat$inboundSchema;
  /** @deprecated use `CreateInputFormat$outboundSchema` instead. */
  export const outboundSchema = CreateInputFormat$outboundSchema;
}

/** @internal */
export const QueryBuilderMode$inboundSchema: z.ZodNativeEnum<
  typeof QueryBuilderMode
> = z.nativeEnum(QueryBuilderMode);

/** @internal */
export const QueryBuilderMode$outboundSchema: z.ZodNativeEnum<
  typeof QueryBuilderMode
> = QueryBuilderMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueryBuilderMode$ {
  /** @deprecated use `QueryBuilderMode$inboundSchema` instead. */
  export const inboundSchema = QueryBuilderMode$inboundSchema;
  /** @deprecated use `QueryBuilderMode$outboundSchema` instead. */
  export const outboundSchema = QueryBuilderMode$outboundSchema;
}

/** @internal */
export const SubscriptionMetadatum$inboundSchema: z.ZodType<
  SubscriptionMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type SubscriptionMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const SubscriptionMetadatum$outboundSchema: z.ZodType<
  SubscriptionMetadatum$Outbound,
  z.ZodTypeDef,
  SubscriptionMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriptionMetadatum$ {
  /** @deprecated use `SubscriptionMetadatum$inboundSchema` instead. */
  export const inboundSchema = SubscriptionMetadatum$inboundSchema;
  /** @deprecated use `SubscriptionMetadatum$outboundSchema` instead. */
  export const outboundSchema = SubscriptionMetadatum$outboundSchema;
  /** @deprecated use `SubscriptionMetadatum$Outbound` instead. */
  export type Outbound = SubscriptionMetadatum$Outbound;
}

export function subscriptionMetadatumToJSON(
  subscriptionMetadatum: SubscriptionMetadatum,
): string {
  return JSON.stringify(
    SubscriptionMetadatum$outboundSchema.parse(subscriptionMetadatum),
  );
}

export function subscriptionMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<SubscriptionMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriptionMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriptionMetadatum' from JSON`,
  );
}

/** @internal */
export const Subscription$inboundSchema: z.ZodType<
  Subscription,
  z.ZodTypeDef,
  unknown
> = z.object({
  subscriptionName: z.string(),
  version: z.string().optional(),
  contentFormat: CreateInputFormat$inboundSchema.default("Raw"),
  heartbeatInterval: z.number().default(60),
  batchTimeout: z.number().default(60),
  readExistingEvents: z.boolean().default(false),
  sendBookmarks: z.boolean().default(true),
  compress: z.boolean().default(true),
  targets: z.array(z.string()),
  locale: z.string().default("en-US"),
  querySelector: QueryBuilderMode$inboundSchema.default("simple"),
  metadata: z.array(z.lazy(() => SubscriptionMetadatum$inboundSchema))
    .optional(),
});

/** @internal */
export type Subscription$Outbound = {
  subscriptionName: string;
  version?: string | undefined;
  contentFormat: string;
  heartbeatInterval: number;
  batchTimeout: number;
  readExistingEvents: boolean;
  sendBookmarks: boolean;
  compress: boolean;
  targets: Array<string>;
  locale: string;
  querySelector: string;
  metadata?: Array<SubscriptionMetadatum$Outbound> | undefined;
};

/** @internal */
export const Subscription$outboundSchema: z.ZodType<
  Subscription$Outbound,
  z.ZodTypeDef,
  Subscription
> = z.object({
  subscriptionName: z.string(),
  version: z.string().optional(),
  contentFormat: CreateInputFormat$outboundSchema.default("Raw"),
  heartbeatInterval: z.number().default(60),
  batchTimeout: z.number().default(60),
  readExistingEvents: z.boolean().default(false),
  sendBookmarks: z.boolean().default(true),
  compress: z.boolean().default(true),
  targets: z.array(z.string()),
  locale: z.string().default("en-US"),
  querySelector: QueryBuilderMode$outboundSchema.default("simple"),
  metadata: z.array(z.lazy(() => SubscriptionMetadatum$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Subscription$ {
  /** @deprecated use `Subscription$inboundSchema` instead. */
  export const inboundSchema = Subscription$inboundSchema;
  /** @deprecated use `Subscription$outboundSchema` instead. */
  export const outboundSchema = Subscription$outboundSchema;
  /** @deprecated use `Subscription$Outbound` instead. */
  export type Outbound = Subscription$Outbound;
}

export function subscriptionToJSON(subscription: Subscription): string {
  return JSON.stringify(Subscription$outboundSchema.parse(subscription));
}

export function subscriptionFromJSON(
  jsonString: string,
): SafeParseResult<Subscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Subscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Subscription' from JSON`,
  );
}

/** @internal */
export const MetadatumWef$inboundSchema: z.ZodType<
  MetadatumWef,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumWef$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumWef$outboundSchema: z.ZodType<
  MetadatumWef$Outbound,
  z.ZodTypeDef,
  MetadatumWef
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumWef$ {
  /** @deprecated use `MetadatumWef$inboundSchema` instead. */
  export const inboundSchema = MetadatumWef$inboundSchema;
  /** @deprecated use `MetadatumWef$outboundSchema` instead. */
  export const outboundSchema = MetadatumWef$outboundSchema;
  /** @deprecated use `MetadatumWef$Outbound` instead. */
  export type Outbound = MetadatumWef$Outbound;
}

export function metadatumWefToJSON(metadatumWef: MetadatumWef): string {
  return JSON.stringify(MetadatumWef$outboundSchema.parse(metadatumWef));
}

export function metadatumWefFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumWef, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumWef$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumWef' from JSON`,
  );
}

/** @internal */
export const InputWef$inboundSchema: z.ZodType<
  InputWef,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeWef$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionWef$inboundSchema)).optional(),
  pq: z.lazy(() => PqWef$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number().default(5986),
  authMethod: AuthMethodAuthenticationMethod$inboundSchema.default(
    "clientCert",
  ),
  tls: z.lazy(() => MTLSSettings$inboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  keepAliveTimeout: z.number().default(90),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  socketTimeout: z.number().default(0),
  caFingerprint: z.string().optional(),
  keytab: z.string().optional(),
  principal: z.string().optional(),
  allowMachineIdMismatch: z.boolean().default(false),
  subscriptions: z.array(z.lazy(() => Subscription$inboundSchema)),
  metadata: z.array(z.lazy(() => MetadatumWef$inboundSchema)).optional(),
  description: z.string().optional(),
  logFingerprintMismatch: z.boolean().default(false),
});

/** @internal */
export type InputWef$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionWef$Outbound> | undefined;
  pq?: PqWef$Outbound | undefined;
  host: string;
  port: number;
  authMethod: string;
  tls?: MTLSSettings$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  socketTimeout: number;
  caFingerprint?: string | undefined;
  keytab?: string | undefined;
  principal?: string | undefined;
  allowMachineIdMismatch: boolean;
  subscriptions: Array<Subscription$Outbound>;
  metadata?: Array<MetadatumWef$Outbound> | undefined;
  description?: string | undefined;
  logFingerprintMismatch: boolean;
};

/** @internal */
export const InputWef$outboundSchema: z.ZodType<
  InputWef$Outbound,
  z.ZodTypeDef,
  InputWef
> = z.object({
  id: z.string(),
  type: TypeWef$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionWef$outboundSchema)).optional(),
  pq: z.lazy(() => PqWef$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number().default(5986),
  authMethod: AuthMethodAuthenticationMethod$outboundSchema.default(
    "clientCert",
  ),
  tls: z.lazy(() => MTLSSettings$outboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  keepAliveTimeout: z.number().default(90),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  socketTimeout: z.number().default(0),
  caFingerprint: z.string().optional(),
  keytab: z.string().optional(),
  principal: z.string().optional(),
  allowMachineIdMismatch: z.boolean().default(false),
  subscriptions: z.array(z.lazy(() => Subscription$outboundSchema)),
  metadata: z.array(z.lazy(() => MetadatumWef$outboundSchema)).optional(),
  description: z.string().optional(),
  logFingerprintMismatch: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWef$ {
  /** @deprecated use `InputWef$inboundSchema` instead. */
  export const inboundSchema = InputWef$inboundSchema;
  /** @deprecated use `InputWef$outboundSchema` instead. */
  export const outboundSchema = InputWef$outboundSchema;
  /** @deprecated use `InputWef$Outbound` instead. */
  export type Outbound = InputWef$Outbound;
}

export function inputWefToJSON(inputWef: InputWef): string {
  return JSON.stringify(InputWef$outboundSchema.parse(inputWef));
}

export function inputWefFromJSON(
  jsonString: string,
): SafeParseResult<InputWef, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWef$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWef' from JSON`,
  );
}

/** @internal */
export const TypeTCP$inboundSchema: z.ZodNativeEnum<typeof TypeTCP> = z
  .nativeEnum(TypeTCP);

/** @internal */
export const TypeTCP$outboundSchema: z.ZodNativeEnum<typeof TypeTCP> =
  TypeTCP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeTCP$ {
  /** @deprecated use `TypeTCP$inboundSchema` instead. */
  export const inboundSchema = TypeTCP$inboundSchema;
  /** @deprecated use `TypeTCP$outboundSchema` instead. */
  export const outboundSchema = TypeTCP$outboundSchema;
}

/** @internal */
export const ConnectionTCP$inboundSchema: z.ZodType<
  ConnectionTCP,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionTCP$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionTCP$outboundSchema: z.ZodType<
  ConnectionTCP$Outbound,
  z.ZodTypeDef,
  ConnectionTCP
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionTCP$ {
  /** @deprecated use `ConnectionTCP$inboundSchema` instead. */
  export const inboundSchema = ConnectionTCP$inboundSchema;
  /** @deprecated use `ConnectionTCP$outboundSchema` instead. */
  export const outboundSchema = ConnectionTCP$outboundSchema;
  /** @deprecated use `ConnectionTCP$Outbound` instead. */
  export type Outbound = ConnectionTCP$Outbound;
}

export function connectionTCPToJSON(connectionTCP: ConnectionTCP): string {
  return JSON.stringify(ConnectionTCP$outboundSchema.parse(connectionTCP));
}

export function connectionTCPFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionTCP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionTCP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionTCP' from JSON`,
  );
}

/** @internal */
export const ModeTCP$inboundSchema: z.ZodNativeEnum<typeof ModeTCP> = z
  .nativeEnum(ModeTCP);

/** @internal */
export const ModeTCP$outboundSchema: z.ZodNativeEnum<typeof ModeTCP> =
  ModeTCP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeTCP$ {
  /** @deprecated use `ModeTCP$inboundSchema` instead. */
  export const inboundSchema = ModeTCP$inboundSchema;
  /** @deprecated use `ModeTCP$outboundSchema` instead. */
  export const outboundSchema = ModeTCP$outboundSchema;
}

/** @internal */
export const CompressionTCP$inboundSchema: z.ZodNativeEnum<
  typeof CompressionTCP
> = z.nativeEnum(CompressionTCP);

/** @internal */
export const CompressionTCP$outboundSchema: z.ZodNativeEnum<
  typeof CompressionTCP
> = CompressionTCP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionTCP$ {
  /** @deprecated use `CompressionTCP$inboundSchema` instead. */
  export const inboundSchema = CompressionTCP$inboundSchema;
  /** @deprecated use `CompressionTCP$outboundSchema` instead. */
  export const outboundSchema = CompressionTCP$outboundSchema;
}

/** @internal */
export const PqTCP$inboundSchema: z.ZodType<PqTCP, z.ZodTypeDef, unknown> = z
  .object({
    mode: ModeTCP$inboundSchema.default("always"),
    maxBufferSize: z.number().default(1000),
    commitFrequency: z.number().default(42),
    maxFileSize: z.string().default("1 MB"),
    maxSize: z.string().default("5GB"),
    path: z.string().default("$CRIBL_HOME/state/queues"),
    compress: CompressionTCP$inboundSchema.default("none"),
  });

/** @internal */
export type PqTCP$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqTCP$outboundSchema: z.ZodType<
  PqTCP$Outbound,
  z.ZodTypeDef,
  PqTCP
> = z.object({
  mode: ModeTCP$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionTCP$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqTCP$ {
  /** @deprecated use `PqTCP$inboundSchema` instead. */
  export const inboundSchema = PqTCP$inboundSchema;
  /** @deprecated use `PqTCP$outboundSchema` instead. */
  export const outboundSchema = PqTCP$outboundSchema;
  /** @deprecated use `PqTCP$Outbound` instead. */
  export type Outbound = PqTCP$Outbound;
}

export function pqTCPToJSON(pqTCP: PqTCP): string {
  return JSON.stringify(PqTCP$outboundSchema.parse(pqTCP));
}

export function pqTCPFromJSON(
  jsonString: string,
): SafeParseResult<PqTCP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqTCP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqTCP' from JSON`,
  );
}

/** @internal */
export const MinimumTLSVersionTCP$inboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionTCP
> = z.nativeEnum(MinimumTLSVersionTCP);

/** @internal */
export const MinimumTLSVersionTCP$outboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionTCP
> = MinimumTLSVersionTCP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MinimumTLSVersionTCP$ {
  /** @deprecated use `MinimumTLSVersionTCP$inboundSchema` instead. */
  export const inboundSchema = MinimumTLSVersionTCP$inboundSchema;
  /** @deprecated use `MinimumTLSVersionTCP$outboundSchema` instead. */
  export const outboundSchema = MinimumTLSVersionTCP$outboundSchema;
}

/** @internal */
export const MaximumTLSVersionTCP$inboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionTCP
> = z.nativeEnum(MaximumTLSVersionTCP);

/** @internal */
export const MaximumTLSVersionTCP$outboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionTCP
> = MaximumTLSVersionTCP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaximumTLSVersionTCP$ {
  /** @deprecated use `MaximumTLSVersionTCP$inboundSchema` instead. */
  export const inboundSchema = MaximumTLSVersionTCP$inboundSchema;
  /** @deprecated use `MaximumTLSVersionTCP$outboundSchema` instead. */
  export const outboundSchema = MaximumTLSVersionTCP$outboundSchema;
}

/** @internal */
export const TLSSettingsServerSideTCP$inboundSchema: z.ZodType<
  TLSSettingsServerSideTCP,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionTCP$inboundSchema.optional(),
  maxVersion: MaximumTLSVersionTCP$inboundSchema.optional(),
});

/** @internal */
export type TLSSettingsServerSideTCP$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TLSSettingsServerSideTCP$outboundSchema: z.ZodType<
  TLSSettingsServerSideTCP$Outbound,
  z.ZodTypeDef,
  TLSSettingsServerSideTCP
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionTCP$outboundSchema.optional(),
  maxVersion: MaximumTLSVersionTCP$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsServerSideTCP$ {
  /** @deprecated use `TLSSettingsServerSideTCP$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsServerSideTCP$inboundSchema;
  /** @deprecated use `TLSSettingsServerSideTCP$outboundSchema` instead. */
  export const outboundSchema = TLSSettingsServerSideTCP$outboundSchema;
  /** @deprecated use `TLSSettingsServerSideTCP$Outbound` instead. */
  export type Outbound = TLSSettingsServerSideTCP$Outbound;
}

export function tlsSettingsServerSideTCPToJSON(
  tlsSettingsServerSideTCP: TLSSettingsServerSideTCP,
): string {
  return JSON.stringify(
    TLSSettingsServerSideTCP$outboundSchema.parse(tlsSettingsServerSideTCP),
  );
}

export function tlsSettingsServerSideTCPFromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsServerSideTCP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TLSSettingsServerSideTCP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsServerSideTCP' from JSON`,
  );
}

/** @internal */
export const MetadatumTCP$inboundSchema: z.ZodType<
  MetadatumTCP,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumTCP$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumTCP$outboundSchema: z.ZodType<
  MetadatumTCP$Outbound,
  z.ZodTypeDef,
  MetadatumTCP
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumTCP$ {
  /** @deprecated use `MetadatumTCP$inboundSchema` instead. */
  export const inboundSchema = MetadatumTCP$inboundSchema;
  /** @deprecated use `MetadatumTCP$outboundSchema` instead. */
  export const outboundSchema = MetadatumTCP$outboundSchema;
  /** @deprecated use `MetadatumTCP$Outbound` instead. */
  export type Outbound = MetadatumTCP$Outbound;
}

export function metadatumTCPToJSON(metadatumTCP: MetadatumTCP): string {
  return JSON.stringify(MetadatumTCP$outboundSchema.parse(metadatumTCP));
}

export function metadatumTCPFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumTCP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumTCP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumTCP' from JSON`,
  );
}

/** @internal */
export const PreprocessTCP$inboundSchema: z.ZodType<
  PreprocessTCP,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  command: z.string().optional(),
  args: z.array(z.string()).optional(),
});

/** @internal */
export type PreprocessTCP$Outbound = {
  disabled: boolean;
  command?: string | undefined;
  args?: Array<string> | undefined;
};

/** @internal */
export const PreprocessTCP$outboundSchema: z.ZodType<
  PreprocessTCP$Outbound,
  z.ZodTypeDef,
  PreprocessTCP
> = z.object({
  disabled: z.boolean().default(true),
  command: z.string().optional(),
  args: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PreprocessTCP$ {
  /** @deprecated use `PreprocessTCP$inboundSchema` instead. */
  export const inboundSchema = PreprocessTCP$inboundSchema;
  /** @deprecated use `PreprocessTCP$outboundSchema` instead. */
  export const outboundSchema = PreprocessTCP$outboundSchema;
  /** @deprecated use `PreprocessTCP$Outbound` instead. */
  export type Outbound = PreprocessTCP$Outbound;
}

export function preprocessTCPToJSON(preprocessTCP: PreprocessTCP): string {
  return JSON.stringify(PreprocessTCP$outboundSchema.parse(preprocessTCP));
}

export function preprocessTCPFromJSON(
  jsonString: string,
): SafeParseResult<PreprocessTCP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreprocessTCP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreprocessTCP' from JSON`,
  );
}

/** @internal */
export const AuthenticationMethodTCP$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodTCP
> = z.nativeEnum(AuthenticationMethodTCP);

/** @internal */
export const AuthenticationMethodTCP$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodTCP
> = AuthenticationMethodTCP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodTCP$ {
  /** @deprecated use `AuthenticationMethodTCP$inboundSchema` instead. */
  export const inboundSchema = AuthenticationMethodTCP$inboundSchema;
  /** @deprecated use `AuthenticationMethodTCP$outboundSchema` instead. */
  export const outboundSchema = AuthenticationMethodTCP$outboundSchema;
}

/** @internal */
export const InputTcp$inboundSchema: z.ZodType<
  InputTcp,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeTCP$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionTCP$inboundSchema)).optional(),
  pq: z.lazy(() => PqTCP$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => TLSSettingsServerSideTCP$inboundSchema).optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumTCP$inboundSchema)).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableHeader: z.boolean().default(false),
  preprocess: z.lazy(() => PreprocessTCP$inboundSchema).optional(),
  description: z.string().optional(),
  authType: AuthenticationMethodTCP$inboundSchema.default("manual"),
});

/** @internal */
export type InputTcp$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionTCP$Outbound> | undefined;
  pq?: PqTCP$Outbound | undefined;
  host: string;
  port: number;
  tls?: TLSSettingsServerSideTCP$Outbound | undefined;
  ipWhitelistRegex: string;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  enableProxyHeader: boolean;
  metadata?: Array<MetadatumTCP$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  enableHeader: boolean;
  preprocess?: PreprocessTCP$Outbound | undefined;
  description?: string | undefined;
  authType: string;
};

/** @internal */
export const InputTcp$outboundSchema: z.ZodType<
  InputTcp$Outbound,
  z.ZodTypeDef,
  InputTcp
> = z.object({
  id: z.string(),
  type: TypeTCP$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionTCP$outboundSchema)).optional(),
  pq: z.lazy(() => PqTCP$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => TLSSettingsServerSideTCP$outboundSchema).optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumTCP$outboundSchema)).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableHeader: z.boolean().default(false),
  preprocess: z.lazy(() => PreprocessTCP$outboundSchema).optional(),
  description: z.string().optional(),
  authType: AuthenticationMethodTCP$outboundSchema.default("manual"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcp$ {
  /** @deprecated use `InputTcp$inboundSchema` instead. */
  export const inboundSchema = InputTcp$inboundSchema;
  /** @deprecated use `InputTcp$outboundSchema` instead. */
  export const outboundSchema = InputTcp$outboundSchema;
  /** @deprecated use `InputTcp$Outbound` instead. */
  export type Outbound = InputTcp$Outbound;
}

export function inputTcpToJSON(inputTcp: InputTcp): string {
  return JSON.stringify(InputTcp$outboundSchema.parse(inputTcp));
}

export function inputTcpFromJSON(
  jsonString: string,
): SafeParseResult<InputTcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputTcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputTcp' from JSON`,
  );
}

/** @internal */
export const InputSyslogType2$inboundSchema: z.ZodNativeEnum<
  typeof InputSyslogType2
> = z.nativeEnum(InputSyslogType2);

/** @internal */
export const InputSyslogType2$outboundSchema: z.ZodNativeEnum<
  typeof InputSyslogType2
> = InputSyslogType2$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogType2$ {
  /** @deprecated use `InputSyslogType2$inboundSchema` instead. */
  export const inboundSchema = InputSyslogType2$inboundSchema;
  /** @deprecated use `InputSyslogType2$outboundSchema` instead. */
  export const outboundSchema = InputSyslogType2$outboundSchema;
}

/** @internal */
export const InputSyslogConnection2$inboundSchema: z.ZodType<
  InputSyslogConnection2,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputSyslogConnection2$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputSyslogConnection2$outboundSchema: z.ZodType<
  InputSyslogConnection2$Outbound,
  z.ZodTypeDef,
  InputSyslogConnection2
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogConnection2$ {
  /** @deprecated use `InputSyslogConnection2$inboundSchema` instead. */
  export const inboundSchema = InputSyslogConnection2$inboundSchema;
  /** @deprecated use `InputSyslogConnection2$outboundSchema` instead. */
  export const outboundSchema = InputSyslogConnection2$outboundSchema;
  /** @deprecated use `InputSyslogConnection2$Outbound` instead. */
  export type Outbound = InputSyslogConnection2$Outbound;
}

export function inputSyslogConnection2ToJSON(
  inputSyslogConnection2: InputSyslogConnection2,
): string {
  return JSON.stringify(
    InputSyslogConnection2$outboundSchema.parse(inputSyslogConnection2),
  );
}

export function inputSyslogConnection2FromJSON(
  jsonString: string,
): SafeParseResult<InputSyslogConnection2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSyslogConnection2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSyslogConnection2' from JSON`,
  );
}

/** @internal */
export const InputSyslogMode2$inboundSchema: z.ZodNativeEnum<
  typeof InputSyslogMode2
> = z.nativeEnum(InputSyslogMode2);

/** @internal */
export const InputSyslogMode2$outboundSchema: z.ZodNativeEnum<
  typeof InputSyslogMode2
> = InputSyslogMode2$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogMode2$ {
  /** @deprecated use `InputSyslogMode2$inboundSchema` instead. */
  export const inboundSchema = InputSyslogMode2$inboundSchema;
  /** @deprecated use `InputSyslogMode2$outboundSchema` instead. */
  export const outboundSchema = InputSyslogMode2$outboundSchema;
}

/** @internal */
export const InputSyslogCompression2$inboundSchema: z.ZodNativeEnum<
  typeof InputSyslogCompression2
> = z.nativeEnum(InputSyslogCompression2);

/** @internal */
export const InputSyslogCompression2$outboundSchema: z.ZodNativeEnum<
  typeof InputSyslogCompression2
> = InputSyslogCompression2$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogCompression2$ {
  /** @deprecated use `InputSyslogCompression2$inboundSchema` instead. */
  export const inboundSchema = InputSyslogCompression2$inboundSchema;
  /** @deprecated use `InputSyslogCompression2$outboundSchema` instead. */
  export const outboundSchema = InputSyslogCompression2$outboundSchema;
}

/** @internal */
export const InputSyslogPq2$inboundSchema: z.ZodType<
  InputSyslogPq2,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputSyslogMode2$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSyslogCompression2$inboundSchema.default("none"),
});

/** @internal */
export type InputSyslogPq2$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputSyslogPq2$outboundSchema: z.ZodType<
  InputSyslogPq2$Outbound,
  z.ZodTypeDef,
  InputSyslogPq2
> = z.object({
  mode: InputSyslogMode2$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSyslogCompression2$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogPq2$ {
  /** @deprecated use `InputSyslogPq2$inboundSchema` instead. */
  export const inboundSchema = InputSyslogPq2$inboundSchema;
  /** @deprecated use `InputSyslogPq2$outboundSchema` instead. */
  export const outboundSchema = InputSyslogPq2$outboundSchema;
  /** @deprecated use `InputSyslogPq2$Outbound` instead. */
  export type Outbound = InputSyslogPq2$Outbound;
}

export function inputSyslogPq2ToJSON(inputSyslogPq2: InputSyslogPq2): string {
  return JSON.stringify(InputSyslogPq2$outboundSchema.parse(inputSyslogPq2));
}

export function inputSyslogPq2FromJSON(
  jsonString: string,
): SafeParseResult<InputSyslogPq2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSyslogPq2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSyslogPq2' from JSON`,
  );
}

/** @internal */
export const InputSyslogMinimumTLSVersion2$inboundSchema: z.ZodNativeEnum<
  typeof InputSyslogMinimumTLSVersion2
> = z.nativeEnum(InputSyslogMinimumTLSVersion2);

/** @internal */
export const InputSyslogMinimumTLSVersion2$outboundSchema: z.ZodNativeEnum<
  typeof InputSyslogMinimumTLSVersion2
> = InputSyslogMinimumTLSVersion2$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogMinimumTLSVersion2$ {
  /** @deprecated use `InputSyslogMinimumTLSVersion2$inboundSchema` instead. */
  export const inboundSchema = InputSyslogMinimumTLSVersion2$inboundSchema;
  /** @deprecated use `InputSyslogMinimumTLSVersion2$outboundSchema` instead. */
  export const outboundSchema = InputSyslogMinimumTLSVersion2$outboundSchema;
}

/** @internal */
export const InputSyslogMaximumTLSVersion2$inboundSchema: z.ZodNativeEnum<
  typeof InputSyslogMaximumTLSVersion2
> = z.nativeEnum(InputSyslogMaximumTLSVersion2);

/** @internal */
export const InputSyslogMaximumTLSVersion2$outboundSchema: z.ZodNativeEnum<
  typeof InputSyslogMaximumTLSVersion2
> = InputSyslogMaximumTLSVersion2$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogMaximumTLSVersion2$ {
  /** @deprecated use `InputSyslogMaximumTLSVersion2$inboundSchema` instead. */
  export const inboundSchema = InputSyslogMaximumTLSVersion2$inboundSchema;
  /** @deprecated use `InputSyslogMaximumTLSVersion2$outboundSchema` instead. */
  export const outboundSchema = InputSyslogMaximumTLSVersion2$outboundSchema;
}

/** @internal */
export const InputSyslogTLSSettingsServerSide2$inboundSchema: z.ZodType<
  InputSyslogTLSSettingsServerSide2,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputSyslogMinimumTLSVersion2$inboundSchema.optional(),
  maxVersion: InputSyslogMaximumTLSVersion2$inboundSchema.optional(),
});

/** @internal */
export type InputSyslogTLSSettingsServerSide2$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputSyslogTLSSettingsServerSide2$outboundSchema: z.ZodType<
  InputSyslogTLSSettingsServerSide2$Outbound,
  z.ZodTypeDef,
  InputSyslogTLSSettingsServerSide2
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputSyslogMinimumTLSVersion2$outboundSchema.optional(),
  maxVersion: InputSyslogMaximumTLSVersion2$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogTLSSettingsServerSide2$ {
  /** @deprecated use `InputSyslogTLSSettingsServerSide2$inboundSchema` instead. */
  export const inboundSchema = InputSyslogTLSSettingsServerSide2$inboundSchema;
  /** @deprecated use `InputSyslogTLSSettingsServerSide2$outboundSchema` instead. */
  export const outboundSchema =
    InputSyslogTLSSettingsServerSide2$outboundSchema;
  /** @deprecated use `InputSyslogTLSSettingsServerSide2$Outbound` instead. */
  export type Outbound = InputSyslogTLSSettingsServerSide2$Outbound;
}

export function inputSyslogTLSSettingsServerSide2ToJSON(
  inputSyslogTLSSettingsServerSide2: InputSyslogTLSSettingsServerSide2,
): string {
  return JSON.stringify(
    InputSyslogTLSSettingsServerSide2$outboundSchema.parse(
      inputSyslogTLSSettingsServerSide2,
    ),
  );
}

export function inputSyslogTLSSettingsServerSide2FromJSON(
  jsonString: string,
): SafeParseResult<InputSyslogTLSSettingsServerSide2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSyslogTLSSettingsServerSide2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSyslogTLSSettingsServerSide2' from JSON`,
  );
}

/** @internal */
export const InputSyslogMetadatum2$inboundSchema: z.ZodType<
  InputSyslogMetadatum2,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputSyslogMetadatum2$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputSyslogMetadatum2$outboundSchema: z.ZodType<
  InputSyslogMetadatum2$Outbound,
  z.ZodTypeDef,
  InputSyslogMetadatum2
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogMetadatum2$ {
  /** @deprecated use `InputSyslogMetadatum2$inboundSchema` instead. */
  export const inboundSchema = InputSyslogMetadatum2$inboundSchema;
  /** @deprecated use `InputSyslogMetadatum2$outboundSchema` instead. */
  export const outboundSchema = InputSyslogMetadatum2$outboundSchema;
  /** @deprecated use `InputSyslogMetadatum2$Outbound` instead. */
  export type Outbound = InputSyslogMetadatum2$Outbound;
}

export function inputSyslogMetadatum2ToJSON(
  inputSyslogMetadatum2: InputSyslogMetadatum2,
): string {
  return JSON.stringify(
    InputSyslogMetadatum2$outboundSchema.parse(inputSyslogMetadatum2),
  );
}

export function inputSyslogMetadatum2FromJSON(
  jsonString: string,
): SafeParseResult<InputSyslogMetadatum2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSyslogMetadatum2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSyslogMetadatum2' from JSON`,
  );
}

/** @internal */
export const InputSyslogSyslog2$inboundSchema: z.ZodType<
  InputSyslogSyslog2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputSyslogType2$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSyslogConnection2$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputSyslogPq2$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  udpPort: z.number().optional(),
  tcpPort: z.number(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  timestampTimezone: z.string().default("local"),
  singleMsgUdpPackets: z.boolean().default(false),
  enableProxyHeader: z.boolean().default(false),
  keepFieldsList: z.array(z.string()).optional(),
  octetCounting: z.boolean().default(false),
  inferFraming: z.boolean().default(true),
  strictlyInferOctetCounting: z.boolean().default(true),
  allowNonStandardAppName: z.boolean().default(false),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  tls: z.lazy(() => InputSyslogTLSSettingsServerSide2$inboundSchema).optional(),
  metadata: z.array(z.lazy(() => InputSyslogMetadatum2$inboundSchema))
    .optional(),
  udpSocketRxBufSize: z.number().optional(),
  enableLoadBalancing: z.boolean().default(false),
  description: z.string().optional(),
  enableEnhancedProxyHeaderParsing: z.boolean().optional(),
});

/** @internal */
export type InputSyslogSyslog2$Outbound = {
  id: string;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputSyslogConnection2$Outbound> | undefined;
  pq?: InputSyslogPq2$Outbound | undefined;
  host: string;
  udpPort?: number | undefined;
  tcpPort: number;
  maxBufferSize: number;
  ipWhitelistRegex: string;
  timestampTimezone: string;
  singleMsgUdpPackets: boolean;
  enableProxyHeader: boolean;
  keepFieldsList?: Array<string> | undefined;
  octetCounting: boolean;
  inferFraming: boolean;
  strictlyInferOctetCounting: boolean;
  allowNonStandardAppName: boolean;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  tls?: InputSyslogTLSSettingsServerSide2$Outbound | undefined;
  metadata?: Array<InputSyslogMetadatum2$Outbound> | undefined;
  udpSocketRxBufSize?: number | undefined;
  enableLoadBalancing: boolean;
  description?: string | undefined;
  enableEnhancedProxyHeaderParsing?: boolean | undefined;
};

/** @internal */
export const InputSyslogSyslog2$outboundSchema: z.ZodType<
  InputSyslogSyslog2$Outbound,
  z.ZodTypeDef,
  InputSyslogSyslog2
> = z.object({
  id: z.string(),
  type: InputSyslogType2$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSyslogConnection2$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputSyslogPq2$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  udpPort: z.number().optional(),
  tcpPort: z.number(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  timestampTimezone: z.string().default("local"),
  singleMsgUdpPackets: z.boolean().default(false),
  enableProxyHeader: z.boolean().default(false),
  keepFieldsList: z.array(z.string()).optional(),
  octetCounting: z.boolean().default(false),
  inferFraming: z.boolean().default(true),
  strictlyInferOctetCounting: z.boolean().default(true),
  allowNonStandardAppName: z.boolean().default(false),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  tls: z.lazy(() => InputSyslogTLSSettingsServerSide2$outboundSchema)
    .optional(),
  metadata: z.array(z.lazy(() => InputSyslogMetadatum2$outboundSchema))
    .optional(),
  udpSocketRxBufSize: z.number().optional(),
  enableLoadBalancing: z.boolean().default(false),
  description: z.string().optional(),
  enableEnhancedProxyHeaderParsing: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogSyslog2$ {
  /** @deprecated use `InputSyslogSyslog2$inboundSchema` instead. */
  export const inboundSchema = InputSyslogSyslog2$inboundSchema;
  /** @deprecated use `InputSyslogSyslog2$outboundSchema` instead. */
  export const outboundSchema = InputSyslogSyslog2$outboundSchema;
  /** @deprecated use `InputSyslogSyslog2$Outbound` instead. */
  export type Outbound = InputSyslogSyslog2$Outbound;
}

export function inputSyslogSyslog2ToJSON(
  inputSyslogSyslog2: InputSyslogSyslog2,
): string {
  return JSON.stringify(
    InputSyslogSyslog2$outboundSchema.parse(inputSyslogSyslog2),
  );
}

export function inputSyslogSyslog2FromJSON(
  jsonString: string,
): SafeParseResult<InputSyslogSyslog2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSyslogSyslog2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSyslogSyslog2' from JSON`,
  );
}

/** @internal */
export const InputSyslogType1$inboundSchema: z.ZodNativeEnum<
  typeof InputSyslogType1
> = z.nativeEnum(InputSyslogType1);

/** @internal */
export const InputSyslogType1$outboundSchema: z.ZodNativeEnum<
  typeof InputSyslogType1
> = InputSyslogType1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogType1$ {
  /** @deprecated use `InputSyslogType1$inboundSchema` instead. */
  export const inboundSchema = InputSyslogType1$inboundSchema;
  /** @deprecated use `InputSyslogType1$outboundSchema` instead. */
  export const outboundSchema = InputSyslogType1$outboundSchema;
}

/** @internal */
export const InputSyslogConnection1$inboundSchema: z.ZodType<
  InputSyslogConnection1,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputSyslogConnection1$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputSyslogConnection1$outboundSchema: z.ZodType<
  InputSyslogConnection1$Outbound,
  z.ZodTypeDef,
  InputSyslogConnection1
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogConnection1$ {
  /** @deprecated use `InputSyslogConnection1$inboundSchema` instead. */
  export const inboundSchema = InputSyslogConnection1$inboundSchema;
  /** @deprecated use `InputSyslogConnection1$outboundSchema` instead. */
  export const outboundSchema = InputSyslogConnection1$outboundSchema;
  /** @deprecated use `InputSyslogConnection1$Outbound` instead. */
  export type Outbound = InputSyslogConnection1$Outbound;
}

export function inputSyslogConnection1ToJSON(
  inputSyslogConnection1: InputSyslogConnection1,
): string {
  return JSON.stringify(
    InputSyslogConnection1$outboundSchema.parse(inputSyslogConnection1),
  );
}

export function inputSyslogConnection1FromJSON(
  jsonString: string,
): SafeParseResult<InputSyslogConnection1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSyslogConnection1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSyslogConnection1' from JSON`,
  );
}

/** @internal */
export const InputSyslogMode1$inboundSchema: z.ZodNativeEnum<
  typeof InputSyslogMode1
> = z.nativeEnum(InputSyslogMode1);

/** @internal */
export const InputSyslogMode1$outboundSchema: z.ZodNativeEnum<
  typeof InputSyslogMode1
> = InputSyslogMode1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogMode1$ {
  /** @deprecated use `InputSyslogMode1$inboundSchema` instead. */
  export const inboundSchema = InputSyslogMode1$inboundSchema;
  /** @deprecated use `InputSyslogMode1$outboundSchema` instead. */
  export const outboundSchema = InputSyslogMode1$outboundSchema;
}

/** @internal */
export const InputSyslogCompression1$inboundSchema: z.ZodNativeEnum<
  typeof InputSyslogCompression1
> = z.nativeEnum(InputSyslogCompression1);

/** @internal */
export const InputSyslogCompression1$outboundSchema: z.ZodNativeEnum<
  typeof InputSyslogCompression1
> = InputSyslogCompression1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogCompression1$ {
  /** @deprecated use `InputSyslogCompression1$inboundSchema` instead. */
  export const inboundSchema = InputSyslogCompression1$inboundSchema;
  /** @deprecated use `InputSyslogCompression1$outboundSchema` instead. */
  export const outboundSchema = InputSyslogCompression1$outboundSchema;
}

/** @internal */
export const InputSyslogPq1$inboundSchema: z.ZodType<
  InputSyslogPq1,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputSyslogMode1$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSyslogCompression1$inboundSchema.default("none"),
});

/** @internal */
export type InputSyslogPq1$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputSyslogPq1$outboundSchema: z.ZodType<
  InputSyslogPq1$Outbound,
  z.ZodTypeDef,
  InputSyslogPq1
> = z.object({
  mode: InputSyslogMode1$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSyslogCompression1$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogPq1$ {
  /** @deprecated use `InputSyslogPq1$inboundSchema` instead. */
  export const inboundSchema = InputSyslogPq1$inboundSchema;
  /** @deprecated use `InputSyslogPq1$outboundSchema` instead. */
  export const outboundSchema = InputSyslogPq1$outboundSchema;
  /** @deprecated use `InputSyslogPq1$Outbound` instead. */
  export type Outbound = InputSyslogPq1$Outbound;
}

export function inputSyslogPq1ToJSON(inputSyslogPq1: InputSyslogPq1): string {
  return JSON.stringify(InputSyslogPq1$outboundSchema.parse(inputSyslogPq1));
}

export function inputSyslogPq1FromJSON(
  jsonString: string,
): SafeParseResult<InputSyslogPq1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSyslogPq1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSyslogPq1' from JSON`,
  );
}

/** @internal */
export const InputSyslogMinimumTLSVersion1$inboundSchema: z.ZodNativeEnum<
  typeof InputSyslogMinimumTLSVersion1
> = z.nativeEnum(InputSyslogMinimumTLSVersion1);

/** @internal */
export const InputSyslogMinimumTLSVersion1$outboundSchema: z.ZodNativeEnum<
  typeof InputSyslogMinimumTLSVersion1
> = InputSyslogMinimumTLSVersion1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogMinimumTLSVersion1$ {
  /** @deprecated use `InputSyslogMinimumTLSVersion1$inboundSchema` instead. */
  export const inboundSchema = InputSyslogMinimumTLSVersion1$inboundSchema;
  /** @deprecated use `InputSyslogMinimumTLSVersion1$outboundSchema` instead. */
  export const outboundSchema = InputSyslogMinimumTLSVersion1$outboundSchema;
}

/** @internal */
export const InputSyslogMaximumTLSVersion1$inboundSchema: z.ZodNativeEnum<
  typeof InputSyslogMaximumTLSVersion1
> = z.nativeEnum(InputSyslogMaximumTLSVersion1);

/** @internal */
export const InputSyslogMaximumTLSVersion1$outboundSchema: z.ZodNativeEnum<
  typeof InputSyslogMaximumTLSVersion1
> = InputSyslogMaximumTLSVersion1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogMaximumTLSVersion1$ {
  /** @deprecated use `InputSyslogMaximumTLSVersion1$inboundSchema` instead. */
  export const inboundSchema = InputSyslogMaximumTLSVersion1$inboundSchema;
  /** @deprecated use `InputSyslogMaximumTLSVersion1$outboundSchema` instead. */
  export const outboundSchema = InputSyslogMaximumTLSVersion1$outboundSchema;
}

/** @internal */
export const InputSyslogTLSSettingsServerSide1$inboundSchema: z.ZodType<
  InputSyslogTLSSettingsServerSide1,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputSyslogMinimumTLSVersion1$inboundSchema.optional(),
  maxVersion: InputSyslogMaximumTLSVersion1$inboundSchema.optional(),
});

/** @internal */
export type InputSyslogTLSSettingsServerSide1$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputSyslogTLSSettingsServerSide1$outboundSchema: z.ZodType<
  InputSyslogTLSSettingsServerSide1$Outbound,
  z.ZodTypeDef,
  InputSyslogTLSSettingsServerSide1
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputSyslogMinimumTLSVersion1$outboundSchema.optional(),
  maxVersion: InputSyslogMaximumTLSVersion1$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogTLSSettingsServerSide1$ {
  /** @deprecated use `InputSyslogTLSSettingsServerSide1$inboundSchema` instead. */
  export const inboundSchema = InputSyslogTLSSettingsServerSide1$inboundSchema;
  /** @deprecated use `InputSyslogTLSSettingsServerSide1$outboundSchema` instead. */
  export const outboundSchema =
    InputSyslogTLSSettingsServerSide1$outboundSchema;
  /** @deprecated use `InputSyslogTLSSettingsServerSide1$Outbound` instead. */
  export type Outbound = InputSyslogTLSSettingsServerSide1$Outbound;
}

export function inputSyslogTLSSettingsServerSide1ToJSON(
  inputSyslogTLSSettingsServerSide1: InputSyslogTLSSettingsServerSide1,
): string {
  return JSON.stringify(
    InputSyslogTLSSettingsServerSide1$outboundSchema.parse(
      inputSyslogTLSSettingsServerSide1,
    ),
  );
}

export function inputSyslogTLSSettingsServerSide1FromJSON(
  jsonString: string,
): SafeParseResult<InputSyslogTLSSettingsServerSide1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSyslogTLSSettingsServerSide1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSyslogTLSSettingsServerSide1' from JSON`,
  );
}

/** @internal */
export const InputSyslogMetadatum1$inboundSchema: z.ZodType<
  InputSyslogMetadatum1,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputSyslogMetadatum1$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputSyslogMetadatum1$outboundSchema: z.ZodType<
  InputSyslogMetadatum1$Outbound,
  z.ZodTypeDef,
  InputSyslogMetadatum1
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogMetadatum1$ {
  /** @deprecated use `InputSyslogMetadatum1$inboundSchema` instead. */
  export const inboundSchema = InputSyslogMetadatum1$inboundSchema;
  /** @deprecated use `InputSyslogMetadatum1$outboundSchema` instead. */
  export const outboundSchema = InputSyslogMetadatum1$outboundSchema;
  /** @deprecated use `InputSyslogMetadatum1$Outbound` instead. */
  export type Outbound = InputSyslogMetadatum1$Outbound;
}

export function inputSyslogMetadatum1ToJSON(
  inputSyslogMetadatum1: InputSyslogMetadatum1,
): string {
  return JSON.stringify(
    InputSyslogMetadatum1$outboundSchema.parse(inputSyslogMetadatum1),
  );
}

export function inputSyslogMetadatum1FromJSON(
  jsonString: string,
): SafeParseResult<InputSyslogMetadatum1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSyslogMetadatum1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSyslogMetadatum1' from JSON`,
  );
}

/** @internal */
export const InputSyslogSyslog1$inboundSchema: z.ZodType<
  InputSyslogSyslog1,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputSyslogType1$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSyslogConnection1$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputSyslogPq1$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  udpPort: z.number(),
  tcpPort: z.number().optional(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  timestampTimezone: z.string().default("local"),
  singleMsgUdpPackets: z.boolean().default(false),
  enableProxyHeader: z.boolean().default(false),
  keepFieldsList: z.array(z.string()).optional(),
  octetCounting: z.boolean().default(false),
  inferFraming: z.boolean().default(true),
  strictlyInferOctetCounting: z.boolean().default(true),
  allowNonStandardAppName: z.boolean().default(false),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  tls: z.lazy(() => InputSyslogTLSSettingsServerSide1$inboundSchema).optional(),
  metadata: z.array(z.lazy(() => InputSyslogMetadatum1$inboundSchema))
    .optional(),
  udpSocketRxBufSize: z.number().optional(),
  enableLoadBalancing: z.boolean().default(false),
  description: z.string().optional(),
  enableEnhancedProxyHeaderParsing: z.boolean().optional(),
});

/** @internal */
export type InputSyslogSyslog1$Outbound = {
  id: string;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputSyslogConnection1$Outbound> | undefined;
  pq?: InputSyslogPq1$Outbound | undefined;
  host: string;
  udpPort: number;
  tcpPort?: number | undefined;
  maxBufferSize: number;
  ipWhitelistRegex: string;
  timestampTimezone: string;
  singleMsgUdpPackets: boolean;
  enableProxyHeader: boolean;
  keepFieldsList?: Array<string> | undefined;
  octetCounting: boolean;
  inferFraming: boolean;
  strictlyInferOctetCounting: boolean;
  allowNonStandardAppName: boolean;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  tls?: InputSyslogTLSSettingsServerSide1$Outbound | undefined;
  metadata?: Array<InputSyslogMetadatum1$Outbound> | undefined;
  udpSocketRxBufSize?: number | undefined;
  enableLoadBalancing: boolean;
  description?: string | undefined;
  enableEnhancedProxyHeaderParsing?: boolean | undefined;
};

/** @internal */
export const InputSyslogSyslog1$outboundSchema: z.ZodType<
  InputSyslogSyslog1$Outbound,
  z.ZodTypeDef,
  InputSyslogSyslog1
> = z.object({
  id: z.string(),
  type: InputSyslogType1$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSyslogConnection1$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputSyslogPq1$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  udpPort: z.number(),
  tcpPort: z.number().optional(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  timestampTimezone: z.string().default("local"),
  singleMsgUdpPackets: z.boolean().default(false),
  enableProxyHeader: z.boolean().default(false),
  keepFieldsList: z.array(z.string()).optional(),
  octetCounting: z.boolean().default(false),
  inferFraming: z.boolean().default(true),
  strictlyInferOctetCounting: z.boolean().default(true),
  allowNonStandardAppName: z.boolean().default(false),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  tls: z.lazy(() => InputSyslogTLSSettingsServerSide1$outboundSchema)
    .optional(),
  metadata: z.array(z.lazy(() => InputSyslogMetadatum1$outboundSchema))
    .optional(),
  udpSocketRxBufSize: z.number().optional(),
  enableLoadBalancing: z.boolean().default(false),
  description: z.string().optional(),
  enableEnhancedProxyHeaderParsing: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogSyslog1$ {
  /** @deprecated use `InputSyslogSyslog1$inboundSchema` instead. */
  export const inboundSchema = InputSyslogSyslog1$inboundSchema;
  /** @deprecated use `InputSyslogSyslog1$outboundSchema` instead. */
  export const outboundSchema = InputSyslogSyslog1$outboundSchema;
  /** @deprecated use `InputSyslogSyslog1$Outbound` instead. */
  export type Outbound = InputSyslogSyslog1$Outbound;
}

export function inputSyslogSyslog1ToJSON(
  inputSyslogSyslog1: InputSyslogSyslog1,
): string {
  return JSON.stringify(
    InputSyslogSyslog1$outboundSchema.parse(inputSyslogSyslog1),
  );
}

export function inputSyslogSyslog1FromJSON(
  jsonString: string,
): SafeParseResult<InputSyslogSyslog1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSyslogSyslog1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSyslogSyslog1' from JSON`,
  );
}

/** @internal */
export const InputSyslog$inboundSchema: z.ZodType<
  InputSyslog,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => InputSyslogSyslog1$inboundSchema),
  z.lazy(() => InputSyslogSyslog2$inboundSchema),
]);

/** @internal */
export type InputSyslog$Outbound =
  | InputSyslogSyslog1$Outbound
  | InputSyslogSyslog2$Outbound;

/** @internal */
export const InputSyslog$outboundSchema: z.ZodType<
  InputSyslog$Outbound,
  z.ZodTypeDef,
  InputSyslog
> = z.union([
  z.lazy(() => InputSyslogSyslog1$outboundSchema),
  z.lazy(() => InputSyslogSyslog2$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslog$ {
  /** @deprecated use `InputSyslog$inboundSchema` instead. */
  export const inboundSchema = InputSyslog$inboundSchema;
  /** @deprecated use `InputSyslog$outboundSchema` instead. */
  export const outboundSchema = InputSyslog$outboundSchema;
  /** @deprecated use `InputSyslog$Outbound` instead. */
  export type Outbound = InputSyslog$Outbound;
}

export function inputSyslogToJSON(inputSyslog: InputSyslog): string {
  return JSON.stringify(InputSyslog$outboundSchema.parse(inputSyslog));
}

export function inputSyslogFromJSON(
  jsonString: string,
): SafeParseResult<InputSyslog, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSyslog$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSyslog' from JSON`,
  );
}

/** @internal */
export const CreateInputTypeSqs$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeSqs
> = z.nativeEnum(CreateInputTypeSqs);

/** @internal */
export const CreateInputTypeSqs$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeSqs
> = CreateInputTypeSqs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputTypeSqs$ {
  /** @deprecated use `CreateInputTypeSqs$inboundSchema` instead. */
  export const inboundSchema = CreateInputTypeSqs$inboundSchema;
  /** @deprecated use `CreateInputTypeSqs$outboundSchema` instead. */
  export const outboundSchema = CreateInputTypeSqs$outboundSchema;
}

/** @internal */
export const ConnectionSqs$inboundSchema: z.ZodType<
  ConnectionSqs,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionSqs$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionSqs$outboundSchema: z.ZodType<
  ConnectionSqs$Outbound,
  z.ZodTypeDef,
  ConnectionSqs
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionSqs$ {
  /** @deprecated use `ConnectionSqs$inboundSchema` instead. */
  export const inboundSchema = ConnectionSqs$inboundSchema;
  /** @deprecated use `ConnectionSqs$outboundSchema` instead. */
  export const outboundSchema = ConnectionSqs$outboundSchema;
  /** @deprecated use `ConnectionSqs$Outbound` instead. */
  export type Outbound = ConnectionSqs$Outbound;
}

export function connectionSqsToJSON(connectionSqs: ConnectionSqs): string {
  return JSON.stringify(ConnectionSqs$outboundSchema.parse(connectionSqs));
}

export function connectionSqsFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionSqs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionSqs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionSqs' from JSON`,
  );
}

/** @internal */
export const CreateInputModeSqs$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputModeSqs
> = z.nativeEnum(CreateInputModeSqs);

/** @internal */
export const CreateInputModeSqs$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputModeSqs
> = CreateInputModeSqs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputModeSqs$ {
  /** @deprecated use `CreateInputModeSqs$inboundSchema` instead. */
  export const inboundSchema = CreateInputModeSqs$inboundSchema;
  /** @deprecated use `CreateInputModeSqs$outboundSchema` instead. */
  export const outboundSchema = CreateInputModeSqs$outboundSchema;
}

/** @internal */
export const PqCompressionSqs$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressionSqs
> = z.nativeEnum(PqCompressionSqs);

/** @internal */
export const PqCompressionSqs$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressionSqs
> = PqCompressionSqs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressionSqs$ {
  /** @deprecated use `PqCompressionSqs$inboundSchema` instead. */
  export const inboundSchema = PqCompressionSqs$inboundSchema;
  /** @deprecated use `PqCompressionSqs$outboundSchema` instead. */
  export const outboundSchema = PqCompressionSqs$outboundSchema;
}

/** @internal */
export const PqSqs$inboundSchema: z.ZodType<PqSqs, z.ZodTypeDef, unknown> = z
  .object({
    mode: CreateInputModeSqs$inboundSchema.default("always"),
    maxBufferSize: z.number().default(1000),
    commitFrequency: z.number().default(42),
    maxFileSize: z.string().default("1 MB"),
    maxSize: z.string().default("5GB"),
    path: z.string().default("$CRIBL_HOME/state/queues"),
    compress: PqCompressionSqs$inboundSchema.default("none"),
  });

/** @internal */
export type PqSqs$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqSqs$outboundSchema: z.ZodType<
  PqSqs$Outbound,
  z.ZodTypeDef,
  PqSqs
> = z.object({
  mode: CreateInputModeSqs$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: PqCompressionSqs$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqSqs$ {
  /** @deprecated use `PqSqs$inboundSchema` instead. */
  export const inboundSchema = PqSqs$inboundSchema;
  /** @deprecated use `PqSqs$outboundSchema` instead. */
  export const outboundSchema = PqSqs$outboundSchema;
  /** @deprecated use `PqSqs$Outbound` instead. */
  export type Outbound = PqSqs$Outbound;
}

export function pqSqsToJSON(pqSqs: PqSqs): string {
  return JSON.stringify(PqSqs$outboundSchema.parse(pqSqs));
}

export function pqSqsFromJSON(
  jsonString: string,
): SafeParseResult<PqSqs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqSqs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqSqs' from JSON`,
  );
}

/** @internal */
export const CreateInputQueueType$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputQueueType
> = z.nativeEnum(CreateInputQueueType);

/** @internal */
export const CreateInputQueueType$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputQueueType
> = CreateInputQueueType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputQueueType$ {
  /** @deprecated use `CreateInputQueueType$inboundSchema` instead. */
  export const inboundSchema = CreateInputQueueType$inboundSchema;
  /** @deprecated use `CreateInputQueueType$outboundSchema` instead. */
  export const outboundSchema = CreateInputQueueType$outboundSchema;
}

/** @internal */
export const CreateInputAuthenticationMethodSqs$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputAuthenticationMethodSqs
> = z.nativeEnum(CreateInputAuthenticationMethodSqs);

/** @internal */
export const CreateInputAuthenticationMethodSqs$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputAuthenticationMethodSqs
> = CreateInputAuthenticationMethodSqs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputAuthenticationMethodSqs$ {
  /** @deprecated use `CreateInputAuthenticationMethodSqs$inboundSchema` instead. */
  export const inboundSchema = CreateInputAuthenticationMethodSqs$inboundSchema;
  /** @deprecated use `CreateInputAuthenticationMethodSqs$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputAuthenticationMethodSqs$outboundSchema;
}

/** @internal */
export const CreateInputSignatureVersionSqs$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputSignatureVersionSqs
> = z.nativeEnum(CreateInputSignatureVersionSqs);

/** @internal */
export const CreateInputSignatureVersionSqs$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputSignatureVersionSqs
> = CreateInputSignatureVersionSqs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputSignatureVersionSqs$ {
  /** @deprecated use `CreateInputSignatureVersionSqs$inboundSchema` instead. */
  export const inboundSchema = CreateInputSignatureVersionSqs$inboundSchema;
  /** @deprecated use `CreateInputSignatureVersionSqs$outboundSchema` instead. */
  export const outboundSchema = CreateInputSignatureVersionSqs$outboundSchema;
}

/** @internal */
export const MetadatumSqs$inboundSchema: z.ZodType<
  MetadatumSqs,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumSqs$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumSqs$outboundSchema: z.ZodType<
  MetadatumSqs$Outbound,
  z.ZodTypeDef,
  MetadatumSqs
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumSqs$ {
  /** @deprecated use `MetadatumSqs$inboundSchema` instead. */
  export const inboundSchema = MetadatumSqs$inboundSchema;
  /** @deprecated use `MetadatumSqs$outboundSchema` instead. */
  export const outboundSchema = MetadatumSqs$outboundSchema;
  /** @deprecated use `MetadatumSqs$Outbound` instead. */
  export type Outbound = MetadatumSqs$Outbound;
}

export function metadatumSqsToJSON(metadatumSqs: MetadatumSqs): string {
  return JSON.stringify(MetadatumSqs$outboundSchema.parse(metadatumSqs));
}

export function metadatumSqsFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumSqs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumSqs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumSqs' from JSON`,
  );
}

/** @internal */
export const InputSqs$inboundSchema: z.ZodType<
  InputSqs,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateInputTypeSqs$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionSqs$inboundSchema)).optional(),
  pq: z.lazy(() => PqSqs$inboundSchema).optional(),
  queueName: z.string(),
  queueType: CreateInputQueueType$inboundSchema.default("standard"),
  awsAccountId: z.string().optional(),
  createQueue: z.boolean().default(false),
  awsAuthenticationMethod: CreateInputAuthenticationMethodSqs$inboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: CreateInputSignatureVersionSqs$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  maxMessages: z.number().default(10),
  visibilityTimeout: z.number().default(600),
  metadata: z.array(z.lazy(() => MetadatumSqs$inboundSchema)).optional(),
  pollTimeout: z.number().default(10),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  numReceivers: z.number().default(3),
});

/** @internal */
export type InputSqs$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionSqs$Outbound> | undefined;
  pq?: PqSqs$Outbound | undefined;
  queueName: string;
  queueType: string;
  awsAccountId?: string | undefined;
  createQueue: boolean;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  maxMessages: number;
  visibilityTimeout: number;
  metadata?: Array<MetadatumSqs$Outbound> | undefined;
  pollTimeout: number;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  numReceivers: number;
};

/** @internal */
export const InputSqs$outboundSchema: z.ZodType<
  InputSqs$Outbound,
  z.ZodTypeDef,
  InputSqs
> = z.object({
  id: z.string(),
  type: CreateInputTypeSqs$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionSqs$outboundSchema)).optional(),
  pq: z.lazy(() => PqSqs$outboundSchema).optional(),
  queueName: z.string(),
  queueType: CreateInputQueueType$outboundSchema.default("standard"),
  awsAccountId: z.string().optional(),
  createQueue: z.boolean().default(false),
  awsAuthenticationMethod: CreateInputAuthenticationMethodSqs$outboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: CreateInputSignatureVersionSqs$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  maxMessages: z.number().default(10),
  visibilityTimeout: z.number().default(600),
  metadata: z.array(z.lazy(() => MetadatumSqs$outboundSchema)).optional(),
  pollTimeout: z.number().default(10),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  numReceivers: z.number().default(3),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSqs$ {
  /** @deprecated use `InputSqs$inboundSchema` instead. */
  export const inboundSchema = InputSqs$inboundSchema;
  /** @deprecated use `InputSqs$outboundSchema` instead. */
  export const outboundSchema = InputSqs$outboundSchema;
  /** @deprecated use `InputSqs$Outbound` instead. */
  export type Outbound = InputSqs$Outbound;
}

export function inputSqsToJSON(inputSqs: InputSqs): string {
  return JSON.stringify(InputSqs$outboundSchema.parse(inputSqs));
}

export function inputSqsFromJSON(
  jsonString: string,
): SafeParseResult<InputSqs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSqs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSqs' from JSON`,
  );
}

/** @internal */
export const TypeModelDrivenTelemetry$inboundSchema: z.ZodNativeEnum<
  typeof TypeModelDrivenTelemetry
> = z.nativeEnum(TypeModelDrivenTelemetry);

/** @internal */
export const TypeModelDrivenTelemetry$outboundSchema: z.ZodNativeEnum<
  typeof TypeModelDrivenTelemetry
> = TypeModelDrivenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeModelDrivenTelemetry$ {
  /** @deprecated use `TypeModelDrivenTelemetry$inboundSchema` instead. */
  export const inboundSchema = TypeModelDrivenTelemetry$inboundSchema;
  /** @deprecated use `TypeModelDrivenTelemetry$outboundSchema` instead. */
  export const outboundSchema = TypeModelDrivenTelemetry$outboundSchema;
}

/** @internal */
export const ConnectionModelDrivenTelemetry$inboundSchema: z.ZodType<
  ConnectionModelDrivenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionModelDrivenTelemetry$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionModelDrivenTelemetry$outboundSchema: z.ZodType<
  ConnectionModelDrivenTelemetry$Outbound,
  z.ZodTypeDef,
  ConnectionModelDrivenTelemetry
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionModelDrivenTelemetry$ {
  /** @deprecated use `ConnectionModelDrivenTelemetry$inboundSchema` instead. */
  export const inboundSchema = ConnectionModelDrivenTelemetry$inboundSchema;
  /** @deprecated use `ConnectionModelDrivenTelemetry$outboundSchema` instead. */
  export const outboundSchema = ConnectionModelDrivenTelemetry$outboundSchema;
  /** @deprecated use `ConnectionModelDrivenTelemetry$Outbound` instead. */
  export type Outbound = ConnectionModelDrivenTelemetry$Outbound;
}

export function connectionModelDrivenTelemetryToJSON(
  connectionModelDrivenTelemetry: ConnectionModelDrivenTelemetry,
): string {
  return JSON.stringify(
    ConnectionModelDrivenTelemetry$outboundSchema.parse(
      connectionModelDrivenTelemetry,
    ),
  );
}

export function connectionModelDrivenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionModelDrivenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionModelDrivenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionModelDrivenTelemetry' from JSON`,
  );
}

/** @internal */
export const ModeModelDrivenTelemetry$inboundSchema: z.ZodNativeEnum<
  typeof ModeModelDrivenTelemetry
> = z.nativeEnum(ModeModelDrivenTelemetry);

/** @internal */
export const ModeModelDrivenTelemetry$outboundSchema: z.ZodNativeEnum<
  typeof ModeModelDrivenTelemetry
> = ModeModelDrivenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeModelDrivenTelemetry$ {
  /** @deprecated use `ModeModelDrivenTelemetry$inboundSchema` instead. */
  export const inboundSchema = ModeModelDrivenTelemetry$inboundSchema;
  /** @deprecated use `ModeModelDrivenTelemetry$outboundSchema` instead. */
  export const outboundSchema = ModeModelDrivenTelemetry$outboundSchema;
}

/** @internal */
export const CompressionModelDrivenTelemetry$inboundSchema: z.ZodNativeEnum<
  typeof CompressionModelDrivenTelemetry
> = z.nativeEnum(CompressionModelDrivenTelemetry);

/** @internal */
export const CompressionModelDrivenTelemetry$outboundSchema: z.ZodNativeEnum<
  typeof CompressionModelDrivenTelemetry
> = CompressionModelDrivenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionModelDrivenTelemetry$ {
  /** @deprecated use `CompressionModelDrivenTelemetry$inboundSchema` instead. */
  export const inboundSchema = CompressionModelDrivenTelemetry$inboundSchema;
  /** @deprecated use `CompressionModelDrivenTelemetry$outboundSchema` instead. */
  export const outboundSchema = CompressionModelDrivenTelemetry$outboundSchema;
}

/** @internal */
export const PqModelDrivenTelemetry$inboundSchema: z.ZodType<
  PqModelDrivenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeModelDrivenTelemetry$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionModelDrivenTelemetry$inboundSchema.default("none"),
});

/** @internal */
export type PqModelDrivenTelemetry$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqModelDrivenTelemetry$outboundSchema: z.ZodType<
  PqModelDrivenTelemetry$Outbound,
  z.ZodTypeDef,
  PqModelDrivenTelemetry
> = z.object({
  mode: ModeModelDrivenTelemetry$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionModelDrivenTelemetry$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqModelDrivenTelemetry$ {
  /** @deprecated use `PqModelDrivenTelemetry$inboundSchema` instead. */
  export const inboundSchema = PqModelDrivenTelemetry$inboundSchema;
  /** @deprecated use `PqModelDrivenTelemetry$outboundSchema` instead. */
  export const outboundSchema = PqModelDrivenTelemetry$outboundSchema;
  /** @deprecated use `PqModelDrivenTelemetry$Outbound` instead. */
  export type Outbound = PqModelDrivenTelemetry$Outbound;
}

export function pqModelDrivenTelemetryToJSON(
  pqModelDrivenTelemetry: PqModelDrivenTelemetry,
): string {
  return JSON.stringify(
    PqModelDrivenTelemetry$outboundSchema.parse(pqModelDrivenTelemetry),
  );
}

export function pqModelDrivenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<PqModelDrivenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqModelDrivenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqModelDrivenTelemetry' from JSON`,
  );
}

/** @internal */
export const MinimumTLSVersionModelDrivenTelemetry$inboundSchema:
  z.ZodNativeEnum<typeof MinimumTLSVersionModelDrivenTelemetry> = z.nativeEnum(
    MinimumTLSVersionModelDrivenTelemetry,
  );

/** @internal */
export const MinimumTLSVersionModelDrivenTelemetry$outboundSchema:
  z.ZodNativeEnum<typeof MinimumTLSVersionModelDrivenTelemetry> =
    MinimumTLSVersionModelDrivenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MinimumTLSVersionModelDrivenTelemetry$ {
  /** @deprecated use `MinimumTLSVersionModelDrivenTelemetry$inboundSchema` instead. */
  export const inboundSchema =
    MinimumTLSVersionModelDrivenTelemetry$inboundSchema;
  /** @deprecated use `MinimumTLSVersionModelDrivenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    MinimumTLSVersionModelDrivenTelemetry$outboundSchema;
}

/** @internal */
export const MaximumTLSVersionModelDrivenTelemetry$inboundSchema:
  z.ZodNativeEnum<typeof MaximumTLSVersionModelDrivenTelemetry> = z.nativeEnum(
    MaximumTLSVersionModelDrivenTelemetry,
  );

/** @internal */
export const MaximumTLSVersionModelDrivenTelemetry$outboundSchema:
  z.ZodNativeEnum<typeof MaximumTLSVersionModelDrivenTelemetry> =
    MaximumTLSVersionModelDrivenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaximumTLSVersionModelDrivenTelemetry$ {
  /** @deprecated use `MaximumTLSVersionModelDrivenTelemetry$inboundSchema` instead. */
  export const inboundSchema =
    MaximumTLSVersionModelDrivenTelemetry$inboundSchema;
  /** @deprecated use `MaximumTLSVersionModelDrivenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    MaximumTLSVersionModelDrivenTelemetry$outboundSchema;
}

/** @internal */
export const TLSSettingsServerSideModelDrivenTelemetry$inboundSchema: z.ZodType<
  TLSSettingsServerSideModelDrivenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionModelDrivenTelemetry$inboundSchema.optional(),
  maxVersion: MaximumTLSVersionModelDrivenTelemetry$inboundSchema.optional(),
});

/** @internal */
export type TLSSettingsServerSideModelDrivenTelemetry$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TLSSettingsServerSideModelDrivenTelemetry$outboundSchema:
  z.ZodType<
    TLSSettingsServerSideModelDrivenTelemetry$Outbound,
    z.ZodTypeDef,
    TLSSettingsServerSideModelDrivenTelemetry
  > = z.object({
    disabled: z.boolean().default(true),
    certificateName: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    caPath: z.string().optional(),
    requestCert: z.boolean().default(false),
    rejectUnauthorized: z.any().optional(),
    commonNameRegex: z.any().optional(),
    minVersion: MinimumTLSVersionModelDrivenTelemetry$outboundSchema.optional(),
    maxVersion: MaximumTLSVersionModelDrivenTelemetry$outboundSchema.optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsServerSideModelDrivenTelemetry$ {
  /** @deprecated use `TLSSettingsServerSideModelDrivenTelemetry$inboundSchema` instead. */
  export const inboundSchema =
    TLSSettingsServerSideModelDrivenTelemetry$inboundSchema;
  /** @deprecated use `TLSSettingsServerSideModelDrivenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    TLSSettingsServerSideModelDrivenTelemetry$outboundSchema;
  /** @deprecated use `TLSSettingsServerSideModelDrivenTelemetry$Outbound` instead. */
  export type Outbound = TLSSettingsServerSideModelDrivenTelemetry$Outbound;
}

export function tlsSettingsServerSideModelDrivenTelemetryToJSON(
  tlsSettingsServerSideModelDrivenTelemetry:
    TLSSettingsServerSideModelDrivenTelemetry,
): string {
  return JSON.stringify(
    TLSSettingsServerSideModelDrivenTelemetry$outboundSchema.parse(
      tlsSettingsServerSideModelDrivenTelemetry,
    ),
  );
}

export function tlsSettingsServerSideModelDrivenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<
  TLSSettingsServerSideModelDrivenTelemetry,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      TLSSettingsServerSideModelDrivenTelemetry$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'TLSSettingsServerSideModelDrivenTelemetry' from JSON`,
  );
}

/** @internal */
export const MetadatumModelDrivenTelemetry$inboundSchema: z.ZodType<
  MetadatumModelDrivenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumModelDrivenTelemetry$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumModelDrivenTelemetry$outboundSchema: z.ZodType<
  MetadatumModelDrivenTelemetry$Outbound,
  z.ZodTypeDef,
  MetadatumModelDrivenTelemetry
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumModelDrivenTelemetry$ {
  /** @deprecated use `MetadatumModelDrivenTelemetry$inboundSchema` instead. */
  export const inboundSchema = MetadatumModelDrivenTelemetry$inboundSchema;
  /** @deprecated use `MetadatumModelDrivenTelemetry$outboundSchema` instead. */
  export const outboundSchema = MetadatumModelDrivenTelemetry$outboundSchema;
  /** @deprecated use `MetadatumModelDrivenTelemetry$Outbound` instead. */
  export type Outbound = MetadatumModelDrivenTelemetry$Outbound;
}

export function metadatumModelDrivenTelemetryToJSON(
  metadatumModelDrivenTelemetry: MetadatumModelDrivenTelemetry,
): string {
  return JSON.stringify(
    MetadatumModelDrivenTelemetry$outboundSchema.parse(
      metadatumModelDrivenTelemetry,
    ),
  );
}

export function metadatumModelDrivenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumModelDrivenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumModelDrivenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumModelDrivenTelemetry' from JSON`,
  );
}

/** @internal */
export const InputModelDrivenTelemetry$inboundSchema: z.ZodType<
  InputModelDrivenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeModelDrivenTelemetry$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(
    z.lazy(() => ConnectionModelDrivenTelemetry$inboundSchema),
  ).optional(),
  pq: z.lazy(() => PqModelDrivenTelemetry$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number().default(57000),
  tls: z.lazy(() => TLSSettingsServerSideModelDrivenTelemetry$inboundSchema)
    .optional(),
  metadata: z.array(z.lazy(() => MetadatumModelDrivenTelemetry$inboundSchema))
    .optional(),
  maxActiveCxn: z.number().default(1000),
  shutdownTimeoutMs: z.number().default(5000),
  description: z.string().optional(),
});

/** @internal */
export type InputModelDrivenTelemetry$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionModelDrivenTelemetry$Outbound> | undefined;
  pq?: PqModelDrivenTelemetry$Outbound | undefined;
  host: string;
  port: number;
  tls?: TLSSettingsServerSideModelDrivenTelemetry$Outbound | undefined;
  metadata?: Array<MetadatumModelDrivenTelemetry$Outbound> | undefined;
  maxActiveCxn: number;
  shutdownTimeoutMs: number;
  description?: string | undefined;
};

/** @internal */
export const InputModelDrivenTelemetry$outboundSchema: z.ZodType<
  InputModelDrivenTelemetry$Outbound,
  z.ZodTypeDef,
  InputModelDrivenTelemetry
> = z.object({
  id: z.string(),
  type: TypeModelDrivenTelemetry$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(
    z.lazy(() => ConnectionModelDrivenTelemetry$outboundSchema),
  ).optional(),
  pq: z.lazy(() => PqModelDrivenTelemetry$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number().default(57000),
  tls: z.lazy(() => TLSSettingsServerSideModelDrivenTelemetry$outboundSchema)
    .optional(),
  metadata: z.array(z.lazy(() => MetadatumModelDrivenTelemetry$outboundSchema))
    .optional(),
  maxActiveCxn: z.number().default(1000),
  shutdownTimeoutMs: z.number().default(5000),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputModelDrivenTelemetry$ {
  /** @deprecated use `InputModelDrivenTelemetry$inboundSchema` instead. */
  export const inboundSchema = InputModelDrivenTelemetry$inboundSchema;
  /** @deprecated use `InputModelDrivenTelemetry$outboundSchema` instead. */
  export const outboundSchema = InputModelDrivenTelemetry$outboundSchema;
  /** @deprecated use `InputModelDrivenTelemetry$Outbound` instead. */
  export type Outbound = InputModelDrivenTelemetry$Outbound;
}

export function inputModelDrivenTelemetryToJSON(
  inputModelDrivenTelemetry: InputModelDrivenTelemetry,
): string {
  return JSON.stringify(
    InputModelDrivenTelemetry$outboundSchema.parse(inputModelDrivenTelemetry),
  );
}

export function inputModelDrivenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<InputModelDrivenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputModelDrivenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputModelDrivenTelemetry' from JSON`,
  );
}

/** @internal */
export const CreateInputTypeOpenTelemetry$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeOpenTelemetry
> = z.nativeEnum(CreateInputTypeOpenTelemetry);

/** @internal */
export const CreateInputTypeOpenTelemetry$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeOpenTelemetry
> = CreateInputTypeOpenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputTypeOpenTelemetry$ {
  /** @deprecated use `CreateInputTypeOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = CreateInputTypeOpenTelemetry$inboundSchema;
  /** @deprecated use `CreateInputTypeOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema = CreateInputTypeOpenTelemetry$outboundSchema;
}

/** @internal */
export const ConnectionOpenTelemetry$inboundSchema: z.ZodType<
  ConnectionOpenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionOpenTelemetry$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionOpenTelemetry$outboundSchema: z.ZodType<
  ConnectionOpenTelemetry$Outbound,
  z.ZodTypeDef,
  ConnectionOpenTelemetry
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionOpenTelemetry$ {
  /** @deprecated use `ConnectionOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = ConnectionOpenTelemetry$inboundSchema;
  /** @deprecated use `ConnectionOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema = ConnectionOpenTelemetry$outboundSchema;
  /** @deprecated use `ConnectionOpenTelemetry$Outbound` instead. */
  export type Outbound = ConnectionOpenTelemetry$Outbound;
}

export function connectionOpenTelemetryToJSON(
  connectionOpenTelemetry: ConnectionOpenTelemetry,
): string {
  return JSON.stringify(
    ConnectionOpenTelemetry$outboundSchema.parse(connectionOpenTelemetry),
  );
}

export function connectionOpenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionOpenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionOpenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionOpenTelemetry' from JSON`,
  );
}

/** @internal */
export const CreateInputModeOpenTelemetry$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputModeOpenTelemetry
> = z.nativeEnum(CreateInputModeOpenTelemetry);

/** @internal */
export const CreateInputModeOpenTelemetry$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputModeOpenTelemetry
> = CreateInputModeOpenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputModeOpenTelemetry$ {
  /** @deprecated use `CreateInputModeOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = CreateInputModeOpenTelemetry$inboundSchema;
  /** @deprecated use `CreateInputModeOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema = CreateInputModeOpenTelemetry$outboundSchema;
}

/** @internal */
export const PqCompressionOpenTelemetry$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressionOpenTelemetry
> = z.nativeEnum(PqCompressionOpenTelemetry);

/** @internal */
export const PqCompressionOpenTelemetry$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressionOpenTelemetry
> = PqCompressionOpenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressionOpenTelemetry$ {
  /** @deprecated use `PqCompressionOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = PqCompressionOpenTelemetry$inboundSchema;
  /** @deprecated use `PqCompressionOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema = PqCompressionOpenTelemetry$outboundSchema;
}

/** @internal */
export const PqOpenTelemetry$inboundSchema: z.ZodType<
  PqOpenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: CreateInputModeOpenTelemetry$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: PqCompressionOpenTelemetry$inboundSchema.default("none"),
});

/** @internal */
export type PqOpenTelemetry$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqOpenTelemetry$outboundSchema: z.ZodType<
  PqOpenTelemetry$Outbound,
  z.ZodTypeDef,
  PqOpenTelemetry
> = z.object({
  mode: CreateInputModeOpenTelemetry$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: PqCompressionOpenTelemetry$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqOpenTelemetry$ {
  /** @deprecated use `PqOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = PqOpenTelemetry$inboundSchema;
  /** @deprecated use `PqOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema = PqOpenTelemetry$outboundSchema;
  /** @deprecated use `PqOpenTelemetry$Outbound` instead. */
  export type Outbound = PqOpenTelemetry$Outbound;
}

export function pqOpenTelemetryToJSON(
  pqOpenTelemetry: PqOpenTelemetry,
): string {
  return JSON.stringify(PqOpenTelemetry$outboundSchema.parse(pqOpenTelemetry));
}

export function pqOpenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<PqOpenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqOpenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqOpenTelemetry' from JSON`,
  );
}

/** @internal */
export const CreateInputMinimumTLSVersionOpenTelemetry$inboundSchema:
  z.ZodNativeEnum<typeof CreateInputMinimumTLSVersionOpenTelemetry> = z
    .nativeEnum(CreateInputMinimumTLSVersionOpenTelemetry);

/** @internal */
export const CreateInputMinimumTLSVersionOpenTelemetry$outboundSchema:
  z.ZodNativeEnum<typeof CreateInputMinimumTLSVersionOpenTelemetry> =
    CreateInputMinimumTLSVersionOpenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputMinimumTLSVersionOpenTelemetry$ {
  /** @deprecated use `CreateInputMinimumTLSVersionOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputMinimumTLSVersionOpenTelemetry$inboundSchema;
  /** @deprecated use `CreateInputMinimumTLSVersionOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputMinimumTLSVersionOpenTelemetry$outboundSchema;
}

/** @internal */
export const CreateInputMaximumTLSVersionOpenTelemetry$inboundSchema:
  z.ZodNativeEnum<typeof CreateInputMaximumTLSVersionOpenTelemetry> = z
    .nativeEnum(CreateInputMaximumTLSVersionOpenTelemetry);

/** @internal */
export const CreateInputMaximumTLSVersionOpenTelemetry$outboundSchema:
  z.ZodNativeEnum<typeof CreateInputMaximumTLSVersionOpenTelemetry> =
    CreateInputMaximumTLSVersionOpenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputMaximumTLSVersionOpenTelemetry$ {
  /** @deprecated use `CreateInputMaximumTLSVersionOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputMaximumTLSVersionOpenTelemetry$inboundSchema;
  /** @deprecated use `CreateInputMaximumTLSVersionOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputMaximumTLSVersionOpenTelemetry$outboundSchema;
}

/** @internal */
export const TLSSettingsServerSideOpenTelemetry$inboundSchema: z.ZodType<
  TLSSettingsServerSideOpenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: CreateInputMinimumTLSVersionOpenTelemetry$inboundSchema
    .optional(),
  maxVersion: CreateInputMaximumTLSVersionOpenTelemetry$inboundSchema
    .optional(),
});

/** @internal */
export type TLSSettingsServerSideOpenTelemetry$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TLSSettingsServerSideOpenTelemetry$outboundSchema: z.ZodType<
  TLSSettingsServerSideOpenTelemetry$Outbound,
  z.ZodTypeDef,
  TLSSettingsServerSideOpenTelemetry
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: CreateInputMinimumTLSVersionOpenTelemetry$outboundSchema
    .optional(),
  maxVersion: CreateInputMaximumTLSVersionOpenTelemetry$outboundSchema
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsServerSideOpenTelemetry$ {
  /** @deprecated use `TLSSettingsServerSideOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsServerSideOpenTelemetry$inboundSchema;
  /** @deprecated use `TLSSettingsServerSideOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    TLSSettingsServerSideOpenTelemetry$outboundSchema;
  /** @deprecated use `TLSSettingsServerSideOpenTelemetry$Outbound` instead. */
  export type Outbound = TLSSettingsServerSideOpenTelemetry$Outbound;
}

export function tlsSettingsServerSideOpenTelemetryToJSON(
  tlsSettingsServerSideOpenTelemetry: TLSSettingsServerSideOpenTelemetry,
): string {
  return JSON.stringify(
    TLSSettingsServerSideOpenTelemetry$outboundSchema.parse(
      tlsSettingsServerSideOpenTelemetry,
    ),
  );
}

export function tlsSettingsServerSideOpenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsServerSideOpenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      TLSSettingsServerSideOpenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsServerSideOpenTelemetry' from JSON`,
  );
}

/** @internal */
export const CreateInputProtocolOpenTelemetry$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputProtocolOpenTelemetry
> = z.nativeEnum(CreateInputProtocolOpenTelemetry);

/** @internal */
export const CreateInputProtocolOpenTelemetry$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputProtocolOpenTelemetry
> = CreateInputProtocolOpenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputProtocolOpenTelemetry$ {
  /** @deprecated use `CreateInputProtocolOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = CreateInputProtocolOpenTelemetry$inboundSchema;
  /** @deprecated use `CreateInputProtocolOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema = CreateInputProtocolOpenTelemetry$outboundSchema;
}

/** @internal */
export const CreateInputOTLPVersion$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputOTLPVersion
> = z.nativeEnum(CreateInputOTLPVersion);

/** @internal */
export const CreateInputOTLPVersion$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputOTLPVersion
> = CreateInputOTLPVersion$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputOTLPVersion$ {
  /** @deprecated use `CreateInputOTLPVersion$inboundSchema` instead. */
  export const inboundSchema = CreateInputOTLPVersion$inboundSchema;
  /** @deprecated use `CreateInputOTLPVersion$outboundSchema` instead. */
  export const outboundSchema = CreateInputOTLPVersion$outboundSchema;
}

/** @internal */
export const CreateInputAuthenticationTypeOpenTelemetry$inboundSchema:
  z.ZodNativeEnum<typeof CreateInputAuthenticationTypeOpenTelemetry> = z
    .nativeEnum(CreateInputAuthenticationTypeOpenTelemetry);

/** @internal */
export const CreateInputAuthenticationTypeOpenTelemetry$outboundSchema:
  z.ZodNativeEnum<typeof CreateInputAuthenticationTypeOpenTelemetry> =
    CreateInputAuthenticationTypeOpenTelemetry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputAuthenticationTypeOpenTelemetry$ {
  /** @deprecated use `CreateInputAuthenticationTypeOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputAuthenticationTypeOpenTelemetry$inboundSchema;
  /** @deprecated use `CreateInputAuthenticationTypeOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputAuthenticationTypeOpenTelemetry$outboundSchema;
}

/** @internal */
export const CreateInputMetadatumOpenTelemetry$inboundSchema: z.ZodType<
  CreateInputMetadatumOpenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type CreateInputMetadatumOpenTelemetry$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CreateInputMetadatumOpenTelemetry$outboundSchema: z.ZodType<
  CreateInputMetadatumOpenTelemetry$Outbound,
  z.ZodTypeDef,
  CreateInputMetadatumOpenTelemetry
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputMetadatumOpenTelemetry$ {
  /** @deprecated use `CreateInputMetadatumOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = CreateInputMetadatumOpenTelemetry$inboundSchema;
  /** @deprecated use `CreateInputMetadatumOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputMetadatumOpenTelemetry$outboundSchema;
  /** @deprecated use `CreateInputMetadatumOpenTelemetry$Outbound` instead. */
  export type Outbound = CreateInputMetadatumOpenTelemetry$Outbound;
}

export function createInputMetadatumOpenTelemetryToJSON(
  createInputMetadatumOpenTelemetry: CreateInputMetadatumOpenTelemetry,
): string {
  return JSON.stringify(
    CreateInputMetadatumOpenTelemetry$outboundSchema.parse(
      createInputMetadatumOpenTelemetry,
    ),
  );
}

export function createInputMetadatumOpenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<CreateInputMetadatumOpenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateInputMetadatumOpenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateInputMetadatumOpenTelemetry' from JSON`,
  );
}

/** @internal */
export const CreateInputOauthParamOpenTelemetry$inboundSchema: z.ZodType<
  CreateInputOauthParamOpenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type CreateInputOauthParamOpenTelemetry$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CreateInputOauthParamOpenTelemetry$outboundSchema: z.ZodType<
  CreateInputOauthParamOpenTelemetry$Outbound,
  z.ZodTypeDef,
  CreateInputOauthParamOpenTelemetry
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputOauthParamOpenTelemetry$ {
  /** @deprecated use `CreateInputOauthParamOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = CreateInputOauthParamOpenTelemetry$inboundSchema;
  /** @deprecated use `CreateInputOauthParamOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputOauthParamOpenTelemetry$outboundSchema;
  /** @deprecated use `CreateInputOauthParamOpenTelemetry$Outbound` instead. */
  export type Outbound = CreateInputOauthParamOpenTelemetry$Outbound;
}

export function createInputOauthParamOpenTelemetryToJSON(
  createInputOauthParamOpenTelemetry: CreateInputOauthParamOpenTelemetry,
): string {
  return JSON.stringify(
    CreateInputOauthParamOpenTelemetry$outboundSchema.parse(
      createInputOauthParamOpenTelemetry,
    ),
  );
}

export function createInputOauthParamOpenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<CreateInputOauthParamOpenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateInputOauthParamOpenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateInputOauthParamOpenTelemetry' from JSON`,
  );
}

/** @internal */
export const CreateInputOauthHeaderOpenTelemetry$inboundSchema: z.ZodType<
  CreateInputOauthHeaderOpenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type CreateInputOauthHeaderOpenTelemetry$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CreateInputOauthHeaderOpenTelemetry$outboundSchema: z.ZodType<
  CreateInputOauthHeaderOpenTelemetry$Outbound,
  z.ZodTypeDef,
  CreateInputOauthHeaderOpenTelemetry
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputOauthHeaderOpenTelemetry$ {
  /** @deprecated use `CreateInputOauthHeaderOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputOauthHeaderOpenTelemetry$inboundSchema;
  /** @deprecated use `CreateInputOauthHeaderOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputOauthHeaderOpenTelemetry$outboundSchema;
  /** @deprecated use `CreateInputOauthHeaderOpenTelemetry$Outbound` instead. */
  export type Outbound = CreateInputOauthHeaderOpenTelemetry$Outbound;
}

export function createInputOauthHeaderOpenTelemetryToJSON(
  createInputOauthHeaderOpenTelemetry: CreateInputOauthHeaderOpenTelemetry,
): string {
  return JSON.stringify(
    CreateInputOauthHeaderOpenTelemetry$outboundSchema.parse(
      createInputOauthHeaderOpenTelemetry,
    ),
  );
}

export function createInputOauthHeaderOpenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<CreateInputOauthHeaderOpenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateInputOauthHeaderOpenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateInputOauthHeaderOpenTelemetry' from JSON`,
  );
}

/** @internal */
export const InputOpenTelemetry$inboundSchema: z.ZodType<
  InputOpenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateInputTypeOpenTelemetry$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionOpenTelemetry$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqOpenTelemetry$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number().default(4317),
  tls: z.lazy(() => TLSSettingsServerSideOpenTelemetry$inboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.any().optional(),
  captureHeaders: z.any().optional(),
  activityLogSampleRate: z.any().optional(),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(15),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  protocol: CreateInputProtocolOpenTelemetry$inboundSchema.default("grpc"),
  extractSpans: z.boolean().default(false),
  extractMetrics: z.boolean().default(false),
  otlpVersion: CreateInputOTLPVersion$inboundSchema.default("0.10.0"),
  authType: CreateInputAuthenticationTypeOpenTelemetry$inboundSchema.default(
    "none",
  ),
  metadata: z.array(
    z.lazy(() => CreateInputMetadatumOpenTelemetry$inboundSchema),
  ).optional(),
  maxActiveCxn: z.number().default(1000),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(
    z.lazy(() => CreateInputOauthParamOpenTelemetry$inboundSchema),
  ).optional(),
  oauthHeaders: z.array(
    z.lazy(() => CreateInputOauthHeaderOpenTelemetry$inboundSchema),
  ).optional(),
  extractLogs: z.boolean().default(false),
});

/** @internal */
export type InputOpenTelemetry$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionOpenTelemetry$Outbound> | undefined;
  pq?: PqOpenTelemetry$Outbound | undefined;
  host: string;
  port: number;
  tls?: TLSSettingsServerSideOpenTelemetry$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader?: any | undefined;
  captureHeaders?: any | undefined;
  activityLogSampleRate?: any | undefined;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  protocol: string;
  extractSpans: boolean;
  extractMetrics: boolean;
  otlpVersion: string;
  authType: string;
  metadata?: Array<CreateInputMetadatumOpenTelemetry$Outbound> | undefined;
  maxActiveCxn: number;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<CreateInputOauthParamOpenTelemetry$Outbound> | undefined;
  oauthHeaders?:
    | Array<CreateInputOauthHeaderOpenTelemetry$Outbound>
    | undefined;
  extractLogs: boolean;
};

/** @internal */
export const InputOpenTelemetry$outboundSchema: z.ZodType<
  InputOpenTelemetry$Outbound,
  z.ZodTypeDef,
  InputOpenTelemetry
> = z.object({
  id: z.string(),
  type: CreateInputTypeOpenTelemetry$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionOpenTelemetry$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqOpenTelemetry$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number().default(4317),
  tls: z.lazy(() => TLSSettingsServerSideOpenTelemetry$outboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.any().optional(),
  captureHeaders: z.any().optional(),
  activityLogSampleRate: z.any().optional(),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(15),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  protocol: CreateInputProtocolOpenTelemetry$outboundSchema.default("grpc"),
  extractSpans: z.boolean().default(false),
  extractMetrics: z.boolean().default(false),
  otlpVersion: CreateInputOTLPVersion$outboundSchema.default("0.10.0"),
  authType: CreateInputAuthenticationTypeOpenTelemetry$outboundSchema.default(
    "none",
  ),
  metadata: z.array(
    z.lazy(() => CreateInputMetadatumOpenTelemetry$outboundSchema),
  ).optional(),
  maxActiveCxn: z.number().default(1000),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(
    z.lazy(() => CreateInputOauthParamOpenTelemetry$outboundSchema),
  ).optional(),
  oauthHeaders: z.array(
    z.lazy(() => CreateInputOauthHeaderOpenTelemetry$outboundSchema),
  ).optional(),
  extractLogs: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOpenTelemetry$ {
  /** @deprecated use `InputOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = InputOpenTelemetry$inboundSchema;
  /** @deprecated use `InputOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema = InputOpenTelemetry$outboundSchema;
  /** @deprecated use `InputOpenTelemetry$Outbound` instead. */
  export type Outbound = InputOpenTelemetry$Outbound;
}

export function inputOpenTelemetryToJSON(
  inputOpenTelemetry: InputOpenTelemetry,
): string {
  return JSON.stringify(
    InputOpenTelemetry$outboundSchema.parse(inputOpenTelemetry),
  );
}

export function inputOpenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<InputOpenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOpenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOpenTelemetry' from JSON`,
  );
}

/** @internal */
export const CreateInputTypeSnmp$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeSnmp
> = z.nativeEnum(CreateInputTypeSnmp);

/** @internal */
export const CreateInputTypeSnmp$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeSnmp
> = CreateInputTypeSnmp$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputTypeSnmp$ {
  /** @deprecated use `CreateInputTypeSnmp$inboundSchema` instead. */
  export const inboundSchema = CreateInputTypeSnmp$inboundSchema;
  /** @deprecated use `CreateInputTypeSnmp$outboundSchema` instead. */
  export const outboundSchema = CreateInputTypeSnmp$outboundSchema;
}

/** @internal */
export const ConnectionSnmp$inboundSchema: z.ZodType<
  ConnectionSnmp,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionSnmp$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionSnmp$outboundSchema: z.ZodType<
  ConnectionSnmp$Outbound,
  z.ZodTypeDef,
  ConnectionSnmp
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionSnmp$ {
  /** @deprecated use `ConnectionSnmp$inboundSchema` instead. */
  export const inboundSchema = ConnectionSnmp$inboundSchema;
  /** @deprecated use `ConnectionSnmp$outboundSchema` instead. */
  export const outboundSchema = ConnectionSnmp$outboundSchema;
  /** @deprecated use `ConnectionSnmp$Outbound` instead. */
  export type Outbound = ConnectionSnmp$Outbound;
}

export function connectionSnmpToJSON(connectionSnmp: ConnectionSnmp): string {
  return JSON.stringify(ConnectionSnmp$outboundSchema.parse(connectionSnmp));
}

export function connectionSnmpFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionSnmp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionSnmp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionSnmp' from JSON`,
  );
}

/** @internal */
export const ModeSnmp$inboundSchema: z.ZodNativeEnum<typeof ModeSnmp> = z
  .nativeEnum(ModeSnmp);

/** @internal */
export const ModeSnmp$outboundSchema: z.ZodNativeEnum<typeof ModeSnmp> =
  ModeSnmp$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeSnmp$ {
  /** @deprecated use `ModeSnmp$inboundSchema` instead. */
  export const inboundSchema = ModeSnmp$inboundSchema;
  /** @deprecated use `ModeSnmp$outboundSchema` instead. */
  export const outboundSchema = ModeSnmp$outboundSchema;
}

/** @internal */
export const CompressionSnmp$inboundSchema: z.ZodNativeEnum<
  typeof CompressionSnmp
> = z.nativeEnum(CompressionSnmp);

/** @internal */
export const CompressionSnmp$outboundSchema: z.ZodNativeEnum<
  typeof CompressionSnmp
> = CompressionSnmp$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionSnmp$ {
  /** @deprecated use `CompressionSnmp$inboundSchema` instead. */
  export const inboundSchema = CompressionSnmp$inboundSchema;
  /** @deprecated use `CompressionSnmp$outboundSchema` instead. */
  export const outboundSchema = CompressionSnmp$outboundSchema;
}

/** @internal */
export const PqSnmp$inboundSchema: z.ZodType<PqSnmp, z.ZodTypeDef, unknown> = z
  .object({
    mode: ModeSnmp$inboundSchema.default("always"),
    maxBufferSize: z.number().default(1000),
    commitFrequency: z.number().default(42),
    maxFileSize: z.string().default("1 MB"),
    maxSize: z.string().default("5GB"),
    path: z.string().default("$CRIBL_HOME/state/queues"),
    compress: CompressionSnmp$inboundSchema.default("none"),
  });

/** @internal */
export type PqSnmp$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqSnmp$outboundSchema: z.ZodType<
  PqSnmp$Outbound,
  z.ZodTypeDef,
  PqSnmp
> = z.object({
  mode: ModeSnmp$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionSnmp$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqSnmp$ {
  /** @deprecated use `PqSnmp$inboundSchema` instead. */
  export const inboundSchema = PqSnmp$inboundSchema;
  /** @deprecated use `PqSnmp$outboundSchema` instead. */
  export const outboundSchema = PqSnmp$outboundSchema;
  /** @deprecated use `PqSnmp$Outbound` instead. */
  export type Outbound = PqSnmp$Outbound;
}

export function pqSnmpToJSON(pqSnmp: PqSnmp): string {
  return JSON.stringify(PqSnmp$outboundSchema.parse(pqSnmp));
}

export function pqSnmpFromJSON(
  jsonString: string,
): SafeParseResult<PqSnmp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqSnmp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqSnmp' from JSON`,
  );
}

/** @internal */
export const AuthenticationProtocol$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationProtocol
> = z.nativeEnum(AuthenticationProtocol);

/** @internal */
export const AuthenticationProtocol$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationProtocol
> = AuthenticationProtocol$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationProtocol$ {
  /** @deprecated use `AuthenticationProtocol$inboundSchema` instead. */
  export const inboundSchema = AuthenticationProtocol$inboundSchema;
  /** @deprecated use `AuthenticationProtocol$outboundSchema` instead. */
  export const outboundSchema = AuthenticationProtocol$outboundSchema;
}

/** @internal */
export const V3User$inboundSchema: z.ZodType<V3User, z.ZodTypeDef, unknown> = z
  .object({
    name: z.string(),
    authProtocol: AuthenticationProtocol$inboundSchema.default("none"),
    authKey: z.any().optional(),
    privProtocol: z.string().default("none"),
  });

/** @internal */
export type V3User$Outbound = {
  name: string;
  authProtocol: string;
  authKey?: any | undefined;
  privProtocol: string;
};

/** @internal */
export const V3User$outboundSchema: z.ZodType<
  V3User$Outbound,
  z.ZodTypeDef,
  V3User
> = z.object({
  name: z.string(),
  authProtocol: AuthenticationProtocol$outboundSchema.default("none"),
  authKey: z.any().optional(),
  privProtocol: z.string().default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace V3User$ {
  /** @deprecated use `V3User$inboundSchema` instead. */
  export const inboundSchema = V3User$inboundSchema;
  /** @deprecated use `V3User$outboundSchema` instead. */
  export const outboundSchema = V3User$outboundSchema;
  /** @deprecated use `V3User$Outbound` instead. */
  export type Outbound = V3User$Outbound;
}

export function v3UserToJSON(v3User: V3User): string {
  return JSON.stringify(V3User$outboundSchema.parse(v3User));
}

export function v3UserFromJSON(
  jsonString: string,
): SafeParseResult<V3User, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => V3User$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'V3User' from JSON`,
  );
}

/** @internal */
export const SNMPv3Authentication$inboundSchema: z.ZodType<
  SNMPv3Authentication,
  z.ZodTypeDef,
  unknown
> = z.object({
  v3AuthEnabled: z.boolean().default(false),
  allowUnmatchedTrap: z.boolean().default(false),
  v3Users: z.array(z.lazy(() => V3User$inboundSchema)).optional(),
});

/** @internal */
export type SNMPv3Authentication$Outbound = {
  v3AuthEnabled: boolean;
  allowUnmatchedTrap: boolean;
  v3Users?: Array<V3User$Outbound> | undefined;
};

/** @internal */
export const SNMPv3Authentication$outboundSchema: z.ZodType<
  SNMPv3Authentication$Outbound,
  z.ZodTypeDef,
  SNMPv3Authentication
> = z.object({
  v3AuthEnabled: z.boolean().default(false),
  allowUnmatchedTrap: z.boolean().default(false),
  v3Users: z.array(z.lazy(() => V3User$outboundSchema)).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SNMPv3Authentication$ {
  /** @deprecated use `SNMPv3Authentication$inboundSchema` instead. */
  export const inboundSchema = SNMPv3Authentication$inboundSchema;
  /** @deprecated use `SNMPv3Authentication$outboundSchema` instead. */
  export const outboundSchema = SNMPv3Authentication$outboundSchema;
  /** @deprecated use `SNMPv3Authentication$Outbound` instead. */
  export type Outbound = SNMPv3Authentication$Outbound;
}

export function snmPv3AuthenticationToJSON(
  snmPv3Authentication: SNMPv3Authentication,
): string {
  return JSON.stringify(
    SNMPv3Authentication$outboundSchema.parse(snmPv3Authentication),
  );
}

export function snmPv3AuthenticationFromJSON(
  jsonString: string,
): SafeParseResult<SNMPv3Authentication, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SNMPv3Authentication$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SNMPv3Authentication' from JSON`,
  );
}

/** @internal */
export const MetadatumSnmp$inboundSchema: z.ZodType<
  MetadatumSnmp,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumSnmp$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumSnmp$outboundSchema: z.ZodType<
  MetadatumSnmp$Outbound,
  z.ZodTypeDef,
  MetadatumSnmp
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumSnmp$ {
  /** @deprecated use `MetadatumSnmp$inboundSchema` instead. */
  export const inboundSchema = MetadatumSnmp$inboundSchema;
  /** @deprecated use `MetadatumSnmp$outboundSchema` instead. */
  export const outboundSchema = MetadatumSnmp$outboundSchema;
  /** @deprecated use `MetadatumSnmp$Outbound` instead. */
  export type Outbound = MetadatumSnmp$Outbound;
}

export function metadatumSnmpToJSON(metadatumSnmp: MetadatumSnmp): string {
  return JSON.stringify(MetadatumSnmp$outboundSchema.parse(metadatumSnmp));
}

export function metadatumSnmpFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumSnmp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumSnmp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumSnmp' from JSON`,
  );
}

/** @internal */
export const InputSnmp$inboundSchema: z.ZodType<
  InputSnmp,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateInputTypeSnmp$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionSnmp$inboundSchema)).optional(),
  pq: z.lazy(() => PqSnmp$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number().default(162),
  snmpV3Auth: z.lazy(() => SNMPv3Authentication$inboundSchema).optional(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  metadata: z.array(z.lazy(() => MetadatumSnmp$inboundSchema)).optional(),
  udpSocketRxBufSize: z.number().optional(),
  varbindsWithTypes: z.boolean().default(false),
  bestEffortParsing: z.boolean().default(false),
  description: z.string().optional(),
});

/** @internal */
export type InputSnmp$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionSnmp$Outbound> | undefined;
  pq?: PqSnmp$Outbound | undefined;
  host: string;
  port: number;
  snmpV3Auth?: SNMPv3Authentication$Outbound | undefined;
  maxBufferSize: number;
  ipWhitelistRegex: string;
  metadata?: Array<MetadatumSnmp$Outbound> | undefined;
  udpSocketRxBufSize?: number | undefined;
  varbindsWithTypes: boolean;
  bestEffortParsing: boolean;
  description?: string | undefined;
};

/** @internal */
export const InputSnmp$outboundSchema: z.ZodType<
  InputSnmp$Outbound,
  z.ZodTypeDef,
  InputSnmp
> = z.object({
  id: z.string(),
  type: CreateInputTypeSnmp$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionSnmp$outboundSchema)).optional(),
  pq: z.lazy(() => PqSnmp$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number().default(162),
  snmpV3Auth: z.lazy(() => SNMPv3Authentication$outboundSchema).optional(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  metadata: z.array(z.lazy(() => MetadatumSnmp$outboundSchema)).optional(),
  udpSocketRxBufSize: z.number().optional(),
  varbindsWithTypes: z.boolean().default(false),
  bestEffortParsing: z.boolean().default(false),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSnmp$ {
  /** @deprecated use `InputSnmp$inboundSchema` instead. */
  export const inboundSchema = InputSnmp$inboundSchema;
  /** @deprecated use `InputSnmp$outboundSchema` instead. */
  export const outboundSchema = InputSnmp$outboundSchema;
  /** @deprecated use `InputSnmp$Outbound` instead. */
  export type Outbound = InputSnmp$Outbound;
}

export function inputSnmpToJSON(inputSnmp: InputSnmp): string {
  return JSON.stringify(InputSnmp$outboundSchema.parse(inputSnmp));
}

export function inputSnmpFromJSON(
  jsonString: string,
): SafeParseResult<InputSnmp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSnmp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSnmp' from JSON`,
  );
}

/** @internal */
export const TypeS3Inventory$inboundSchema: z.ZodNativeEnum<
  typeof TypeS3Inventory
> = z.nativeEnum(TypeS3Inventory);

/** @internal */
export const TypeS3Inventory$outboundSchema: z.ZodNativeEnum<
  typeof TypeS3Inventory
> = TypeS3Inventory$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeS3Inventory$ {
  /** @deprecated use `TypeS3Inventory$inboundSchema` instead. */
  export const inboundSchema = TypeS3Inventory$inboundSchema;
  /** @deprecated use `TypeS3Inventory$outboundSchema` instead. */
  export const outboundSchema = TypeS3Inventory$outboundSchema;
}

/** @internal */
export const ConnectionS3Inventory$inboundSchema: z.ZodType<
  ConnectionS3Inventory,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionS3Inventory$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionS3Inventory$outboundSchema: z.ZodType<
  ConnectionS3Inventory$Outbound,
  z.ZodTypeDef,
  ConnectionS3Inventory
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionS3Inventory$ {
  /** @deprecated use `ConnectionS3Inventory$inboundSchema` instead. */
  export const inboundSchema = ConnectionS3Inventory$inboundSchema;
  /** @deprecated use `ConnectionS3Inventory$outboundSchema` instead. */
  export const outboundSchema = ConnectionS3Inventory$outboundSchema;
  /** @deprecated use `ConnectionS3Inventory$Outbound` instead. */
  export type Outbound = ConnectionS3Inventory$Outbound;
}

export function connectionS3InventoryToJSON(
  connectionS3Inventory: ConnectionS3Inventory,
): string {
  return JSON.stringify(
    ConnectionS3Inventory$outboundSchema.parse(connectionS3Inventory),
  );
}

export function connectionS3InventoryFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionS3Inventory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionS3Inventory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionS3Inventory' from JSON`,
  );
}

/** @internal */
export const ModeS3Inventory$inboundSchema: z.ZodNativeEnum<
  typeof ModeS3Inventory
> = z.nativeEnum(ModeS3Inventory);

/** @internal */
export const ModeS3Inventory$outboundSchema: z.ZodNativeEnum<
  typeof ModeS3Inventory
> = ModeS3Inventory$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeS3Inventory$ {
  /** @deprecated use `ModeS3Inventory$inboundSchema` instead. */
  export const inboundSchema = ModeS3Inventory$inboundSchema;
  /** @deprecated use `ModeS3Inventory$outboundSchema` instead. */
  export const outboundSchema = ModeS3Inventory$outboundSchema;
}

/** @internal */
export const CompressionS3Inventory$inboundSchema: z.ZodNativeEnum<
  typeof CompressionS3Inventory
> = z.nativeEnum(CompressionS3Inventory);

/** @internal */
export const CompressionS3Inventory$outboundSchema: z.ZodNativeEnum<
  typeof CompressionS3Inventory
> = CompressionS3Inventory$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionS3Inventory$ {
  /** @deprecated use `CompressionS3Inventory$inboundSchema` instead. */
  export const inboundSchema = CompressionS3Inventory$inboundSchema;
  /** @deprecated use `CompressionS3Inventory$outboundSchema` instead. */
  export const outboundSchema = CompressionS3Inventory$outboundSchema;
}

/** @internal */
export const PqS3Inventory$inboundSchema: z.ZodType<
  PqS3Inventory,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeS3Inventory$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionS3Inventory$inboundSchema.default("none"),
});

/** @internal */
export type PqS3Inventory$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqS3Inventory$outboundSchema: z.ZodType<
  PqS3Inventory$Outbound,
  z.ZodTypeDef,
  PqS3Inventory
> = z.object({
  mode: ModeS3Inventory$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionS3Inventory$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqS3Inventory$ {
  /** @deprecated use `PqS3Inventory$inboundSchema` instead. */
  export const inboundSchema = PqS3Inventory$inboundSchema;
  /** @deprecated use `PqS3Inventory$outboundSchema` instead. */
  export const outboundSchema = PqS3Inventory$outboundSchema;
  /** @deprecated use `PqS3Inventory$Outbound` instead. */
  export type Outbound = PqS3Inventory$Outbound;
}

export function pqS3InventoryToJSON(pqS3Inventory: PqS3Inventory): string {
  return JSON.stringify(PqS3Inventory$outboundSchema.parse(pqS3Inventory));
}

export function pqS3InventoryFromJSON(
  jsonString: string,
): SafeParseResult<PqS3Inventory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqS3Inventory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqS3Inventory' from JSON`,
  );
}

/** @internal */
export const AuthenticationMethodS3Inventory$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodS3Inventory
> = z.nativeEnum(AuthenticationMethodS3Inventory);

/** @internal */
export const AuthenticationMethodS3Inventory$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodS3Inventory
> = AuthenticationMethodS3Inventory$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodS3Inventory$ {
  /** @deprecated use `AuthenticationMethodS3Inventory$inboundSchema` instead. */
  export const inboundSchema = AuthenticationMethodS3Inventory$inboundSchema;
  /** @deprecated use `AuthenticationMethodS3Inventory$outboundSchema` instead. */
  export const outboundSchema = AuthenticationMethodS3Inventory$outboundSchema;
}

/** @internal */
export const SignatureVersionS3Inventory$inboundSchema: z.ZodNativeEnum<
  typeof SignatureVersionS3Inventory
> = z.nativeEnum(SignatureVersionS3Inventory);

/** @internal */
export const SignatureVersionS3Inventory$outboundSchema: z.ZodNativeEnum<
  typeof SignatureVersionS3Inventory
> = SignatureVersionS3Inventory$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignatureVersionS3Inventory$ {
  /** @deprecated use `SignatureVersionS3Inventory$inboundSchema` instead. */
  export const inboundSchema = SignatureVersionS3Inventory$inboundSchema;
  /** @deprecated use `SignatureVersionS3Inventory$outboundSchema` instead. */
  export const outboundSchema = SignatureVersionS3Inventory$outboundSchema;
}

/** @internal */
export const PreprocessS3Inventory$inboundSchema: z.ZodType<
  PreprocessS3Inventory,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  command: z.string().optional(),
  args: z.array(z.string()).optional(),
});

/** @internal */
export type PreprocessS3Inventory$Outbound = {
  disabled: boolean;
  command?: string | undefined;
  args?: Array<string> | undefined;
};

/** @internal */
export const PreprocessS3Inventory$outboundSchema: z.ZodType<
  PreprocessS3Inventory$Outbound,
  z.ZodTypeDef,
  PreprocessS3Inventory
> = z.object({
  disabled: z.boolean().default(true),
  command: z.string().optional(),
  args: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PreprocessS3Inventory$ {
  /** @deprecated use `PreprocessS3Inventory$inboundSchema` instead. */
  export const inboundSchema = PreprocessS3Inventory$inboundSchema;
  /** @deprecated use `PreprocessS3Inventory$outboundSchema` instead. */
  export const outboundSchema = PreprocessS3Inventory$outboundSchema;
  /** @deprecated use `PreprocessS3Inventory$Outbound` instead. */
  export type Outbound = PreprocessS3Inventory$Outbound;
}

export function preprocessS3InventoryToJSON(
  preprocessS3Inventory: PreprocessS3Inventory,
): string {
  return JSON.stringify(
    PreprocessS3Inventory$outboundSchema.parse(preprocessS3Inventory),
  );
}

export function preprocessS3InventoryFromJSON(
  jsonString: string,
): SafeParseResult<PreprocessS3Inventory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreprocessS3Inventory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreprocessS3Inventory' from JSON`,
  );
}

/** @internal */
export const MetadatumS3Inventory$inboundSchema: z.ZodType<
  MetadatumS3Inventory,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumS3Inventory$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumS3Inventory$outboundSchema: z.ZodType<
  MetadatumS3Inventory$Outbound,
  z.ZodTypeDef,
  MetadatumS3Inventory
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumS3Inventory$ {
  /** @deprecated use `MetadatumS3Inventory$inboundSchema` instead. */
  export const inboundSchema = MetadatumS3Inventory$inboundSchema;
  /** @deprecated use `MetadatumS3Inventory$outboundSchema` instead. */
  export const outboundSchema = MetadatumS3Inventory$outboundSchema;
  /** @deprecated use `MetadatumS3Inventory$Outbound` instead. */
  export type Outbound = MetadatumS3Inventory$Outbound;
}

export function metadatumS3InventoryToJSON(
  metadatumS3Inventory: MetadatumS3Inventory,
): string {
  return JSON.stringify(
    MetadatumS3Inventory$outboundSchema.parse(metadatumS3Inventory),
  );
}

export function metadatumS3InventoryFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumS3Inventory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumS3Inventory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumS3Inventory' from JSON`,
  );
}

/** @internal */
export const CheckpointingS3Inventory$inboundSchema: z.ZodType<
  CheckpointingS3Inventory,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().default(false),
  retries: z.number().default(5),
});

/** @internal */
export type CheckpointingS3Inventory$Outbound = {
  enabled: boolean;
  retries: number;
};

/** @internal */
export const CheckpointingS3Inventory$outboundSchema: z.ZodType<
  CheckpointingS3Inventory$Outbound,
  z.ZodTypeDef,
  CheckpointingS3Inventory
> = z.object({
  enabled: z.boolean().default(false),
  retries: z.number().default(5),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CheckpointingS3Inventory$ {
  /** @deprecated use `CheckpointingS3Inventory$inboundSchema` instead. */
  export const inboundSchema = CheckpointingS3Inventory$inboundSchema;
  /** @deprecated use `CheckpointingS3Inventory$outboundSchema` instead. */
  export const outboundSchema = CheckpointingS3Inventory$outboundSchema;
  /** @deprecated use `CheckpointingS3Inventory$Outbound` instead. */
  export type Outbound = CheckpointingS3Inventory$Outbound;
}

export function checkpointingS3InventoryToJSON(
  checkpointingS3Inventory: CheckpointingS3Inventory,
): string {
  return JSON.stringify(
    CheckpointingS3Inventory$outboundSchema.parse(checkpointingS3Inventory),
  );
}

export function checkpointingS3InventoryFromJSON(
  jsonString: string,
): SafeParseResult<CheckpointingS3Inventory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckpointingS3Inventory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckpointingS3Inventory' from JSON`,
  );
}

/** @internal */
export const TagAfterProcessingS3Inventory$inboundSchema: z.ZodNativeEnum<
  typeof TagAfterProcessingS3Inventory
> = z.nativeEnum(TagAfterProcessingS3Inventory);

/** @internal */
export const TagAfterProcessingS3Inventory$outboundSchema: z.ZodNativeEnum<
  typeof TagAfterProcessingS3Inventory
> = TagAfterProcessingS3Inventory$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TagAfterProcessingS3Inventory$ {
  /** @deprecated use `TagAfterProcessingS3Inventory$inboundSchema` instead. */
  export const inboundSchema = TagAfterProcessingS3Inventory$inboundSchema;
  /** @deprecated use `TagAfterProcessingS3Inventory$outboundSchema` instead. */
  export const outboundSchema = TagAfterProcessingS3Inventory$outboundSchema;
}

/** @internal */
export const InputS3Inventory$inboundSchema: z.ZodType<
  InputS3Inventory,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeS3Inventory$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionS3Inventory$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqS3Inventory$inboundSchema).optional(),
  queueName: z.string(),
  fileFilter: z.string().default("/.*/"),
  awsAccountId: z.string().optional(),
  awsAuthenticationMethod: AuthenticationMethodS3Inventory$inboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionS3Inventory$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  maxMessages: z.number().default(1),
  visibilityTimeout: z.number().default(600),
  numReceivers: z.number().default(1),
  socketTimeout: z.number().default(300),
  skipOnError: z.boolean().default(false),
  enableAssumeRole: z.boolean().default(true),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  enableSQSAssumeRole: z.boolean().default(false),
  preprocess: z.lazy(() => PreprocessS3Inventory$inboundSchema).optional(),
  metadata: z.array(z.lazy(() => MetadatumS3Inventory$inboundSchema))
    .optional(),
  parquetChunkSizeMB: z.number().default(5),
  parquetChunkDownloadTimeout: z.number().default(600),
  checkpointing: z.lazy(() => CheckpointingS3Inventory$inboundSchema)
    .optional(),
  pollTimeout: z.number().default(10),
  checksumSuffix: z.string().default("checksum"),
  maxManifestSizeKB: z.number().int().default(4096),
  validateInventoryFiles: z.boolean().default(false),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  tagAfterProcessing: TagAfterProcessingS3Inventory$inboundSchema.optional(),
  processedTagKey: z.string().optional(),
  processedTagValue: z.string().optional(),
});

/** @internal */
export type InputS3Inventory$Outbound = {
  id: string;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionS3Inventory$Outbound> | undefined;
  pq?: PqS3Inventory$Outbound | undefined;
  queueName: string;
  fileFilter: string;
  awsAccountId?: string | undefined;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  maxMessages: number;
  visibilityTimeout: number;
  numReceivers: number;
  socketTimeout: number;
  skipOnError: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  enableSQSAssumeRole: boolean;
  preprocess?: PreprocessS3Inventory$Outbound | undefined;
  metadata?: Array<MetadatumS3Inventory$Outbound> | undefined;
  parquetChunkSizeMB: number;
  parquetChunkDownloadTimeout: number;
  checkpointing?: CheckpointingS3Inventory$Outbound | undefined;
  pollTimeout: number;
  checksumSuffix: string;
  maxManifestSizeKB: number;
  validateInventoryFiles: boolean;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  tagAfterProcessing?: string | undefined;
  processedTagKey?: string | undefined;
  processedTagValue?: string | undefined;
};

/** @internal */
export const InputS3Inventory$outboundSchema: z.ZodType<
  InputS3Inventory$Outbound,
  z.ZodTypeDef,
  InputS3Inventory
> = z.object({
  id: z.string(),
  type: TypeS3Inventory$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionS3Inventory$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqS3Inventory$outboundSchema).optional(),
  queueName: z.string(),
  fileFilter: z.string().default("/.*/"),
  awsAccountId: z.string().optional(),
  awsAuthenticationMethod: AuthenticationMethodS3Inventory$outboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionS3Inventory$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  maxMessages: z.number().default(1),
  visibilityTimeout: z.number().default(600),
  numReceivers: z.number().default(1),
  socketTimeout: z.number().default(300),
  skipOnError: z.boolean().default(false),
  enableAssumeRole: z.boolean().default(true),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  enableSQSAssumeRole: z.boolean().default(false),
  preprocess: z.lazy(() => PreprocessS3Inventory$outboundSchema).optional(),
  metadata: z.array(z.lazy(() => MetadatumS3Inventory$outboundSchema))
    .optional(),
  parquetChunkSizeMB: z.number().default(5),
  parquetChunkDownloadTimeout: z.number().default(600),
  checkpointing: z.lazy(() => CheckpointingS3Inventory$outboundSchema)
    .optional(),
  pollTimeout: z.number().default(10),
  checksumSuffix: z.string().default("checksum"),
  maxManifestSizeKB: z.number().int().default(4096),
  validateInventoryFiles: z.boolean().default(false),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  tagAfterProcessing: TagAfterProcessingS3Inventory$outboundSchema.optional(),
  processedTagKey: z.string().optional(),
  processedTagValue: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3Inventory$ {
  /** @deprecated use `InputS3Inventory$inboundSchema` instead. */
  export const inboundSchema = InputS3Inventory$inboundSchema;
  /** @deprecated use `InputS3Inventory$outboundSchema` instead. */
  export const outboundSchema = InputS3Inventory$outboundSchema;
  /** @deprecated use `InputS3Inventory$Outbound` instead. */
  export type Outbound = InputS3Inventory$Outbound;
}

export function inputS3InventoryToJSON(
  inputS3Inventory: InputS3Inventory,
): string {
  return JSON.stringify(
    InputS3Inventory$outboundSchema.parse(inputS3Inventory),
  );
}

export function inputS3InventoryFromJSON(
  jsonString: string,
): SafeParseResult<InputS3Inventory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputS3Inventory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputS3Inventory' from JSON`,
  );
}

/** @internal */
export const CreateInputTypeS3$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeS3
> = z.nativeEnum(CreateInputTypeS3);

/** @internal */
export const CreateInputTypeS3$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeS3
> = CreateInputTypeS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputTypeS3$ {
  /** @deprecated use `CreateInputTypeS3$inboundSchema` instead. */
  export const inboundSchema = CreateInputTypeS3$inboundSchema;
  /** @deprecated use `CreateInputTypeS3$outboundSchema` instead. */
  export const outboundSchema = CreateInputTypeS3$outboundSchema;
}

/** @internal */
export const ConnectionS3$inboundSchema: z.ZodType<
  ConnectionS3,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionS3$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionS3$outboundSchema: z.ZodType<
  ConnectionS3$Outbound,
  z.ZodTypeDef,
  ConnectionS3
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionS3$ {
  /** @deprecated use `ConnectionS3$inboundSchema` instead. */
  export const inboundSchema = ConnectionS3$inboundSchema;
  /** @deprecated use `ConnectionS3$outboundSchema` instead. */
  export const outboundSchema = ConnectionS3$outboundSchema;
  /** @deprecated use `ConnectionS3$Outbound` instead. */
  export type Outbound = ConnectionS3$Outbound;
}

export function connectionS3ToJSON(connectionS3: ConnectionS3): string {
  return JSON.stringify(ConnectionS3$outboundSchema.parse(connectionS3));
}

export function connectionS3FromJSON(
  jsonString: string,
): SafeParseResult<ConnectionS3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionS3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionS3' from JSON`,
  );
}

/** @internal */
export const ModeS3$inboundSchema: z.ZodNativeEnum<typeof ModeS3> = z
  .nativeEnum(ModeS3);

/** @internal */
export const ModeS3$outboundSchema: z.ZodNativeEnum<typeof ModeS3> =
  ModeS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeS3$ {
  /** @deprecated use `ModeS3$inboundSchema` instead. */
  export const inboundSchema = ModeS3$inboundSchema;
  /** @deprecated use `ModeS3$outboundSchema` instead. */
  export const outboundSchema = ModeS3$outboundSchema;
}

/** @internal */
export const PqCompressionS3$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressionS3
> = z.nativeEnum(PqCompressionS3);

/** @internal */
export const PqCompressionS3$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressionS3
> = PqCompressionS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressionS3$ {
  /** @deprecated use `PqCompressionS3$inboundSchema` instead. */
  export const inboundSchema = PqCompressionS3$inboundSchema;
  /** @deprecated use `PqCompressionS3$outboundSchema` instead. */
  export const outboundSchema = PqCompressionS3$outboundSchema;
}

/** @internal */
export const PqS3$inboundSchema: z.ZodType<PqS3, z.ZodTypeDef, unknown> = z
  .object({
    mode: ModeS3$inboundSchema.default("always"),
    maxBufferSize: z.number().default(1000),
    commitFrequency: z.number().default(42),
    maxFileSize: z.string().default("1 MB"),
    maxSize: z.string().default("5GB"),
    path: z.string().default("$CRIBL_HOME/state/queues"),
    compress: PqCompressionS3$inboundSchema.default("none"),
  });

/** @internal */
export type PqS3$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqS3$outboundSchema: z.ZodType<PqS3$Outbound, z.ZodTypeDef, PqS3> =
  z.object({
    mode: ModeS3$outboundSchema.default("always"),
    maxBufferSize: z.number().default(1000),
    commitFrequency: z.number().default(42),
    maxFileSize: z.string().default("1 MB"),
    maxSize: z.string().default("5GB"),
    path: z.string().default("$CRIBL_HOME/state/queues"),
    compress: PqCompressionS3$outboundSchema.default("none"),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqS3$ {
  /** @deprecated use `PqS3$inboundSchema` instead. */
  export const inboundSchema = PqS3$inboundSchema;
  /** @deprecated use `PqS3$outboundSchema` instead. */
  export const outboundSchema = PqS3$outboundSchema;
  /** @deprecated use `PqS3$Outbound` instead. */
  export type Outbound = PqS3$Outbound;
}

export function pqS3ToJSON(pqS3: PqS3): string {
  return JSON.stringify(PqS3$outboundSchema.parse(pqS3));
}

export function pqS3FromJSON(
  jsonString: string,
): SafeParseResult<PqS3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqS3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqS3' from JSON`,
  );
}

/** @internal */
export const CreateInputAuthenticationMethodS3$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputAuthenticationMethodS3
> = z.nativeEnum(CreateInputAuthenticationMethodS3);

/** @internal */
export const CreateInputAuthenticationMethodS3$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputAuthenticationMethodS3
> = CreateInputAuthenticationMethodS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputAuthenticationMethodS3$ {
  /** @deprecated use `CreateInputAuthenticationMethodS3$inboundSchema` instead. */
  export const inboundSchema = CreateInputAuthenticationMethodS3$inboundSchema;
  /** @deprecated use `CreateInputAuthenticationMethodS3$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputAuthenticationMethodS3$outboundSchema;
}

/** @internal */
export const CreateInputSignatureVersionS3$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputSignatureVersionS3
> = z.nativeEnum(CreateInputSignatureVersionS3);

/** @internal */
export const CreateInputSignatureVersionS3$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputSignatureVersionS3
> = CreateInputSignatureVersionS3$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputSignatureVersionS3$ {
  /** @deprecated use `CreateInputSignatureVersionS3$inboundSchema` instead. */
  export const inboundSchema = CreateInputSignatureVersionS3$inboundSchema;
  /** @deprecated use `CreateInputSignatureVersionS3$outboundSchema` instead. */
  export const outboundSchema = CreateInputSignatureVersionS3$outboundSchema;
}

/** @internal */
export const PreprocessS3$inboundSchema: z.ZodType<
  PreprocessS3,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  command: z.string().optional(),
  args: z.array(z.string()).optional(),
});

/** @internal */
export type PreprocessS3$Outbound = {
  disabled: boolean;
  command?: string | undefined;
  args?: Array<string> | undefined;
};

/** @internal */
export const PreprocessS3$outboundSchema: z.ZodType<
  PreprocessS3$Outbound,
  z.ZodTypeDef,
  PreprocessS3
> = z.object({
  disabled: z.boolean().default(true),
  command: z.string().optional(),
  args: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PreprocessS3$ {
  /** @deprecated use `PreprocessS3$inboundSchema` instead. */
  export const inboundSchema = PreprocessS3$inboundSchema;
  /** @deprecated use `PreprocessS3$outboundSchema` instead. */
  export const outboundSchema = PreprocessS3$outboundSchema;
  /** @deprecated use `PreprocessS3$Outbound` instead. */
  export type Outbound = PreprocessS3$Outbound;
}

export function preprocessS3ToJSON(preprocessS3: PreprocessS3): string {
  return JSON.stringify(PreprocessS3$outboundSchema.parse(preprocessS3));
}

export function preprocessS3FromJSON(
  jsonString: string,
): SafeParseResult<PreprocessS3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreprocessS3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreprocessS3' from JSON`,
  );
}

/** @internal */
export const MetadatumS3$inboundSchema: z.ZodType<
  MetadatumS3,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumS3$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumS3$outboundSchema: z.ZodType<
  MetadatumS3$Outbound,
  z.ZodTypeDef,
  MetadatumS3
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumS3$ {
  /** @deprecated use `MetadatumS3$inboundSchema` instead. */
  export const inboundSchema = MetadatumS3$inboundSchema;
  /** @deprecated use `MetadatumS3$outboundSchema` instead. */
  export const outboundSchema = MetadatumS3$outboundSchema;
  /** @deprecated use `MetadatumS3$Outbound` instead. */
  export type Outbound = MetadatumS3$Outbound;
}

export function metadatumS3ToJSON(metadatumS3: MetadatumS3): string {
  return JSON.stringify(MetadatumS3$outboundSchema.parse(metadatumS3));
}

export function metadatumS3FromJSON(
  jsonString: string,
): SafeParseResult<MetadatumS3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumS3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumS3' from JSON`,
  );
}

/** @internal */
export const CheckpointingS3$inboundSchema: z.ZodType<
  CheckpointingS3,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().default(false),
  retries: z.number().default(5),
});

/** @internal */
export type CheckpointingS3$Outbound = {
  enabled: boolean;
  retries: number;
};

/** @internal */
export const CheckpointingS3$outboundSchema: z.ZodType<
  CheckpointingS3$Outbound,
  z.ZodTypeDef,
  CheckpointingS3
> = z.object({
  enabled: z.boolean().default(false),
  retries: z.number().default(5),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CheckpointingS3$ {
  /** @deprecated use `CheckpointingS3$inboundSchema` instead. */
  export const inboundSchema = CheckpointingS3$inboundSchema;
  /** @deprecated use `CheckpointingS3$outboundSchema` instead. */
  export const outboundSchema = CheckpointingS3$outboundSchema;
  /** @deprecated use `CheckpointingS3$Outbound` instead. */
  export type Outbound = CheckpointingS3$Outbound;
}

export function checkpointingS3ToJSON(
  checkpointingS3: CheckpointingS3,
): string {
  return JSON.stringify(CheckpointingS3$outboundSchema.parse(checkpointingS3));
}

export function checkpointingS3FromJSON(
  jsonString: string,
): SafeParseResult<CheckpointingS3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckpointingS3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckpointingS3' from JSON`,
  );
}

/** @internal */
export const InputS3$inboundSchema: z.ZodType<InputS3, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    type: CreateInputTypeS3$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(z.lazy(() => ConnectionS3$inboundSchema)).optional(),
    pq: z.lazy(() => PqS3$inboundSchema).optional(),
    queueName: z.string(),
    fileFilter: z.string().default("/.*/"),
    awsAccountId: z.string().optional(),
    awsAuthenticationMethod: CreateInputAuthenticationMethodS3$inboundSchema
      .default("auto"),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: CreateInputSignatureVersionS3$inboundSchema.default("v4"),
    reuseConnections: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().default(10000),
    maxMessages: z.number().default(1),
    visibilityTimeout: z.number().default(600),
    numReceivers: z.number().default(1),
    socketTimeout: z.number().default(300),
    skipOnError: z.boolean().default(false),
    enableAssumeRole: z.boolean().default(true),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().default(3600),
    enableSQSAssumeRole: z.boolean().default(false),
    preprocess: z.lazy(() => PreprocessS3$inboundSchema).optional(),
    metadata: z.array(z.lazy(() => MetadatumS3$inboundSchema)).optional(),
    parquetChunkSizeMB: z.number().default(5),
    parquetChunkDownloadTimeout: z.number().default(600),
    checkpointing: z.lazy(() => CheckpointingS3$inboundSchema).optional(),
    pollTimeout: z.number().default(10),
    encoding: z.string().optional(),
    tagAfterProcessing: z.boolean().default(false),
    description: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    processedTagKey: z.string().optional(),
    processedTagValue: z.string().optional(),
  });

/** @internal */
export type InputS3$Outbound = {
  id: string;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionS3$Outbound> | undefined;
  pq?: PqS3$Outbound | undefined;
  queueName: string;
  fileFilter: string;
  awsAccountId?: string | undefined;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  maxMessages: number;
  visibilityTimeout: number;
  numReceivers: number;
  socketTimeout: number;
  skipOnError: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  enableSQSAssumeRole: boolean;
  preprocess?: PreprocessS3$Outbound | undefined;
  metadata?: Array<MetadatumS3$Outbound> | undefined;
  parquetChunkSizeMB: number;
  parquetChunkDownloadTimeout: number;
  checkpointing?: CheckpointingS3$Outbound | undefined;
  pollTimeout: number;
  encoding?: string | undefined;
  tagAfterProcessing: boolean;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  processedTagKey?: string | undefined;
  processedTagValue?: string | undefined;
};

/** @internal */
export const InputS3$outboundSchema: z.ZodType<
  InputS3$Outbound,
  z.ZodTypeDef,
  InputS3
> = z.object({
  id: z.string(),
  type: CreateInputTypeS3$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionS3$outboundSchema)).optional(),
  pq: z.lazy(() => PqS3$outboundSchema).optional(),
  queueName: z.string(),
  fileFilter: z.string().default("/.*/"),
  awsAccountId: z.string().optional(),
  awsAuthenticationMethod: CreateInputAuthenticationMethodS3$outboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: CreateInputSignatureVersionS3$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  maxMessages: z.number().default(1),
  visibilityTimeout: z.number().default(600),
  numReceivers: z.number().default(1),
  socketTimeout: z.number().default(300),
  skipOnError: z.boolean().default(false),
  enableAssumeRole: z.boolean().default(true),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  enableSQSAssumeRole: z.boolean().default(false),
  preprocess: z.lazy(() => PreprocessS3$outboundSchema).optional(),
  metadata: z.array(z.lazy(() => MetadatumS3$outboundSchema)).optional(),
  parquetChunkSizeMB: z.number().default(5),
  parquetChunkDownloadTimeout: z.number().default(600),
  checkpointing: z.lazy(() => CheckpointingS3$outboundSchema).optional(),
  pollTimeout: z.number().default(10),
  encoding: z.string().optional(),
  tagAfterProcessing: z.boolean().default(false),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  processedTagKey: z.string().optional(),
  processedTagValue: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3$ {
  /** @deprecated use `InputS3$inboundSchema` instead. */
  export const inboundSchema = InputS3$inboundSchema;
  /** @deprecated use `InputS3$outboundSchema` instead. */
  export const outboundSchema = InputS3$outboundSchema;
  /** @deprecated use `InputS3$Outbound` instead. */
  export type Outbound = InputS3$Outbound;
}

export function inputS3ToJSON(inputS3: InputS3): string {
  return JSON.stringify(InputS3$outboundSchema.parse(inputS3));
}

export function inputS3FromJSON(
  jsonString: string,
): SafeParseResult<InputS3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputS3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputS3' from JSON`,
  );
}

/** @internal */
export const TypeMetrics$inboundSchema: z.ZodNativeEnum<typeof TypeMetrics> = z
  .nativeEnum(TypeMetrics);

/** @internal */
export const TypeMetrics$outboundSchema: z.ZodNativeEnum<typeof TypeMetrics> =
  TypeMetrics$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeMetrics$ {
  /** @deprecated use `TypeMetrics$inboundSchema` instead. */
  export const inboundSchema = TypeMetrics$inboundSchema;
  /** @deprecated use `TypeMetrics$outboundSchema` instead. */
  export const outboundSchema = TypeMetrics$outboundSchema;
}

/** @internal */
export const ConnectionMetrics$inboundSchema: z.ZodType<
  ConnectionMetrics,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionMetrics$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionMetrics$outboundSchema: z.ZodType<
  ConnectionMetrics$Outbound,
  z.ZodTypeDef,
  ConnectionMetrics
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionMetrics$ {
  /** @deprecated use `ConnectionMetrics$inboundSchema` instead. */
  export const inboundSchema = ConnectionMetrics$inboundSchema;
  /** @deprecated use `ConnectionMetrics$outboundSchema` instead. */
  export const outboundSchema = ConnectionMetrics$outboundSchema;
  /** @deprecated use `ConnectionMetrics$Outbound` instead. */
  export type Outbound = ConnectionMetrics$Outbound;
}

export function connectionMetricsToJSON(
  connectionMetrics: ConnectionMetrics,
): string {
  return JSON.stringify(
    ConnectionMetrics$outboundSchema.parse(connectionMetrics),
  );
}

export function connectionMetricsFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionMetrics' from JSON`,
  );
}

/** @internal */
export const ModeMetrics$inboundSchema: z.ZodNativeEnum<typeof ModeMetrics> = z
  .nativeEnum(ModeMetrics);

/** @internal */
export const ModeMetrics$outboundSchema: z.ZodNativeEnum<typeof ModeMetrics> =
  ModeMetrics$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeMetrics$ {
  /** @deprecated use `ModeMetrics$inboundSchema` instead. */
  export const inboundSchema = ModeMetrics$inboundSchema;
  /** @deprecated use `ModeMetrics$outboundSchema` instead. */
  export const outboundSchema = ModeMetrics$outboundSchema;
}

/** @internal */
export const CompressionMetrics$inboundSchema: z.ZodNativeEnum<
  typeof CompressionMetrics
> = z.nativeEnum(CompressionMetrics);

/** @internal */
export const CompressionMetrics$outboundSchema: z.ZodNativeEnum<
  typeof CompressionMetrics
> = CompressionMetrics$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionMetrics$ {
  /** @deprecated use `CompressionMetrics$inboundSchema` instead. */
  export const inboundSchema = CompressionMetrics$inboundSchema;
  /** @deprecated use `CompressionMetrics$outboundSchema` instead. */
  export const outboundSchema = CompressionMetrics$outboundSchema;
}

/** @internal */
export const PqMetrics$inboundSchema: z.ZodType<
  PqMetrics,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeMetrics$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionMetrics$inboundSchema.default("none"),
});

/** @internal */
export type PqMetrics$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqMetrics$outboundSchema: z.ZodType<
  PqMetrics$Outbound,
  z.ZodTypeDef,
  PqMetrics
> = z.object({
  mode: ModeMetrics$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionMetrics$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqMetrics$ {
  /** @deprecated use `PqMetrics$inboundSchema` instead. */
  export const inboundSchema = PqMetrics$inboundSchema;
  /** @deprecated use `PqMetrics$outboundSchema` instead. */
  export const outboundSchema = PqMetrics$outboundSchema;
  /** @deprecated use `PqMetrics$Outbound` instead. */
  export type Outbound = PqMetrics$Outbound;
}

export function pqMetricsToJSON(pqMetrics: PqMetrics): string {
  return JSON.stringify(PqMetrics$outboundSchema.parse(pqMetrics));
}

export function pqMetricsFromJSON(
  jsonString: string,
): SafeParseResult<PqMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqMetrics' from JSON`,
  );
}

/** @internal */
export const MinimumTLSVersionMetrics$inboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionMetrics
> = z.nativeEnum(MinimumTLSVersionMetrics);

/** @internal */
export const MinimumTLSVersionMetrics$outboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionMetrics
> = MinimumTLSVersionMetrics$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MinimumTLSVersionMetrics$ {
  /** @deprecated use `MinimumTLSVersionMetrics$inboundSchema` instead. */
  export const inboundSchema = MinimumTLSVersionMetrics$inboundSchema;
  /** @deprecated use `MinimumTLSVersionMetrics$outboundSchema` instead. */
  export const outboundSchema = MinimumTLSVersionMetrics$outboundSchema;
}

/** @internal */
export const MaximumTLSVersionMetrics$inboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionMetrics
> = z.nativeEnum(MaximumTLSVersionMetrics);

/** @internal */
export const MaximumTLSVersionMetrics$outboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionMetrics
> = MaximumTLSVersionMetrics$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaximumTLSVersionMetrics$ {
  /** @deprecated use `MaximumTLSVersionMetrics$inboundSchema` instead. */
  export const inboundSchema = MaximumTLSVersionMetrics$inboundSchema;
  /** @deprecated use `MaximumTLSVersionMetrics$outboundSchema` instead. */
  export const outboundSchema = MaximumTLSVersionMetrics$outboundSchema;
}

/** @internal */
export const TLSSettingsServerSideMetrics$inboundSchema: z.ZodType<
  TLSSettingsServerSideMetrics,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionMetrics$inboundSchema.optional(),
  maxVersion: MaximumTLSVersionMetrics$inboundSchema.optional(),
});

/** @internal */
export type TLSSettingsServerSideMetrics$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TLSSettingsServerSideMetrics$outboundSchema: z.ZodType<
  TLSSettingsServerSideMetrics$Outbound,
  z.ZodTypeDef,
  TLSSettingsServerSideMetrics
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionMetrics$outboundSchema.optional(),
  maxVersion: MaximumTLSVersionMetrics$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsServerSideMetrics$ {
  /** @deprecated use `TLSSettingsServerSideMetrics$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsServerSideMetrics$inboundSchema;
  /** @deprecated use `TLSSettingsServerSideMetrics$outboundSchema` instead. */
  export const outboundSchema = TLSSettingsServerSideMetrics$outboundSchema;
  /** @deprecated use `TLSSettingsServerSideMetrics$Outbound` instead. */
  export type Outbound = TLSSettingsServerSideMetrics$Outbound;
}

export function tlsSettingsServerSideMetricsToJSON(
  tlsSettingsServerSideMetrics: TLSSettingsServerSideMetrics,
): string {
  return JSON.stringify(
    TLSSettingsServerSideMetrics$outboundSchema.parse(
      tlsSettingsServerSideMetrics,
    ),
  );
}

export function tlsSettingsServerSideMetricsFromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsServerSideMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TLSSettingsServerSideMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsServerSideMetrics' from JSON`,
  );
}

/** @internal */
export const MetadatumMetrics$inboundSchema: z.ZodType<
  MetadatumMetrics,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumMetrics$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumMetrics$outboundSchema: z.ZodType<
  MetadatumMetrics$Outbound,
  z.ZodTypeDef,
  MetadatumMetrics
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumMetrics$ {
  /** @deprecated use `MetadatumMetrics$inboundSchema` instead. */
  export const inboundSchema = MetadatumMetrics$inboundSchema;
  /** @deprecated use `MetadatumMetrics$outboundSchema` instead. */
  export const outboundSchema = MetadatumMetrics$outboundSchema;
  /** @deprecated use `MetadatumMetrics$Outbound` instead. */
  export type Outbound = MetadatumMetrics$Outbound;
}

export function metadatumMetricsToJSON(
  metadatumMetrics: MetadatumMetrics,
): string {
  return JSON.stringify(
    MetadatumMetrics$outboundSchema.parse(metadatumMetrics),
  );
}

export function metadatumMetricsFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumMetrics' from JSON`,
  );
}

/** @internal */
export const InputMetrics$inboundSchema: z.ZodType<
  InputMetrics,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeMetrics$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionMetrics$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqMetrics$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  udpPort: z.number().optional(),
  tcpPort: z.number().optional(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  enableProxyHeader: z.boolean().default(false),
  tls: z.lazy(() => TLSSettingsServerSideMetrics$inboundSchema).optional(),
  metadata: z.array(z.lazy(() => MetadatumMetrics$inboundSchema)).optional(),
  udpSocketRxBufSize: z.number().optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputMetrics$Outbound = {
  id: string;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionMetrics$Outbound> | undefined;
  pq?: PqMetrics$Outbound | undefined;
  host: string;
  udpPort?: number | undefined;
  tcpPort?: number | undefined;
  maxBufferSize: number;
  ipWhitelistRegex: string;
  enableProxyHeader: boolean;
  tls?: TLSSettingsServerSideMetrics$Outbound | undefined;
  metadata?: Array<MetadatumMetrics$Outbound> | undefined;
  udpSocketRxBufSize?: number | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputMetrics$outboundSchema: z.ZodType<
  InputMetrics$Outbound,
  z.ZodTypeDef,
  InputMetrics
> = z.object({
  id: z.string(),
  type: TypeMetrics$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionMetrics$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqMetrics$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  udpPort: z.number().optional(),
  tcpPort: z.number().optional(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  enableProxyHeader: z.boolean().default(false),
  tls: z.lazy(() => TLSSettingsServerSideMetrics$outboundSchema).optional(),
  metadata: z.array(z.lazy(() => MetadatumMetrics$outboundSchema)).optional(),
  udpSocketRxBufSize: z.number().optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMetrics$ {
  /** @deprecated use `InputMetrics$inboundSchema` instead. */
  export const inboundSchema = InputMetrics$inboundSchema;
  /** @deprecated use `InputMetrics$outboundSchema` instead. */
  export const outboundSchema = InputMetrics$outboundSchema;
  /** @deprecated use `InputMetrics$Outbound` instead. */
  export type Outbound = InputMetrics$Outbound;
}

export function inputMetricsToJSON(inputMetrics: InputMetrics): string {
  return JSON.stringify(InputMetrics$outboundSchema.parse(inputMetrics));
}

export function inputMetricsFromJSON(
  jsonString: string,
): SafeParseResult<InputMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMetrics' from JSON`,
  );
}

/** @internal */
export const CreateInputTypeKinesis$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeKinesis
> = z.nativeEnum(CreateInputTypeKinesis);

/** @internal */
export const CreateInputTypeKinesis$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeKinesis
> = CreateInputTypeKinesis$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputTypeKinesis$ {
  /** @deprecated use `CreateInputTypeKinesis$inboundSchema` instead. */
  export const inboundSchema = CreateInputTypeKinesis$inboundSchema;
  /** @deprecated use `CreateInputTypeKinesis$outboundSchema` instead. */
  export const outboundSchema = CreateInputTypeKinesis$outboundSchema;
}

/** @internal */
export const ConnectionKinesis$inboundSchema: z.ZodType<
  ConnectionKinesis,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionKinesis$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionKinesis$outboundSchema: z.ZodType<
  ConnectionKinesis$Outbound,
  z.ZodTypeDef,
  ConnectionKinesis
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionKinesis$ {
  /** @deprecated use `ConnectionKinesis$inboundSchema` instead. */
  export const inboundSchema = ConnectionKinesis$inboundSchema;
  /** @deprecated use `ConnectionKinesis$outboundSchema` instead. */
  export const outboundSchema = ConnectionKinesis$outboundSchema;
  /** @deprecated use `ConnectionKinesis$Outbound` instead. */
  export type Outbound = ConnectionKinesis$Outbound;
}

export function connectionKinesisToJSON(
  connectionKinesis: ConnectionKinesis,
): string {
  return JSON.stringify(
    ConnectionKinesis$outboundSchema.parse(connectionKinesis),
  );
}

export function connectionKinesisFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionKinesis, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionKinesis$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionKinesis' from JSON`,
  );
}

/** @internal */
export const CreateInputModeKinesis$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputModeKinesis
> = z.nativeEnum(CreateInputModeKinesis);

/** @internal */
export const CreateInputModeKinesis$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputModeKinesis
> = CreateInputModeKinesis$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputModeKinesis$ {
  /** @deprecated use `CreateInputModeKinesis$inboundSchema` instead. */
  export const inboundSchema = CreateInputModeKinesis$inboundSchema;
  /** @deprecated use `CreateInputModeKinesis$outboundSchema` instead. */
  export const outboundSchema = CreateInputModeKinesis$outboundSchema;
}

/** @internal */
export const PqCompressionKinesis$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressionKinesis
> = z.nativeEnum(PqCompressionKinesis);

/** @internal */
export const PqCompressionKinesis$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressionKinesis
> = PqCompressionKinesis$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressionKinesis$ {
  /** @deprecated use `PqCompressionKinesis$inboundSchema` instead. */
  export const inboundSchema = PqCompressionKinesis$inboundSchema;
  /** @deprecated use `PqCompressionKinesis$outboundSchema` instead. */
  export const outboundSchema = PqCompressionKinesis$outboundSchema;
}

/** @internal */
export const PqKinesis$inboundSchema: z.ZodType<
  PqKinesis,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: CreateInputModeKinesis$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: PqCompressionKinesis$inboundSchema.default("none"),
});

/** @internal */
export type PqKinesis$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqKinesis$outboundSchema: z.ZodType<
  PqKinesis$Outbound,
  z.ZodTypeDef,
  PqKinesis
> = z.object({
  mode: CreateInputModeKinesis$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: PqCompressionKinesis$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqKinesis$ {
  /** @deprecated use `PqKinesis$inboundSchema` instead. */
  export const inboundSchema = PqKinesis$inboundSchema;
  /** @deprecated use `PqKinesis$outboundSchema` instead. */
  export const outboundSchema = PqKinesis$outboundSchema;
  /** @deprecated use `PqKinesis$Outbound` instead. */
  export type Outbound = PqKinesis$Outbound;
}

export function pqKinesisToJSON(pqKinesis: PqKinesis): string {
  return JSON.stringify(PqKinesis$outboundSchema.parse(pqKinesis));
}

export function pqKinesisFromJSON(
  jsonString: string,
): SafeParseResult<PqKinesis, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqKinesis$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqKinesis' from JSON`,
  );
}

/** @internal */
export const ShardIteratorStart$inboundSchema: z.ZodNativeEnum<
  typeof ShardIteratorStart
> = z.nativeEnum(ShardIteratorStart);

/** @internal */
export const ShardIteratorStart$outboundSchema: z.ZodNativeEnum<
  typeof ShardIteratorStart
> = ShardIteratorStart$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ShardIteratorStart$ {
  /** @deprecated use `ShardIteratorStart$inboundSchema` instead. */
  export const inboundSchema = ShardIteratorStart$inboundSchema;
  /** @deprecated use `ShardIteratorStart$outboundSchema` instead. */
  export const outboundSchema = ShardIteratorStart$outboundSchema;
}

/** @internal */
export const CreateInputRecordDataFormat$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputRecordDataFormat
> = z.nativeEnum(CreateInputRecordDataFormat);

/** @internal */
export const CreateInputRecordDataFormat$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputRecordDataFormat
> = CreateInputRecordDataFormat$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputRecordDataFormat$ {
  /** @deprecated use `CreateInputRecordDataFormat$inboundSchema` instead. */
  export const inboundSchema = CreateInputRecordDataFormat$inboundSchema;
  /** @deprecated use `CreateInputRecordDataFormat$outboundSchema` instead. */
  export const outboundSchema = CreateInputRecordDataFormat$outboundSchema;
}

/** @internal */
export const ShardLoadBalancing$inboundSchema: z.ZodNativeEnum<
  typeof ShardLoadBalancing
> = z.nativeEnum(ShardLoadBalancing);

/** @internal */
export const ShardLoadBalancing$outboundSchema: z.ZodNativeEnum<
  typeof ShardLoadBalancing
> = ShardLoadBalancing$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ShardLoadBalancing$ {
  /** @deprecated use `ShardLoadBalancing$inboundSchema` instead. */
  export const inboundSchema = ShardLoadBalancing$inboundSchema;
  /** @deprecated use `ShardLoadBalancing$outboundSchema` instead. */
  export const outboundSchema = ShardLoadBalancing$outboundSchema;
}

/** @internal */
export const CreateInputAuthenticationMethodKinesis$inboundSchema:
  z.ZodNativeEnum<typeof CreateInputAuthenticationMethodKinesis> = z.nativeEnum(
    CreateInputAuthenticationMethodKinesis,
  );

/** @internal */
export const CreateInputAuthenticationMethodKinesis$outboundSchema:
  z.ZodNativeEnum<typeof CreateInputAuthenticationMethodKinesis> =
    CreateInputAuthenticationMethodKinesis$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputAuthenticationMethodKinesis$ {
  /** @deprecated use `CreateInputAuthenticationMethodKinesis$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputAuthenticationMethodKinesis$inboundSchema;
  /** @deprecated use `CreateInputAuthenticationMethodKinesis$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputAuthenticationMethodKinesis$outboundSchema;
}

/** @internal */
export const CreateInputSignatureVersionKinesis$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputSignatureVersionKinesis
> = z.nativeEnum(CreateInputSignatureVersionKinesis);

/** @internal */
export const CreateInputSignatureVersionKinesis$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputSignatureVersionKinesis
> = CreateInputSignatureVersionKinesis$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputSignatureVersionKinesis$ {
  /** @deprecated use `CreateInputSignatureVersionKinesis$inboundSchema` instead. */
  export const inboundSchema = CreateInputSignatureVersionKinesis$inboundSchema;
  /** @deprecated use `CreateInputSignatureVersionKinesis$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputSignatureVersionKinesis$outboundSchema;
}

/** @internal */
export const MetadatumKinesis$inboundSchema: z.ZodType<
  MetadatumKinesis,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumKinesis$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumKinesis$outboundSchema: z.ZodType<
  MetadatumKinesis$Outbound,
  z.ZodTypeDef,
  MetadatumKinesis
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumKinesis$ {
  /** @deprecated use `MetadatumKinesis$inboundSchema` instead. */
  export const inboundSchema = MetadatumKinesis$inboundSchema;
  /** @deprecated use `MetadatumKinesis$outboundSchema` instead. */
  export const outboundSchema = MetadatumKinesis$outboundSchema;
  /** @deprecated use `MetadatumKinesis$Outbound` instead. */
  export type Outbound = MetadatumKinesis$Outbound;
}

export function metadatumKinesisToJSON(
  metadatumKinesis: MetadatumKinesis,
): string {
  return JSON.stringify(
    MetadatumKinesis$outboundSchema.parse(metadatumKinesis),
  );
}

export function metadatumKinesisFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumKinesis, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumKinesis$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumKinesis' from JSON`,
  );
}

/** @internal */
export const InputKinesis$inboundSchema: z.ZodType<
  InputKinesis,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateInputTypeKinesis$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionKinesis$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqKinesis$inboundSchema).optional(),
  streamName: z.string(),
  serviceInterval: z.number().default(1),
  shardExpr: z.string().default("true"),
  shardIteratorType: ShardIteratorStart$inboundSchema.default("TRIM_HORIZON"),
  payloadFormat: CreateInputRecordDataFormat$inboundSchema.default("cribl"),
  getRecordsLimit: z.number().default(5000),
  getRecordsLimitTotal: z.number().default(20000),
  loadBalancingAlgorithm: ShardLoadBalancing$inboundSchema.default(
    "ConsistentHashing",
  ),
  awsAuthenticationMethod: CreateInputAuthenticationMethodKinesis$inboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: CreateInputSignatureVersionKinesis$inboundSchema.default(
    "v4",
  ),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  verifyKPLCheckSums: z.boolean().default(false),
  avoidDuplicates: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumKinesis$inboundSchema)).optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});

/** @internal */
export type InputKinesis$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionKinesis$Outbound> | undefined;
  pq?: PqKinesis$Outbound | undefined;
  streamName: string;
  serviceInterval: number;
  shardExpr: string;
  shardIteratorType: string;
  payloadFormat: string;
  getRecordsLimit: number;
  getRecordsLimitTotal: number;
  loadBalancingAlgorithm: string;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  verifyKPLCheckSums: boolean;
  avoidDuplicates: boolean;
  metadata?: Array<MetadatumKinesis$Outbound> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
};

/** @internal */
export const InputKinesis$outboundSchema: z.ZodType<
  InputKinesis$Outbound,
  z.ZodTypeDef,
  InputKinesis
> = z.object({
  id: z.string(),
  type: CreateInputTypeKinesis$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionKinesis$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqKinesis$outboundSchema).optional(),
  streamName: z.string(),
  serviceInterval: z.number().default(1),
  shardExpr: z.string().default("true"),
  shardIteratorType: ShardIteratorStart$outboundSchema.default("TRIM_HORIZON"),
  payloadFormat: CreateInputRecordDataFormat$outboundSchema.default("cribl"),
  getRecordsLimit: z.number().default(5000),
  getRecordsLimitTotal: z.number().default(20000),
  loadBalancingAlgorithm: ShardLoadBalancing$outboundSchema.default(
    "ConsistentHashing",
  ),
  awsAuthenticationMethod: CreateInputAuthenticationMethodKinesis$outboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: CreateInputSignatureVersionKinesis$outboundSchema.default(
    "v4",
  ),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  verifyKPLCheckSums: z.boolean().default(false),
  avoidDuplicates: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumKinesis$outboundSchema)).optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKinesis$ {
  /** @deprecated use `InputKinesis$inboundSchema` instead. */
  export const inboundSchema = InputKinesis$inboundSchema;
  /** @deprecated use `InputKinesis$outboundSchema` instead. */
  export const outboundSchema = InputKinesis$outboundSchema;
  /** @deprecated use `InputKinesis$Outbound` instead. */
  export type Outbound = InputKinesis$Outbound;
}

export function inputKinesisToJSON(inputKinesis: InputKinesis): string {
  return JSON.stringify(InputKinesis$outboundSchema.parse(inputKinesis));
}

export function inputKinesisFromJSON(
  jsonString: string,
): SafeParseResult<InputKinesis, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputKinesis$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputKinesis' from JSON`,
  );
}

/** @internal */
export const TypeHTTPRaw$inboundSchema: z.ZodNativeEnum<typeof TypeHTTPRaw> = z
  .nativeEnum(TypeHTTPRaw);

/** @internal */
export const TypeHTTPRaw$outboundSchema: z.ZodNativeEnum<typeof TypeHTTPRaw> =
  TypeHTTPRaw$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeHTTPRaw$ {
  /** @deprecated use `TypeHTTPRaw$inboundSchema` instead. */
  export const inboundSchema = TypeHTTPRaw$inboundSchema;
  /** @deprecated use `TypeHTTPRaw$outboundSchema` instead. */
  export const outboundSchema = TypeHTTPRaw$outboundSchema;
}

/** @internal */
export const ConnectionHTTPRaw$inboundSchema: z.ZodType<
  ConnectionHTTPRaw,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionHTTPRaw$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionHTTPRaw$outboundSchema: z.ZodType<
  ConnectionHTTPRaw$Outbound,
  z.ZodTypeDef,
  ConnectionHTTPRaw
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionHTTPRaw$ {
  /** @deprecated use `ConnectionHTTPRaw$inboundSchema` instead. */
  export const inboundSchema = ConnectionHTTPRaw$inboundSchema;
  /** @deprecated use `ConnectionHTTPRaw$outboundSchema` instead. */
  export const outboundSchema = ConnectionHTTPRaw$outboundSchema;
  /** @deprecated use `ConnectionHTTPRaw$Outbound` instead. */
  export type Outbound = ConnectionHTTPRaw$Outbound;
}

export function connectionHTTPRawToJSON(
  connectionHTTPRaw: ConnectionHTTPRaw,
): string {
  return JSON.stringify(
    ConnectionHTTPRaw$outboundSchema.parse(connectionHTTPRaw),
  );
}

export function connectionHTTPRawFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionHTTPRaw, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionHTTPRaw$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionHTTPRaw' from JSON`,
  );
}

/** @internal */
export const ModeHTTPRaw$inboundSchema: z.ZodNativeEnum<typeof ModeHTTPRaw> = z
  .nativeEnum(ModeHTTPRaw);

/** @internal */
export const ModeHTTPRaw$outboundSchema: z.ZodNativeEnum<typeof ModeHTTPRaw> =
  ModeHTTPRaw$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeHTTPRaw$ {
  /** @deprecated use `ModeHTTPRaw$inboundSchema` instead. */
  export const inboundSchema = ModeHTTPRaw$inboundSchema;
  /** @deprecated use `ModeHTTPRaw$outboundSchema` instead. */
  export const outboundSchema = ModeHTTPRaw$outboundSchema;
}

/** @internal */
export const CompressionHTTPRaw$inboundSchema: z.ZodNativeEnum<
  typeof CompressionHTTPRaw
> = z.nativeEnum(CompressionHTTPRaw);

/** @internal */
export const CompressionHTTPRaw$outboundSchema: z.ZodNativeEnum<
  typeof CompressionHTTPRaw
> = CompressionHTTPRaw$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionHTTPRaw$ {
  /** @deprecated use `CompressionHTTPRaw$inboundSchema` instead. */
  export const inboundSchema = CompressionHTTPRaw$inboundSchema;
  /** @deprecated use `CompressionHTTPRaw$outboundSchema` instead. */
  export const outboundSchema = CompressionHTTPRaw$outboundSchema;
}

/** @internal */
export const PqHTTPRaw$inboundSchema: z.ZodType<
  PqHTTPRaw,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeHTTPRaw$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionHTTPRaw$inboundSchema.default("none"),
});

/** @internal */
export type PqHTTPRaw$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqHTTPRaw$outboundSchema: z.ZodType<
  PqHTTPRaw$Outbound,
  z.ZodTypeDef,
  PqHTTPRaw
> = z.object({
  mode: ModeHTTPRaw$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionHTTPRaw$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqHTTPRaw$ {
  /** @deprecated use `PqHTTPRaw$inboundSchema` instead. */
  export const inboundSchema = PqHTTPRaw$inboundSchema;
  /** @deprecated use `PqHTTPRaw$outboundSchema` instead. */
  export const outboundSchema = PqHTTPRaw$outboundSchema;
  /** @deprecated use `PqHTTPRaw$Outbound` instead. */
  export type Outbound = PqHTTPRaw$Outbound;
}

export function pqHTTPRawToJSON(pqHTTPRaw: PqHTTPRaw): string {
  return JSON.stringify(PqHTTPRaw$outboundSchema.parse(pqHTTPRaw));
}

export function pqHTTPRawFromJSON(
  jsonString: string,
): SafeParseResult<PqHTTPRaw, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqHTTPRaw$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqHTTPRaw' from JSON`,
  );
}

/** @internal */
export const MinimumTLSVersionHTTPRaw$inboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionHTTPRaw
> = z.nativeEnum(MinimumTLSVersionHTTPRaw);

/** @internal */
export const MinimumTLSVersionHTTPRaw$outboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionHTTPRaw
> = MinimumTLSVersionHTTPRaw$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MinimumTLSVersionHTTPRaw$ {
  /** @deprecated use `MinimumTLSVersionHTTPRaw$inboundSchema` instead. */
  export const inboundSchema = MinimumTLSVersionHTTPRaw$inboundSchema;
  /** @deprecated use `MinimumTLSVersionHTTPRaw$outboundSchema` instead. */
  export const outboundSchema = MinimumTLSVersionHTTPRaw$outboundSchema;
}

/** @internal */
export const MaximumTLSVersionHTTPRaw$inboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionHTTPRaw
> = z.nativeEnum(MaximumTLSVersionHTTPRaw);

/** @internal */
export const MaximumTLSVersionHTTPRaw$outboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionHTTPRaw
> = MaximumTLSVersionHTTPRaw$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaximumTLSVersionHTTPRaw$ {
  /** @deprecated use `MaximumTLSVersionHTTPRaw$inboundSchema` instead. */
  export const inboundSchema = MaximumTLSVersionHTTPRaw$inboundSchema;
  /** @deprecated use `MaximumTLSVersionHTTPRaw$outboundSchema` instead. */
  export const outboundSchema = MaximumTLSVersionHTTPRaw$outboundSchema;
}

/** @internal */
export const TLSSettingsServerSideHTTPRaw$inboundSchema: z.ZodType<
  TLSSettingsServerSideHTTPRaw,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionHTTPRaw$inboundSchema.optional(),
  maxVersion: MaximumTLSVersionHTTPRaw$inboundSchema.optional(),
});

/** @internal */
export type TLSSettingsServerSideHTTPRaw$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TLSSettingsServerSideHTTPRaw$outboundSchema: z.ZodType<
  TLSSettingsServerSideHTTPRaw$Outbound,
  z.ZodTypeDef,
  TLSSettingsServerSideHTTPRaw
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionHTTPRaw$outboundSchema.optional(),
  maxVersion: MaximumTLSVersionHTTPRaw$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsServerSideHTTPRaw$ {
  /** @deprecated use `TLSSettingsServerSideHTTPRaw$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsServerSideHTTPRaw$inboundSchema;
  /** @deprecated use `TLSSettingsServerSideHTTPRaw$outboundSchema` instead. */
  export const outboundSchema = TLSSettingsServerSideHTTPRaw$outboundSchema;
  /** @deprecated use `TLSSettingsServerSideHTTPRaw$Outbound` instead. */
  export type Outbound = TLSSettingsServerSideHTTPRaw$Outbound;
}

export function tlsSettingsServerSideHTTPRawToJSON(
  tlsSettingsServerSideHTTPRaw: TLSSettingsServerSideHTTPRaw,
): string {
  return JSON.stringify(
    TLSSettingsServerSideHTTPRaw$outboundSchema.parse(
      tlsSettingsServerSideHTTPRaw,
    ),
  );
}

export function tlsSettingsServerSideHTTPRawFromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsServerSideHTTPRaw, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TLSSettingsServerSideHTTPRaw$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsServerSideHTTPRaw' from JSON`,
  );
}

/** @internal */
export const MetadatumHTTPRaw$inboundSchema: z.ZodType<
  MetadatumHTTPRaw,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumHTTPRaw$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumHTTPRaw$outboundSchema: z.ZodType<
  MetadatumHTTPRaw$Outbound,
  z.ZodTypeDef,
  MetadatumHTTPRaw
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumHTTPRaw$ {
  /** @deprecated use `MetadatumHTTPRaw$inboundSchema` instead. */
  export const inboundSchema = MetadatumHTTPRaw$inboundSchema;
  /** @deprecated use `MetadatumHTTPRaw$outboundSchema` instead. */
  export const outboundSchema = MetadatumHTTPRaw$outboundSchema;
  /** @deprecated use `MetadatumHTTPRaw$Outbound` instead. */
  export type Outbound = MetadatumHTTPRaw$Outbound;
}

export function metadatumHTTPRawToJSON(
  metadatumHTTPRaw: MetadatumHTTPRaw,
): string {
  return JSON.stringify(
    MetadatumHTTPRaw$outboundSchema.parse(metadatumHTTPRaw),
  );
}

export function metadatumHTTPRawFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumHTTPRaw, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumHTTPRaw$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumHTTPRaw' from JSON`,
  );
}

/** @internal */
export const AuthTokensExtMetadatumHTTPRaw$inboundSchema: z.ZodType<
  AuthTokensExtMetadatumHTTPRaw,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type AuthTokensExtMetadatumHTTPRaw$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const AuthTokensExtMetadatumHTTPRaw$outboundSchema: z.ZodType<
  AuthTokensExtMetadatumHTTPRaw$Outbound,
  z.ZodTypeDef,
  AuthTokensExtMetadatumHTTPRaw
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokensExtMetadatumHTTPRaw$ {
  /** @deprecated use `AuthTokensExtMetadatumHTTPRaw$inboundSchema` instead. */
  export const inboundSchema = AuthTokensExtMetadatumHTTPRaw$inboundSchema;
  /** @deprecated use `AuthTokensExtMetadatumHTTPRaw$outboundSchema` instead. */
  export const outboundSchema = AuthTokensExtMetadatumHTTPRaw$outboundSchema;
  /** @deprecated use `AuthTokensExtMetadatumHTTPRaw$Outbound` instead. */
  export type Outbound = AuthTokensExtMetadatumHTTPRaw$Outbound;
}

export function authTokensExtMetadatumHTTPRawToJSON(
  authTokensExtMetadatumHTTPRaw: AuthTokensExtMetadatumHTTPRaw,
): string {
  return JSON.stringify(
    AuthTokensExtMetadatumHTTPRaw$outboundSchema.parse(
      authTokensExtMetadatumHTTPRaw,
    ),
  );
}

export function authTokensExtMetadatumHTTPRawFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokensExtMetadatumHTTPRaw, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthTokensExtMetadatumHTTPRaw$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokensExtMetadatumHTTPRaw' from JSON`,
  );
}

/** @internal */
export const AuthTokensExtHTTPRaw$inboundSchema: z.ZodType<
  AuthTokensExtHTTPRaw,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  description: z.string().optional(),
  metadata: z.array(z.lazy(() => AuthTokensExtMetadatumHTTPRaw$inboundSchema))
    .optional(),
});

/** @internal */
export type AuthTokensExtHTTPRaw$Outbound = {
  token: string;
  description?: string | undefined;
  metadata?: Array<AuthTokensExtMetadatumHTTPRaw$Outbound> | undefined;
};

/** @internal */
export const AuthTokensExtHTTPRaw$outboundSchema: z.ZodType<
  AuthTokensExtHTTPRaw$Outbound,
  z.ZodTypeDef,
  AuthTokensExtHTTPRaw
> = z.object({
  token: z.string(),
  description: z.string().optional(),
  metadata: z.array(z.lazy(() => AuthTokensExtMetadatumHTTPRaw$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokensExtHTTPRaw$ {
  /** @deprecated use `AuthTokensExtHTTPRaw$inboundSchema` instead. */
  export const inboundSchema = AuthTokensExtHTTPRaw$inboundSchema;
  /** @deprecated use `AuthTokensExtHTTPRaw$outboundSchema` instead. */
  export const outboundSchema = AuthTokensExtHTTPRaw$outboundSchema;
  /** @deprecated use `AuthTokensExtHTTPRaw$Outbound` instead. */
  export type Outbound = AuthTokensExtHTTPRaw$Outbound;
}

export function authTokensExtHTTPRawToJSON(
  authTokensExtHTTPRaw: AuthTokensExtHTTPRaw,
): string {
  return JSON.stringify(
    AuthTokensExtHTTPRaw$outboundSchema.parse(authTokensExtHTTPRaw),
  );
}

export function authTokensExtHTTPRawFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokensExtHTTPRaw, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthTokensExtHTTPRaw$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokensExtHTTPRaw' from JSON`,
  );
}

/** @internal */
export const InputHttpRaw$inboundSchema: z.ZodType<
  InputHttpRaw,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeHTTPRaw$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionHTTPRaw$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqHTTPRaw$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: z.lazy(() => TLSSettingsServerSideHTTPRaw$inboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  metadata: z.array(z.lazy(() => MetadatumHTTPRaw$inboundSchema)).optional(),
  allowedPaths: z.array(z.string()).optional(),
  allowedMethods: z.array(z.string()).optional(),
  authTokensExt: z.array(z.lazy(() => AuthTokensExtHTTPRaw$inboundSchema))
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputHttpRaw$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionHTTPRaw$Outbound> | undefined;
  pq?: PqHTTPRaw$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: TLSSettingsServerSideHTTPRaw$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  metadata?: Array<MetadatumHTTPRaw$Outbound> | undefined;
  allowedPaths?: Array<string> | undefined;
  allowedMethods?: Array<string> | undefined;
  authTokensExt?: Array<AuthTokensExtHTTPRaw$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputHttpRaw$outboundSchema: z.ZodType<
  InputHttpRaw$Outbound,
  z.ZodTypeDef,
  InputHttpRaw
> = z.object({
  id: z.string(),
  type: TypeHTTPRaw$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionHTTPRaw$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqHTTPRaw$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: z.lazy(() => TLSSettingsServerSideHTTPRaw$outboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  metadata: z.array(z.lazy(() => MetadatumHTTPRaw$outboundSchema)).optional(),
  allowedPaths: z.array(z.string()).optional(),
  allowedMethods: z.array(z.string()).optional(),
  authTokensExt: z.array(z.lazy(() => AuthTokensExtHTTPRaw$outboundSchema))
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpRaw$ {
  /** @deprecated use `InputHttpRaw$inboundSchema` instead. */
  export const inboundSchema = InputHttpRaw$inboundSchema;
  /** @deprecated use `InputHttpRaw$outboundSchema` instead. */
  export const outboundSchema = InputHttpRaw$outboundSchema;
  /** @deprecated use `InputHttpRaw$Outbound` instead. */
  export type Outbound = InputHttpRaw$Outbound;
}

export function inputHttpRawToJSON(inputHttpRaw: InputHttpRaw): string {
  return JSON.stringify(InputHttpRaw$outboundSchema.parse(inputHttpRaw));
}

export function inputHttpRawFromJSON(
  jsonString: string,
): SafeParseResult<InputHttpRaw, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputHttpRaw$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputHttpRaw' from JSON`,
  );
}

/** @internal */
export const TypeDatagen$inboundSchema: z.ZodNativeEnum<typeof TypeDatagen> = z
  .nativeEnum(TypeDatagen);

/** @internal */
export const TypeDatagen$outboundSchema: z.ZodNativeEnum<typeof TypeDatagen> =
  TypeDatagen$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeDatagen$ {
  /** @deprecated use `TypeDatagen$inboundSchema` instead. */
  export const inboundSchema = TypeDatagen$inboundSchema;
  /** @deprecated use `TypeDatagen$outboundSchema` instead. */
  export const outboundSchema = TypeDatagen$outboundSchema;
}

/** @internal */
export const ConnectionDatagen$inboundSchema: z.ZodType<
  ConnectionDatagen,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionDatagen$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionDatagen$outboundSchema: z.ZodType<
  ConnectionDatagen$Outbound,
  z.ZodTypeDef,
  ConnectionDatagen
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionDatagen$ {
  /** @deprecated use `ConnectionDatagen$inboundSchema` instead. */
  export const inboundSchema = ConnectionDatagen$inboundSchema;
  /** @deprecated use `ConnectionDatagen$outboundSchema` instead. */
  export const outboundSchema = ConnectionDatagen$outboundSchema;
  /** @deprecated use `ConnectionDatagen$Outbound` instead. */
  export type Outbound = ConnectionDatagen$Outbound;
}

export function connectionDatagenToJSON(
  connectionDatagen: ConnectionDatagen,
): string {
  return JSON.stringify(
    ConnectionDatagen$outboundSchema.parse(connectionDatagen),
  );
}

export function connectionDatagenFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionDatagen, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionDatagen$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionDatagen' from JSON`,
  );
}

/** @internal */
export const ModeDatagen$inboundSchema: z.ZodNativeEnum<typeof ModeDatagen> = z
  .nativeEnum(ModeDatagen);

/** @internal */
export const ModeDatagen$outboundSchema: z.ZodNativeEnum<typeof ModeDatagen> =
  ModeDatagen$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeDatagen$ {
  /** @deprecated use `ModeDatagen$inboundSchema` instead. */
  export const inboundSchema = ModeDatagen$inboundSchema;
  /** @deprecated use `ModeDatagen$outboundSchema` instead. */
  export const outboundSchema = ModeDatagen$outboundSchema;
}

/** @internal */
export const CompressionDatagen$inboundSchema: z.ZodNativeEnum<
  typeof CompressionDatagen
> = z.nativeEnum(CompressionDatagen);

/** @internal */
export const CompressionDatagen$outboundSchema: z.ZodNativeEnum<
  typeof CompressionDatagen
> = CompressionDatagen$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionDatagen$ {
  /** @deprecated use `CompressionDatagen$inboundSchema` instead. */
  export const inboundSchema = CompressionDatagen$inboundSchema;
  /** @deprecated use `CompressionDatagen$outboundSchema` instead. */
  export const outboundSchema = CompressionDatagen$outboundSchema;
}

/** @internal */
export const PqDatagen$inboundSchema: z.ZodType<
  PqDatagen,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeDatagen$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionDatagen$inboundSchema.default("none"),
});

/** @internal */
export type PqDatagen$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqDatagen$outboundSchema: z.ZodType<
  PqDatagen$Outbound,
  z.ZodTypeDef,
  PqDatagen
> = z.object({
  mode: ModeDatagen$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionDatagen$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqDatagen$ {
  /** @deprecated use `PqDatagen$inboundSchema` instead. */
  export const inboundSchema = PqDatagen$inboundSchema;
  /** @deprecated use `PqDatagen$outboundSchema` instead. */
  export const outboundSchema = PqDatagen$outboundSchema;
  /** @deprecated use `PqDatagen$Outbound` instead. */
  export type Outbound = PqDatagen$Outbound;
}

export function pqDatagenToJSON(pqDatagen: PqDatagen): string {
  return JSON.stringify(PqDatagen$outboundSchema.parse(pqDatagen));
}

export function pqDatagenFromJSON(
  jsonString: string,
): SafeParseResult<PqDatagen, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqDatagen$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqDatagen' from JSON`,
  );
}

/** @internal */
export const Sample$inboundSchema: z.ZodType<Sample, z.ZodTypeDef, unknown> = z
  .object({
    sample: z.string(),
    eventsPerSec: z.number().default(10),
  });

/** @internal */
export type Sample$Outbound = {
  sample: string;
  eventsPerSec: number;
};

/** @internal */
export const Sample$outboundSchema: z.ZodType<
  Sample$Outbound,
  z.ZodTypeDef,
  Sample
> = z.object({
  sample: z.string(),
  eventsPerSec: z.number().default(10),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Sample$ {
  /** @deprecated use `Sample$inboundSchema` instead. */
  export const inboundSchema = Sample$inboundSchema;
  /** @deprecated use `Sample$outboundSchema` instead. */
  export const outboundSchema = Sample$outboundSchema;
  /** @deprecated use `Sample$Outbound` instead. */
  export type Outbound = Sample$Outbound;
}

export function sampleToJSON(sample: Sample): string {
  return JSON.stringify(Sample$outboundSchema.parse(sample));
}

export function sampleFromJSON(
  jsonString: string,
): SafeParseResult<Sample, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Sample$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Sample' from JSON`,
  );
}

/** @internal */
export const MetadatumDatagen$inboundSchema: z.ZodType<
  MetadatumDatagen,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumDatagen$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumDatagen$outboundSchema: z.ZodType<
  MetadatumDatagen$Outbound,
  z.ZodTypeDef,
  MetadatumDatagen
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumDatagen$ {
  /** @deprecated use `MetadatumDatagen$inboundSchema` instead. */
  export const inboundSchema = MetadatumDatagen$inboundSchema;
  /** @deprecated use `MetadatumDatagen$outboundSchema` instead. */
  export const outboundSchema = MetadatumDatagen$outboundSchema;
  /** @deprecated use `MetadatumDatagen$Outbound` instead. */
  export type Outbound = MetadatumDatagen$Outbound;
}

export function metadatumDatagenToJSON(
  metadatumDatagen: MetadatumDatagen,
): string {
  return JSON.stringify(
    MetadatumDatagen$outboundSchema.parse(metadatumDatagen),
  );
}

export function metadatumDatagenFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumDatagen, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumDatagen$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumDatagen' from JSON`,
  );
}

/** @internal */
export const InputDatagen$inboundSchema: z.ZodType<
  InputDatagen,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeDatagen$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionDatagen$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqDatagen$inboundSchema).optional(),
  samples: z.array(z.lazy(() => Sample$inboundSchema)),
  metadata: z.array(z.lazy(() => MetadatumDatagen$inboundSchema)).optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputDatagen$Outbound = {
  id: string;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionDatagen$Outbound> | undefined;
  pq?: PqDatagen$Outbound | undefined;
  samples: Array<Sample$Outbound>;
  metadata?: Array<MetadatumDatagen$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputDatagen$outboundSchema: z.ZodType<
  InputDatagen$Outbound,
  z.ZodTypeDef,
  InputDatagen
> = z.object({
  id: z.string(),
  type: TypeDatagen$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionDatagen$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqDatagen$outboundSchema).optional(),
  samples: z.array(z.lazy(() => Sample$outboundSchema)),
  metadata: z.array(z.lazy(() => MetadatumDatagen$outboundSchema)).optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatagen$ {
  /** @deprecated use `InputDatagen$inboundSchema` instead. */
  export const inboundSchema = InputDatagen$inboundSchema;
  /** @deprecated use `InputDatagen$outboundSchema` instead. */
  export const outboundSchema = InputDatagen$outboundSchema;
  /** @deprecated use `InputDatagen$Outbound` instead. */
  export type Outbound = InputDatagen$Outbound;
}

export function inputDatagenToJSON(inputDatagen: InputDatagen): string {
  return JSON.stringify(InputDatagen$outboundSchema.parse(inputDatagen));
}

export function inputDatagenFromJSON(
  jsonString: string,
): SafeParseResult<InputDatagen, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputDatagen$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputDatagen' from JSON`,
  );
}

/** @internal */
export const TypeDatadogAgent$inboundSchema: z.ZodNativeEnum<
  typeof TypeDatadogAgent
> = z.nativeEnum(TypeDatadogAgent);

/** @internal */
export const TypeDatadogAgent$outboundSchema: z.ZodNativeEnum<
  typeof TypeDatadogAgent
> = TypeDatadogAgent$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeDatadogAgent$ {
  /** @deprecated use `TypeDatadogAgent$inboundSchema` instead. */
  export const inboundSchema = TypeDatadogAgent$inboundSchema;
  /** @deprecated use `TypeDatadogAgent$outboundSchema` instead. */
  export const outboundSchema = TypeDatadogAgent$outboundSchema;
}

/** @internal */
export const ConnectionDatadogAgent$inboundSchema: z.ZodType<
  ConnectionDatadogAgent,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionDatadogAgent$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionDatadogAgent$outboundSchema: z.ZodType<
  ConnectionDatadogAgent$Outbound,
  z.ZodTypeDef,
  ConnectionDatadogAgent
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionDatadogAgent$ {
  /** @deprecated use `ConnectionDatadogAgent$inboundSchema` instead. */
  export const inboundSchema = ConnectionDatadogAgent$inboundSchema;
  /** @deprecated use `ConnectionDatadogAgent$outboundSchema` instead. */
  export const outboundSchema = ConnectionDatadogAgent$outboundSchema;
  /** @deprecated use `ConnectionDatadogAgent$Outbound` instead. */
  export type Outbound = ConnectionDatadogAgent$Outbound;
}

export function connectionDatadogAgentToJSON(
  connectionDatadogAgent: ConnectionDatadogAgent,
): string {
  return JSON.stringify(
    ConnectionDatadogAgent$outboundSchema.parse(connectionDatadogAgent),
  );
}

export function connectionDatadogAgentFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionDatadogAgent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionDatadogAgent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionDatadogAgent' from JSON`,
  );
}

/** @internal */
export const ModeDatadogAgent$inboundSchema: z.ZodNativeEnum<
  typeof ModeDatadogAgent
> = z.nativeEnum(ModeDatadogAgent);

/** @internal */
export const ModeDatadogAgent$outboundSchema: z.ZodNativeEnum<
  typeof ModeDatadogAgent
> = ModeDatadogAgent$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeDatadogAgent$ {
  /** @deprecated use `ModeDatadogAgent$inboundSchema` instead. */
  export const inboundSchema = ModeDatadogAgent$inboundSchema;
  /** @deprecated use `ModeDatadogAgent$outboundSchema` instead. */
  export const outboundSchema = ModeDatadogAgent$outboundSchema;
}

/** @internal */
export const CompressionDatadogAgent$inboundSchema: z.ZodNativeEnum<
  typeof CompressionDatadogAgent
> = z.nativeEnum(CompressionDatadogAgent);

/** @internal */
export const CompressionDatadogAgent$outboundSchema: z.ZodNativeEnum<
  typeof CompressionDatadogAgent
> = CompressionDatadogAgent$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionDatadogAgent$ {
  /** @deprecated use `CompressionDatadogAgent$inboundSchema` instead. */
  export const inboundSchema = CompressionDatadogAgent$inboundSchema;
  /** @deprecated use `CompressionDatadogAgent$outboundSchema` instead. */
  export const outboundSchema = CompressionDatadogAgent$outboundSchema;
}

/** @internal */
export const PqDatadogAgent$inboundSchema: z.ZodType<
  PqDatadogAgent,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeDatadogAgent$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionDatadogAgent$inboundSchema.default("none"),
});

/** @internal */
export type PqDatadogAgent$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqDatadogAgent$outboundSchema: z.ZodType<
  PqDatadogAgent$Outbound,
  z.ZodTypeDef,
  PqDatadogAgent
> = z.object({
  mode: ModeDatadogAgent$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionDatadogAgent$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqDatadogAgent$ {
  /** @deprecated use `PqDatadogAgent$inboundSchema` instead. */
  export const inboundSchema = PqDatadogAgent$inboundSchema;
  /** @deprecated use `PqDatadogAgent$outboundSchema` instead. */
  export const outboundSchema = PqDatadogAgent$outboundSchema;
  /** @deprecated use `PqDatadogAgent$Outbound` instead. */
  export type Outbound = PqDatadogAgent$Outbound;
}

export function pqDatadogAgentToJSON(pqDatadogAgent: PqDatadogAgent): string {
  return JSON.stringify(PqDatadogAgent$outboundSchema.parse(pqDatadogAgent));
}

export function pqDatadogAgentFromJSON(
  jsonString: string,
): SafeParseResult<PqDatadogAgent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqDatadogAgent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqDatadogAgent' from JSON`,
  );
}

/** @internal */
export const MinimumTLSVersionDatadogAgent$inboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionDatadogAgent
> = z.nativeEnum(MinimumTLSVersionDatadogAgent);

/** @internal */
export const MinimumTLSVersionDatadogAgent$outboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionDatadogAgent
> = MinimumTLSVersionDatadogAgent$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MinimumTLSVersionDatadogAgent$ {
  /** @deprecated use `MinimumTLSVersionDatadogAgent$inboundSchema` instead. */
  export const inboundSchema = MinimumTLSVersionDatadogAgent$inboundSchema;
  /** @deprecated use `MinimumTLSVersionDatadogAgent$outboundSchema` instead. */
  export const outboundSchema = MinimumTLSVersionDatadogAgent$outboundSchema;
}

/** @internal */
export const MaximumTLSVersionDatadogAgent$inboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionDatadogAgent
> = z.nativeEnum(MaximumTLSVersionDatadogAgent);

/** @internal */
export const MaximumTLSVersionDatadogAgent$outboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionDatadogAgent
> = MaximumTLSVersionDatadogAgent$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaximumTLSVersionDatadogAgent$ {
  /** @deprecated use `MaximumTLSVersionDatadogAgent$inboundSchema` instead. */
  export const inboundSchema = MaximumTLSVersionDatadogAgent$inboundSchema;
  /** @deprecated use `MaximumTLSVersionDatadogAgent$outboundSchema` instead. */
  export const outboundSchema = MaximumTLSVersionDatadogAgent$outboundSchema;
}

/** @internal */
export const TLSSettingsServerSideDatadogAgent$inboundSchema: z.ZodType<
  TLSSettingsServerSideDatadogAgent,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionDatadogAgent$inboundSchema.optional(),
  maxVersion: MaximumTLSVersionDatadogAgent$inboundSchema.optional(),
});

/** @internal */
export type TLSSettingsServerSideDatadogAgent$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TLSSettingsServerSideDatadogAgent$outboundSchema: z.ZodType<
  TLSSettingsServerSideDatadogAgent$Outbound,
  z.ZodTypeDef,
  TLSSettingsServerSideDatadogAgent
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionDatadogAgent$outboundSchema.optional(),
  maxVersion: MaximumTLSVersionDatadogAgent$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsServerSideDatadogAgent$ {
  /** @deprecated use `TLSSettingsServerSideDatadogAgent$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsServerSideDatadogAgent$inboundSchema;
  /** @deprecated use `TLSSettingsServerSideDatadogAgent$outboundSchema` instead. */
  export const outboundSchema =
    TLSSettingsServerSideDatadogAgent$outboundSchema;
  /** @deprecated use `TLSSettingsServerSideDatadogAgent$Outbound` instead. */
  export type Outbound = TLSSettingsServerSideDatadogAgent$Outbound;
}

export function tlsSettingsServerSideDatadogAgentToJSON(
  tlsSettingsServerSideDatadogAgent: TLSSettingsServerSideDatadogAgent,
): string {
  return JSON.stringify(
    TLSSettingsServerSideDatadogAgent$outboundSchema.parse(
      tlsSettingsServerSideDatadogAgent,
    ),
  );
}

export function tlsSettingsServerSideDatadogAgentFromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsServerSideDatadogAgent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TLSSettingsServerSideDatadogAgent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsServerSideDatadogAgent' from JSON`,
  );
}

/** @internal */
export const MetadatumDatadogAgent$inboundSchema: z.ZodType<
  MetadatumDatadogAgent,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumDatadogAgent$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumDatadogAgent$outboundSchema: z.ZodType<
  MetadatumDatadogAgent$Outbound,
  z.ZodTypeDef,
  MetadatumDatadogAgent
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumDatadogAgent$ {
  /** @deprecated use `MetadatumDatadogAgent$inboundSchema` instead. */
  export const inboundSchema = MetadatumDatadogAgent$inboundSchema;
  /** @deprecated use `MetadatumDatadogAgent$outboundSchema` instead. */
  export const outboundSchema = MetadatumDatadogAgent$outboundSchema;
  /** @deprecated use `MetadatumDatadogAgent$Outbound` instead. */
  export type Outbound = MetadatumDatadogAgent$Outbound;
}

export function metadatumDatadogAgentToJSON(
  metadatumDatadogAgent: MetadatumDatadogAgent,
): string {
  return JSON.stringify(
    MetadatumDatadogAgent$outboundSchema.parse(metadatumDatadogAgent),
  );
}

export function metadatumDatadogAgentFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumDatadogAgent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumDatadogAgent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumDatadogAgent' from JSON`,
  );
}

/** @internal */
export const ProxyModeDatadogAgent$inboundSchema: z.ZodType<
  ProxyModeDatadogAgent,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
});

/** @internal */
export type ProxyModeDatadogAgent$Outbound = {
  enabled: boolean;
  rejectUnauthorized: boolean;
};

/** @internal */
export const ProxyModeDatadogAgent$outboundSchema: z.ZodType<
  ProxyModeDatadogAgent$Outbound,
  z.ZodTypeDef,
  ProxyModeDatadogAgent
> = z.object({
  enabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ProxyModeDatadogAgent$ {
  /** @deprecated use `ProxyModeDatadogAgent$inboundSchema` instead. */
  export const inboundSchema = ProxyModeDatadogAgent$inboundSchema;
  /** @deprecated use `ProxyModeDatadogAgent$outboundSchema` instead. */
  export const outboundSchema = ProxyModeDatadogAgent$outboundSchema;
  /** @deprecated use `ProxyModeDatadogAgent$Outbound` instead. */
  export type Outbound = ProxyModeDatadogAgent$Outbound;
}

export function proxyModeDatadogAgentToJSON(
  proxyModeDatadogAgent: ProxyModeDatadogAgent,
): string {
  return JSON.stringify(
    ProxyModeDatadogAgent$outboundSchema.parse(proxyModeDatadogAgent),
  );
}

export function proxyModeDatadogAgentFromJSON(
  jsonString: string,
): SafeParseResult<ProxyModeDatadogAgent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ProxyModeDatadogAgent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProxyModeDatadogAgent' from JSON`,
  );
}

/** @internal */
export const InputDatadogAgent$inboundSchema: z.ZodType<
  InputDatadogAgent,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeDatadogAgent$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionDatadogAgent$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqDatadogAgent$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => TLSSettingsServerSideDatadogAgent$inboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  extractMetrics: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumDatadogAgent$inboundSchema))
    .optional(),
  proxyMode: z.lazy(() => ProxyModeDatadogAgent$inboundSchema).optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputDatadogAgent$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionDatadogAgent$Outbound> | undefined;
  pq?: PqDatadogAgent$Outbound | undefined;
  host: string;
  port: number;
  tls?: TLSSettingsServerSideDatadogAgent$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  extractMetrics: boolean;
  metadata?: Array<MetadatumDatadogAgent$Outbound> | undefined;
  proxyMode?: ProxyModeDatadogAgent$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputDatadogAgent$outboundSchema: z.ZodType<
  InputDatadogAgent$Outbound,
  z.ZodTypeDef,
  InputDatadogAgent
> = z.object({
  id: z.string(),
  type: TypeDatadogAgent$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionDatadogAgent$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqDatadogAgent$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => TLSSettingsServerSideDatadogAgent$outboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  extractMetrics: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumDatadogAgent$outboundSchema))
    .optional(),
  proxyMode: z.lazy(() => ProxyModeDatadogAgent$outboundSchema).optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatadogAgent$ {
  /** @deprecated use `InputDatadogAgent$inboundSchema` instead. */
  export const inboundSchema = InputDatadogAgent$inboundSchema;
  /** @deprecated use `InputDatadogAgent$outboundSchema` instead. */
  export const outboundSchema = InputDatadogAgent$outboundSchema;
  /** @deprecated use `InputDatadogAgent$Outbound` instead. */
  export type Outbound = InputDatadogAgent$Outbound;
}

export function inputDatadogAgentToJSON(
  inputDatadogAgent: InputDatadogAgent,
): string {
  return JSON.stringify(
    InputDatadogAgent$outboundSchema.parse(inputDatadogAgent),
  );
}

export function inputDatadogAgentFromJSON(
  jsonString: string,
): SafeParseResult<InputDatadogAgent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputDatadogAgent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputDatadogAgent' from JSON`,
  );
}

/** @internal */
export const TypeCrowdstrike$inboundSchema: z.ZodNativeEnum<
  typeof TypeCrowdstrike
> = z.nativeEnum(TypeCrowdstrike);

/** @internal */
export const TypeCrowdstrike$outboundSchema: z.ZodNativeEnum<
  typeof TypeCrowdstrike
> = TypeCrowdstrike$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeCrowdstrike$ {
  /** @deprecated use `TypeCrowdstrike$inboundSchema` instead. */
  export const inboundSchema = TypeCrowdstrike$inboundSchema;
  /** @deprecated use `TypeCrowdstrike$outboundSchema` instead. */
  export const outboundSchema = TypeCrowdstrike$outboundSchema;
}

/** @internal */
export const ConnectionCrowdstrike$inboundSchema: z.ZodType<
  ConnectionCrowdstrike,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionCrowdstrike$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionCrowdstrike$outboundSchema: z.ZodType<
  ConnectionCrowdstrike$Outbound,
  z.ZodTypeDef,
  ConnectionCrowdstrike
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionCrowdstrike$ {
  /** @deprecated use `ConnectionCrowdstrike$inboundSchema` instead. */
  export const inboundSchema = ConnectionCrowdstrike$inboundSchema;
  /** @deprecated use `ConnectionCrowdstrike$outboundSchema` instead. */
  export const outboundSchema = ConnectionCrowdstrike$outboundSchema;
  /** @deprecated use `ConnectionCrowdstrike$Outbound` instead. */
  export type Outbound = ConnectionCrowdstrike$Outbound;
}

export function connectionCrowdstrikeToJSON(
  connectionCrowdstrike: ConnectionCrowdstrike,
): string {
  return JSON.stringify(
    ConnectionCrowdstrike$outboundSchema.parse(connectionCrowdstrike),
  );
}

export function connectionCrowdstrikeFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionCrowdstrike, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionCrowdstrike$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionCrowdstrike' from JSON`,
  );
}

/** @internal */
export const ModeCrowdstrike$inboundSchema: z.ZodNativeEnum<
  typeof ModeCrowdstrike
> = z.nativeEnum(ModeCrowdstrike);

/** @internal */
export const ModeCrowdstrike$outboundSchema: z.ZodNativeEnum<
  typeof ModeCrowdstrike
> = ModeCrowdstrike$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeCrowdstrike$ {
  /** @deprecated use `ModeCrowdstrike$inboundSchema` instead. */
  export const inboundSchema = ModeCrowdstrike$inboundSchema;
  /** @deprecated use `ModeCrowdstrike$outboundSchema` instead. */
  export const outboundSchema = ModeCrowdstrike$outboundSchema;
}

/** @internal */
export const CompressionCrowdstrike$inboundSchema: z.ZodNativeEnum<
  typeof CompressionCrowdstrike
> = z.nativeEnum(CompressionCrowdstrike);

/** @internal */
export const CompressionCrowdstrike$outboundSchema: z.ZodNativeEnum<
  typeof CompressionCrowdstrike
> = CompressionCrowdstrike$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionCrowdstrike$ {
  /** @deprecated use `CompressionCrowdstrike$inboundSchema` instead. */
  export const inboundSchema = CompressionCrowdstrike$inboundSchema;
  /** @deprecated use `CompressionCrowdstrike$outboundSchema` instead. */
  export const outboundSchema = CompressionCrowdstrike$outboundSchema;
}

/** @internal */
export const PqCrowdstrike$inboundSchema: z.ZodType<
  PqCrowdstrike,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeCrowdstrike$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionCrowdstrike$inboundSchema.default("none"),
});

/** @internal */
export type PqCrowdstrike$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqCrowdstrike$outboundSchema: z.ZodType<
  PqCrowdstrike$Outbound,
  z.ZodTypeDef,
  PqCrowdstrike
> = z.object({
  mode: ModeCrowdstrike$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionCrowdstrike$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCrowdstrike$ {
  /** @deprecated use `PqCrowdstrike$inboundSchema` instead. */
  export const inboundSchema = PqCrowdstrike$inboundSchema;
  /** @deprecated use `PqCrowdstrike$outboundSchema` instead. */
  export const outboundSchema = PqCrowdstrike$outboundSchema;
  /** @deprecated use `PqCrowdstrike$Outbound` instead. */
  export type Outbound = PqCrowdstrike$Outbound;
}

export function pqCrowdstrikeToJSON(pqCrowdstrike: PqCrowdstrike): string {
  return JSON.stringify(PqCrowdstrike$outboundSchema.parse(pqCrowdstrike));
}

export function pqCrowdstrikeFromJSON(
  jsonString: string,
): SafeParseResult<PqCrowdstrike, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqCrowdstrike$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqCrowdstrike' from JSON`,
  );
}

/** @internal */
export const AuthenticationMethodCrowdstrike$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodCrowdstrike
> = z.nativeEnum(AuthenticationMethodCrowdstrike);

/** @internal */
export const AuthenticationMethodCrowdstrike$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodCrowdstrike
> = AuthenticationMethodCrowdstrike$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodCrowdstrike$ {
  /** @deprecated use `AuthenticationMethodCrowdstrike$inboundSchema` instead. */
  export const inboundSchema = AuthenticationMethodCrowdstrike$inboundSchema;
  /** @deprecated use `AuthenticationMethodCrowdstrike$outboundSchema` instead. */
  export const outboundSchema = AuthenticationMethodCrowdstrike$outboundSchema;
}

/** @internal */
export const SignatureVersionCrowdstrike$inboundSchema: z.ZodNativeEnum<
  typeof SignatureVersionCrowdstrike
> = z.nativeEnum(SignatureVersionCrowdstrike);

/** @internal */
export const SignatureVersionCrowdstrike$outboundSchema: z.ZodNativeEnum<
  typeof SignatureVersionCrowdstrike
> = SignatureVersionCrowdstrike$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignatureVersionCrowdstrike$ {
  /** @deprecated use `SignatureVersionCrowdstrike$inboundSchema` instead. */
  export const inboundSchema = SignatureVersionCrowdstrike$inboundSchema;
  /** @deprecated use `SignatureVersionCrowdstrike$outboundSchema` instead. */
  export const outboundSchema = SignatureVersionCrowdstrike$outboundSchema;
}

/** @internal */
export const PreprocessCrowdstrike$inboundSchema: z.ZodType<
  PreprocessCrowdstrike,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  command: z.string().optional(),
  args: z.array(z.string()).optional(),
});

/** @internal */
export type PreprocessCrowdstrike$Outbound = {
  disabled: boolean;
  command?: string | undefined;
  args?: Array<string> | undefined;
};

/** @internal */
export const PreprocessCrowdstrike$outboundSchema: z.ZodType<
  PreprocessCrowdstrike$Outbound,
  z.ZodTypeDef,
  PreprocessCrowdstrike
> = z.object({
  disabled: z.boolean().default(true),
  command: z.string().optional(),
  args: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PreprocessCrowdstrike$ {
  /** @deprecated use `PreprocessCrowdstrike$inboundSchema` instead. */
  export const inboundSchema = PreprocessCrowdstrike$inboundSchema;
  /** @deprecated use `PreprocessCrowdstrike$outboundSchema` instead. */
  export const outboundSchema = PreprocessCrowdstrike$outboundSchema;
  /** @deprecated use `PreprocessCrowdstrike$Outbound` instead. */
  export type Outbound = PreprocessCrowdstrike$Outbound;
}

export function preprocessCrowdstrikeToJSON(
  preprocessCrowdstrike: PreprocessCrowdstrike,
): string {
  return JSON.stringify(
    PreprocessCrowdstrike$outboundSchema.parse(preprocessCrowdstrike),
  );
}

export function preprocessCrowdstrikeFromJSON(
  jsonString: string,
): SafeParseResult<PreprocessCrowdstrike, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreprocessCrowdstrike$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreprocessCrowdstrike' from JSON`,
  );
}

/** @internal */
export const MetadatumCrowdstrike$inboundSchema: z.ZodType<
  MetadatumCrowdstrike,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumCrowdstrike$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumCrowdstrike$outboundSchema: z.ZodType<
  MetadatumCrowdstrike$Outbound,
  z.ZodTypeDef,
  MetadatumCrowdstrike
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumCrowdstrike$ {
  /** @deprecated use `MetadatumCrowdstrike$inboundSchema` instead. */
  export const inboundSchema = MetadatumCrowdstrike$inboundSchema;
  /** @deprecated use `MetadatumCrowdstrike$outboundSchema` instead. */
  export const outboundSchema = MetadatumCrowdstrike$outboundSchema;
  /** @deprecated use `MetadatumCrowdstrike$Outbound` instead. */
  export type Outbound = MetadatumCrowdstrike$Outbound;
}

export function metadatumCrowdstrikeToJSON(
  metadatumCrowdstrike: MetadatumCrowdstrike,
): string {
  return JSON.stringify(
    MetadatumCrowdstrike$outboundSchema.parse(metadatumCrowdstrike),
  );
}

export function metadatumCrowdstrikeFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumCrowdstrike, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumCrowdstrike$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumCrowdstrike' from JSON`,
  );
}

/** @internal */
export const CheckpointingCrowdstrike$inboundSchema: z.ZodType<
  CheckpointingCrowdstrike,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().default(false),
  retries: z.number().default(5),
});

/** @internal */
export type CheckpointingCrowdstrike$Outbound = {
  enabled: boolean;
  retries: number;
};

/** @internal */
export const CheckpointingCrowdstrike$outboundSchema: z.ZodType<
  CheckpointingCrowdstrike$Outbound,
  z.ZodTypeDef,
  CheckpointingCrowdstrike
> = z.object({
  enabled: z.boolean().default(false),
  retries: z.number().default(5),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CheckpointingCrowdstrike$ {
  /** @deprecated use `CheckpointingCrowdstrike$inboundSchema` instead. */
  export const inboundSchema = CheckpointingCrowdstrike$inboundSchema;
  /** @deprecated use `CheckpointingCrowdstrike$outboundSchema` instead. */
  export const outboundSchema = CheckpointingCrowdstrike$outboundSchema;
  /** @deprecated use `CheckpointingCrowdstrike$Outbound` instead. */
  export type Outbound = CheckpointingCrowdstrike$Outbound;
}

export function checkpointingCrowdstrikeToJSON(
  checkpointingCrowdstrike: CheckpointingCrowdstrike,
): string {
  return JSON.stringify(
    CheckpointingCrowdstrike$outboundSchema.parse(checkpointingCrowdstrike),
  );
}

export function checkpointingCrowdstrikeFromJSON(
  jsonString: string,
): SafeParseResult<CheckpointingCrowdstrike, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckpointingCrowdstrike$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckpointingCrowdstrike' from JSON`,
  );
}

/** @internal */
export const TagAfterProcessingCrowdstrike$inboundSchema: z.ZodNativeEnum<
  typeof TagAfterProcessingCrowdstrike
> = z.nativeEnum(TagAfterProcessingCrowdstrike);

/** @internal */
export const TagAfterProcessingCrowdstrike$outboundSchema: z.ZodNativeEnum<
  typeof TagAfterProcessingCrowdstrike
> = TagAfterProcessingCrowdstrike$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TagAfterProcessingCrowdstrike$ {
  /** @deprecated use `TagAfterProcessingCrowdstrike$inboundSchema` instead. */
  export const inboundSchema = TagAfterProcessingCrowdstrike$inboundSchema;
  /** @deprecated use `TagAfterProcessingCrowdstrike$outboundSchema` instead. */
  export const outboundSchema = TagAfterProcessingCrowdstrike$outboundSchema;
}

/** @internal */
export const InputCrowdstrike$inboundSchema: z.ZodType<
  InputCrowdstrike,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeCrowdstrike$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionCrowdstrike$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqCrowdstrike$inboundSchema).optional(),
  queueName: z.string(),
  fileFilter: z.string().default("/.*/"),
  awsAccountId: z.string().optional(),
  awsAuthenticationMethod: AuthenticationMethodCrowdstrike$inboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionCrowdstrike$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  maxMessages: z.number().default(1),
  visibilityTimeout: z.number().default(21600),
  numReceivers: z.number().default(1),
  socketTimeout: z.number().default(300),
  skipOnError: z.boolean().default(false),
  enableAssumeRole: z.boolean().default(true),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  enableSQSAssumeRole: z.boolean().default(false),
  preprocess: z.lazy(() => PreprocessCrowdstrike$inboundSchema).optional(),
  metadata: z.array(z.lazy(() => MetadatumCrowdstrike$inboundSchema))
    .optional(),
  checkpointing: z.lazy(() => CheckpointingCrowdstrike$inboundSchema)
    .optional(),
  pollTimeout: z.number().default(10),
  encoding: z.string().optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  tagAfterProcessing: TagAfterProcessingCrowdstrike$inboundSchema.optional(),
  processedTagKey: z.string().optional(),
  processedTagValue: z.string().optional(),
});

/** @internal */
export type InputCrowdstrike$Outbound = {
  id: string;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionCrowdstrike$Outbound> | undefined;
  pq?: PqCrowdstrike$Outbound | undefined;
  queueName: string;
  fileFilter: string;
  awsAccountId?: string | undefined;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  maxMessages: number;
  visibilityTimeout: number;
  numReceivers: number;
  socketTimeout: number;
  skipOnError: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  enableSQSAssumeRole: boolean;
  preprocess?: PreprocessCrowdstrike$Outbound | undefined;
  metadata?: Array<MetadatumCrowdstrike$Outbound> | undefined;
  checkpointing?: CheckpointingCrowdstrike$Outbound | undefined;
  pollTimeout: number;
  encoding?: string | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  tagAfterProcessing?: string | undefined;
  processedTagKey?: string | undefined;
  processedTagValue?: string | undefined;
};

/** @internal */
export const InputCrowdstrike$outboundSchema: z.ZodType<
  InputCrowdstrike$Outbound,
  z.ZodTypeDef,
  InputCrowdstrike
> = z.object({
  id: z.string(),
  type: TypeCrowdstrike$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionCrowdstrike$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqCrowdstrike$outboundSchema).optional(),
  queueName: z.string(),
  fileFilter: z.string().default("/.*/"),
  awsAccountId: z.string().optional(),
  awsAuthenticationMethod: AuthenticationMethodCrowdstrike$outboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionCrowdstrike$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  maxMessages: z.number().default(1),
  visibilityTimeout: z.number().default(21600),
  numReceivers: z.number().default(1),
  socketTimeout: z.number().default(300),
  skipOnError: z.boolean().default(false),
  enableAssumeRole: z.boolean().default(true),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  enableSQSAssumeRole: z.boolean().default(false),
  preprocess: z.lazy(() => PreprocessCrowdstrike$outboundSchema).optional(),
  metadata: z.array(z.lazy(() => MetadatumCrowdstrike$outboundSchema))
    .optional(),
  checkpointing: z.lazy(() => CheckpointingCrowdstrike$outboundSchema)
    .optional(),
  pollTimeout: z.number().default(10),
  encoding: z.string().optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  tagAfterProcessing: TagAfterProcessingCrowdstrike$outboundSchema.optional(),
  processedTagKey: z.string().optional(),
  processedTagValue: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCrowdstrike$ {
  /** @deprecated use `InputCrowdstrike$inboundSchema` instead. */
  export const inboundSchema = InputCrowdstrike$inboundSchema;
  /** @deprecated use `InputCrowdstrike$outboundSchema` instead. */
  export const outboundSchema = InputCrowdstrike$outboundSchema;
  /** @deprecated use `InputCrowdstrike$Outbound` instead. */
  export type Outbound = InputCrowdstrike$Outbound;
}

export function inputCrowdstrikeToJSON(
  inputCrowdstrike: InputCrowdstrike,
): string {
  return JSON.stringify(
    InputCrowdstrike$outboundSchema.parse(inputCrowdstrike),
  );
}

export function inputCrowdstrikeFromJSON(
  jsonString: string,
): SafeParseResult<InputCrowdstrike, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputCrowdstrike$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCrowdstrike' from JSON`,
  );
}

/** @internal */
export const TypeTcpjson$inboundSchema: z.ZodNativeEnum<typeof TypeTcpjson> = z
  .nativeEnum(TypeTcpjson);

/** @internal */
export const TypeTcpjson$outboundSchema: z.ZodNativeEnum<typeof TypeTcpjson> =
  TypeTcpjson$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeTcpjson$ {
  /** @deprecated use `TypeTcpjson$inboundSchema` instead. */
  export const inboundSchema = TypeTcpjson$inboundSchema;
  /** @deprecated use `TypeTcpjson$outboundSchema` instead. */
  export const outboundSchema = TypeTcpjson$outboundSchema;
}

/** @internal */
export const ConnectionTcpjson$inboundSchema: z.ZodType<
  ConnectionTcpjson,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionTcpjson$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionTcpjson$outboundSchema: z.ZodType<
  ConnectionTcpjson$Outbound,
  z.ZodTypeDef,
  ConnectionTcpjson
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionTcpjson$ {
  /** @deprecated use `ConnectionTcpjson$inboundSchema` instead. */
  export const inboundSchema = ConnectionTcpjson$inboundSchema;
  /** @deprecated use `ConnectionTcpjson$outboundSchema` instead. */
  export const outboundSchema = ConnectionTcpjson$outboundSchema;
  /** @deprecated use `ConnectionTcpjson$Outbound` instead. */
  export type Outbound = ConnectionTcpjson$Outbound;
}

export function connectionTcpjsonToJSON(
  connectionTcpjson: ConnectionTcpjson,
): string {
  return JSON.stringify(
    ConnectionTcpjson$outboundSchema.parse(connectionTcpjson),
  );
}

export function connectionTcpjsonFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionTcpjson, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionTcpjson$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionTcpjson' from JSON`,
  );
}

/** @internal */
export const ModeTcpjson$inboundSchema: z.ZodNativeEnum<typeof ModeTcpjson> = z
  .nativeEnum(ModeTcpjson);

/** @internal */
export const ModeTcpjson$outboundSchema: z.ZodNativeEnum<typeof ModeTcpjson> =
  ModeTcpjson$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeTcpjson$ {
  /** @deprecated use `ModeTcpjson$inboundSchema` instead. */
  export const inboundSchema = ModeTcpjson$inboundSchema;
  /** @deprecated use `ModeTcpjson$outboundSchema` instead. */
  export const outboundSchema = ModeTcpjson$outboundSchema;
}

/** @internal */
export const CompressionTcpjson$inboundSchema: z.ZodNativeEnum<
  typeof CompressionTcpjson
> = z.nativeEnum(CompressionTcpjson);

/** @internal */
export const CompressionTcpjson$outboundSchema: z.ZodNativeEnum<
  typeof CompressionTcpjson
> = CompressionTcpjson$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionTcpjson$ {
  /** @deprecated use `CompressionTcpjson$inboundSchema` instead. */
  export const inboundSchema = CompressionTcpjson$inboundSchema;
  /** @deprecated use `CompressionTcpjson$outboundSchema` instead. */
  export const outboundSchema = CompressionTcpjson$outboundSchema;
}

/** @internal */
export const PqTcpjson$inboundSchema: z.ZodType<
  PqTcpjson,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeTcpjson$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionTcpjson$inboundSchema.default("none"),
});

/** @internal */
export type PqTcpjson$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqTcpjson$outboundSchema: z.ZodType<
  PqTcpjson$Outbound,
  z.ZodTypeDef,
  PqTcpjson
> = z.object({
  mode: ModeTcpjson$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionTcpjson$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqTcpjson$ {
  /** @deprecated use `PqTcpjson$inboundSchema` instead. */
  export const inboundSchema = PqTcpjson$inboundSchema;
  /** @deprecated use `PqTcpjson$outboundSchema` instead. */
  export const outboundSchema = PqTcpjson$outboundSchema;
  /** @deprecated use `PqTcpjson$Outbound` instead. */
  export type Outbound = PqTcpjson$Outbound;
}

export function pqTcpjsonToJSON(pqTcpjson: PqTcpjson): string {
  return JSON.stringify(PqTcpjson$outboundSchema.parse(pqTcpjson));
}

export function pqTcpjsonFromJSON(
  jsonString: string,
): SafeParseResult<PqTcpjson, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqTcpjson$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqTcpjson' from JSON`,
  );
}

/** @internal */
export const MinimumTLSVersionTcpjson$inboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionTcpjson
> = z.nativeEnum(MinimumTLSVersionTcpjson);

/** @internal */
export const MinimumTLSVersionTcpjson$outboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionTcpjson
> = MinimumTLSVersionTcpjson$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MinimumTLSVersionTcpjson$ {
  /** @deprecated use `MinimumTLSVersionTcpjson$inboundSchema` instead. */
  export const inboundSchema = MinimumTLSVersionTcpjson$inboundSchema;
  /** @deprecated use `MinimumTLSVersionTcpjson$outboundSchema` instead. */
  export const outboundSchema = MinimumTLSVersionTcpjson$outboundSchema;
}

/** @internal */
export const MaximumTLSVersionTcpjson$inboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionTcpjson
> = z.nativeEnum(MaximumTLSVersionTcpjson);

/** @internal */
export const MaximumTLSVersionTcpjson$outboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionTcpjson
> = MaximumTLSVersionTcpjson$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaximumTLSVersionTcpjson$ {
  /** @deprecated use `MaximumTLSVersionTcpjson$inboundSchema` instead. */
  export const inboundSchema = MaximumTLSVersionTcpjson$inboundSchema;
  /** @deprecated use `MaximumTLSVersionTcpjson$outboundSchema` instead. */
  export const outboundSchema = MaximumTLSVersionTcpjson$outboundSchema;
}

/** @internal */
export const TLSSettingsServerSideTcpjson$inboundSchema: z.ZodType<
  TLSSettingsServerSideTcpjson,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionTcpjson$inboundSchema.optional(),
  maxVersion: MaximumTLSVersionTcpjson$inboundSchema.optional(),
});

/** @internal */
export type TLSSettingsServerSideTcpjson$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TLSSettingsServerSideTcpjson$outboundSchema: z.ZodType<
  TLSSettingsServerSideTcpjson$Outbound,
  z.ZodTypeDef,
  TLSSettingsServerSideTcpjson
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionTcpjson$outboundSchema.optional(),
  maxVersion: MaximumTLSVersionTcpjson$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsServerSideTcpjson$ {
  /** @deprecated use `TLSSettingsServerSideTcpjson$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsServerSideTcpjson$inboundSchema;
  /** @deprecated use `TLSSettingsServerSideTcpjson$outboundSchema` instead. */
  export const outboundSchema = TLSSettingsServerSideTcpjson$outboundSchema;
  /** @deprecated use `TLSSettingsServerSideTcpjson$Outbound` instead. */
  export type Outbound = TLSSettingsServerSideTcpjson$Outbound;
}

export function tlsSettingsServerSideTcpjsonToJSON(
  tlsSettingsServerSideTcpjson: TLSSettingsServerSideTcpjson,
): string {
  return JSON.stringify(
    TLSSettingsServerSideTcpjson$outboundSchema.parse(
      tlsSettingsServerSideTcpjson,
    ),
  );
}

export function tlsSettingsServerSideTcpjsonFromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsServerSideTcpjson, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TLSSettingsServerSideTcpjson$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsServerSideTcpjson' from JSON`,
  );
}

/** @internal */
export const MetadatumTcpjson$inboundSchema: z.ZodType<
  MetadatumTcpjson,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumTcpjson$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumTcpjson$outboundSchema: z.ZodType<
  MetadatumTcpjson$Outbound,
  z.ZodTypeDef,
  MetadatumTcpjson
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumTcpjson$ {
  /** @deprecated use `MetadatumTcpjson$inboundSchema` instead. */
  export const inboundSchema = MetadatumTcpjson$inboundSchema;
  /** @deprecated use `MetadatumTcpjson$outboundSchema` instead. */
  export const outboundSchema = MetadatumTcpjson$outboundSchema;
  /** @deprecated use `MetadatumTcpjson$Outbound` instead. */
  export type Outbound = MetadatumTcpjson$Outbound;
}

export function metadatumTcpjsonToJSON(
  metadatumTcpjson: MetadatumTcpjson,
): string {
  return JSON.stringify(
    MetadatumTcpjson$outboundSchema.parse(metadatumTcpjson),
  );
}

export function metadatumTcpjsonFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumTcpjson, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumTcpjson$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumTcpjson' from JSON`,
  );
}

/** @internal */
export const AuthenticationMethodTcpjson$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodTcpjson
> = z.nativeEnum(AuthenticationMethodTcpjson);

/** @internal */
export const AuthenticationMethodTcpjson$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodTcpjson
> = AuthenticationMethodTcpjson$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodTcpjson$ {
  /** @deprecated use `AuthenticationMethodTcpjson$inboundSchema` instead. */
  export const inboundSchema = AuthenticationMethodTcpjson$inboundSchema;
  /** @deprecated use `AuthenticationMethodTcpjson$outboundSchema` instead. */
  export const outboundSchema = AuthenticationMethodTcpjson$outboundSchema;
}

/** @internal */
export const InputTcpjson$inboundSchema: z.ZodType<
  InputTcpjson,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeTcpjson$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionTcpjson$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqTcpjson$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => TLSSettingsServerSideTcpjson$inboundSchema).optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumTcpjson$inboundSchema)).optional(),
  enableLoadBalancing: z.boolean().default(false),
  authType: AuthenticationMethodTcpjson$inboundSchema.default("manual"),
  description: z.string().optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});

/** @internal */
export type InputTcpjson$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionTcpjson$Outbound> | undefined;
  pq?: PqTcpjson$Outbound | undefined;
  host: string;
  port: number;
  tls?: TLSSettingsServerSideTcpjson$Outbound | undefined;
  ipWhitelistRegex: string;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  enableProxyHeader: boolean;
  metadata?: Array<MetadatumTcpjson$Outbound> | undefined;
  enableLoadBalancing: boolean;
  authType: string;
  description?: string | undefined;
  authToken: string;
  textSecret?: string | undefined;
};

/** @internal */
export const InputTcpjson$outboundSchema: z.ZodType<
  InputTcpjson$Outbound,
  z.ZodTypeDef,
  InputTcpjson
> = z.object({
  id: z.string(),
  type: TypeTcpjson$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionTcpjson$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqTcpjson$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => TLSSettingsServerSideTcpjson$outboundSchema).optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumTcpjson$outboundSchema)).optional(),
  enableLoadBalancing: z.boolean().default(false),
  authType: AuthenticationMethodTcpjson$outboundSchema.default("manual"),
  description: z.string().optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcpjson$ {
  /** @deprecated use `InputTcpjson$inboundSchema` instead. */
  export const inboundSchema = InputTcpjson$inboundSchema;
  /** @deprecated use `InputTcpjson$outboundSchema` instead. */
  export const outboundSchema = InputTcpjson$outboundSchema;
  /** @deprecated use `InputTcpjson$Outbound` instead. */
  export type Outbound = InputTcpjson$Outbound;
}

export function inputTcpjsonToJSON(inputTcpjson: InputTcpjson): string {
  return JSON.stringify(InputTcpjson$outboundSchema.parse(inputTcpjson));
}

export function inputTcpjsonFromJSON(
  jsonString: string,
): SafeParseResult<InputTcpjson, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputTcpjson$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputTcpjson' from JSON`,
  );
}

/** @internal */
export const TypeCriblLakeHTTP$inboundSchema: z.ZodNativeEnum<
  typeof TypeCriblLakeHTTP
> = z.nativeEnum(TypeCriblLakeHTTP);

/** @internal */
export const TypeCriblLakeHTTP$outboundSchema: z.ZodNativeEnum<
  typeof TypeCriblLakeHTTP
> = TypeCriblLakeHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeCriblLakeHTTP$ {
  /** @deprecated use `TypeCriblLakeHTTP$inboundSchema` instead. */
  export const inboundSchema = TypeCriblLakeHTTP$inboundSchema;
  /** @deprecated use `TypeCriblLakeHTTP$outboundSchema` instead. */
  export const outboundSchema = TypeCriblLakeHTTP$outboundSchema;
}

/** @internal */
export const ConnectionCriblLakeHTTP$inboundSchema: z.ZodType<
  ConnectionCriblLakeHTTP,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionCriblLakeHTTP$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionCriblLakeHTTP$outboundSchema: z.ZodType<
  ConnectionCriblLakeHTTP$Outbound,
  z.ZodTypeDef,
  ConnectionCriblLakeHTTP
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionCriblLakeHTTP$ {
  /** @deprecated use `ConnectionCriblLakeHTTP$inboundSchema` instead. */
  export const inboundSchema = ConnectionCriblLakeHTTP$inboundSchema;
  /** @deprecated use `ConnectionCriblLakeHTTP$outboundSchema` instead. */
  export const outboundSchema = ConnectionCriblLakeHTTP$outboundSchema;
  /** @deprecated use `ConnectionCriblLakeHTTP$Outbound` instead. */
  export type Outbound = ConnectionCriblLakeHTTP$Outbound;
}

export function connectionCriblLakeHTTPToJSON(
  connectionCriblLakeHTTP: ConnectionCriblLakeHTTP,
): string {
  return JSON.stringify(
    ConnectionCriblLakeHTTP$outboundSchema.parse(connectionCriblLakeHTTP),
  );
}

export function connectionCriblLakeHTTPFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionCriblLakeHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionCriblLakeHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionCriblLakeHTTP' from JSON`,
  );
}

/** @internal */
export const ModeCriblLakeHTTP$inboundSchema: z.ZodNativeEnum<
  typeof ModeCriblLakeHTTP
> = z.nativeEnum(ModeCriblLakeHTTP);

/** @internal */
export const ModeCriblLakeHTTP$outboundSchema: z.ZodNativeEnum<
  typeof ModeCriblLakeHTTP
> = ModeCriblLakeHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeCriblLakeHTTP$ {
  /** @deprecated use `ModeCriblLakeHTTP$inboundSchema` instead. */
  export const inboundSchema = ModeCriblLakeHTTP$inboundSchema;
  /** @deprecated use `ModeCriblLakeHTTP$outboundSchema` instead. */
  export const outboundSchema = ModeCriblLakeHTTP$outboundSchema;
}

/** @internal */
export const CompressionCriblLakeHTTP$inboundSchema: z.ZodNativeEnum<
  typeof CompressionCriblLakeHTTP
> = z.nativeEnum(CompressionCriblLakeHTTP);

/** @internal */
export const CompressionCriblLakeHTTP$outboundSchema: z.ZodNativeEnum<
  typeof CompressionCriblLakeHTTP
> = CompressionCriblLakeHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionCriblLakeHTTP$ {
  /** @deprecated use `CompressionCriblLakeHTTP$inboundSchema` instead. */
  export const inboundSchema = CompressionCriblLakeHTTP$inboundSchema;
  /** @deprecated use `CompressionCriblLakeHTTP$outboundSchema` instead. */
  export const outboundSchema = CompressionCriblLakeHTTP$outboundSchema;
}

/** @internal */
export const PqCriblLakeHTTP$inboundSchema: z.ZodType<
  PqCriblLakeHTTP,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeCriblLakeHTTP$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionCriblLakeHTTP$inboundSchema.default("none"),
});

/** @internal */
export type PqCriblLakeHTTP$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqCriblLakeHTTP$outboundSchema: z.ZodType<
  PqCriblLakeHTTP$Outbound,
  z.ZodTypeDef,
  PqCriblLakeHTTP
> = z.object({
  mode: ModeCriblLakeHTTP$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionCriblLakeHTTP$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCriblLakeHTTP$ {
  /** @deprecated use `PqCriblLakeHTTP$inboundSchema` instead. */
  export const inboundSchema = PqCriblLakeHTTP$inboundSchema;
  /** @deprecated use `PqCriblLakeHTTP$outboundSchema` instead. */
  export const outboundSchema = PqCriblLakeHTTP$outboundSchema;
  /** @deprecated use `PqCriblLakeHTTP$Outbound` instead. */
  export type Outbound = PqCriblLakeHTTP$Outbound;
}

export function pqCriblLakeHTTPToJSON(
  pqCriblLakeHTTP: PqCriblLakeHTTP,
): string {
  return JSON.stringify(PqCriblLakeHTTP$outboundSchema.parse(pqCriblLakeHTTP));
}

export function pqCriblLakeHTTPFromJSON(
  jsonString: string,
): SafeParseResult<PqCriblLakeHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqCriblLakeHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqCriblLakeHTTP' from JSON`,
  );
}

/** @internal */
export const MinimumTLSVersionCriblLakeHTTP$inboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionCriblLakeHTTP
> = z.nativeEnum(MinimumTLSVersionCriblLakeHTTP);

/** @internal */
export const MinimumTLSVersionCriblLakeHTTP$outboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionCriblLakeHTTP
> = MinimumTLSVersionCriblLakeHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MinimumTLSVersionCriblLakeHTTP$ {
  /** @deprecated use `MinimumTLSVersionCriblLakeHTTP$inboundSchema` instead. */
  export const inboundSchema = MinimumTLSVersionCriblLakeHTTP$inboundSchema;
  /** @deprecated use `MinimumTLSVersionCriblLakeHTTP$outboundSchema` instead. */
  export const outboundSchema = MinimumTLSVersionCriblLakeHTTP$outboundSchema;
}

/** @internal */
export const MaximumTLSVersionCriblLakeHTTP$inboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionCriblLakeHTTP
> = z.nativeEnum(MaximumTLSVersionCriblLakeHTTP);

/** @internal */
export const MaximumTLSVersionCriblLakeHTTP$outboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionCriblLakeHTTP
> = MaximumTLSVersionCriblLakeHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaximumTLSVersionCriblLakeHTTP$ {
  /** @deprecated use `MaximumTLSVersionCriblLakeHTTP$inboundSchema` instead. */
  export const inboundSchema = MaximumTLSVersionCriblLakeHTTP$inboundSchema;
  /** @deprecated use `MaximumTLSVersionCriblLakeHTTP$outboundSchema` instead. */
  export const outboundSchema = MaximumTLSVersionCriblLakeHTTP$outboundSchema;
}

/** @internal */
export const TLSSettingsServerSideCriblLakeHTTP$inboundSchema: z.ZodType<
  TLSSettingsServerSideCriblLakeHTTP,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionCriblLakeHTTP$inboundSchema.optional(),
  maxVersion: MaximumTLSVersionCriblLakeHTTP$inboundSchema.optional(),
});

/** @internal */
export type TLSSettingsServerSideCriblLakeHTTP$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TLSSettingsServerSideCriblLakeHTTP$outboundSchema: z.ZodType<
  TLSSettingsServerSideCriblLakeHTTP$Outbound,
  z.ZodTypeDef,
  TLSSettingsServerSideCriblLakeHTTP
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionCriblLakeHTTP$outboundSchema.optional(),
  maxVersion: MaximumTLSVersionCriblLakeHTTP$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsServerSideCriblLakeHTTP$ {
  /** @deprecated use `TLSSettingsServerSideCriblLakeHTTP$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsServerSideCriblLakeHTTP$inboundSchema;
  /** @deprecated use `TLSSettingsServerSideCriblLakeHTTP$outboundSchema` instead. */
  export const outboundSchema =
    TLSSettingsServerSideCriblLakeHTTP$outboundSchema;
  /** @deprecated use `TLSSettingsServerSideCriblLakeHTTP$Outbound` instead. */
  export type Outbound = TLSSettingsServerSideCriblLakeHTTP$Outbound;
}

export function tlsSettingsServerSideCriblLakeHTTPToJSON(
  tlsSettingsServerSideCriblLakeHTTP: TLSSettingsServerSideCriblLakeHTTP,
): string {
  return JSON.stringify(
    TLSSettingsServerSideCriblLakeHTTP$outboundSchema.parse(
      tlsSettingsServerSideCriblLakeHTTP,
    ),
  );
}

export function tlsSettingsServerSideCriblLakeHTTPFromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsServerSideCriblLakeHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      TLSSettingsServerSideCriblLakeHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsServerSideCriblLakeHTTP' from JSON`,
  );
}

/** @internal */
export const MetadatumCriblLakeHTTP$inboundSchema: z.ZodType<
  MetadatumCriblLakeHTTP,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumCriblLakeHTTP$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumCriblLakeHTTP$outboundSchema: z.ZodType<
  MetadatumCriblLakeHTTP$Outbound,
  z.ZodTypeDef,
  MetadatumCriblLakeHTTP
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumCriblLakeHTTP$ {
  /** @deprecated use `MetadatumCriblLakeHTTP$inboundSchema` instead. */
  export const inboundSchema = MetadatumCriblLakeHTTP$inboundSchema;
  /** @deprecated use `MetadatumCriblLakeHTTP$outboundSchema` instead. */
  export const outboundSchema = MetadatumCriblLakeHTTP$outboundSchema;
  /** @deprecated use `MetadatumCriblLakeHTTP$Outbound` instead. */
  export type Outbound = MetadatumCriblLakeHTTP$Outbound;
}

export function metadatumCriblLakeHTTPToJSON(
  metadatumCriblLakeHTTP: MetadatumCriblLakeHTTP,
): string {
  return JSON.stringify(
    MetadatumCriblLakeHTTP$outboundSchema.parse(metadatumCriblLakeHTTP),
  );
}

export function metadatumCriblLakeHTTPFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumCriblLakeHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumCriblLakeHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumCriblLakeHTTP' from JSON`,
  );
}

/** @internal */
export const InputCriblLakeHttp$inboundSchema: z.ZodType<
  InputCriblLakeHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeCriblLakeHTTP$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionCriblLakeHTTP$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqCriblLakeHTTP$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: z.lazy(() => TLSSettingsServerSideCriblLakeHTTP$inboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  metadata: z.array(z.lazy(() => MetadatumCriblLakeHTTP$inboundSchema))
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputCriblLakeHttp$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionCriblLakeHTTP$Outbound> | undefined;
  pq?: PqCriblLakeHTTP$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: TLSSettingsServerSideCriblLakeHTTP$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  metadata?: Array<MetadatumCriblLakeHTTP$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCriblLakeHttp$outboundSchema: z.ZodType<
  InputCriblLakeHttp$Outbound,
  z.ZodTypeDef,
  InputCriblLakeHttp
> = z.object({
  id: z.string(),
  type: TypeCriblLakeHTTP$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionCriblLakeHTTP$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqCriblLakeHTTP$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: z.lazy(() => TLSSettingsServerSideCriblLakeHTTP$outboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  metadata: z.array(z.lazy(() => MetadatumCriblLakeHTTP$outboundSchema))
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblLakeHttp$ {
  /** @deprecated use `InputCriblLakeHttp$inboundSchema` instead. */
  export const inboundSchema = InputCriblLakeHttp$inboundSchema;
  /** @deprecated use `InputCriblLakeHttp$outboundSchema` instead. */
  export const outboundSchema = InputCriblLakeHttp$outboundSchema;
  /** @deprecated use `InputCriblLakeHttp$Outbound` instead. */
  export type Outbound = InputCriblLakeHttp$Outbound;
}

export function inputCriblLakeHttpToJSON(
  inputCriblLakeHttp: InputCriblLakeHttp,
): string {
  return JSON.stringify(
    InputCriblLakeHttp$outboundSchema.parse(inputCriblLakeHttp),
  );
}

export function inputCriblLakeHttpFromJSON(
  jsonString: string,
): SafeParseResult<InputCriblLakeHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputCriblLakeHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCriblLakeHttp' from JSON`,
  );
}

/** @internal */
export const TypeCriblHTTP$inboundSchema: z.ZodNativeEnum<
  typeof TypeCriblHTTP
> = z.nativeEnum(TypeCriblHTTP);

/** @internal */
export const TypeCriblHTTP$outboundSchema: z.ZodNativeEnum<
  typeof TypeCriblHTTP
> = TypeCriblHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeCriblHTTP$ {
  /** @deprecated use `TypeCriblHTTP$inboundSchema` instead. */
  export const inboundSchema = TypeCriblHTTP$inboundSchema;
  /** @deprecated use `TypeCriblHTTP$outboundSchema` instead. */
  export const outboundSchema = TypeCriblHTTP$outboundSchema;
}

/** @internal */
export const ConnectionCriblHTTP$inboundSchema: z.ZodType<
  ConnectionCriblHTTP,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionCriblHTTP$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionCriblHTTP$outboundSchema: z.ZodType<
  ConnectionCriblHTTP$Outbound,
  z.ZodTypeDef,
  ConnectionCriblHTTP
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionCriblHTTP$ {
  /** @deprecated use `ConnectionCriblHTTP$inboundSchema` instead. */
  export const inboundSchema = ConnectionCriblHTTP$inboundSchema;
  /** @deprecated use `ConnectionCriblHTTP$outboundSchema` instead. */
  export const outboundSchema = ConnectionCriblHTTP$outboundSchema;
  /** @deprecated use `ConnectionCriblHTTP$Outbound` instead. */
  export type Outbound = ConnectionCriblHTTP$Outbound;
}

export function connectionCriblHTTPToJSON(
  connectionCriblHTTP: ConnectionCriblHTTP,
): string {
  return JSON.stringify(
    ConnectionCriblHTTP$outboundSchema.parse(connectionCriblHTTP),
  );
}

export function connectionCriblHTTPFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionCriblHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionCriblHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionCriblHTTP' from JSON`,
  );
}

/** @internal */
export const ModeCriblHTTP$inboundSchema: z.ZodNativeEnum<
  typeof ModeCriblHTTP
> = z.nativeEnum(ModeCriblHTTP);

/** @internal */
export const ModeCriblHTTP$outboundSchema: z.ZodNativeEnum<
  typeof ModeCriblHTTP
> = ModeCriblHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeCriblHTTP$ {
  /** @deprecated use `ModeCriblHTTP$inboundSchema` instead. */
  export const inboundSchema = ModeCriblHTTP$inboundSchema;
  /** @deprecated use `ModeCriblHTTP$outboundSchema` instead. */
  export const outboundSchema = ModeCriblHTTP$outboundSchema;
}

/** @internal */
export const CompressionCriblHTTP$inboundSchema: z.ZodNativeEnum<
  typeof CompressionCriblHTTP
> = z.nativeEnum(CompressionCriblHTTP);

/** @internal */
export const CompressionCriblHTTP$outboundSchema: z.ZodNativeEnum<
  typeof CompressionCriblHTTP
> = CompressionCriblHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionCriblHTTP$ {
  /** @deprecated use `CompressionCriblHTTP$inboundSchema` instead. */
  export const inboundSchema = CompressionCriblHTTP$inboundSchema;
  /** @deprecated use `CompressionCriblHTTP$outboundSchema` instead. */
  export const outboundSchema = CompressionCriblHTTP$outboundSchema;
}

/** @internal */
export const PqCriblHTTP$inboundSchema: z.ZodType<
  PqCriblHTTP,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeCriblHTTP$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionCriblHTTP$inboundSchema.default("none"),
});

/** @internal */
export type PqCriblHTTP$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqCriblHTTP$outboundSchema: z.ZodType<
  PqCriblHTTP$Outbound,
  z.ZodTypeDef,
  PqCriblHTTP
> = z.object({
  mode: ModeCriblHTTP$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionCriblHTTP$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCriblHTTP$ {
  /** @deprecated use `PqCriblHTTP$inboundSchema` instead. */
  export const inboundSchema = PqCriblHTTP$inboundSchema;
  /** @deprecated use `PqCriblHTTP$outboundSchema` instead. */
  export const outboundSchema = PqCriblHTTP$outboundSchema;
  /** @deprecated use `PqCriblHTTP$Outbound` instead. */
  export type Outbound = PqCriblHTTP$Outbound;
}

export function pqCriblHTTPToJSON(pqCriblHTTP: PqCriblHTTP): string {
  return JSON.stringify(PqCriblHTTP$outboundSchema.parse(pqCriblHTTP));
}

export function pqCriblHTTPFromJSON(
  jsonString: string,
): SafeParseResult<PqCriblHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqCriblHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqCriblHTTP' from JSON`,
  );
}

/** @internal */
export const MinimumTLSVersionCriblHTTP$inboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionCriblHTTP
> = z.nativeEnum(MinimumTLSVersionCriblHTTP);

/** @internal */
export const MinimumTLSVersionCriblHTTP$outboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionCriblHTTP
> = MinimumTLSVersionCriblHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MinimumTLSVersionCriblHTTP$ {
  /** @deprecated use `MinimumTLSVersionCriblHTTP$inboundSchema` instead. */
  export const inboundSchema = MinimumTLSVersionCriblHTTP$inboundSchema;
  /** @deprecated use `MinimumTLSVersionCriblHTTP$outboundSchema` instead. */
  export const outboundSchema = MinimumTLSVersionCriblHTTP$outboundSchema;
}

/** @internal */
export const MaximumTLSVersionCriblHTTP$inboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionCriblHTTP
> = z.nativeEnum(MaximumTLSVersionCriblHTTP);

/** @internal */
export const MaximumTLSVersionCriblHTTP$outboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionCriblHTTP
> = MaximumTLSVersionCriblHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaximumTLSVersionCriblHTTP$ {
  /** @deprecated use `MaximumTLSVersionCriblHTTP$inboundSchema` instead. */
  export const inboundSchema = MaximumTLSVersionCriblHTTP$inboundSchema;
  /** @deprecated use `MaximumTLSVersionCriblHTTP$outboundSchema` instead. */
  export const outboundSchema = MaximumTLSVersionCriblHTTP$outboundSchema;
}

/** @internal */
export const TLSSettingsServerSideCriblHTTP$inboundSchema: z.ZodType<
  TLSSettingsServerSideCriblHTTP,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionCriblHTTP$inboundSchema.optional(),
  maxVersion: MaximumTLSVersionCriblHTTP$inboundSchema.optional(),
});

/** @internal */
export type TLSSettingsServerSideCriblHTTP$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TLSSettingsServerSideCriblHTTP$outboundSchema: z.ZodType<
  TLSSettingsServerSideCriblHTTP$Outbound,
  z.ZodTypeDef,
  TLSSettingsServerSideCriblHTTP
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionCriblHTTP$outboundSchema.optional(),
  maxVersion: MaximumTLSVersionCriblHTTP$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsServerSideCriblHTTP$ {
  /** @deprecated use `TLSSettingsServerSideCriblHTTP$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsServerSideCriblHTTP$inboundSchema;
  /** @deprecated use `TLSSettingsServerSideCriblHTTP$outboundSchema` instead. */
  export const outboundSchema = TLSSettingsServerSideCriblHTTP$outboundSchema;
  /** @deprecated use `TLSSettingsServerSideCriblHTTP$Outbound` instead. */
  export type Outbound = TLSSettingsServerSideCriblHTTP$Outbound;
}

export function tlsSettingsServerSideCriblHTTPToJSON(
  tlsSettingsServerSideCriblHTTP: TLSSettingsServerSideCriblHTTP,
): string {
  return JSON.stringify(
    TLSSettingsServerSideCriblHTTP$outboundSchema.parse(
      tlsSettingsServerSideCriblHTTP,
    ),
  );
}

export function tlsSettingsServerSideCriblHTTPFromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsServerSideCriblHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TLSSettingsServerSideCriblHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsServerSideCriblHTTP' from JSON`,
  );
}

/** @internal */
export const MetadatumCriblHTTP$inboundSchema: z.ZodType<
  MetadatumCriblHTTP,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumCriblHTTP$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumCriblHTTP$outboundSchema: z.ZodType<
  MetadatumCriblHTTP$Outbound,
  z.ZodTypeDef,
  MetadatumCriblHTTP
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumCriblHTTP$ {
  /** @deprecated use `MetadatumCriblHTTP$inboundSchema` instead. */
  export const inboundSchema = MetadatumCriblHTTP$inboundSchema;
  /** @deprecated use `MetadatumCriblHTTP$outboundSchema` instead. */
  export const outboundSchema = MetadatumCriblHTTP$outboundSchema;
  /** @deprecated use `MetadatumCriblHTTP$Outbound` instead. */
  export type Outbound = MetadatumCriblHTTP$Outbound;
}

export function metadatumCriblHTTPToJSON(
  metadatumCriblHTTP: MetadatumCriblHTTP,
): string {
  return JSON.stringify(
    MetadatumCriblHTTP$outboundSchema.parse(metadatumCriblHTTP),
  );
}

export function metadatumCriblHTTPFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumCriblHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumCriblHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumCriblHTTP' from JSON`,
  );
}

/** @internal */
export const InputCriblHttp$inboundSchema: z.ZodType<
  InputCriblHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeCriblHTTP$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionCriblHTTP$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqCriblHTTP$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: z.lazy(() => TLSSettingsServerSideCriblHTTP$inboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  metadata: z.array(z.lazy(() => MetadatumCriblHTTP$inboundSchema)).optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputCriblHttp$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionCriblHTTP$Outbound> | undefined;
  pq?: PqCriblHTTP$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: TLSSettingsServerSideCriblHTTP$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  metadata?: Array<MetadatumCriblHTTP$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCriblHttp$outboundSchema: z.ZodType<
  InputCriblHttp$Outbound,
  z.ZodTypeDef,
  InputCriblHttp
> = z.object({
  id: z.string(),
  type: TypeCriblHTTP$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionCriblHTTP$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqCriblHTTP$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: z.lazy(() => TLSSettingsServerSideCriblHTTP$outboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  metadata: z.array(z.lazy(() => MetadatumCriblHTTP$outboundSchema)).optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblHttp$ {
  /** @deprecated use `InputCriblHttp$inboundSchema` instead. */
  export const inboundSchema = InputCriblHttp$inboundSchema;
  /** @deprecated use `InputCriblHttp$outboundSchema` instead. */
  export const outboundSchema = InputCriblHttp$outboundSchema;
  /** @deprecated use `InputCriblHttp$Outbound` instead. */
  export type Outbound = InputCriblHttp$Outbound;
}

export function inputCriblHttpToJSON(inputCriblHttp: InputCriblHttp): string {
  return JSON.stringify(InputCriblHttp$outboundSchema.parse(inputCriblHttp));
}

export function inputCriblHttpFromJSON(
  jsonString: string,
): SafeParseResult<InputCriblHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputCriblHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCriblHttp' from JSON`,
  );
}

/** @internal */
export const TypeCriblTCP$inboundSchema: z.ZodNativeEnum<typeof TypeCriblTCP> =
  z.nativeEnum(TypeCriblTCP);

/** @internal */
export const TypeCriblTCP$outboundSchema: z.ZodNativeEnum<typeof TypeCriblTCP> =
  TypeCriblTCP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeCriblTCP$ {
  /** @deprecated use `TypeCriblTCP$inboundSchema` instead. */
  export const inboundSchema = TypeCriblTCP$inboundSchema;
  /** @deprecated use `TypeCriblTCP$outboundSchema` instead. */
  export const outboundSchema = TypeCriblTCP$outboundSchema;
}

/** @internal */
export const ConnectionCriblTCP$inboundSchema: z.ZodType<
  ConnectionCriblTCP,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionCriblTCP$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionCriblTCP$outboundSchema: z.ZodType<
  ConnectionCriblTCP$Outbound,
  z.ZodTypeDef,
  ConnectionCriblTCP
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionCriblTCP$ {
  /** @deprecated use `ConnectionCriblTCP$inboundSchema` instead. */
  export const inboundSchema = ConnectionCriblTCP$inboundSchema;
  /** @deprecated use `ConnectionCriblTCP$outboundSchema` instead. */
  export const outboundSchema = ConnectionCriblTCP$outboundSchema;
  /** @deprecated use `ConnectionCriblTCP$Outbound` instead. */
  export type Outbound = ConnectionCriblTCP$Outbound;
}

export function connectionCriblTCPToJSON(
  connectionCriblTCP: ConnectionCriblTCP,
): string {
  return JSON.stringify(
    ConnectionCriblTCP$outboundSchema.parse(connectionCriblTCP),
  );
}

export function connectionCriblTCPFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionCriblTCP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionCriblTCP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionCriblTCP' from JSON`,
  );
}

/** @internal */
export const ModeCriblTCP$inboundSchema: z.ZodNativeEnum<typeof ModeCriblTCP> =
  z.nativeEnum(ModeCriblTCP);

/** @internal */
export const ModeCriblTCP$outboundSchema: z.ZodNativeEnum<typeof ModeCriblTCP> =
  ModeCriblTCP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeCriblTCP$ {
  /** @deprecated use `ModeCriblTCP$inboundSchema` instead. */
  export const inboundSchema = ModeCriblTCP$inboundSchema;
  /** @deprecated use `ModeCriblTCP$outboundSchema` instead. */
  export const outboundSchema = ModeCriblTCP$outboundSchema;
}

/** @internal */
export const CompressionCriblTCP$inboundSchema: z.ZodNativeEnum<
  typeof CompressionCriblTCP
> = z.nativeEnum(CompressionCriblTCP);

/** @internal */
export const CompressionCriblTCP$outboundSchema: z.ZodNativeEnum<
  typeof CompressionCriblTCP
> = CompressionCriblTCP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionCriblTCP$ {
  /** @deprecated use `CompressionCriblTCP$inboundSchema` instead. */
  export const inboundSchema = CompressionCriblTCP$inboundSchema;
  /** @deprecated use `CompressionCriblTCP$outboundSchema` instead. */
  export const outboundSchema = CompressionCriblTCP$outboundSchema;
}

/** @internal */
export const PqCriblTCP$inboundSchema: z.ZodType<
  PqCriblTCP,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeCriblTCP$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionCriblTCP$inboundSchema.default("none"),
});

/** @internal */
export type PqCriblTCP$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqCriblTCP$outboundSchema: z.ZodType<
  PqCriblTCP$Outbound,
  z.ZodTypeDef,
  PqCriblTCP
> = z.object({
  mode: ModeCriblTCP$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionCriblTCP$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCriblTCP$ {
  /** @deprecated use `PqCriblTCP$inboundSchema` instead. */
  export const inboundSchema = PqCriblTCP$inboundSchema;
  /** @deprecated use `PqCriblTCP$outboundSchema` instead. */
  export const outboundSchema = PqCriblTCP$outboundSchema;
  /** @deprecated use `PqCriblTCP$Outbound` instead. */
  export type Outbound = PqCriblTCP$Outbound;
}

export function pqCriblTCPToJSON(pqCriblTCP: PqCriblTCP): string {
  return JSON.stringify(PqCriblTCP$outboundSchema.parse(pqCriblTCP));
}

export function pqCriblTCPFromJSON(
  jsonString: string,
): SafeParseResult<PqCriblTCP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqCriblTCP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqCriblTCP' from JSON`,
  );
}

/** @internal */
export const MinimumTLSVersionCriblTCP$inboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionCriblTCP
> = z.nativeEnum(MinimumTLSVersionCriblTCP);

/** @internal */
export const MinimumTLSVersionCriblTCP$outboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionCriblTCP
> = MinimumTLSVersionCriblTCP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MinimumTLSVersionCriblTCP$ {
  /** @deprecated use `MinimumTLSVersionCriblTCP$inboundSchema` instead. */
  export const inboundSchema = MinimumTLSVersionCriblTCP$inboundSchema;
  /** @deprecated use `MinimumTLSVersionCriblTCP$outboundSchema` instead. */
  export const outboundSchema = MinimumTLSVersionCriblTCP$outboundSchema;
}

/** @internal */
export const MaximumTLSVersionCriblTCP$inboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionCriblTCP
> = z.nativeEnum(MaximumTLSVersionCriblTCP);

/** @internal */
export const MaximumTLSVersionCriblTCP$outboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionCriblTCP
> = MaximumTLSVersionCriblTCP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaximumTLSVersionCriblTCP$ {
  /** @deprecated use `MaximumTLSVersionCriblTCP$inboundSchema` instead. */
  export const inboundSchema = MaximumTLSVersionCriblTCP$inboundSchema;
  /** @deprecated use `MaximumTLSVersionCriblTCP$outboundSchema` instead. */
  export const outboundSchema = MaximumTLSVersionCriblTCP$outboundSchema;
}

/** @internal */
export const TLSSettingsServerSideCriblTCP$inboundSchema: z.ZodType<
  TLSSettingsServerSideCriblTCP,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionCriblTCP$inboundSchema.optional(),
  maxVersion: MaximumTLSVersionCriblTCP$inboundSchema.optional(),
});

/** @internal */
export type TLSSettingsServerSideCriblTCP$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TLSSettingsServerSideCriblTCP$outboundSchema: z.ZodType<
  TLSSettingsServerSideCriblTCP$Outbound,
  z.ZodTypeDef,
  TLSSettingsServerSideCriblTCP
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionCriblTCP$outboundSchema.optional(),
  maxVersion: MaximumTLSVersionCriblTCP$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsServerSideCriblTCP$ {
  /** @deprecated use `TLSSettingsServerSideCriblTCP$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsServerSideCriblTCP$inboundSchema;
  /** @deprecated use `TLSSettingsServerSideCriblTCP$outboundSchema` instead. */
  export const outboundSchema = TLSSettingsServerSideCriblTCP$outboundSchema;
  /** @deprecated use `TLSSettingsServerSideCriblTCP$Outbound` instead. */
  export type Outbound = TLSSettingsServerSideCriblTCP$Outbound;
}

export function tlsSettingsServerSideCriblTCPToJSON(
  tlsSettingsServerSideCriblTCP: TLSSettingsServerSideCriblTCP,
): string {
  return JSON.stringify(
    TLSSettingsServerSideCriblTCP$outboundSchema.parse(
      tlsSettingsServerSideCriblTCP,
    ),
  );
}

export function tlsSettingsServerSideCriblTCPFromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsServerSideCriblTCP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TLSSettingsServerSideCriblTCP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsServerSideCriblTCP' from JSON`,
  );
}

/** @internal */
export const MetadatumCriblTCP$inboundSchema: z.ZodType<
  MetadatumCriblTCP,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumCriblTCP$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumCriblTCP$outboundSchema: z.ZodType<
  MetadatumCriblTCP$Outbound,
  z.ZodTypeDef,
  MetadatumCriblTCP
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumCriblTCP$ {
  /** @deprecated use `MetadatumCriblTCP$inboundSchema` instead. */
  export const inboundSchema = MetadatumCriblTCP$inboundSchema;
  /** @deprecated use `MetadatumCriblTCP$outboundSchema` instead. */
  export const outboundSchema = MetadatumCriblTCP$outboundSchema;
  /** @deprecated use `MetadatumCriblTCP$Outbound` instead. */
  export type Outbound = MetadatumCriblTCP$Outbound;
}

export function metadatumCriblTCPToJSON(
  metadatumCriblTCP: MetadatumCriblTCP,
): string {
  return JSON.stringify(
    MetadatumCriblTCP$outboundSchema.parse(metadatumCriblTCP),
  );
}

export function metadatumCriblTCPFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumCriblTCP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumCriblTCP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumCriblTCP' from JSON`,
  );
}

/** @internal */
export const InputCriblTcp$inboundSchema: z.ZodType<
  InputCriblTcp,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeCriblTCP$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionCriblTCP$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqCriblTCP$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => TLSSettingsServerSideCriblTCP$inboundSchema).optional(),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumCriblTCP$inboundSchema)).optional(),
  enableLoadBalancing: z.boolean().default(false),
  description: z.string().optional(),
});

/** @internal */
export type InputCriblTcp$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionCriblTCP$Outbound> | undefined;
  pq?: PqCriblTCP$Outbound | undefined;
  host: string;
  port: number;
  tls?: TLSSettingsServerSideCriblTCP$Outbound | undefined;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  enableProxyHeader: boolean;
  metadata?: Array<MetadatumCriblTCP$Outbound> | undefined;
  enableLoadBalancing: boolean;
  description?: string | undefined;
};

/** @internal */
export const InputCriblTcp$outboundSchema: z.ZodType<
  InputCriblTcp$Outbound,
  z.ZodTypeDef,
  InputCriblTcp
> = z.object({
  id: z.string(),
  type: TypeCriblTCP$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionCriblTCP$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqCriblTCP$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => TLSSettingsServerSideCriblTCP$outboundSchema).optional(),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumCriblTCP$outboundSchema)).optional(),
  enableLoadBalancing: z.boolean().default(false),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblTcp$ {
  /** @deprecated use `InputCriblTcp$inboundSchema` instead. */
  export const inboundSchema = InputCriblTcp$inboundSchema;
  /** @deprecated use `InputCriblTcp$outboundSchema` instead. */
  export const outboundSchema = InputCriblTcp$outboundSchema;
  /** @deprecated use `InputCriblTcp$Outbound` instead. */
  export type Outbound = InputCriblTcp$Outbound;
}

export function inputCriblTcpToJSON(inputCriblTcp: InputCriblTcp): string {
  return JSON.stringify(InputCriblTcp$outboundSchema.parse(inputCriblTcp));
}

export function inputCriblTcpFromJSON(
  jsonString: string,
): SafeParseResult<InputCriblTcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputCriblTcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCriblTcp' from JSON`,
  );
}

/** @internal */
export const CreateInputTypeGooglePubsub$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeGooglePubsub
> = z.nativeEnum(CreateInputTypeGooglePubsub);

/** @internal */
export const CreateInputTypeGooglePubsub$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeGooglePubsub
> = CreateInputTypeGooglePubsub$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputTypeGooglePubsub$ {
  /** @deprecated use `CreateInputTypeGooglePubsub$inboundSchema` instead. */
  export const inboundSchema = CreateInputTypeGooglePubsub$inboundSchema;
  /** @deprecated use `CreateInputTypeGooglePubsub$outboundSchema` instead. */
  export const outboundSchema = CreateInputTypeGooglePubsub$outboundSchema;
}

/** @internal */
export const ConnectionGooglePubsub$inboundSchema: z.ZodType<
  ConnectionGooglePubsub,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionGooglePubsub$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionGooglePubsub$outboundSchema: z.ZodType<
  ConnectionGooglePubsub$Outbound,
  z.ZodTypeDef,
  ConnectionGooglePubsub
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionGooglePubsub$ {
  /** @deprecated use `ConnectionGooglePubsub$inboundSchema` instead. */
  export const inboundSchema = ConnectionGooglePubsub$inboundSchema;
  /** @deprecated use `ConnectionGooglePubsub$outboundSchema` instead. */
  export const outboundSchema = ConnectionGooglePubsub$outboundSchema;
  /** @deprecated use `ConnectionGooglePubsub$Outbound` instead. */
  export type Outbound = ConnectionGooglePubsub$Outbound;
}

export function connectionGooglePubsubToJSON(
  connectionGooglePubsub: ConnectionGooglePubsub,
): string {
  return JSON.stringify(
    ConnectionGooglePubsub$outboundSchema.parse(connectionGooglePubsub),
  );
}

export function connectionGooglePubsubFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionGooglePubsub, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionGooglePubsub$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionGooglePubsub' from JSON`,
  );
}

/** @internal */
export const CreateInputModeGooglePubsub$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputModeGooglePubsub
> = z.nativeEnum(CreateInputModeGooglePubsub);

/** @internal */
export const CreateInputModeGooglePubsub$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputModeGooglePubsub
> = CreateInputModeGooglePubsub$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputModeGooglePubsub$ {
  /** @deprecated use `CreateInputModeGooglePubsub$inboundSchema` instead. */
  export const inboundSchema = CreateInputModeGooglePubsub$inboundSchema;
  /** @deprecated use `CreateInputModeGooglePubsub$outboundSchema` instead. */
  export const outboundSchema = CreateInputModeGooglePubsub$outboundSchema;
}

/** @internal */
export const PqCompressionGooglePubsub$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressionGooglePubsub
> = z.nativeEnum(PqCompressionGooglePubsub);

/** @internal */
export const PqCompressionGooglePubsub$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressionGooglePubsub
> = PqCompressionGooglePubsub$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressionGooglePubsub$ {
  /** @deprecated use `PqCompressionGooglePubsub$inboundSchema` instead. */
  export const inboundSchema = PqCompressionGooglePubsub$inboundSchema;
  /** @deprecated use `PqCompressionGooglePubsub$outboundSchema` instead. */
  export const outboundSchema = PqCompressionGooglePubsub$outboundSchema;
}

/** @internal */
export const PqGooglePubsub$inboundSchema: z.ZodType<
  PqGooglePubsub,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: CreateInputModeGooglePubsub$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: PqCompressionGooglePubsub$inboundSchema.default("none"),
});

/** @internal */
export type PqGooglePubsub$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqGooglePubsub$outboundSchema: z.ZodType<
  PqGooglePubsub$Outbound,
  z.ZodTypeDef,
  PqGooglePubsub
> = z.object({
  mode: CreateInputModeGooglePubsub$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: PqCompressionGooglePubsub$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqGooglePubsub$ {
  /** @deprecated use `PqGooglePubsub$inboundSchema` instead. */
  export const inboundSchema = PqGooglePubsub$inboundSchema;
  /** @deprecated use `PqGooglePubsub$outboundSchema` instead. */
  export const outboundSchema = PqGooglePubsub$outboundSchema;
  /** @deprecated use `PqGooglePubsub$Outbound` instead. */
  export type Outbound = PqGooglePubsub$Outbound;
}

export function pqGooglePubsubToJSON(pqGooglePubsub: PqGooglePubsub): string {
  return JSON.stringify(PqGooglePubsub$outboundSchema.parse(pqGooglePubsub));
}

export function pqGooglePubsubFromJSON(
  jsonString: string,
): SafeParseResult<PqGooglePubsub, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqGooglePubsub$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqGooglePubsub' from JSON`,
  );
}

/** @internal */
export const CreateInputGoogleAuthenticationMethod$inboundSchema:
  z.ZodNativeEnum<typeof CreateInputGoogleAuthenticationMethod> = z.nativeEnum(
    CreateInputGoogleAuthenticationMethod,
  );

/** @internal */
export const CreateInputGoogleAuthenticationMethod$outboundSchema:
  z.ZodNativeEnum<typeof CreateInputGoogleAuthenticationMethod> =
    CreateInputGoogleAuthenticationMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputGoogleAuthenticationMethod$ {
  /** @deprecated use `CreateInputGoogleAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputGoogleAuthenticationMethod$inboundSchema;
  /** @deprecated use `CreateInputGoogleAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputGoogleAuthenticationMethod$outboundSchema;
}

/** @internal */
export const MetadatumGooglePubsub$inboundSchema: z.ZodType<
  MetadatumGooglePubsub,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumGooglePubsub$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumGooglePubsub$outboundSchema: z.ZodType<
  MetadatumGooglePubsub$Outbound,
  z.ZodTypeDef,
  MetadatumGooglePubsub
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumGooglePubsub$ {
  /** @deprecated use `MetadatumGooglePubsub$inboundSchema` instead. */
  export const inboundSchema = MetadatumGooglePubsub$inboundSchema;
  /** @deprecated use `MetadatumGooglePubsub$outboundSchema` instead. */
  export const outboundSchema = MetadatumGooglePubsub$outboundSchema;
  /** @deprecated use `MetadatumGooglePubsub$Outbound` instead. */
  export type Outbound = MetadatumGooglePubsub$Outbound;
}

export function metadatumGooglePubsubToJSON(
  metadatumGooglePubsub: MetadatumGooglePubsub,
): string {
  return JSON.stringify(
    MetadatumGooglePubsub$outboundSchema.parse(metadatumGooglePubsub),
  );
}

export function metadatumGooglePubsubFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumGooglePubsub, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumGooglePubsub$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumGooglePubsub' from JSON`,
  );
}

/** @internal */
export const InputGooglePubsub$inboundSchema: z.ZodType<
  InputGooglePubsub,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateInputTypeGooglePubsub$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionGooglePubsub$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqGooglePubsub$inboundSchema).optional(),
  topicName: z.string(),
  subscriptionName: z.string(),
  createTopic: z.boolean().default(false),
  createSubscription: z.boolean().default(true),
  region: z.string().optional(),
  googleAuthMethod: CreateInputGoogleAuthenticationMethod$inboundSchema.default(
    "manual",
  ),
  serviceAccountCredentials: z.string().optional(),
  secret: z.string().optional(),
  maxBacklog: z.number().default(1000),
  concurrency: z.number().default(5),
  requestTimeout: z.number().default(60000),
  metadata: z.array(z.lazy(() => MetadatumGooglePubsub$inboundSchema))
    .optional(),
  description: z.string().optional(),
  orderedDelivery: z.boolean().default(false),
});

/** @internal */
export type InputGooglePubsub$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionGooglePubsub$Outbound> | undefined;
  pq?: PqGooglePubsub$Outbound | undefined;
  topicName: string;
  subscriptionName: string;
  createTopic: boolean;
  createSubscription: boolean;
  region?: string | undefined;
  googleAuthMethod: string;
  serviceAccountCredentials?: string | undefined;
  secret?: string | undefined;
  maxBacklog: number;
  concurrency: number;
  requestTimeout: number;
  metadata?: Array<MetadatumGooglePubsub$Outbound> | undefined;
  description?: string | undefined;
  orderedDelivery: boolean;
};

/** @internal */
export const InputGooglePubsub$outboundSchema: z.ZodType<
  InputGooglePubsub$Outbound,
  z.ZodTypeDef,
  InputGooglePubsub
> = z.object({
  id: z.string(),
  type: CreateInputTypeGooglePubsub$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionGooglePubsub$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqGooglePubsub$outboundSchema).optional(),
  topicName: z.string(),
  subscriptionName: z.string(),
  createTopic: z.boolean().default(false),
  createSubscription: z.boolean().default(true),
  region: z.string().optional(),
  googleAuthMethod: CreateInputGoogleAuthenticationMethod$outboundSchema
    .default("manual"),
  serviceAccountCredentials: z.string().optional(),
  secret: z.string().optional(),
  maxBacklog: z.number().default(1000),
  concurrency: z.number().default(5),
  requestTimeout: z.number().default(60000),
  metadata: z.array(z.lazy(() => MetadatumGooglePubsub$outboundSchema))
    .optional(),
  description: z.string().optional(),
  orderedDelivery: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGooglePubsub$ {
  /** @deprecated use `InputGooglePubsub$inboundSchema` instead. */
  export const inboundSchema = InputGooglePubsub$inboundSchema;
  /** @deprecated use `InputGooglePubsub$outboundSchema` instead. */
  export const outboundSchema = InputGooglePubsub$outboundSchema;
  /** @deprecated use `InputGooglePubsub$Outbound` instead. */
  export type Outbound = InputGooglePubsub$Outbound;
}

export function inputGooglePubsubToJSON(
  inputGooglePubsub: InputGooglePubsub,
): string {
  return JSON.stringify(
    InputGooglePubsub$outboundSchema.parse(inputGooglePubsub),
  );
}

export function inputGooglePubsubFromJSON(
  jsonString: string,
): SafeParseResult<InputGooglePubsub, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGooglePubsub$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGooglePubsub' from JSON`,
  );
}

/** @internal */
export const TypeFirehose$inboundSchema: z.ZodNativeEnum<typeof TypeFirehose> =
  z.nativeEnum(TypeFirehose);

/** @internal */
export const TypeFirehose$outboundSchema: z.ZodNativeEnum<typeof TypeFirehose> =
  TypeFirehose$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeFirehose$ {
  /** @deprecated use `TypeFirehose$inboundSchema` instead. */
  export const inboundSchema = TypeFirehose$inboundSchema;
  /** @deprecated use `TypeFirehose$outboundSchema` instead. */
  export const outboundSchema = TypeFirehose$outboundSchema;
}

/** @internal */
export const ConnectionFirehose$inboundSchema: z.ZodType<
  ConnectionFirehose,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionFirehose$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionFirehose$outboundSchema: z.ZodType<
  ConnectionFirehose$Outbound,
  z.ZodTypeDef,
  ConnectionFirehose
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionFirehose$ {
  /** @deprecated use `ConnectionFirehose$inboundSchema` instead. */
  export const inboundSchema = ConnectionFirehose$inboundSchema;
  /** @deprecated use `ConnectionFirehose$outboundSchema` instead. */
  export const outboundSchema = ConnectionFirehose$outboundSchema;
  /** @deprecated use `ConnectionFirehose$Outbound` instead. */
  export type Outbound = ConnectionFirehose$Outbound;
}

export function connectionFirehoseToJSON(
  connectionFirehose: ConnectionFirehose,
): string {
  return JSON.stringify(
    ConnectionFirehose$outboundSchema.parse(connectionFirehose),
  );
}

export function connectionFirehoseFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionFirehose, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionFirehose$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionFirehose' from JSON`,
  );
}

/** @internal */
export const ModeFirehose$inboundSchema: z.ZodNativeEnum<typeof ModeFirehose> =
  z.nativeEnum(ModeFirehose);

/** @internal */
export const ModeFirehose$outboundSchema: z.ZodNativeEnum<typeof ModeFirehose> =
  ModeFirehose$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeFirehose$ {
  /** @deprecated use `ModeFirehose$inboundSchema` instead. */
  export const inboundSchema = ModeFirehose$inboundSchema;
  /** @deprecated use `ModeFirehose$outboundSchema` instead. */
  export const outboundSchema = ModeFirehose$outboundSchema;
}

/** @internal */
export const CompressionFirehose$inboundSchema: z.ZodNativeEnum<
  typeof CompressionFirehose
> = z.nativeEnum(CompressionFirehose);

/** @internal */
export const CompressionFirehose$outboundSchema: z.ZodNativeEnum<
  typeof CompressionFirehose
> = CompressionFirehose$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionFirehose$ {
  /** @deprecated use `CompressionFirehose$inboundSchema` instead. */
  export const inboundSchema = CompressionFirehose$inboundSchema;
  /** @deprecated use `CompressionFirehose$outboundSchema` instead. */
  export const outboundSchema = CompressionFirehose$outboundSchema;
}

/** @internal */
export const PqFirehose$inboundSchema: z.ZodType<
  PqFirehose,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeFirehose$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionFirehose$inboundSchema.default("none"),
});

/** @internal */
export type PqFirehose$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqFirehose$outboundSchema: z.ZodType<
  PqFirehose$Outbound,
  z.ZodTypeDef,
  PqFirehose
> = z.object({
  mode: ModeFirehose$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionFirehose$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqFirehose$ {
  /** @deprecated use `PqFirehose$inboundSchema` instead. */
  export const inboundSchema = PqFirehose$inboundSchema;
  /** @deprecated use `PqFirehose$outboundSchema` instead. */
  export const outboundSchema = PqFirehose$outboundSchema;
  /** @deprecated use `PqFirehose$Outbound` instead. */
  export type Outbound = PqFirehose$Outbound;
}

export function pqFirehoseToJSON(pqFirehose: PqFirehose): string {
  return JSON.stringify(PqFirehose$outboundSchema.parse(pqFirehose));
}

export function pqFirehoseFromJSON(
  jsonString: string,
): SafeParseResult<PqFirehose, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqFirehose$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqFirehose' from JSON`,
  );
}

/** @internal */
export const MinimumTLSVersionFirehose$inboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionFirehose
> = z.nativeEnum(MinimumTLSVersionFirehose);

/** @internal */
export const MinimumTLSVersionFirehose$outboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionFirehose
> = MinimumTLSVersionFirehose$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MinimumTLSVersionFirehose$ {
  /** @deprecated use `MinimumTLSVersionFirehose$inboundSchema` instead. */
  export const inboundSchema = MinimumTLSVersionFirehose$inboundSchema;
  /** @deprecated use `MinimumTLSVersionFirehose$outboundSchema` instead. */
  export const outboundSchema = MinimumTLSVersionFirehose$outboundSchema;
}

/** @internal */
export const MaximumTLSVersionFirehose$inboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionFirehose
> = z.nativeEnum(MaximumTLSVersionFirehose);

/** @internal */
export const MaximumTLSVersionFirehose$outboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionFirehose
> = MaximumTLSVersionFirehose$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaximumTLSVersionFirehose$ {
  /** @deprecated use `MaximumTLSVersionFirehose$inboundSchema` instead. */
  export const inboundSchema = MaximumTLSVersionFirehose$inboundSchema;
  /** @deprecated use `MaximumTLSVersionFirehose$outboundSchema` instead. */
  export const outboundSchema = MaximumTLSVersionFirehose$outboundSchema;
}

/** @internal */
export const TLSSettingsServerSideFirehose$inboundSchema: z.ZodType<
  TLSSettingsServerSideFirehose,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionFirehose$inboundSchema.optional(),
  maxVersion: MaximumTLSVersionFirehose$inboundSchema.optional(),
});

/** @internal */
export type TLSSettingsServerSideFirehose$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TLSSettingsServerSideFirehose$outboundSchema: z.ZodType<
  TLSSettingsServerSideFirehose$Outbound,
  z.ZodTypeDef,
  TLSSettingsServerSideFirehose
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionFirehose$outboundSchema.optional(),
  maxVersion: MaximumTLSVersionFirehose$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsServerSideFirehose$ {
  /** @deprecated use `TLSSettingsServerSideFirehose$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsServerSideFirehose$inboundSchema;
  /** @deprecated use `TLSSettingsServerSideFirehose$outboundSchema` instead. */
  export const outboundSchema = TLSSettingsServerSideFirehose$outboundSchema;
  /** @deprecated use `TLSSettingsServerSideFirehose$Outbound` instead. */
  export type Outbound = TLSSettingsServerSideFirehose$Outbound;
}

export function tlsSettingsServerSideFirehoseToJSON(
  tlsSettingsServerSideFirehose: TLSSettingsServerSideFirehose,
): string {
  return JSON.stringify(
    TLSSettingsServerSideFirehose$outboundSchema.parse(
      tlsSettingsServerSideFirehose,
    ),
  );
}

export function tlsSettingsServerSideFirehoseFromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsServerSideFirehose, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TLSSettingsServerSideFirehose$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsServerSideFirehose' from JSON`,
  );
}

/** @internal */
export const MetadatumFirehose$inboundSchema: z.ZodType<
  MetadatumFirehose,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumFirehose$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumFirehose$outboundSchema: z.ZodType<
  MetadatumFirehose$Outbound,
  z.ZodTypeDef,
  MetadatumFirehose
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumFirehose$ {
  /** @deprecated use `MetadatumFirehose$inboundSchema` instead. */
  export const inboundSchema = MetadatumFirehose$inboundSchema;
  /** @deprecated use `MetadatumFirehose$outboundSchema` instead. */
  export const outboundSchema = MetadatumFirehose$outboundSchema;
  /** @deprecated use `MetadatumFirehose$Outbound` instead. */
  export type Outbound = MetadatumFirehose$Outbound;
}

export function metadatumFirehoseToJSON(
  metadatumFirehose: MetadatumFirehose,
): string {
  return JSON.stringify(
    MetadatumFirehose$outboundSchema.parse(metadatumFirehose),
  );
}

export function metadatumFirehoseFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumFirehose, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumFirehose$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumFirehose' from JSON`,
  );
}

/** @internal */
export const InputFirehose$inboundSchema: z.ZodType<
  InputFirehose,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeFirehose$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionFirehose$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqFirehose$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: z.lazy(() => TLSSettingsServerSideFirehose$inboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  metadata: z.array(z.lazy(() => MetadatumFirehose$inboundSchema)).optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputFirehose$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionFirehose$Outbound> | undefined;
  pq?: PqFirehose$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: TLSSettingsServerSideFirehose$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  metadata?: Array<MetadatumFirehose$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputFirehose$outboundSchema: z.ZodType<
  InputFirehose$Outbound,
  z.ZodTypeDef,
  InputFirehose
> = z.object({
  id: z.string(),
  type: TypeFirehose$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionFirehose$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqFirehose$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: z.lazy(() => TLSSettingsServerSideFirehose$outboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  metadata: z.array(z.lazy(() => MetadatumFirehose$outboundSchema)).optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputFirehose$ {
  /** @deprecated use `InputFirehose$inboundSchema` instead. */
  export const inboundSchema = InputFirehose$inboundSchema;
  /** @deprecated use `InputFirehose$outboundSchema` instead. */
  export const outboundSchema = InputFirehose$outboundSchema;
  /** @deprecated use `InputFirehose$Outbound` instead. */
  export type Outbound = InputFirehose$Outbound;
}

export function inputFirehoseToJSON(inputFirehose: InputFirehose): string {
  return JSON.stringify(InputFirehose$outboundSchema.parse(inputFirehose));
}

export function inputFirehoseFromJSON(
  jsonString: string,
): SafeParseResult<InputFirehose, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputFirehose$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputFirehose' from JSON`,
  );
}

/** @internal */
export const InputExecType$inboundSchema: z.ZodNativeEnum<
  typeof InputExecType
> = z.nativeEnum(InputExecType);

/** @internal */
export const InputExecType$outboundSchema: z.ZodNativeEnum<
  typeof InputExecType
> = InputExecType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputExecType$ {
  /** @deprecated use `InputExecType$inboundSchema` instead. */
  export const inboundSchema = InputExecType$inboundSchema;
  /** @deprecated use `InputExecType$outboundSchema` instead. */
  export const outboundSchema = InputExecType$outboundSchema;
}

/** @internal */
export const InputExecConnection$inboundSchema: z.ZodType<
  InputExecConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputExecConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputExecConnection$outboundSchema: z.ZodType<
  InputExecConnection$Outbound,
  z.ZodTypeDef,
  InputExecConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputExecConnection$ {
  /** @deprecated use `InputExecConnection$inboundSchema` instead. */
  export const inboundSchema = InputExecConnection$inboundSchema;
  /** @deprecated use `InputExecConnection$outboundSchema` instead. */
  export const outboundSchema = InputExecConnection$outboundSchema;
  /** @deprecated use `InputExecConnection$Outbound` instead. */
  export type Outbound = InputExecConnection$Outbound;
}

export function inputExecConnectionToJSON(
  inputExecConnection: InputExecConnection,
): string {
  return JSON.stringify(
    InputExecConnection$outboundSchema.parse(inputExecConnection),
  );
}

export function inputExecConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputExecConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputExecConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputExecConnection' from JSON`,
  );
}

/** @internal */
export const InputExecMode$inboundSchema: z.ZodNativeEnum<
  typeof InputExecMode
> = z.nativeEnum(InputExecMode);

/** @internal */
export const InputExecMode$outboundSchema: z.ZodNativeEnum<
  typeof InputExecMode
> = InputExecMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputExecMode$ {
  /** @deprecated use `InputExecMode$inboundSchema` instead. */
  export const inboundSchema = InputExecMode$inboundSchema;
  /** @deprecated use `InputExecMode$outboundSchema` instead. */
  export const outboundSchema = InputExecMode$outboundSchema;
}

/** @internal */
export const InputExecCompression$inboundSchema: z.ZodNativeEnum<
  typeof InputExecCompression
> = z.nativeEnum(InputExecCompression);

/** @internal */
export const InputExecCompression$outboundSchema: z.ZodNativeEnum<
  typeof InputExecCompression
> = InputExecCompression$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputExecCompression$ {
  /** @deprecated use `InputExecCompression$inboundSchema` instead. */
  export const inboundSchema = InputExecCompression$inboundSchema;
  /** @deprecated use `InputExecCompression$outboundSchema` instead. */
  export const outboundSchema = InputExecCompression$outboundSchema;
}

/** @internal */
export const InputExecPq$inboundSchema: z.ZodType<
  InputExecPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputExecMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputExecCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputExecPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputExecPq$outboundSchema: z.ZodType<
  InputExecPq$Outbound,
  z.ZodTypeDef,
  InputExecPq
> = z.object({
  mode: InputExecMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputExecCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputExecPq$ {
  /** @deprecated use `InputExecPq$inboundSchema` instead. */
  export const inboundSchema = InputExecPq$inboundSchema;
  /** @deprecated use `InputExecPq$outboundSchema` instead. */
  export const outboundSchema = InputExecPq$outboundSchema;
  /** @deprecated use `InputExecPq$Outbound` instead. */
  export type Outbound = InputExecPq$Outbound;
}

export function inputExecPqToJSON(inputExecPq: InputExecPq): string {
  return JSON.stringify(InputExecPq$outboundSchema.parse(inputExecPq));
}

export function inputExecPqFromJSON(
  jsonString: string,
): SafeParseResult<InputExecPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputExecPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputExecPq' from JSON`,
  );
}

/** @internal */
export const ScheduleType$inboundSchema: z.ZodNativeEnum<typeof ScheduleType> =
  z.nativeEnum(ScheduleType);

/** @internal */
export const ScheduleType$outboundSchema: z.ZodNativeEnum<typeof ScheduleType> =
  ScheduleType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ScheduleType$ {
  /** @deprecated use `ScheduleType$inboundSchema` instead. */
  export const inboundSchema = ScheduleType$inboundSchema;
  /** @deprecated use `ScheduleType$outboundSchema` instead. */
  export const outboundSchema = ScheduleType$outboundSchema;
}

/** @internal */
export const InputExecMetadatum$inboundSchema: z.ZodType<
  InputExecMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputExecMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputExecMetadatum$outboundSchema: z.ZodType<
  InputExecMetadatum$Outbound,
  z.ZodTypeDef,
  InputExecMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputExecMetadatum$ {
  /** @deprecated use `InputExecMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputExecMetadatum$inboundSchema;
  /** @deprecated use `InputExecMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputExecMetadatum$outboundSchema;
  /** @deprecated use `InputExecMetadatum$Outbound` instead. */
  export type Outbound = InputExecMetadatum$Outbound;
}

export function inputExecMetadatumToJSON(
  inputExecMetadatum: InputExecMetadatum,
): string {
  return JSON.stringify(
    InputExecMetadatum$outboundSchema.parse(inputExecMetadatum),
  );
}

export function inputExecMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputExecMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputExecMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputExecMetadatum' from JSON`,
  );
}

/** @internal */
export const InputExec$inboundSchema: z.ZodType<
  InputExec,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputExecType$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputExecConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputExecPq$inboundSchema).optional(),
  command: z.string(),
  retries: z.number().default(10),
  scheduleType: ScheduleType$inboundSchema.default("interval"),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  metadata: z.array(z.lazy(() => InputExecMetadatum$inboundSchema)).optional(),
  description: z.string().optional(),
  interval: z.number().default(60),
  cronSchedule: z.string().default("* * * * *"),
});

/** @internal */
export type InputExec$Outbound = {
  id: string;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputExecConnection$Outbound> | undefined;
  pq?: InputExecPq$Outbound | undefined;
  command: string;
  retries: number;
  scheduleType: string;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  metadata?: Array<InputExecMetadatum$Outbound> | undefined;
  description?: string | undefined;
  interval: number;
  cronSchedule: string;
};

/** @internal */
export const InputExec$outboundSchema: z.ZodType<
  InputExec$Outbound,
  z.ZodTypeDef,
  InputExec
> = z.object({
  id: z.string(),
  type: InputExecType$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputExecConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputExecPq$outboundSchema).optional(),
  command: z.string(),
  retries: z.number().default(10),
  scheduleType: ScheduleType$outboundSchema.default("interval"),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  metadata: z.array(z.lazy(() => InputExecMetadatum$outboundSchema)).optional(),
  description: z.string().optional(),
  interval: z.number().default(60),
  cronSchedule: z.string().default("* * * * *"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputExec$ {
  /** @deprecated use `InputExec$inboundSchema` instead. */
  export const inboundSchema = InputExec$inboundSchema;
  /** @deprecated use `InputExec$outboundSchema` instead. */
  export const outboundSchema = InputExec$outboundSchema;
  /** @deprecated use `InputExec$Outbound` instead. */
  export type Outbound = InputExec$Outbound;
}

export function inputExecToJSON(inputExec: InputExec): string {
  return JSON.stringify(InputExec$outboundSchema.parse(inputExec));
}

export function inputExecFromJSON(
  jsonString: string,
): SafeParseResult<InputExec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputExec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputExec' from JSON`,
  );
}

/** @internal */
export const TypeEventhub$inboundSchema: z.ZodNativeEnum<typeof TypeEventhub> =
  z.nativeEnum(TypeEventhub);

/** @internal */
export const TypeEventhub$outboundSchema: z.ZodNativeEnum<typeof TypeEventhub> =
  TypeEventhub$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeEventhub$ {
  /** @deprecated use `TypeEventhub$inboundSchema` instead. */
  export const inboundSchema = TypeEventhub$inboundSchema;
  /** @deprecated use `TypeEventhub$outboundSchema` instead. */
  export const outboundSchema = TypeEventhub$outboundSchema;
}

/** @internal */
export const ConnectionEventhub$inboundSchema: z.ZodType<
  ConnectionEventhub,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionEventhub$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionEventhub$outboundSchema: z.ZodType<
  ConnectionEventhub$Outbound,
  z.ZodTypeDef,
  ConnectionEventhub
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionEventhub$ {
  /** @deprecated use `ConnectionEventhub$inboundSchema` instead. */
  export const inboundSchema = ConnectionEventhub$inboundSchema;
  /** @deprecated use `ConnectionEventhub$outboundSchema` instead. */
  export const outboundSchema = ConnectionEventhub$outboundSchema;
  /** @deprecated use `ConnectionEventhub$Outbound` instead. */
  export type Outbound = ConnectionEventhub$Outbound;
}

export function connectionEventhubToJSON(
  connectionEventhub: ConnectionEventhub,
): string {
  return JSON.stringify(
    ConnectionEventhub$outboundSchema.parse(connectionEventhub),
  );
}

export function connectionEventhubFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionEventhub, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionEventhub$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionEventhub' from JSON`,
  );
}

/** @internal */
export const ModeEventhub$inboundSchema: z.ZodNativeEnum<typeof ModeEventhub> =
  z.nativeEnum(ModeEventhub);

/** @internal */
export const ModeEventhub$outboundSchema: z.ZodNativeEnum<typeof ModeEventhub> =
  ModeEventhub$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeEventhub$ {
  /** @deprecated use `ModeEventhub$inboundSchema` instead. */
  export const inboundSchema = ModeEventhub$inboundSchema;
  /** @deprecated use `ModeEventhub$outboundSchema` instead. */
  export const outboundSchema = ModeEventhub$outboundSchema;
}

/** @internal */
export const CompressionEventhub$inboundSchema: z.ZodNativeEnum<
  typeof CompressionEventhub
> = z.nativeEnum(CompressionEventhub);

/** @internal */
export const CompressionEventhub$outboundSchema: z.ZodNativeEnum<
  typeof CompressionEventhub
> = CompressionEventhub$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionEventhub$ {
  /** @deprecated use `CompressionEventhub$inboundSchema` instead. */
  export const inboundSchema = CompressionEventhub$inboundSchema;
  /** @deprecated use `CompressionEventhub$outboundSchema` instead. */
  export const outboundSchema = CompressionEventhub$outboundSchema;
}

/** @internal */
export const PqEventhub$inboundSchema: z.ZodType<
  PqEventhub,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeEventhub$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionEventhub$inboundSchema.default("none"),
});

/** @internal */
export type PqEventhub$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqEventhub$outboundSchema: z.ZodType<
  PqEventhub$Outbound,
  z.ZodTypeDef,
  PqEventhub
> = z.object({
  mode: ModeEventhub$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionEventhub$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqEventhub$ {
  /** @deprecated use `PqEventhub$inboundSchema` instead. */
  export const inboundSchema = PqEventhub$inboundSchema;
  /** @deprecated use `PqEventhub$outboundSchema` instead. */
  export const outboundSchema = PqEventhub$outboundSchema;
  /** @deprecated use `PqEventhub$Outbound` instead. */
  export type Outbound = PqEventhub$Outbound;
}

export function pqEventhubToJSON(pqEventhub: PqEventhub): string {
  return JSON.stringify(PqEventhub$outboundSchema.parse(pqEventhub));
}

export function pqEventhubFromJSON(
  jsonString: string,
): SafeParseResult<PqEventhub, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqEventhub$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqEventhub' from JSON`,
  );
}

/** @internal */
export const SASLMechanismEventhub$inboundSchema: z.ZodNativeEnum<
  typeof SASLMechanismEventhub
> = z.nativeEnum(SASLMechanismEventhub);

/** @internal */
export const SASLMechanismEventhub$outboundSchema: z.ZodNativeEnum<
  typeof SASLMechanismEventhub
> = SASLMechanismEventhub$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SASLMechanismEventhub$ {
  /** @deprecated use `SASLMechanismEventhub$inboundSchema` instead. */
  export const inboundSchema = SASLMechanismEventhub$inboundSchema;
  /** @deprecated use `SASLMechanismEventhub$outboundSchema` instead. */
  export const outboundSchema = SASLMechanismEventhub$outboundSchema;
}

/** @internal */
export const AuthenticationEventhub$inboundSchema: z.ZodType<
  AuthenticationEventhub,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(false),
  mechanism: SASLMechanismEventhub$inboundSchema.default("plain"),
});

/** @internal */
export type AuthenticationEventhub$Outbound = {
  disabled: boolean;
  mechanism: string;
};

/** @internal */
export const AuthenticationEventhub$outboundSchema: z.ZodType<
  AuthenticationEventhub$Outbound,
  z.ZodTypeDef,
  AuthenticationEventhub
> = z.object({
  disabled: z.boolean().default(false),
  mechanism: SASLMechanismEventhub$outboundSchema.default("plain"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationEventhub$ {
  /** @deprecated use `AuthenticationEventhub$inboundSchema` instead. */
  export const inboundSchema = AuthenticationEventhub$inboundSchema;
  /** @deprecated use `AuthenticationEventhub$outboundSchema` instead. */
  export const outboundSchema = AuthenticationEventhub$outboundSchema;
  /** @deprecated use `AuthenticationEventhub$Outbound` instead. */
  export type Outbound = AuthenticationEventhub$Outbound;
}

export function authenticationEventhubToJSON(
  authenticationEventhub: AuthenticationEventhub,
): string {
  return JSON.stringify(
    AuthenticationEventhub$outboundSchema.parse(authenticationEventhub),
  );
}

export function authenticationEventhubFromJSON(
  jsonString: string,
): SafeParseResult<AuthenticationEventhub, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthenticationEventhub$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthenticationEventhub' from JSON`,
  );
}

/** @internal */
export const TLSSettingsClientSideEventhub$inboundSchema: z.ZodType<
  TLSSettingsClientSideEventhub,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
});

/** @internal */
export type TLSSettingsClientSideEventhub$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
};

/** @internal */
export const TLSSettingsClientSideEventhub$outboundSchema: z.ZodType<
  TLSSettingsClientSideEventhub$Outbound,
  z.ZodTypeDef,
  TLSSettingsClientSideEventhub
> = z.object({
  disabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsClientSideEventhub$ {
  /** @deprecated use `TLSSettingsClientSideEventhub$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsClientSideEventhub$inboundSchema;
  /** @deprecated use `TLSSettingsClientSideEventhub$outboundSchema` instead. */
  export const outboundSchema = TLSSettingsClientSideEventhub$outboundSchema;
  /** @deprecated use `TLSSettingsClientSideEventhub$Outbound` instead. */
  export type Outbound = TLSSettingsClientSideEventhub$Outbound;
}

export function tlsSettingsClientSideEventhubToJSON(
  tlsSettingsClientSideEventhub: TLSSettingsClientSideEventhub,
): string {
  return JSON.stringify(
    TLSSettingsClientSideEventhub$outboundSchema.parse(
      tlsSettingsClientSideEventhub,
    ),
  );
}

export function tlsSettingsClientSideEventhubFromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsClientSideEventhub, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TLSSettingsClientSideEventhub$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsClientSideEventhub' from JSON`,
  );
}

/** @internal */
export const MetadatumEventhub$inboundSchema: z.ZodType<
  MetadatumEventhub,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumEventhub$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumEventhub$outboundSchema: z.ZodType<
  MetadatumEventhub$Outbound,
  z.ZodTypeDef,
  MetadatumEventhub
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumEventhub$ {
  /** @deprecated use `MetadatumEventhub$inboundSchema` instead. */
  export const inboundSchema = MetadatumEventhub$inboundSchema;
  /** @deprecated use `MetadatumEventhub$outboundSchema` instead. */
  export const outboundSchema = MetadatumEventhub$outboundSchema;
  /** @deprecated use `MetadatumEventhub$Outbound` instead. */
  export type Outbound = MetadatumEventhub$Outbound;
}

export function metadatumEventhubToJSON(
  metadatumEventhub: MetadatumEventhub,
): string {
  return JSON.stringify(
    MetadatumEventhub$outboundSchema.parse(metadatumEventhub),
  );
}

export function metadatumEventhubFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumEventhub, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumEventhub$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumEventhub' from JSON`,
  );
}

/** @internal */
export const InputEventhub$inboundSchema: z.ZodType<
  InputEventhub,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeEventhub$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionEventhub$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqEventhub$inboundSchema).optional(),
  brokers: z.array(z.string()),
  topics: z.array(z.string()),
  groupId: z.string().default("Cribl"),
  fromBeginning: z.boolean().default(true),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => AuthenticationEventhub$inboundSchema).optional(),
  tls: z.lazy(() => TLSSettingsClientSideEventhub$inboundSchema).optional(),
  sessionTimeout: z.number().default(30000),
  rebalanceTimeout: z.number().default(60000),
  heartbeatInterval: z.number().default(3000),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().default(1048576),
  maxBytes: z.number().default(10485760),
  maxSocketErrors: z.number().default(0),
  minimizeDuplicates: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumEventhub$inboundSchema)).optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputEventhub$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionEventhub$Outbound> | undefined;
  pq?: PqEventhub$Outbound | undefined;
  brokers: Array<string>;
  topics: Array<string>;
  groupId: string;
  fromBeginning: boolean;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  maxBackOff: number;
  initialBackoff: number;
  backoffRate: number;
  authenticationTimeout: number;
  reauthenticationThreshold: number;
  sasl?: AuthenticationEventhub$Outbound | undefined;
  tls?: TLSSettingsClientSideEventhub$Outbound | undefined;
  sessionTimeout: number;
  rebalanceTimeout: number;
  heartbeatInterval: number;
  autoCommitInterval?: number | undefined;
  autoCommitThreshold?: number | undefined;
  maxBytesPerPartition: number;
  maxBytes: number;
  maxSocketErrors: number;
  minimizeDuplicates: boolean;
  metadata?: Array<MetadatumEventhub$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputEventhub$outboundSchema: z.ZodType<
  InputEventhub$Outbound,
  z.ZodTypeDef,
  InputEventhub
> = z.object({
  id: z.string(),
  type: TypeEventhub$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionEventhub$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqEventhub$outboundSchema).optional(),
  brokers: z.array(z.string()),
  topics: z.array(z.string()),
  groupId: z.string().default("Cribl"),
  fromBeginning: z.boolean().default(true),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => AuthenticationEventhub$outboundSchema).optional(),
  tls: z.lazy(() => TLSSettingsClientSideEventhub$outboundSchema).optional(),
  sessionTimeout: z.number().default(30000),
  rebalanceTimeout: z.number().default(60000),
  heartbeatInterval: z.number().default(3000),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().default(1048576),
  maxBytes: z.number().default(10485760),
  maxSocketErrors: z.number().default(0),
  minimizeDuplicates: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumEventhub$outboundSchema)).optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEventhub$ {
  /** @deprecated use `InputEventhub$inboundSchema` instead. */
  export const inboundSchema = InputEventhub$inboundSchema;
  /** @deprecated use `InputEventhub$outboundSchema` instead. */
  export const outboundSchema = InputEventhub$outboundSchema;
  /** @deprecated use `InputEventhub$Outbound` instead. */
  export type Outbound = InputEventhub$Outbound;
}

export function inputEventhubToJSON(inputEventhub: InputEventhub): string {
  return JSON.stringify(InputEventhub$outboundSchema.parse(inputEventhub));
}

export function inputEventhubFromJSON(
  jsonString: string,
): SafeParseResult<InputEventhub, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputEventhub$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputEventhub' from JSON`,
  );
}

/** @internal */
export const TypeOffice365MsgTrace$inboundSchema: z.ZodNativeEnum<
  typeof TypeOffice365MsgTrace
> = z.nativeEnum(TypeOffice365MsgTrace);

/** @internal */
export const TypeOffice365MsgTrace$outboundSchema: z.ZodNativeEnum<
  typeof TypeOffice365MsgTrace
> = TypeOffice365MsgTrace$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeOffice365MsgTrace$ {
  /** @deprecated use `TypeOffice365MsgTrace$inboundSchema` instead. */
  export const inboundSchema = TypeOffice365MsgTrace$inboundSchema;
  /** @deprecated use `TypeOffice365MsgTrace$outboundSchema` instead. */
  export const outboundSchema = TypeOffice365MsgTrace$outboundSchema;
}

/** @internal */
export const ConnectionOffice365MsgTrace$inboundSchema: z.ZodType<
  ConnectionOffice365MsgTrace,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionOffice365MsgTrace$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionOffice365MsgTrace$outboundSchema: z.ZodType<
  ConnectionOffice365MsgTrace$Outbound,
  z.ZodTypeDef,
  ConnectionOffice365MsgTrace
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionOffice365MsgTrace$ {
  /** @deprecated use `ConnectionOffice365MsgTrace$inboundSchema` instead. */
  export const inboundSchema = ConnectionOffice365MsgTrace$inboundSchema;
  /** @deprecated use `ConnectionOffice365MsgTrace$outboundSchema` instead. */
  export const outboundSchema = ConnectionOffice365MsgTrace$outboundSchema;
  /** @deprecated use `ConnectionOffice365MsgTrace$Outbound` instead. */
  export type Outbound = ConnectionOffice365MsgTrace$Outbound;
}

export function connectionOffice365MsgTraceToJSON(
  connectionOffice365MsgTrace: ConnectionOffice365MsgTrace,
): string {
  return JSON.stringify(
    ConnectionOffice365MsgTrace$outboundSchema.parse(
      connectionOffice365MsgTrace,
    ),
  );
}

export function connectionOffice365MsgTraceFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionOffice365MsgTrace, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionOffice365MsgTrace$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionOffice365MsgTrace' from JSON`,
  );
}

/** @internal */
export const ModeOffice365MsgTrace$inboundSchema: z.ZodNativeEnum<
  typeof ModeOffice365MsgTrace
> = z.nativeEnum(ModeOffice365MsgTrace);

/** @internal */
export const ModeOffice365MsgTrace$outboundSchema: z.ZodNativeEnum<
  typeof ModeOffice365MsgTrace
> = ModeOffice365MsgTrace$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeOffice365MsgTrace$ {
  /** @deprecated use `ModeOffice365MsgTrace$inboundSchema` instead. */
  export const inboundSchema = ModeOffice365MsgTrace$inboundSchema;
  /** @deprecated use `ModeOffice365MsgTrace$outboundSchema` instead. */
  export const outboundSchema = ModeOffice365MsgTrace$outboundSchema;
}

/** @internal */
export const CompressionOffice365MsgTrace$inboundSchema: z.ZodNativeEnum<
  typeof CompressionOffice365MsgTrace
> = z.nativeEnum(CompressionOffice365MsgTrace);

/** @internal */
export const CompressionOffice365MsgTrace$outboundSchema: z.ZodNativeEnum<
  typeof CompressionOffice365MsgTrace
> = CompressionOffice365MsgTrace$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionOffice365MsgTrace$ {
  /** @deprecated use `CompressionOffice365MsgTrace$inboundSchema` instead. */
  export const inboundSchema = CompressionOffice365MsgTrace$inboundSchema;
  /** @deprecated use `CompressionOffice365MsgTrace$outboundSchema` instead. */
  export const outboundSchema = CompressionOffice365MsgTrace$outboundSchema;
}

/** @internal */
export const PqOffice365MsgTrace$inboundSchema: z.ZodType<
  PqOffice365MsgTrace,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeOffice365MsgTrace$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionOffice365MsgTrace$inboundSchema.default("none"),
});

/** @internal */
export type PqOffice365MsgTrace$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqOffice365MsgTrace$outboundSchema: z.ZodType<
  PqOffice365MsgTrace$Outbound,
  z.ZodTypeDef,
  PqOffice365MsgTrace
> = z.object({
  mode: ModeOffice365MsgTrace$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionOffice365MsgTrace$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqOffice365MsgTrace$ {
  /** @deprecated use `PqOffice365MsgTrace$inboundSchema` instead. */
  export const inboundSchema = PqOffice365MsgTrace$inboundSchema;
  /** @deprecated use `PqOffice365MsgTrace$outboundSchema` instead. */
  export const outboundSchema = PqOffice365MsgTrace$outboundSchema;
  /** @deprecated use `PqOffice365MsgTrace$Outbound` instead. */
  export type Outbound = PqOffice365MsgTrace$Outbound;
}

export function pqOffice365MsgTraceToJSON(
  pqOffice365MsgTrace: PqOffice365MsgTrace,
): string {
  return JSON.stringify(
    PqOffice365MsgTrace$outboundSchema.parse(pqOffice365MsgTrace),
  );
}

export function pqOffice365MsgTraceFromJSON(
  jsonString: string,
): SafeParseResult<PqOffice365MsgTrace, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqOffice365MsgTrace$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqOffice365MsgTrace' from JSON`,
  );
}

/** @internal */
export const AuthenticationMethodOffice365MsgTrace$inboundSchema:
  z.ZodNativeEnum<typeof AuthenticationMethodOffice365MsgTrace> = z.nativeEnum(
    AuthenticationMethodOffice365MsgTrace,
  );

/** @internal */
export const AuthenticationMethodOffice365MsgTrace$outboundSchema:
  z.ZodNativeEnum<typeof AuthenticationMethodOffice365MsgTrace> =
    AuthenticationMethodOffice365MsgTrace$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodOffice365MsgTrace$ {
  /** @deprecated use `AuthenticationMethodOffice365MsgTrace$inboundSchema` instead. */
  export const inboundSchema =
    AuthenticationMethodOffice365MsgTrace$inboundSchema;
  /** @deprecated use `AuthenticationMethodOffice365MsgTrace$outboundSchema` instead. */
  export const outboundSchema =
    AuthenticationMethodOffice365MsgTrace$outboundSchema;
}

/** @internal */
export const LogLevelOffice365MsgTrace$inboundSchema: z.ZodNativeEnum<
  typeof LogLevelOffice365MsgTrace
> = z.nativeEnum(LogLevelOffice365MsgTrace);

/** @internal */
export const LogLevelOffice365MsgTrace$outboundSchema: z.ZodNativeEnum<
  typeof LogLevelOffice365MsgTrace
> = LogLevelOffice365MsgTrace$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LogLevelOffice365MsgTrace$ {
  /** @deprecated use `LogLevelOffice365MsgTrace$inboundSchema` instead. */
  export const inboundSchema = LogLevelOffice365MsgTrace$inboundSchema;
  /** @deprecated use `LogLevelOffice365MsgTrace$outboundSchema` instead. */
  export const outboundSchema = LogLevelOffice365MsgTrace$outboundSchema;
}

/** @internal */
export const MetadatumOffice365MsgTrace$inboundSchema: z.ZodType<
  MetadatumOffice365MsgTrace,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumOffice365MsgTrace$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumOffice365MsgTrace$outboundSchema: z.ZodType<
  MetadatumOffice365MsgTrace$Outbound,
  z.ZodTypeDef,
  MetadatumOffice365MsgTrace
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumOffice365MsgTrace$ {
  /** @deprecated use `MetadatumOffice365MsgTrace$inboundSchema` instead. */
  export const inboundSchema = MetadatumOffice365MsgTrace$inboundSchema;
  /** @deprecated use `MetadatumOffice365MsgTrace$outboundSchema` instead. */
  export const outboundSchema = MetadatumOffice365MsgTrace$outboundSchema;
  /** @deprecated use `MetadatumOffice365MsgTrace$Outbound` instead. */
  export type Outbound = MetadatumOffice365MsgTrace$Outbound;
}

export function metadatumOffice365MsgTraceToJSON(
  metadatumOffice365MsgTrace: MetadatumOffice365MsgTrace,
): string {
  return JSON.stringify(
    MetadatumOffice365MsgTrace$outboundSchema.parse(metadatumOffice365MsgTrace),
  );
}

export function metadatumOffice365MsgTraceFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumOffice365MsgTrace, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumOffice365MsgTrace$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumOffice365MsgTrace' from JSON`,
  );
}

/** @internal */
export const RetryTypeOffice365MsgTrace$inboundSchema: z.ZodNativeEnum<
  typeof RetryTypeOffice365MsgTrace
> = z.nativeEnum(RetryTypeOffice365MsgTrace);

/** @internal */
export const RetryTypeOffice365MsgTrace$outboundSchema: z.ZodNativeEnum<
  typeof RetryTypeOffice365MsgTrace
> = RetryTypeOffice365MsgTrace$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RetryTypeOffice365MsgTrace$ {
  /** @deprecated use `RetryTypeOffice365MsgTrace$inboundSchema` instead. */
  export const inboundSchema = RetryTypeOffice365MsgTrace$inboundSchema;
  /** @deprecated use `RetryTypeOffice365MsgTrace$outboundSchema` instead. */
  export const outboundSchema = RetryTypeOffice365MsgTrace$outboundSchema;
}

/** @internal */
export const RetryRulesOffice365MsgTrace$inboundSchema: z.ZodType<
  RetryRulesOffice365MsgTrace,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOffice365MsgTrace$inboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/** @internal */
export type RetryRulesOffice365MsgTrace$Outbound = {
  type: string;
  interval: number;
  limit: number;
  multiplier: number;
  codes?: Array<number> | undefined;
  enableHeader: boolean;
  retryConnectTimeout: boolean;
  retryConnectReset: boolean;
};

/** @internal */
export const RetryRulesOffice365MsgTrace$outboundSchema: z.ZodType<
  RetryRulesOffice365MsgTrace$Outbound,
  z.ZodTypeDef,
  RetryRulesOffice365MsgTrace
> = z.object({
  type: RetryTypeOffice365MsgTrace$outboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RetryRulesOffice365MsgTrace$ {
  /** @deprecated use `RetryRulesOffice365MsgTrace$inboundSchema` instead. */
  export const inboundSchema = RetryRulesOffice365MsgTrace$inboundSchema;
  /** @deprecated use `RetryRulesOffice365MsgTrace$outboundSchema` instead. */
  export const outboundSchema = RetryRulesOffice365MsgTrace$outboundSchema;
  /** @deprecated use `RetryRulesOffice365MsgTrace$Outbound` instead. */
  export type Outbound = RetryRulesOffice365MsgTrace$Outbound;
}

export function retryRulesOffice365MsgTraceToJSON(
  retryRulesOffice365MsgTrace: RetryRulesOffice365MsgTrace,
): string {
  return JSON.stringify(
    RetryRulesOffice365MsgTrace$outboundSchema.parse(
      retryRulesOffice365MsgTrace,
    ),
  );
}

export function retryRulesOffice365MsgTraceFromJSON(
  jsonString: string,
): SafeParseResult<RetryRulesOffice365MsgTrace, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetryRulesOffice365MsgTrace$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetryRulesOffice365MsgTrace' from JSON`,
  );
}

/** @internal */
export const SubscriptionPlanOffice365MsgTrace$inboundSchema: z.ZodNativeEnum<
  typeof SubscriptionPlanOffice365MsgTrace
> = z.nativeEnum(SubscriptionPlanOffice365MsgTrace);

/** @internal */
export const SubscriptionPlanOffice365MsgTrace$outboundSchema: z.ZodNativeEnum<
  typeof SubscriptionPlanOffice365MsgTrace
> = SubscriptionPlanOffice365MsgTrace$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriptionPlanOffice365MsgTrace$ {
  /** @deprecated use `SubscriptionPlanOffice365MsgTrace$inboundSchema` instead. */
  export const inboundSchema = SubscriptionPlanOffice365MsgTrace$inboundSchema;
  /** @deprecated use `SubscriptionPlanOffice365MsgTrace$outboundSchema` instead. */
  export const outboundSchema =
    SubscriptionPlanOffice365MsgTrace$outboundSchema;
}

/** @internal */
export const CertOptions$inboundSchema: z.ZodType<
  CertOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  certificateName: z.string().optional(),
  privKeyPath: z.string(),
  passphrase: z.string().optional(),
  certPath: z.string(),
});

/** @internal */
export type CertOptions$Outbound = {
  certificateName?: string | undefined;
  privKeyPath: string;
  passphrase?: string | undefined;
  certPath: string;
};

/** @internal */
export const CertOptions$outboundSchema: z.ZodType<
  CertOptions$Outbound,
  z.ZodTypeDef,
  CertOptions
> = z.object({
  certificateName: z.string().optional(),
  privKeyPath: z.string(),
  passphrase: z.string().optional(),
  certPath: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CertOptions$ {
  /** @deprecated use `CertOptions$inboundSchema` instead. */
  export const inboundSchema = CertOptions$inboundSchema;
  /** @deprecated use `CertOptions$outboundSchema` instead. */
  export const outboundSchema = CertOptions$outboundSchema;
  /** @deprecated use `CertOptions$Outbound` instead. */
  export type Outbound = CertOptions$Outbound;
}

export function certOptionsToJSON(certOptions: CertOptions): string {
  return JSON.stringify(CertOptions$outboundSchema.parse(certOptions));
}

export function certOptionsFromJSON(
  jsonString: string,
): SafeParseResult<CertOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CertOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CertOptions' from JSON`,
  );
}

/** @internal */
export const InputOffice365MsgTrace$inboundSchema: z.ZodType<
  InputOffice365MsgTrace,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeOffice365MsgTrace$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionOffice365MsgTrace$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqOffice365MsgTrace$inboundSchema).optional(),
  url: z.string().default(
    "https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace",
  ),
  interval: z.number().default(60),
  startDate: z.string().optional(),
  endDate: z.string().optional(),
  timeout: z.number().default(300),
  disableTimeFilter: z.boolean().default(true),
  authType: AuthenticationMethodOffice365MsgTrace$inboundSchema.default(
    "oauth",
  ),
  rescheduleDroppedTasks: z.boolean().default(true),
  maxTaskReschedule: z.number().default(1),
  logLevel: LogLevelOffice365MsgTrace$inboundSchema.default("info"),
  jobTimeout: z.string().default("0"),
  keepAliveTime: z.number().default(30),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumOffice365MsgTrace$inboundSchema))
    .optional(),
  retryRules: z.lazy(() => RetryRulesOffice365MsgTrace$inboundSchema)
    .optional(),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  clientSecret: z.string().optional(),
  tenantId: z.string().optional(),
  clientId: z.string().optional(),
  resource: z.string().default("https://outlook.office365.com"),
  planType: SubscriptionPlanOffice365MsgTrace$inboundSchema.default(
    "enterprise_gcc",
  ),
  textSecret: z.string().optional(),
  certOptions: z.lazy(() => CertOptions$inboundSchema).optional(),
});

/** @internal */
export type InputOffice365MsgTrace$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionOffice365MsgTrace$Outbound> | undefined;
  pq?: PqOffice365MsgTrace$Outbound | undefined;
  url: string;
  interval: number;
  startDate?: string | undefined;
  endDate?: string | undefined;
  timeout: number;
  disableTimeFilter: boolean;
  authType: string;
  rescheduleDroppedTasks: boolean;
  maxTaskReschedule: number;
  logLevel: string;
  jobTimeout: string;
  keepAliveTime: number;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<MetadatumOffice365MsgTrace$Outbound> | undefined;
  retryRules?: RetryRulesOffice365MsgTrace$Outbound | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  clientSecret?: string | undefined;
  tenantId?: string | undefined;
  clientId?: string | undefined;
  resource: string;
  planType: string;
  textSecret?: string | undefined;
  certOptions?: CertOptions$Outbound | undefined;
};

/** @internal */
export const InputOffice365MsgTrace$outboundSchema: z.ZodType<
  InputOffice365MsgTrace$Outbound,
  z.ZodTypeDef,
  InputOffice365MsgTrace
> = z.object({
  id: z.string(),
  type: TypeOffice365MsgTrace$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionOffice365MsgTrace$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqOffice365MsgTrace$outboundSchema).optional(),
  url: z.string().default(
    "https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace",
  ),
  interval: z.number().default(60),
  startDate: z.string().optional(),
  endDate: z.string().optional(),
  timeout: z.number().default(300),
  disableTimeFilter: z.boolean().default(true),
  authType: AuthenticationMethodOffice365MsgTrace$outboundSchema.default(
    "oauth",
  ),
  rescheduleDroppedTasks: z.boolean().default(true),
  maxTaskReschedule: z.number().default(1),
  logLevel: LogLevelOffice365MsgTrace$outboundSchema.default("info"),
  jobTimeout: z.string().default("0"),
  keepAliveTime: z.number().default(30),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumOffice365MsgTrace$outboundSchema))
    .optional(),
  retryRules: z.lazy(() => RetryRulesOffice365MsgTrace$outboundSchema)
    .optional(),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  clientSecret: z.string().optional(),
  tenantId: z.string().optional(),
  clientId: z.string().optional(),
  resource: z.string().default("https://outlook.office365.com"),
  planType: SubscriptionPlanOffice365MsgTrace$outboundSchema.default(
    "enterprise_gcc",
  ),
  textSecret: z.string().optional(),
  certOptions: z.lazy(() => CertOptions$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTrace$ {
  /** @deprecated use `InputOffice365MsgTrace$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MsgTrace$inboundSchema;
  /** @deprecated use `InputOffice365MsgTrace$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MsgTrace$outboundSchema;
  /** @deprecated use `InputOffice365MsgTrace$Outbound` instead. */
  export type Outbound = InputOffice365MsgTrace$Outbound;
}

export function inputOffice365MsgTraceToJSON(
  inputOffice365MsgTrace: InputOffice365MsgTrace,
): string {
  return JSON.stringify(
    InputOffice365MsgTrace$outboundSchema.parse(inputOffice365MsgTrace),
  );
}

export function inputOffice365MsgTraceFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365MsgTrace, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365MsgTrace$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365MsgTrace' from JSON`,
  );
}

/** @internal */
export const TypeOffice365Service$inboundSchema: z.ZodNativeEnum<
  typeof TypeOffice365Service
> = z.nativeEnum(TypeOffice365Service);

/** @internal */
export const TypeOffice365Service$outboundSchema: z.ZodNativeEnum<
  typeof TypeOffice365Service
> = TypeOffice365Service$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeOffice365Service$ {
  /** @deprecated use `TypeOffice365Service$inboundSchema` instead. */
  export const inboundSchema = TypeOffice365Service$inboundSchema;
  /** @deprecated use `TypeOffice365Service$outboundSchema` instead. */
  export const outboundSchema = TypeOffice365Service$outboundSchema;
}

/** @internal */
export const ConnectionOffice365Service$inboundSchema: z.ZodType<
  ConnectionOffice365Service,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionOffice365Service$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionOffice365Service$outboundSchema: z.ZodType<
  ConnectionOffice365Service$Outbound,
  z.ZodTypeDef,
  ConnectionOffice365Service
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionOffice365Service$ {
  /** @deprecated use `ConnectionOffice365Service$inboundSchema` instead. */
  export const inboundSchema = ConnectionOffice365Service$inboundSchema;
  /** @deprecated use `ConnectionOffice365Service$outboundSchema` instead. */
  export const outboundSchema = ConnectionOffice365Service$outboundSchema;
  /** @deprecated use `ConnectionOffice365Service$Outbound` instead. */
  export type Outbound = ConnectionOffice365Service$Outbound;
}

export function connectionOffice365ServiceToJSON(
  connectionOffice365Service: ConnectionOffice365Service,
): string {
  return JSON.stringify(
    ConnectionOffice365Service$outboundSchema.parse(connectionOffice365Service),
  );
}

export function connectionOffice365ServiceFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionOffice365Service, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionOffice365Service$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionOffice365Service' from JSON`,
  );
}

/** @internal */
export const ModeOffice365Service$inboundSchema: z.ZodNativeEnum<
  typeof ModeOffice365Service
> = z.nativeEnum(ModeOffice365Service);

/** @internal */
export const ModeOffice365Service$outboundSchema: z.ZodNativeEnum<
  typeof ModeOffice365Service
> = ModeOffice365Service$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeOffice365Service$ {
  /** @deprecated use `ModeOffice365Service$inboundSchema` instead. */
  export const inboundSchema = ModeOffice365Service$inboundSchema;
  /** @deprecated use `ModeOffice365Service$outboundSchema` instead. */
  export const outboundSchema = ModeOffice365Service$outboundSchema;
}

/** @internal */
export const CompressionOffice365Service$inboundSchema: z.ZodNativeEnum<
  typeof CompressionOffice365Service
> = z.nativeEnum(CompressionOffice365Service);

/** @internal */
export const CompressionOffice365Service$outboundSchema: z.ZodNativeEnum<
  typeof CompressionOffice365Service
> = CompressionOffice365Service$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionOffice365Service$ {
  /** @deprecated use `CompressionOffice365Service$inboundSchema` instead. */
  export const inboundSchema = CompressionOffice365Service$inboundSchema;
  /** @deprecated use `CompressionOffice365Service$outboundSchema` instead. */
  export const outboundSchema = CompressionOffice365Service$outboundSchema;
}

/** @internal */
export const PqOffice365Service$inboundSchema: z.ZodType<
  PqOffice365Service,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeOffice365Service$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionOffice365Service$inboundSchema.default("none"),
});

/** @internal */
export type PqOffice365Service$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqOffice365Service$outboundSchema: z.ZodType<
  PqOffice365Service$Outbound,
  z.ZodTypeDef,
  PqOffice365Service
> = z.object({
  mode: ModeOffice365Service$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionOffice365Service$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqOffice365Service$ {
  /** @deprecated use `PqOffice365Service$inboundSchema` instead. */
  export const inboundSchema = PqOffice365Service$inboundSchema;
  /** @deprecated use `PqOffice365Service$outboundSchema` instead. */
  export const outboundSchema = PqOffice365Service$outboundSchema;
  /** @deprecated use `PqOffice365Service$Outbound` instead. */
  export type Outbound = PqOffice365Service$Outbound;
}

export function pqOffice365ServiceToJSON(
  pqOffice365Service: PqOffice365Service,
): string {
  return JSON.stringify(
    PqOffice365Service$outboundSchema.parse(pqOffice365Service),
  );
}

export function pqOffice365ServiceFromJSON(
  jsonString: string,
): SafeParseResult<PqOffice365Service, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqOffice365Service$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqOffice365Service' from JSON`,
  );
}

/** @internal */
export const SubscriptionPlanOffice365Service$inboundSchema: z.ZodNativeEnum<
  typeof SubscriptionPlanOffice365Service
> = z.nativeEnum(SubscriptionPlanOffice365Service);

/** @internal */
export const SubscriptionPlanOffice365Service$outboundSchema: z.ZodNativeEnum<
  typeof SubscriptionPlanOffice365Service
> = SubscriptionPlanOffice365Service$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriptionPlanOffice365Service$ {
  /** @deprecated use `SubscriptionPlanOffice365Service$inboundSchema` instead. */
  export const inboundSchema = SubscriptionPlanOffice365Service$inboundSchema;
  /** @deprecated use `SubscriptionPlanOffice365Service$outboundSchema` instead. */
  export const outboundSchema = SubscriptionPlanOffice365Service$outboundSchema;
}

/** @internal */
export const MetadatumOffice365Service$inboundSchema: z.ZodType<
  MetadatumOffice365Service,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumOffice365Service$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumOffice365Service$outboundSchema: z.ZodType<
  MetadatumOffice365Service$Outbound,
  z.ZodTypeDef,
  MetadatumOffice365Service
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumOffice365Service$ {
  /** @deprecated use `MetadatumOffice365Service$inboundSchema` instead. */
  export const inboundSchema = MetadatumOffice365Service$inboundSchema;
  /** @deprecated use `MetadatumOffice365Service$outboundSchema` instead. */
  export const outboundSchema = MetadatumOffice365Service$outboundSchema;
  /** @deprecated use `MetadatumOffice365Service$Outbound` instead. */
  export type Outbound = MetadatumOffice365Service$Outbound;
}

export function metadatumOffice365ServiceToJSON(
  metadatumOffice365Service: MetadatumOffice365Service,
): string {
  return JSON.stringify(
    MetadatumOffice365Service$outboundSchema.parse(metadatumOffice365Service),
  );
}

export function metadatumOffice365ServiceFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumOffice365Service, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumOffice365Service$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumOffice365Service' from JSON`,
  );
}

/** @internal */
export const LogLevelOffice365Service$inboundSchema: z.ZodNativeEnum<
  typeof LogLevelOffice365Service
> = z.nativeEnum(LogLevelOffice365Service);

/** @internal */
export const LogLevelOffice365Service$outboundSchema: z.ZodNativeEnum<
  typeof LogLevelOffice365Service
> = LogLevelOffice365Service$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LogLevelOffice365Service$ {
  /** @deprecated use `LogLevelOffice365Service$inboundSchema` instead. */
  export const inboundSchema = LogLevelOffice365Service$inboundSchema;
  /** @deprecated use `LogLevelOffice365Service$outboundSchema` instead. */
  export const outboundSchema = LogLevelOffice365Service$outboundSchema;
}

/** @internal */
export const ContentConfigOffice365Service$inboundSchema: z.ZodType<
  ContentConfigOffice365Service,
  z.ZodTypeDef,
  unknown
> = z.object({
  contentType: z.string().optional(),
  description: z.string().optional(),
  interval: z.number().optional(),
  logLevel: LogLevelOffice365Service$inboundSchema.optional(),
  enabled: z.boolean().optional(),
});

/** @internal */
export type ContentConfigOffice365Service$Outbound = {
  contentType?: string | undefined;
  description?: string | undefined;
  interval?: number | undefined;
  logLevel?: string | undefined;
  enabled?: boolean | undefined;
};

/** @internal */
export const ContentConfigOffice365Service$outboundSchema: z.ZodType<
  ContentConfigOffice365Service$Outbound,
  z.ZodTypeDef,
  ContentConfigOffice365Service
> = z.object({
  contentType: z.string().optional(),
  description: z.string().optional(),
  interval: z.number().optional(),
  logLevel: LogLevelOffice365Service$outboundSchema.optional(),
  enabled: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContentConfigOffice365Service$ {
  /** @deprecated use `ContentConfigOffice365Service$inboundSchema` instead. */
  export const inboundSchema = ContentConfigOffice365Service$inboundSchema;
  /** @deprecated use `ContentConfigOffice365Service$outboundSchema` instead. */
  export const outboundSchema = ContentConfigOffice365Service$outboundSchema;
  /** @deprecated use `ContentConfigOffice365Service$Outbound` instead. */
  export type Outbound = ContentConfigOffice365Service$Outbound;
}

export function contentConfigOffice365ServiceToJSON(
  contentConfigOffice365Service: ContentConfigOffice365Service,
): string {
  return JSON.stringify(
    ContentConfigOffice365Service$outboundSchema.parse(
      contentConfigOffice365Service,
    ),
  );
}

export function contentConfigOffice365ServiceFromJSON(
  jsonString: string,
): SafeParseResult<ContentConfigOffice365Service, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentConfigOffice365Service$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentConfigOffice365Service' from JSON`,
  );
}

/** @internal */
export const RetryTypeOffice365Service$inboundSchema: z.ZodNativeEnum<
  typeof RetryTypeOffice365Service
> = z.nativeEnum(RetryTypeOffice365Service);

/** @internal */
export const RetryTypeOffice365Service$outboundSchema: z.ZodNativeEnum<
  typeof RetryTypeOffice365Service
> = RetryTypeOffice365Service$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RetryTypeOffice365Service$ {
  /** @deprecated use `RetryTypeOffice365Service$inboundSchema` instead. */
  export const inboundSchema = RetryTypeOffice365Service$inboundSchema;
  /** @deprecated use `RetryTypeOffice365Service$outboundSchema` instead. */
  export const outboundSchema = RetryTypeOffice365Service$outboundSchema;
}

/** @internal */
export const RetryRulesOffice365Service$inboundSchema: z.ZodType<
  RetryRulesOffice365Service,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOffice365Service$inboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/** @internal */
export type RetryRulesOffice365Service$Outbound = {
  type: string;
  interval: number;
  limit: number;
  multiplier: number;
  codes?: Array<number> | undefined;
  enableHeader: boolean;
  retryConnectTimeout: boolean;
  retryConnectReset: boolean;
};

/** @internal */
export const RetryRulesOffice365Service$outboundSchema: z.ZodType<
  RetryRulesOffice365Service$Outbound,
  z.ZodTypeDef,
  RetryRulesOffice365Service
> = z.object({
  type: RetryTypeOffice365Service$outboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RetryRulesOffice365Service$ {
  /** @deprecated use `RetryRulesOffice365Service$inboundSchema` instead. */
  export const inboundSchema = RetryRulesOffice365Service$inboundSchema;
  /** @deprecated use `RetryRulesOffice365Service$outboundSchema` instead. */
  export const outboundSchema = RetryRulesOffice365Service$outboundSchema;
  /** @deprecated use `RetryRulesOffice365Service$Outbound` instead. */
  export type Outbound = RetryRulesOffice365Service$Outbound;
}

export function retryRulesOffice365ServiceToJSON(
  retryRulesOffice365Service: RetryRulesOffice365Service,
): string {
  return JSON.stringify(
    RetryRulesOffice365Service$outboundSchema.parse(retryRulesOffice365Service),
  );
}

export function retryRulesOffice365ServiceFromJSON(
  jsonString: string,
): SafeParseResult<RetryRulesOffice365Service, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetryRulesOffice365Service$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetryRulesOffice365Service' from JSON`,
  );
}

/** @internal */
export const AuthenticationMethodOffice365Service$inboundSchema:
  z.ZodNativeEnum<typeof AuthenticationMethodOffice365Service> = z.nativeEnum(
    AuthenticationMethodOffice365Service,
  );

/** @internal */
export const AuthenticationMethodOffice365Service$outboundSchema:
  z.ZodNativeEnum<typeof AuthenticationMethodOffice365Service> =
    AuthenticationMethodOffice365Service$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodOffice365Service$ {
  /** @deprecated use `AuthenticationMethodOffice365Service$inboundSchema` instead. */
  export const inboundSchema =
    AuthenticationMethodOffice365Service$inboundSchema;
  /** @deprecated use `AuthenticationMethodOffice365Service$outboundSchema` instead. */
  export const outboundSchema =
    AuthenticationMethodOffice365Service$outboundSchema;
}

/** @internal */
export const InputOffice365Service$inboundSchema: z.ZodType<
  InputOffice365Service,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeOffice365Service$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionOffice365Service$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqOffice365Service$inboundSchema).optional(),
  planType: SubscriptionPlanOffice365Service$inboundSchema.default(
    "enterprise_gcc",
  ),
  tenantId: z.string(),
  appId: z.string(),
  timeout: z.number().default(300),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumOffice365Service$inboundSchema))
    .optional(),
  contentConfig: z.array(
    z.lazy(() => ContentConfigOffice365Service$inboundSchema),
  ).optional(),
  retryRules: z.lazy(() => RetryRulesOffice365Service$inboundSchema).optional(),
  authType: AuthenticationMethodOffice365Service$inboundSchema.default(
    "manual",
  ),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
});

/** @internal */
export type InputOffice365Service$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionOffice365Service$Outbound> | undefined;
  pq?: PqOffice365Service$Outbound | undefined;
  planType: string;
  tenantId: string;
  appId: string;
  timeout: number;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<MetadatumOffice365Service$Outbound> | undefined;
  contentConfig?: Array<ContentConfigOffice365Service$Outbound> | undefined;
  retryRules?: RetryRulesOffice365Service$Outbound | undefined;
  authType: string;
  description?: string | undefined;
  clientSecret?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputOffice365Service$outboundSchema: z.ZodType<
  InputOffice365Service$Outbound,
  z.ZodTypeDef,
  InputOffice365Service
> = z.object({
  id: z.string(),
  type: TypeOffice365Service$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionOffice365Service$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqOffice365Service$outboundSchema).optional(),
  planType: SubscriptionPlanOffice365Service$outboundSchema.default(
    "enterprise_gcc",
  ),
  tenantId: z.string(),
  appId: z.string(),
  timeout: z.number().default(300),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumOffice365Service$outboundSchema))
    .optional(),
  contentConfig: z.array(
    z.lazy(() => ContentConfigOffice365Service$outboundSchema),
  ).optional(),
  retryRules: z.lazy(() => RetryRulesOffice365Service$outboundSchema)
    .optional(),
  authType: AuthenticationMethodOffice365Service$outboundSchema.default(
    "manual",
  ),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365Service$ {
  /** @deprecated use `InputOffice365Service$inboundSchema` instead. */
  export const inboundSchema = InputOffice365Service$inboundSchema;
  /** @deprecated use `InputOffice365Service$outboundSchema` instead. */
  export const outboundSchema = InputOffice365Service$outboundSchema;
  /** @deprecated use `InputOffice365Service$Outbound` instead. */
  export type Outbound = InputOffice365Service$Outbound;
}

export function inputOffice365ServiceToJSON(
  inputOffice365Service: InputOffice365Service,
): string {
  return JSON.stringify(
    InputOffice365Service$outboundSchema.parse(inputOffice365Service),
  );
}

export function inputOffice365ServiceFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365Service, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365Service$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365Service' from JSON`,
  );
}

/** @internal */
export const TypeOffice365Mgmt$inboundSchema: z.ZodNativeEnum<
  typeof TypeOffice365Mgmt
> = z.nativeEnum(TypeOffice365Mgmt);

/** @internal */
export const TypeOffice365Mgmt$outboundSchema: z.ZodNativeEnum<
  typeof TypeOffice365Mgmt
> = TypeOffice365Mgmt$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeOffice365Mgmt$ {
  /** @deprecated use `TypeOffice365Mgmt$inboundSchema` instead. */
  export const inboundSchema = TypeOffice365Mgmt$inboundSchema;
  /** @deprecated use `TypeOffice365Mgmt$outboundSchema` instead. */
  export const outboundSchema = TypeOffice365Mgmt$outboundSchema;
}

/** @internal */
export const ConnectionOffice365Mgmt$inboundSchema: z.ZodType<
  ConnectionOffice365Mgmt,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionOffice365Mgmt$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionOffice365Mgmt$outboundSchema: z.ZodType<
  ConnectionOffice365Mgmt$Outbound,
  z.ZodTypeDef,
  ConnectionOffice365Mgmt
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionOffice365Mgmt$ {
  /** @deprecated use `ConnectionOffice365Mgmt$inboundSchema` instead. */
  export const inboundSchema = ConnectionOffice365Mgmt$inboundSchema;
  /** @deprecated use `ConnectionOffice365Mgmt$outboundSchema` instead. */
  export const outboundSchema = ConnectionOffice365Mgmt$outboundSchema;
  /** @deprecated use `ConnectionOffice365Mgmt$Outbound` instead. */
  export type Outbound = ConnectionOffice365Mgmt$Outbound;
}

export function connectionOffice365MgmtToJSON(
  connectionOffice365Mgmt: ConnectionOffice365Mgmt,
): string {
  return JSON.stringify(
    ConnectionOffice365Mgmt$outboundSchema.parse(connectionOffice365Mgmt),
  );
}

export function connectionOffice365MgmtFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionOffice365Mgmt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionOffice365Mgmt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionOffice365Mgmt' from JSON`,
  );
}

/** @internal */
export const ModeOffice365Mgmt$inboundSchema: z.ZodNativeEnum<
  typeof ModeOffice365Mgmt
> = z.nativeEnum(ModeOffice365Mgmt);

/** @internal */
export const ModeOffice365Mgmt$outboundSchema: z.ZodNativeEnum<
  typeof ModeOffice365Mgmt
> = ModeOffice365Mgmt$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeOffice365Mgmt$ {
  /** @deprecated use `ModeOffice365Mgmt$inboundSchema` instead. */
  export const inboundSchema = ModeOffice365Mgmt$inboundSchema;
  /** @deprecated use `ModeOffice365Mgmt$outboundSchema` instead. */
  export const outboundSchema = ModeOffice365Mgmt$outboundSchema;
}

/** @internal */
export const CompressionOffice365Mgmt$inboundSchema: z.ZodNativeEnum<
  typeof CompressionOffice365Mgmt
> = z.nativeEnum(CompressionOffice365Mgmt);

/** @internal */
export const CompressionOffice365Mgmt$outboundSchema: z.ZodNativeEnum<
  typeof CompressionOffice365Mgmt
> = CompressionOffice365Mgmt$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionOffice365Mgmt$ {
  /** @deprecated use `CompressionOffice365Mgmt$inboundSchema` instead. */
  export const inboundSchema = CompressionOffice365Mgmt$inboundSchema;
  /** @deprecated use `CompressionOffice365Mgmt$outboundSchema` instead. */
  export const outboundSchema = CompressionOffice365Mgmt$outboundSchema;
}

/** @internal */
export const PqOffice365Mgmt$inboundSchema: z.ZodType<
  PqOffice365Mgmt,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeOffice365Mgmt$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionOffice365Mgmt$inboundSchema.default("none"),
});

/** @internal */
export type PqOffice365Mgmt$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqOffice365Mgmt$outboundSchema: z.ZodType<
  PqOffice365Mgmt$Outbound,
  z.ZodTypeDef,
  PqOffice365Mgmt
> = z.object({
  mode: ModeOffice365Mgmt$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionOffice365Mgmt$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqOffice365Mgmt$ {
  /** @deprecated use `PqOffice365Mgmt$inboundSchema` instead. */
  export const inboundSchema = PqOffice365Mgmt$inboundSchema;
  /** @deprecated use `PqOffice365Mgmt$outboundSchema` instead. */
  export const outboundSchema = PqOffice365Mgmt$outboundSchema;
  /** @deprecated use `PqOffice365Mgmt$Outbound` instead. */
  export type Outbound = PqOffice365Mgmt$Outbound;
}

export function pqOffice365MgmtToJSON(
  pqOffice365Mgmt: PqOffice365Mgmt,
): string {
  return JSON.stringify(PqOffice365Mgmt$outboundSchema.parse(pqOffice365Mgmt));
}

export function pqOffice365MgmtFromJSON(
  jsonString: string,
): SafeParseResult<PqOffice365Mgmt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqOffice365Mgmt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqOffice365Mgmt' from JSON`,
  );
}

/** @internal */
export const SubscriptionPlanOffice365Mgmt$inboundSchema: z.ZodNativeEnum<
  typeof SubscriptionPlanOffice365Mgmt
> = z.nativeEnum(SubscriptionPlanOffice365Mgmt);

/** @internal */
export const SubscriptionPlanOffice365Mgmt$outboundSchema: z.ZodNativeEnum<
  typeof SubscriptionPlanOffice365Mgmt
> = SubscriptionPlanOffice365Mgmt$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriptionPlanOffice365Mgmt$ {
  /** @deprecated use `SubscriptionPlanOffice365Mgmt$inboundSchema` instead. */
  export const inboundSchema = SubscriptionPlanOffice365Mgmt$inboundSchema;
  /** @deprecated use `SubscriptionPlanOffice365Mgmt$outboundSchema` instead. */
  export const outboundSchema = SubscriptionPlanOffice365Mgmt$outboundSchema;
}

/** @internal */
export const MetadatumOffice365Mgmt$inboundSchema: z.ZodType<
  MetadatumOffice365Mgmt,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumOffice365Mgmt$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumOffice365Mgmt$outboundSchema: z.ZodType<
  MetadatumOffice365Mgmt$Outbound,
  z.ZodTypeDef,
  MetadatumOffice365Mgmt
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumOffice365Mgmt$ {
  /** @deprecated use `MetadatumOffice365Mgmt$inboundSchema` instead. */
  export const inboundSchema = MetadatumOffice365Mgmt$inboundSchema;
  /** @deprecated use `MetadatumOffice365Mgmt$outboundSchema` instead. */
  export const outboundSchema = MetadatumOffice365Mgmt$outboundSchema;
  /** @deprecated use `MetadatumOffice365Mgmt$Outbound` instead. */
  export type Outbound = MetadatumOffice365Mgmt$Outbound;
}

export function metadatumOffice365MgmtToJSON(
  metadatumOffice365Mgmt: MetadatumOffice365Mgmt,
): string {
  return JSON.stringify(
    MetadatumOffice365Mgmt$outboundSchema.parse(metadatumOffice365Mgmt),
  );
}

export function metadatumOffice365MgmtFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumOffice365Mgmt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumOffice365Mgmt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumOffice365Mgmt' from JSON`,
  );
}

/** @internal */
export const LogLevelOffice365Mgmt$inboundSchema: z.ZodNativeEnum<
  typeof LogLevelOffice365Mgmt
> = z.nativeEnum(LogLevelOffice365Mgmt);

/** @internal */
export const LogLevelOffice365Mgmt$outboundSchema: z.ZodNativeEnum<
  typeof LogLevelOffice365Mgmt
> = LogLevelOffice365Mgmt$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LogLevelOffice365Mgmt$ {
  /** @deprecated use `LogLevelOffice365Mgmt$inboundSchema` instead. */
  export const inboundSchema = LogLevelOffice365Mgmt$inboundSchema;
  /** @deprecated use `LogLevelOffice365Mgmt$outboundSchema` instead. */
  export const outboundSchema = LogLevelOffice365Mgmt$outboundSchema;
}

/** @internal */
export const ContentConfigOffice365Mgmt$inboundSchema: z.ZodType<
  ContentConfigOffice365Mgmt,
  z.ZodTypeDef,
  unknown
> = z.object({
  contentType: z.string().optional(),
  description: z.string().optional(),
  interval: z.number().optional(),
  logLevel: LogLevelOffice365Mgmt$inboundSchema.optional(),
  enabled: z.boolean().optional(),
});

/** @internal */
export type ContentConfigOffice365Mgmt$Outbound = {
  contentType?: string | undefined;
  description?: string | undefined;
  interval?: number | undefined;
  logLevel?: string | undefined;
  enabled?: boolean | undefined;
};

/** @internal */
export const ContentConfigOffice365Mgmt$outboundSchema: z.ZodType<
  ContentConfigOffice365Mgmt$Outbound,
  z.ZodTypeDef,
  ContentConfigOffice365Mgmt
> = z.object({
  contentType: z.string().optional(),
  description: z.string().optional(),
  interval: z.number().optional(),
  logLevel: LogLevelOffice365Mgmt$outboundSchema.optional(),
  enabled: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContentConfigOffice365Mgmt$ {
  /** @deprecated use `ContentConfigOffice365Mgmt$inboundSchema` instead. */
  export const inboundSchema = ContentConfigOffice365Mgmt$inboundSchema;
  /** @deprecated use `ContentConfigOffice365Mgmt$outboundSchema` instead. */
  export const outboundSchema = ContentConfigOffice365Mgmt$outboundSchema;
  /** @deprecated use `ContentConfigOffice365Mgmt$Outbound` instead. */
  export type Outbound = ContentConfigOffice365Mgmt$Outbound;
}

export function contentConfigOffice365MgmtToJSON(
  contentConfigOffice365Mgmt: ContentConfigOffice365Mgmt,
): string {
  return JSON.stringify(
    ContentConfigOffice365Mgmt$outboundSchema.parse(contentConfigOffice365Mgmt),
  );
}

export function contentConfigOffice365MgmtFromJSON(
  jsonString: string,
): SafeParseResult<ContentConfigOffice365Mgmt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentConfigOffice365Mgmt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentConfigOffice365Mgmt' from JSON`,
  );
}

/** @internal */
export const RetryTypeOffice365Mgmt$inboundSchema: z.ZodNativeEnum<
  typeof RetryTypeOffice365Mgmt
> = z.nativeEnum(RetryTypeOffice365Mgmt);

/** @internal */
export const RetryTypeOffice365Mgmt$outboundSchema: z.ZodNativeEnum<
  typeof RetryTypeOffice365Mgmt
> = RetryTypeOffice365Mgmt$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RetryTypeOffice365Mgmt$ {
  /** @deprecated use `RetryTypeOffice365Mgmt$inboundSchema` instead. */
  export const inboundSchema = RetryTypeOffice365Mgmt$inboundSchema;
  /** @deprecated use `RetryTypeOffice365Mgmt$outboundSchema` instead. */
  export const outboundSchema = RetryTypeOffice365Mgmt$outboundSchema;
}

/** @internal */
export const RetryRulesOffice365Mgmt$inboundSchema: z.ZodType<
  RetryRulesOffice365Mgmt,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOffice365Mgmt$inboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/** @internal */
export type RetryRulesOffice365Mgmt$Outbound = {
  type: string;
  interval: number;
  limit: number;
  multiplier: number;
  codes?: Array<number> | undefined;
  enableHeader: boolean;
  retryConnectTimeout: boolean;
  retryConnectReset: boolean;
};

/** @internal */
export const RetryRulesOffice365Mgmt$outboundSchema: z.ZodType<
  RetryRulesOffice365Mgmt$Outbound,
  z.ZodTypeDef,
  RetryRulesOffice365Mgmt
> = z.object({
  type: RetryTypeOffice365Mgmt$outboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RetryRulesOffice365Mgmt$ {
  /** @deprecated use `RetryRulesOffice365Mgmt$inboundSchema` instead. */
  export const inboundSchema = RetryRulesOffice365Mgmt$inboundSchema;
  /** @deprecated use `RetryRulesOffice365Mgmt$outboundSchema` instead. */
  export const outboundSchema = RetryRulesOffice365Mgmt$outboundSchema;
  /** @deprecated use `RetryRulesOffice365Mgmt$Outbound` instead. */
  export type Outbound = RetryRulesOffice365Mgmt$Outbound;
}

export function retryRulesOffice365MgmtToJSON(
  retryRulesOffice365Mgmt: RetryRulesOffice365Mgmt,
): string {
  return JSON.stringify(
    RetryRulesOffice365Mgmt$outboundSchema.parse(retryRulesOffice365Mgmt),
  );
}

export function retryRulesOffice365MgmtFromJSON(
  jsonString: string,
): SafeParseResult<RetryRulesOffice365Mgmt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetryRulesOffice365Mgmt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetryRulesOffice365Mgmt' from JSON`,
  );
}

/** @internal */
export const AuthenticationMethodOffice365Mgmt$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodOffice365Mgmt
> = z.nativeEnum(AuthenticationMethodOffice365Mgmt);

/** @internal */
export const AuthenticationMethodOffice365Mgmt$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodOffice365Mgmt
> = AuthenticationMethodOffice365Mgmt$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodOffice365Mgmt$ {
  /** @deprecated use `AuthenticationMethodOffice365Mgmt$inboundSchema` instead. */
  export const inboundSchema = AuthenticationMethodOffice365Mgmt$inboundSchema;
  /** @deprecated use `AuthenticationMethodOffice365Mgmt$outboundSchema` instead. */
  export const outboundSchema =
    AuthenticationMethodOffice365Mgmt$outboundSchema;
}

/** @internal */
export const InputOffice365Mgmt$inboundSchema: z.ZodType<
  InputOffice365Mgmt,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeOffice365Mgmt$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionOffice365Mgmt$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqOffice365Mgmt$inboundSchema).optional(),
  planType: SubscriptionPlanOffice365Mgmt$inboundSchema.default(
    "enterprise_gcc",
  ),
  tenantId: z.string(),
  appId: z.string(),
  timeout: z.number().default(300),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumOffice365Mgmt$inboundSchema))
    .optional(),
  publisherIdentifier: z.string().optional(),
  contentConfig: z.array(z.lazy(() => ContentConfigOffice365Mgmt$inboundSchema))
    .optional(),
  ingestionLag: z.number().default(0),
  retryRules: z.lazy(() => RetryRulesOffice365Mgmt$inboundSchema).optional(),
  authType: AuthenticationMethodOffice365Mgmt$inboundSchema.default("manual"),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
});

/** @internal */
export type InputOffice365Mgmt$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionOffice365Mgmt$Outbound> | undefined;
  pq?: PqOffice365Mgmt$Outbound | undefined;
  planType: string;
  tenantId: string;
  appId: string;
  timeout: number;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<MetadatumOffice365Mgmt$Outbound> | undefined;
  publisherIdentifier?: string | undefined;
  contentConfig?: Array<ContentConfigOffice365Mgmt$Outbound> | undefined;
  ingestionLag: number;
  retryRules?: RetryRulesOffice365Mgmt$Outbound | undefined;
  authType: string;
  description?: string | undefined;
  clientSecret?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputOffice365Mgmt$outboundSchema: z.ZodType<
  InputOffice365Mgmt$Outbound,
  z.ZodTypeDef,
  InputOffice365Mgmt
> = z.object({
  id: z.string(),
  type: TypeOffice365Mgmt$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionOffice365Mgmt$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqOffice365Mgmt$outboundSchema).optional(),
  planType: SubscriptionPlanOffice365Mgmt$outboundSchema.default(
    "enterprise_gcc",
  ),
  tenantId: z.string(),
  appId: z.string(),
  timeout: z.number().default(300),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumOffice365Mgmt$outboundSchema))
    .optional(),
  publisherIdentifier: z.string().optional(),
  contentConfig: z.array(
    z.lazy(() => ContentConfigOffice365Mgmt$outboundSchema),
  ).optional(),
  ingestionLag: z.number().default(0),
  retryRules: z.lazy(() => RetryRulesOffice365Mgmt$outboundSchema).optional(),
  authType: AuthenticationMethodOffice365Mgmt$outboundSchema.default("manual"),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365Mgmt$ {
  /** @deprecated use `InputOffice365Mgmt$inboundSchema` instead. */
  export const inboundSchema = InputOffice365Mgmt$inboundSchema;
  /** @deprecated use `InputOffice365Mgmt$outboundSchema` instead. */
  export const outboundSchema = InputOffice365Mgmt$outboundSchema;
  /** @deprecated use `InputOffice365Mgmt$Outbound` instead. */
  export type Outbound = InputOffice365Mgmt$Outbound;
}

export function inputOffice365MgmtToJSON(
  inputOffice365Mgmt: InputOffice365Mgmt,
): string {
  return JSON.stringify(
    InputOffice365Mgmt$outboundSchema.parse(inputOffice365Mgmt),
  );
}

export function inputOffice365MgmtFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365Mgmt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365Mgmt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365Mgmt' from JSON`,
  );
}

/** @internal */
export const TypeEdgePrometheus$inboundSchema: z.ZodNativeEnum<
  typeof TypeEdgePrometheus
> = z.nativeEnum(TypeEdgePrometheus);

/** @internal */
export const TypeEdgePrometheus$outboundSchema: z.ZodNativeEnum<
  typeof TypeEdgePrometheus
> = TypeEdgePrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeEdgePrometheus$ {
  /** @deprecated use `TypeEdgePrometheus$inboundSchema` instead. */
  export const inboundSchema = TypeEdgePrometheus$inboundSchema;
  /** @deprecated use `TypeEdgePrometheus$outboundSchema` instead. */
  export const outboundSchema = TypeEdgePrometheus$outboundSchema;
}

/** @internal */
export const ConnectionEdgePrometheus$inboundSchema: z.ZodType<
  ConnectionEdgePrometheus,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionEdgePrometheus$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionEdgePrometheus$outboundSchema: z.ZodType<
  ConnectionEdgePrometheus$Outbound,
  z.ZodTypeDef,
  ConnectionEdgePrometheus
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionEdgePrometheus$ {
  /** @deprecated use `ConnectionEdgePrometheus$inboundSchema` instead. */
  export const inboundSchema = ConnectionEdgePrometheus$inboundSchema;
  /** @deprecated use `ConnectionEdgePrometheus$outboundSchema` instead. */
  export const outboundSchema = ConnectionEdgePrometheus$outboundSchema;
  /** @deprecated use `ConnectionEdgePrometheus$Outbound` instead. */
  export type Outbound = ConnectionEdgePrometheus$Outbound;
}

export function connectionEdgePrometheusToJSON(
  connectionEdgePrometheus: ConnectionEdgePrometheus,
): string {
  return JSON.stringify(
    ConnectionEdgePrometheus$outboundSchema.parse(connectionEdgePrometheus),
  );
}

export function connectionEdgePrometheusFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionEdgePrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionEdgePrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionEdgePrometheus' from JSON`,
  );
}

/** @internal */
export const ModeEdgePrometheus$inboundSchema: z.ZodNativeEnum<
  typeof ModeEdgePrometheus
> = z.nativeEnum(ModeEdgePrometheus);

/** @internal */
export const ModeEdgePrometheus$outboundSchema: z.ZodNativeEnum<
  typeof ModeEdgePrometheus
> = ModeEdgePrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeEdgePrometheus$ {
  /** @deprecated use `ModeEdgePrometheus$inboundSchema` instead. */
  export const inboundSchema = ModeEdgePrometheus$inboundSchema;
  /** @deprecated use `ModeEdgePrometheus$outboundSchema` instead. */
  export const outboundSchema = ModeEdgePrometheus$outboundSchema;
}

/** @internal */
export const PqCompressionEdgePrometheus$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressionEdgePrometheus
> = z.nativeEnum(PqCompressionEdgePrometheus);

/** @internal */
export const PqCompressionEdgePrometheus$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressionEdgePrometheus
> = PqCompressionEdgePrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressionEdgePrometheus$ {
  /** @deprecated use `PqCompressionEdgePrometheus$inboundSchema` instead. */
  export const inboundSchema = PqCompressionEdgePrometheus$inboundSchema;
  /** @deprecated use `PqCompressionEdgePrometheus$outboundSchema` instead. */
  export const outboundSchema = PqCompressionEdgePrometheus$outboundSchema;
}

/** @internal */
export const PqEdgePrometheus$inboundSchema: z.ZodType<
  PqEdgePrometheus,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeEdgePrometheus$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: PqCompressionEdgePrometheus$inboundSchema.default("none"),
});

/** @internal */
export type PqEdgePrometheus$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqEdgePrometheus$outboundSchema: z.ZodType<
  PqEdgePrometheus$Outbound,
  z.ZodTypeDef,
  PqEdgePrometheus
> = z.object({
  mode: ModeEdgePrometheus$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: PqCompressionEdgePrometheus$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqEdgePrometheus$ {
  /** @deprecated use `PqEdgePrometheus$inboundSchema` instead. */
  export const inboundSchema = PqEdgePrometheus$inboundSchema;
  /** @deprecated use `PqEdgePrometheus$outboundSchema` instead. */
  export const outboundSchema = PqEdgePrometheus$outboundSchema;
  /** @deprecated use `PqEdgePrometheus$Outbound` instead. */
  export type Outbound = PqEdgePrometheus$Outbound;
}

export function pqEdgePrometheusToJSON(
  pqEdgePrometheus: PqEdgePrometheus,
): string {
  return JSON.stringify(
    PqEdgePrometheus$outboundSchema.parse(pqEdgePrometheus),
  );
}

export function pqEdgePrometheusFromJSON(
  jsonString: string,
): SafeParseResult<PqEdgePrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqEdgePrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqEdgePrometheus' from JSON`,
  );
}

/** @internal */
export const DiscoveryTypeEdgePrometheus$inboundSchema: z.ZodNativeEnum<
  typeof DiscoveryTypeEdgePrometheus
> = z.nativeEnum(DiscoveryTypeEdgePrometheus);

/** @internal */
export const DiscoveryTypeEdgePrometheus$outboundSchema: z.ZodNativeEnum<
  typeof DiscoveryTypeEdgePrometheus
> = DiscoveryTypeEdgePrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DiscoveryTypeEdgePrometheus$ {
  /** @deprecated use `DiscoveryTypeEdgePrometheus$inboundSchema` instead. */
  export const inboundSchema = DiscoveryTypeEdgePrometheus$inboundSchema;
  /** @deprecated use `DiscoveryTypeEdgePrometheus$outboundSchema` instead. */
  export const outboundSchema = DiscoveryTypeEdgePrometheus$outboundSchema;
}

/** @internal */
export const PersistenceCompression$inboundSchema: z.ZodNativeEnum<
  typeof PersistenceCompression
> = z.nativeEnum(PersistenceCompression);

/** @internal */
export const PersistenceCompression$outboundSchema: z.ZodNativeEnum<
  typeof PersistenceCompression
> = PersistenceCompression$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PersistenceCompression$ {
  /** @deprecated use `PersistenceCompression$inboundSchema` instead. */
  export const inboundSchema = PersistenceCompression$inboundSchema;
  /** @deprecated use `PersistenceCompression$outboundSchema` instead. */
  export const outboundSchema = PersistenceCompression$outboundSchema;
}

/** @internal */
export const DiskSpooling$inboundSchema: z.ZodType<
  DiskSpooling,
  z.ZodTypeDef,
  unknown
> = z.object({
  enable: z.boolean().default(false),
  timeWindow: z.string().default("10m"),
  maxDataSize: z.string().default("1GB"),
  maxDataTime: z.string().default("24h"),
  compress: PersistenceCompression$inboundSchema.default("gzip"),
});

/** @internal */
export type DiskSpooling$Outbound = {
  enable: boolean;
  timeWindow: string;
  maxDataSize: string;
  maxDataTime: string;
  compress: string;
};

/** @internal */
export const DiskSpooling$outboundSchema: z.ZodType<
  DiskSpooling$Outbound,
  z.ZodTypeDef,
  DiskSpooling
> = z.object({
  enable: z.boolean().default(false),
  timeWindow: z.string().default("10m"),
  maxDataSize: z.string().default("1GB"),
  maxDataTime: z.string().default("24h"),
  compress: PersistenceCompression$outboundSchema.default("gzip"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DiskSpooling$ {
  /** @deprecated use `DiskSpooling$inboundSchema` instead. */
  export const inboundSchema = DiskSpooling$inboundSchema;
  /** @deprecated use `DiskSpooling$outboundSchema` instead. */
  export const outboundSchema = DiskSpooling$outboundSchema;
  /** @deprecated use `DiskSpooling$Outbound` instead. */
  export type Outbound = DiskSpooling$Outbound;
}

export function diskSpoolingToJSON(diskSpooling: DiskSpooling): string {
  return JSON.stringify(DiskSpooling$outboundSchema.parse(diskSpooling));
}

export function diskSpoolingFromJSON(
  jsonString: string,
): SafeParseResult<DiskSpooling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DiskSpooling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DiskSpooling' from JSON`,
  );
}

/** @internal */
export const MetadatumEdgePrometheus$inboundSchema: z.ZodType<
  MetadatumEdgePrometheus,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumEdgePrometheus$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumEdgePrometheus$outboundSchema: z.ZodType<
  MetadatumEdgePrometheus$Outbound,
  z.ZodTypeDef,
  MetadatumEdgePrometheus
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumEdgePrometheus$ {
  /** @deprecated use `MetadatumEdgePrometheus$inboundSchema` instead. */
  export const inboundSchema = MetadatumEdgePrometheus$inboundSchema;
  /** @deprecated use `MetadatumEdgePrometheus$outboundSchema` instead. */
  export const outboundSchema = MetadatumEdgePrometheus$outboundSchema;
  /** @deprecated use `MetadatumEdgePrometheus$Outbound` instead. */
  export type Outbound = MetadatumEdgePrometheus$Outbound;
}

export function metadatumEdgePrometheusToJSON(
  metadatumEdgePrometheus: MetadatumEdgePrometheus,
): string {
  return JSON.stringify(
    MetadatumEdgePrometheus$outboundSchema.parse(metadatumEdgePrometheus),
  );
}

export function metadatumEdgePrometheusFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumEdgePrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumEdgePrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumEdgePrometheus' from JSON`,
  );
}

/** @internal */
export const AuthTypeAuthenticationMethodEdgePrometheus$inboundSchema:
  z.ZodNativeEnum<typeof AuthTypeAuthenticationMethodEdgePrometheus> = z
    .nativeEnum(AuthTypeAuthenticationMethodEdgePrometheus);

/** @internal */
export const AuthTypeAuthenticationMethodEdgePrometheus$outboundSchema:
  z.ZodNativeEnum<typeof AuthTypeAuthenticationMethodEdgePrometheus> =
    AuthTypeAuthenticationMethodEdgePrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTypeAuthenticationMethodEdgePrometheus$ {
  /** @deprecated use `AuthTypeAuthenticationMethodEdgePrometheus$inboundSchema` instead. */
  export const inboundSchema =
    AuthTypeAuthenticationMethodEdgePrometheus$inboundSchema;
  /** @deprecated use `AuthTypeAuthenticationMethodEdgePrometheus$outboundSchema` instead. */
  export const outboundSchema =
    AuthTypeAuthenticationMethodEdgePrometheus$outboundSchema;
}

/** @internal */
export const TargetProtocol$inboundSchema: z.ZodNativeEnum<
  typeof TargetProtocol
> = z.nativeEnum(TargetProtocol);

/** @internal */
export const TargetProtocol$outboundSchema: z.ZodNativeEnum<
  typeof TargetProtocol
> = TargetProtocol$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TargetProtocol$ {
  /** @deprecated use `TargetProtocol$inboundSchema` instead. */
  export const inboundSchema = TargetProtocol$inboundSchema;
  /** @deprecated use `TargetProtocol$outboundSchema` instead. */
  export const outboundSchema = TargetProtocol$outboundSchema;
}

/** @internal */
export const Target$inboundSchema: z.ZodType<Target, z.ZodTypeDef, unknown> = z
  .object({
    protocol: TargetProtocol$inboundSchema.default("http"),
    host: z.string(),
    port: z.number().default(9090),
    path: z.string().default("/metrics"),
  });

/** @internal */
export type Target$Outbound = {
  protocol: string;
  host: string;
  port: number;
  path: string;
};

/** @internal */
export const Target$outboundSchema: z.ZodType<
  Target$Outbound,
  z.ZodTypeDef,
  Target
> = z.object({
  protocol: TargetProtocol$outboundSchema.default("http"),
  host: z.string(),
  port: z.number().default(9090),
  path: z.string().default("/metrics"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Target$ {
  /** @deprecated use `Target$inboundSchema` instead. */
  export const inboundSchema = Target$inboundSchema;
  /** @deprecated use `Target$outboundSchema` instead. */
  export const outboundSchema = Target$outboundSchema;
  /** @deprecated use `Target$Outbound` instead. */
  export type Outbound = Target$Outbound;
}

export function targetToJSON(target: Target): string {
  return JSON.stringify(Target$outboundSchema.parse(target));
}

export function targetFromJSON(
  jsonString: string,
): SafeParseResult<Target, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Target$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Target' from JSON`,
  );
}

/** @internal */
export const RecordTypeEdgePrometheus$inboundSchema: z.ZodNativeEnum<
  typeof RecordTypeEdgePrometheus
> = z.nativeEnum(RecordTypeEdgePrometheus);

/** @internal */
export const RecordTypeEdgePrometheus$outboundSchema: z.ZodNativeEnum<
  typeof RecordTypeEdgePrometheus
> = RecordTypeEdgePrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RecordTypeEdgePrometheus$ {
  /** @deprecated use `RecordTypeEdgePrometheus$inboundSchema` instead. */
  export const inboundSchema = RecordTypeEdgePrometheus$inboundSchema;
  /** @deprecated use `RecordTypeEdgePrometheus$outboundSchema` instead. */
  export const outboundSchema = RecordTypeEdgePrometheus$outboundSchema;
}

/** @internal */
export const ScrapeProtocolProtocol$inboundSchema: z.ZodNativeEnum<
  typeof ScrapeProtocolProtocol
> = z.nativeEnum(ScrapeProtocolProtocol);

/** @internal */
export const ScrapeProtocolProtocol$outboundSchema: z.ZodNativeEnum<
  typeof ScrapeProtocolProtocol
> = ScrapeProtocolProtocol$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ScrapeProtocolProtocol$ {
  /** @deprecated use `ScrapeProtocolProtocol$inboundSchema` instead. */
  export const inboundSchema = ScrapeProtocolProtocol$inboundSchema;
  /** @deprecated use `ScrapeProtocolProtocol$outboundSchema` instead. */
  export const outboundSchema = ScrapeProtocolProtocol$outboundSchema;
}

/** @internal */
export const SearchFilterEdgePrometheus$inboundSchema: z.ZodType<
  SearchFilterEdgePrometheus,
  z.ZodTypeDef,
  unknown
> = z.object({
  Name: z.string(),
  Values: z.array(z.string()),
}).transform((v) => {
  return remap$(v, {
    "Name": "name",
    "Values": "values",
  });
});

/** @internal */
export type SearchFilterEdgePrometheus$Outbound = {
  Name: string;
  Values: Array<string>;
};

/** @internal */
export const SearchFilterEdgePrometheus$outboundSchema: z.ZodType<
  SearchFilterEdgePrometheus$Outbound,
  z.ZodTypeDef,
  SearchFilterEdgePrometheus
> = z.object({
  name: z.string(),
  values: z.array(z.string()),
}).transform((v) => {
  return remap$(v, {
    name: "Name",
    values: "Values",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchFilterEdgePrometheus$ {
  /** @deprecated use `SearchFilterEdgePrometheus$inboundSchema` instead. */
  export const inboundSchema = SearchFilterEdgePrometheus$inboundSchema;
  /** @deprecated use `SearchFilterEdgePrometheus$outboundSchema` instead. */
  export const outboundSchema = SearchFilterEdgePrometheus$outboundSchema;
  /** @deprecated use `SearchFilterEdgePrometheus$Outbound` instead. */
  export type Outbound = SearchFilterEdgePrometheus$Outbound;
}

export function searchFilterEdgePrometheusToJSON(
  searchFilterEdgePrometheus: SearchFilterEdgePrometheus,
): string {
  return JSON.stringify(
    SearchFilterEdgePrometheus$outboundSchema.parse(searchFilterEdgePrometheus),
  );
}

export function searchFilterEdgePrometheusFromJSON(
  jsonString: string,
): SafeParseResult<SearchFilterEdgePrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchFilterEdgePrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchFilterEdgePrometheus' from JSON`,
  );
}

/** @internal */
export const AwsAuthenticationMethodAuthenticationMethodEdgePrometheus$inboundSchema:
  z.ZodNativeEnum<
    typeof AwsAuthenticationMethodAuthenticationMethodEdgePrometheus
  > = z.nativeEnum(AwsAuthenticationMethodAuthenticationMethodEdgePrometheus);

/** @internal */
export const AwsAuthenticationMethodAuthenticationMethodEdgePrometheus$outboundSchema:
  z.ZodNativeEnum<
    typeof AwsAuthenticationMethodAuthenticationMethodEdgePrometheus
  > = AwsAuthenticationMethodAuthenticationMethodEdgePrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AwsAuthenticationMethodAuthenticationMethodEdgePrometheus$ {
  /** @deprecated use `AwsAuthenticationMethodAuthenticationMethodEdgePrometheus$inboundSchema` instead. */
  export const inboundSchema =
    AwsAuthenticationMethodAuthenticationMethodEdgePrometheus$inboundSchema;
  /** @deprecated use `AwsAuthenticationMethodAuthenticationMethodEdgePrometheus$outboundSchema` instead. */
  export const outboundSchema =
    AwsAuthenticationMethodAuthenticationMethodEdgePrometheus$outboundSchema;
}

/** @internal */
export const SignatureVersionEdgePrometheus$inboundSchema: z.ZodNativeEnum<
  typeof SignatureVersionEdgePrometheus
> = z.nativeEnum(SignatureVersionEdgePrometheus);

/** @internal */
export const SignatureVersionEdgePrometheus$outboundSchema: z.ZodNativeEnum<
  typeof SignatureVersionEdgePrometheus
> = SignatureVersionEdgePrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignatureVersionEdgePrometheus$ {
  /** @deprecated use `SignatureVersionEdgePrometheus$inboundSchema` instead. */
  export const inboundSchema = SignatureVersionEdgePrometheus$inboundSchema;
  /** @deprecated use `SignatureVersionEdgePrometheus$outboundSchema` instead. */
  export const outboundSchema = SignatureVersionEdgePrometheus$outboundSchema;
}

/** @internal */
export const PodFilter$inboundSchema: z.ZodType<
  PodFilter,
  z.ZodTypeDef,
  unknown
> = z.object({
  filter: z.string(),
  description: z.string().optional(),
});

/** @internal */
export type PodFilter$Outbound = {
  filter: string;
  description?: string | undefined;
};

/** @internal */
export const PodFilter$outboundSchema: z.ZodType<
  PodFilter$Outbound,
  z.ZodTypeDef,
  PodFilter
> = z.object({
  filter: z.string(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PodFilter$ {
  /** @deprecated use `PodFilter$inboundSchema` instead. */
  export const inboundSchema = PodFilter$inboundSchema;
  /** @deprecated use `PodFilter$outboundSchema` instead. */
  export const outboundSchema = PodFilter$outboundSchema;
  /** @deprecated use `PodFilter$Outbound` instead. */
  export type Outbound = PodFilter$Outbound;
}

export function podFilterToJSON(podFilter: PodFilter): string {
  return JSON.stringify(PodFilter$outboundSchema.parse(podFilter));
}

export function podFilterFromJSON(
  jsonString: string,
): SafeParseResult<PodFilter, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PodFilter$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PodFilter' from JSON`,
  );
}

/** @internal */
export const InputEdgePrometheus$inboundSchema: z.ZodType<
  InputEdgePrometheus,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeEdgePrometheus$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionEdgePrometheus$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqEdgePrometheus$inboundSchema).optional(),
  dimensionList: z.array(z.string()).optional(),
  discoveryType: DiscoveryTypeEdgePrometheus$inboundSchema.default("static"),
  interval: z.number().default(15),
  timeout: z.number().default(5000),
  persistence: z.lazy(() => DiskSpooling$inboundSchema).optional(),
  metadata: z.array(z.lazy(() => MetadatumEdgePrometheus$inboundSchema))
    .optional(),
  authType: AuthTypeAuthenticationMethodEdgePrometheus$inboundSchema.default(
    "manual",
  ),
  description: z.string().optional(),
  targets: z.array(z.lazy(() => Target$inboundSchema)).optional(),
  nameList: z.array(z.string()).optional(),
  recordType: RecordTypeEdgePrometheus$inboundSchema.default("SRV"),
  scrapeProtocol: ScrapeProtocolProtocol$inboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  usePublicIp: z.boolean().default(true),
  scrapePort: z.number().default(9090),
  searchFilter: z.array(z.lazy(() => SearchFilterEdgePrometheus$inboundSchema))
    .optional(),
  awsAuthenticationMethod:
    AwsAuthenticationMethodAuthenticationMethodEdgePrometheus$inboundSchema
      .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionEdgePrometheus$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  scrapeProtocolExpr: z.string().default(
    "metadata.annotations['prometheus.io/scheme'] || 'http'",
  ),
  scrapePortExpr: z.string().default(
    "metadata.annotations['prometheus.io/port'] || 9090",
  ),
  scrapePathExpr: z.string().default(
    "metadata.annotations['prometheus.io/path'] || '/metrics'",
  ),
  podFilter: z.array(z.lazy(() => PodFilter$inboundSchema)).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});

/** @internal */
export type InputEdgePrometheus$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionEdgePrometheus$Outbound> | undefined;
  pq?: PqEdgePrometheus$Outbound | undefined;
  dimensionList?: Array<string> | undefined;
  discoveryType: string;
  interval: number;
  timeout: number;
  persistence?: DiskSpooling$Outbound | undefined;
  metadata?: Array<MetadatumEdgePrometheus$Outbound> | undefined;
  authType: string;
  description?: string | undefined;
  targets?: Array<Target$Outbound> | undefined;
  nameList?: Array<string> | undefined;
  recordType: string;
  scrapeProtocol: string;
  scrapePath: string;
  usePublicIp: boolean;
  scrapePort: number;
  searchFilter?: Array<SearchFilterEdgePrometheus$Outbound> | undefined;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  scrapeProtocolExpr: string;
  scrapePortExpr: string;
  scrapePathExpr: string;
  podFilter?: Array<PodFilter$Outbound> | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputEdgePrometheus$outboundSchema: z.ZodType<
  InputEdgePrometheus$Outbound,
  z.ZodTypeDef,
  InputEdgePrometheus
> = z.object({
  id: z.string(),
  type: TypeEdgePrometheus$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionEdgePrometheus$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqEdgePrometheus$outboundSchema).optional(),
  dimensionList: z.array(z.string()).optional(),
  discoveryType: DiscoveryTypeEdgePrometheus$outboundSchema.default("static"),
  interval: z.number().default(15),
  timeout: z.number().default(5000),
  persistence: z.lazy(() => DiskSpooling$outboundSchema).optional(),
  metadata: z.array(z.lazy(() => MetadatumEdgePrometheus$outboundSchema))
    .optional(),
  authType: AuthTypeAuthenticationMethodEdgePrometheus$outboundSchema.default(
    "manual",
  ),
  description: z.string().optional(),
  targets: z.array(z.lazy(() => Target$outboundSchema)).optional(),
  nameList: z.array(z.string()).optional(),
  recordType: RecordTypeEdgePrometheus$outboundSchema.default("SRV"),
  scrapeProtocol: ScrapeProtocolProtocol$outboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  usePublicIp: z.boolean().default(true),
  scrapePort: z.number().default(9090),
  searchFilter: z.array(z.lazy(() => SearchFilterEdgePrometheus$outboundSchema))
    .optional(),
  awsAuthenticationMethod:
    AwsAuthenticationMethodAuthenticationMethodEdgePrometheus$outboundSchema
      .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionEdgePrometheus$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  scrapeProtocolExpr: z.string().default(
    "metadata.annotations['prometheus.io/scheme'] || 'http'",
  ),
  scrapePortExpr: z.string().default(
    "metadata.annotations['prometheus.io/port'] || 9090",
  ),
  scrapePathExpr: z.string().default(
    "metadata.annotations['prometheus.io/path'] || '/metrics'",
  ),
  podFilter: z.array(z.lazy(() => PodFilter$outboundSchema)).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEdgePrometheus$ {
  /** @deprecated use `InputEdgePrometheus$inboundSchema` instead. */
  export const inboundSchema = InputEdgePrometheus$inboundSchema;
  /** @deprecated use `InputEdgePrometheus$outboundSchema` instead. */
  export const outboundSchema = InputEdgePrometheus$outboundSchema;
  /** @deprecated use `InputEdgePrometheus$Outbound` instead. */
  export type Outbound = InputEdgePrometheus$Outbound;
}

export function inputEdgePrometheusToJSON(
  inputEdgePrometheus: InputEdgePrometheus,
): string {
  return JSON.stringify(
    InputEdgePrometheus$outboundSchema.parse(inputEdgePrometheus),
  );
}

export function inputEdgePrometheusFromJSON(
  jsonString: string,
): SafeParseResult<InputEdgePrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputEdgePrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputEdgePrometheus' from JSON`,
  );
}

/** @internal */
export const CreateInputTypePrometheus$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypePrometheus
> = z.nativeEnum(CreateInputTypePrometheus);

/** @internal */
export const CreateInputTypePrometheus$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypePrometheus
> = CreateInputTypePrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputTypePrometheus$ {
  /** @deprecated use `CreateInputTypePrometheus$inboundSchema` instead. */
  export const inboundSchema = CreateInputTypePrometheus$inboundSchema;
  /** @deprecated use `CreateInputTypePrometheus$outboundSchema` instead. */
  export const outboundSchema = CreateInputTypePrometheus$outboundSchema;
}

/** @internal */
export const ConnectionPrometheus$inboundSchema: z.ZodType<
  ConnectionPrometheus,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionPrometheus$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionPrometheus$outboundSchema: z.ZodType<
  ConnectionPrometheus$Outbound,
  z.ZodTypeDef,
  ConnectionPrometheus
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionPrometheus$ {
  /** @deprecated use `ConnectionPrometheus$inboundSchema` instead. */
  export const inboundSchema = ConnectionPrometheus$inboundSchema;
  /** @deprecated use `ConnectionPrometheus$outboundSchema` instead. */
  export const outboundSchema = ConnectionPrometheus$outboundSchema;
  /** @deprecated use `ConnectionPrometheus$Outbound` instead. */
  export type Outbound = ConnectionPrometheus$Outbound;
}

export function connectionPrometheusToJSON(
  connectionPrometheus: ConnectionPrometheus,
): string {
  return JSON.stringify(
    ConnectionPrometheus$outboundSchema.parse(connectionPrometheus),
  );
}

export function connectionPrometheusFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionPrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionPrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionPrometheus' from JSON`,
  );
}

/** @internal */
export const CreateInputModePrometheus$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputModePrometheus
> = z.nativeEnum(CreateInputModePrometheus);

/** @internal */
export const CreateInputModePrometheus$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputModePrometheus
> = CreateInputModePrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputModePrometheus$ {
  /** @deprecated use `CreateInputModePrometheus$inboundSchema` instead. */
  export const inboundSchema = CreateInputModePrometheus$inboundSchema;
  /** @deprecated use `CreateInputModePrometheus$outboundSchema` instead. */
  export const outboundSchema = CreateInputModePrometheus$outboundSchema;
}

/** @internal */
export const PqCompressionPrometheus$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressionPrometheus
> = z.nativeEnum(PqCompressionPrometheus);

/** @internal */
export const PqCompressionPrometheus$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressionPrometheus
> = PqCompressionPrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressionPrometheus$ {
  /** @deprecated use `PqCompressionPrometheus$inboundSchema` instead. */
  export const inboundSchema = PqCompressionPrometheus$inboundSchema;
  /** @deprecated use `PqCompressionPrometheus$outboundSchema` instead. */
  export const outboundSchema = PqCompressionPrometheus$outboundSchema;
}

/** @internal */
export const PqPrometheus$inboundSchema: z.ZodType<
  PqPrometheus,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: CreateInputModePrometheus$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: PqCompressionPrometheus$inboundSchema.default("none"),
});

/** @internal */
export type PqPrometheus$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqPrometheus$outboundSchema: z.ZodType<
  PqPrometheus$Outbound,
  z.ZodTypeDef,
  PqPrometheus
> = z.object({
  mode: CreateInputModePrometheus$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: PqCompressionPrometheus$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqPrometheus$ {
  /** @deprecated use `PqPrometheus$inboundSchema` instead. */
  export const inboundSchema = PqPrometheus$inboundSchema;
  /** @deprecated use `PqPrometheus$outboundSchema` instead. */
  export const outboundSchema = PqPrometheus$outboundSchema;
  /** @deprecated use `PqPrometheus$Outbound` instead. */
  export type Outbound = PqPrometheus$Outbound;
}

export function pqPrometheusToJSON(pqPrometheus: PqPrometheus): string {
  return JSON.stringify(PqPrometheus$outboundSchema.parse(pqPrometheus));
}

export function pqPrometheusFromJSON(
  jsonString: string,
): SafeParseResult<PqPrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqPrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqPrometheus' from JSON`,
  );
}

/** @internal */
export const DiscoveryTypePrometheus$inboundSchema: z.ZodNativeEnum<
  typeof DiscoveryTypePrometheus
> = z.nativeEnum(DiscoveryTypePrometheus);

/** @internal */
export const DiscoveryTypePrometheus$outboundSchema: z.ZodNativeEnum<
  typeof DiscoveryTypePrometheus
> = DiscoveryTypePrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DiscoveryTypePrometheus$ {
  /** @deprecated use `DiscoveryTypePrometheus$inboundSchema` instead. */
  export const inboundSchema = DiscoveryTypePrometheus$inboundSchema;
  /** @deprecated use `DiscoveryTypePrometheus$outboundSchema` instead. */
  export const outboundSchema = DiscoveryTypePrometheus$outboundSchema;
}

/** @internal */
export const LogLevelPrometheus$inboundSchema: z.ZodNativeEnum<
  typeof LogLevelPrometheus
> = z.nativeEnum(LogLevelPrometheus);

/** @internal */
export const LogLevelPrometheus$outboundSchema: z.ZodNativeEnum<
  typeof LogLevelPrometheus
> = LogLevelPrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LogLevelPrometheus$ {
  /** @deprecated use `LogLevelPrometheus$inboundSchema` instead. */
  export const inboundSchema = LogLevelPrometheus$inboundSchema;
  /** @deprecated use `LogLevelPrometheus$outboundSchema` instead. */
  export const outboundSchema = LogLevelPrometheus$outboundSchema;
}

/** @internal */
export const MetadatumPrometheus$inboundSchema: z.ZodType<
  MetadatumPrometheus,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumPrometheus$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumPrometheus$outboundSchema: z.ZodType<
  MetadatumPrometheus$Outbound,
  z.ZodTypeDef,
  MetadatumPrometheus
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumPrometheus$ {
  /** @deprecated use `MetadatumPrometheus$inboundSchema` instead. */
  export const inboundSchema = MetadatumPrometheus$inboundSchema;
  /** @deprecated use `MetadatumPrometheus$outboundSchema` instead. */
  export const outboundSchema = MetadatumPrometheus$outboundSchema;
  /** @deprecated use `MetadatumPrometheus$Outbound` instead. */
  export type Outbound = MetadatumPrometheus$Outbound;
}

export function metadatumPrometheusToJSON(
  metadatumPrometheus: MetadatumPrometheus,
): string {
  return JSON.stringify(
    MetadatumPrometheus$outboundSchema.parse(metadatumPrometheus),
  );
}

export function metadatumPrometheusFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumPrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumPrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumPrometheus' from JSON`,
  );
}

/** @internal */
export const AuthTypeAuthenticationMethodPrometheus$inboundSchema:
  z.ZodNativeEnum<typeof AuthTypeAuthenticationMethodPrometheus> = z.nativeEnum(
    AuthTypeAuthenticationMethodPrometheus,
  );

/** @internal */
export const AuthTypeAuthenticationMethodPrometheus$outboundSchema:
  z.ZodNativeEnum<typeof AuthTypeAuthenticationMethodPrometheus> =
    AuthTypeAuthenticationMethodPrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTypeAuthenticationMethodPrometheus$ {
  /** @deprecated use `AuthTypeAuthenticationMethodPrometheus$inboundSchema` instead. */
  export const inboundSchema =
    AuthTypeAuthenticationMethodPrometheus$inboundSchema;
  /** @deprecated use `AuthTypeAuthenticationMethodPrometheus$outboundSchema` instead. */
  export const outboundSchema =
    AuthTypeAuthenticationMethodPrometheus$outboundSchema;
}

/** @internal */
export const RecordTypePrometheus$inboundSchema: z.ZodNativeEnum<
  typeof RecordTypePrometheus
> = z.nativeEnum(RecordTypePrometheus);

/** @internal */
export const RecordTypePrometheus$outboundSchema: z.ZodNativeEnum<
  typeof RecordTypePrometheus
> = RecordTypePrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RecordTypePrometheus$ {
  /** @deprecated use `RecordTypePrometheus$inboundSchema` instead. */
  export const inboundSchema = RecordTypePrometheus$inboundSchema;
  /** @deprecated use `RecordTypePrometheus$outboundSchema` instead. */
  export const outboundSchema = RecordTypePrometheus$outboundSchema;
}

/** @internal */
export const MetricsProtocol$inboundSchema: z.ZodNativeEnum<
  typeof MetricsProtocol
> = z.nativeEnum(MetricsProtocol);

/** @internal */
export const MetricsProtocol$outboundSchema: z.ZodNativeEnum<
  typeof MetricsProtocol
> = MetricsProtocol$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetricsProtocol$ {
  /** @deprecated use `MetricsProtocol$inboundSchema` instead. */
  export const inboundSchema = MetricsProtocol$inboundSchema;
  /** @deprecated use `MetricsProtocol$outboundSchema` instead. */
  export const outboundSchema = MetricsProtocol$outboundSchema;
}

/** @internal */
export const SearchFilterPrometheus$inboundSchema: z.ZodType<
  SearchFilterPrometheus,
  z.ZodTypeDef,
  unknown
> = z.object({
  Name: z.string(),
  Values: z.array(z.string()),
}).transform((v) => {
  return remap$(v, {
    "Name": "name",
    "Values": "values",
  });
});

/** @internal */
export type SearchFilterPrometheus$Outbound = {
  Name: string;
  Values: Array<string>;
};

/** @internal */
export const SearchFilterPrometheus$outboundSchema: z.ZodType<
  SearchFilterPrometheus$Outbound,
  z.ZodTypeDef,
  SearchFilterPrometheus
> = z.object({
  name: z.string(),
  values: z.array(z.string()),
}).transform((v) => {
  return remap$(v, {
    name: "Name",
    values: "Values",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchFilterPrometheus$ {
  /** @deprecated use `SearchFilterPrometheus$inboundSchema` instead. */
  export const inboundSchema = SearchFilterPrometheus$inboundSchema;
  /** @deprecated use `SearchFilterPrometheus$outboundSchema` instead. */
  export const outboundSchema = SearchFilterPrometheus$outboundSchema;
  /** @deprecated use `SearchFilterPrometheus$Outbound` instead. */
  export type Outbound = SearchFilterPrometheus$Outbound;
}

export function searchFilterPrometheusToJSON(
  searchFilterPrometheus: SearchFilterPrometheus,
): string {
  return JSON.stringify(
    SearchFilterPrometheus$outboundSchema.parse(searchFilterPrometheus),
  );
}

export function searchFilterPrometheusFromJSON(
  jsonString: string,
): SafeParseResult<SearchFilterPrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchFilterPrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchFilterPrometheus' from JSON`,
  );
}

/** @internal */
export const AwsAuthenticationMethodAuthenticationMethodPrometheus$inboundSchema:
  z.ZodNativeEnum<
    typeof AwsAuthenticationMethodAuthenticationMethodPrometheus
  > = z.nativeEnum(AwsAuthenticationMethodAuthenticationMethodPrometheus);

/** @internal */
export const AwsAuthenticationMethodAuthenticationMethodPrometheus$outboundSchema:
  z.ZodNativeEnum<
    typeof AwsAuthenticationMethodAuthenticationMethodPrometheus
  > = AwsAuthenticationMethodAuthenticationMethodPrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AwsAuthenticationMethodAuthenticationMethodPrometheus$ {
  /** @deprecated use `AwsAuthenticationMethodAuthenticationMethodPrometheus$inboundSchema` instead. */
  export const inboundSchema =
    AwsAuthenticationMethodAuthenticationMethodPrometheus$inboundSchema;
  /** @deprecated use `AwsAuthenticationMethodAuthenticationMethodPrometheus$outboundSchema` instead. */
  export const outboundSchema =
    AwsAuthenticationMethodAuthenticationMethodPrometheus$outboundSchema;
}

/** @internal */
export const SignatureVersionPrometheus$inboundSchema: z.ZodNativeEnum<
  typeof SignatureVersionPrometheus
> = z.nativeEnum(SignatureVersionPrometheus);

/** @internal */
export const SignatureVersionPrometheus$outboundSchema: z.ZodNativeEnum<
  typeof SignatureVersionPrometheus
> = SignatureVersionPrometheus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignatureVersionPrometheus$ {
  /** @deprecated use `SignatureVersionPrometheus$inboundSchema` instead. */
  export const inboundSchema = SignatureVersionPrometheus$inboundSchema;
  /** @deprecated use `SignatureVersionPrometheus$outboundSchema` instead. */
  export const outboundSchema = SignatureVersionPrometheus$outboundSchema;
}

/** @internal */
export const InputPrometheus$inboundSchema: z.ZodType<
  InputPrometheus,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateInputTypePrometheus$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionPrometheus$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqPrometheus$inboundSchema).optional(),
  dimensionList: z.array(z.string()).optional(),
  discoveryType: DiscoveryTypePrometheus$inboundSchema.default("static"),
  interval: z.number().default(15),
  logLevel: LogLevelPrometheus$inboundSchema.default("info"),
  rejectUnauthorized: z.boolean().default(true),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumPrometheus$inboundSchema)).optional(),
  authType: AuthTypeAuthenticationMethodPrometheus$inboundSchema.default(
    "manual",
  ),
  description: z.string().optional(),
  targetList: z.array(z.string()).optional(),
  nameList: z.array(z.string()).optional(),
  recordType: RecordTypePrometheus$inboundSchema.default("SRV"),
  scrapeProtocol: MetricsProtocol$inboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  usePublicIp: z.boolean().default(true),
  scrapePort: z.number().default(9090),
  searchFilter: z.array(z.lazy(() => SearchFilterPrometheus$inboundSchema))
    .optional(),
  awsAuthenticationMethod:
    AwsAuthenticationMethodAuthenticationMethodPrometheus$inboundSchema.default(
      "auto",
    ),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionPrometheus$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});

/** @internal */
export type InputPrometheus$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionPrometheus$Outbound> | undefined;
  pq?: PqPrometheus$Outbound | undefined;
  dimensionList?: Array<string> | undefined;
  discoveryType: string;
  interval: number;
  logLevel: string;
  rejectUnauthorized: boolean;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<MetadatumPrometheus$Outbound> | undefined;
  authType: string;
  description?: string | undefined;
  targetList?: Array<string> | undefined;
  nameList?: Array<string> | undefined;
  recordType: string;
  scrapeProtocol: string;
  scrapePath: string;
  usePublicIp: boolean;
  scrapePort: number;
  searchFilter?: Array<SearchFilterPrometheus$Outbound> | undefined;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputPrometheus$outboundSchema: z.ZodType<
  InputPrometheus$Outbound,
  z.ZodTypeDef,
  InputPrometheus
> = z.object({
  id: z.string(),
  type: CreateInputTypePrometheus$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionPrometheus$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqPrometheus$outboundSchema).optional(),
  dimensionList: z.array(z.string()).optional(),
  discoveryType: DiscoveryTypePrometheus$outboundSchema.default("static"),
  interval: z.number().default(15),
  logLevel: LogLevelPrometheus$outboundSchema.default("info"),
  rejectUnauthorized: z.boolean().default(true),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumPrometheus$outboundSchema))
    .optional(),
  authType: AuthTypeAuthenticationMethodPrometheus$outboundSchema.default(
    "manual",
  ),
  description: z.string().optional(),
  targetList: z.array(z.string()).optional(),
  nameList: z.array(z.string()).optional(),
  recordType: RecordTypePrometheus$outboundSchema.default("SRV"),
  scrapeProtocol: MetricsProtocol$outboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  usePublicIp: z.boolean().default(true),
  scrapePort: z.number().default(9090),
  searchFilter: z.array(z.lazy(() => SearchFilterPrometheus$outboundSchema))
    .optional(),
  awsAuthenticationMethod:
    AwsAuthenticationMethodAuthenticationMethodPrometheus$outboundSchema
      .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionPrometheus$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheus$ {
  /** @deprecated use `InputPrometheus$inboundSchema` instead. */
  export const inboundSchema = InputPrometheus$inboundSchema;
  /** @deprecated use `InputPrometheus$outboundSchema` instead. */
  export const outboundSchema = InputPrometheus$outboundSchema;
  /** @deprecated use `InputPrometheus$Outbound` instead. */
  export type Outbound = InputPrometheus$Outbound;
}

export function inputPrometheusToJSON(
  inputPrometheus: InputPrometheus,
): string {
  return JSON.stringify(InputPrometheus$outboundSchema.parse(inputPrometheus));
}

export function inputPrometheusFromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheus' from JSON`,
  );
}

/** @internal */
export const TypePrometheusRw$inboundSchema: z.ZodNativeEnum<
  typeof TypePrometheusRw
> = z.nativeEnum(TypePrometheusRw);

/** @internal */
export const TypePrometheusRw$outboundSchema: z.ZodNativeEnum<
  typeof TypePrometheusRw
> = TypePrometheusRw$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypePrometheusRw$ {
  /** @deprecated use `TypePrometheusRw$inboundSchema` instead. */
  export const inboundSchema = TypePrometheusRw$inboundSchema;
  /** @deprecated use `TypePrometheusRw$outboundSchema` instead. */
  export const outboundSchema = TypePrometheusRw$outboundSchema;
}

/** @internal */
export const ConnectionPrometheusRw$inboundSchema: z.ZodType<
  ConnectionPrometheusRw,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionPrometheusRw$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionPrometheusRw$outboundSchema: z.ZodType<
  ConnectionPrometheusRw$Outbound,
  z.ZodTypeDef,
  ConnectionPrometheusRw
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionPrometheusRw$ {
  /** @deprecated use `ConnectionPrometheusRw$inboundSchema` instead. */
  export const inboundSchema = ConnectionPrometheusRw$inboundSchema;
  /** @deprecated use `ConnectionPrometheusRw$outboundSchema` instead. */
  export const outboundSchema = ConnectionPrometheusRw$outboundSchema;
  /** @deprecated use `ConnectionPrometheusRw$Outbound` instead. */
  export type Outbound = ConnectionPrometheusRw$Outbound;
}

export function connectionPrometheusRwToJSON(
  connectionPrometheusRw: ConnectionPrometheusRw,
): string {
  return JSON.stringify(
    ConnectionPrometheusRw$outboundSchema.parse(connectionPrometheusRw),
  );
}

export function connectionPrometheusRwFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionPrometheusRw, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionPrometheusRw$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionPrometheusRw' from JSON`,
  );
}

/** @internal */
export const ModePrometheusRw$inboundSchema: z.ZodNativeEnum<
  typeof ModePrometheusRw
> = z.nativeEnum(ModePrometheusRw);

/** @internal */
export const ModePrometheusRw$outboundSchema: z.ZodNativeEnum<
  typeof ModePrometheusRw
> = ModePrometheusRw$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModePrometheusRw$ {
  /** @deprecated use `ModePrometheusRw$inboundSchema` instead. */
  export const inboundSchema = ModePrometheusRw$inboundSchema;
  /** @deprecated use `ModePrometheusRw$outboundSchema` instead. */
  export const outboundSchema = ModePrometheusRw$outboundSchema;
}

/** @internal */
export const CompressionPrometheusRw$inboundSchema: z.ZodNativeEnum<
  typeof CompressionPrometheusRw
> = z.nativeEnum(CompressionPrometheusRw);

/** @internal */
export const CompressionPrometheusRw$outboundSchema: z.ZodNativeEnum<
  typeof CompressionPrometheusRw
> = CompressionPrometheusRw$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionPrometheusRw$ {
  /** @deprecated use `CompressionPrometheusRw$inboundSchema` instead. */
  export const inboundSchema = CompressionPrometheusRw$inboundSchema;
  /** @deprecated use `CompressionPrometheusRw$outboundSchema` instead. */
  export const outboundSchema = CompressionPrometheusRw$outboundSchema;
}

/** @internal */
export const PqPrometheusRw$inboundSchema: z.ZodType<
  PqPrometheusRw,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModePrometheusRw$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionPrometheusRw$inboundSchema.default("none"),
});

/** @internal */
export type PqPrometheusRw$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqPrometheusRw$outboundSchema: z.ZodType<
  PqPrometheusRw$Outbound,
  z.ZodTypeDef,
  PqPrometheusRw
> = z.object({
  mode: ModePrometheusRw$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionPrometheusRw$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqPrometheusRw$ {
  /** @deprecated use `PqPrometheusRw$inboundSchema` instead. */
  export const inboundSchema = PqPrometheusRw$inboundSchema;
  /** @deprecated use `PqPrometheusRw$outboundSchema` instead. */
  export const outboundSchema = PqPrometheusRw$outboundSchema;
  /** @deprecated use `PqPrometheusRw$Outbound` instead. */
  export type Outbound = PqPrometheusRw$Outbound;
}

export function pqPrometheusRwToJSON(pqPrometheusRw: PqPrometheusRw): string {
  return JSON.stringify(PqPrometheusRw$outboundSchema.parse(pqPrometheusRw));
}

export function pqPrometheusRwFromJSON(
  jsonString: string,
): SafeParseResult<PqPrometheusRw, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqPrometheusRw$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqPrometheusRw' from JSON`,
  );
}

/** @internal */
export const MinimumTLSVersionPrometheusRw$inboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionPrometheusRw
> = z.nativeEnum(MinimumTLSVersionPrometheusRw);

/** @internal */
export const MinimumTLSVersionPrometheusRw$outboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionPrometheusRw
> = MinimumTLSVersionPrometheusRw$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MinimumTLSVersionPrometheusRw$ {
  /** @deprecated use `MinimumTLSVersionPrometheusRw$inboundSchema` instead. */
  export const inboundSchema = MinimumTLSVersionPrometheusRw$inboundSchema;
  /** @deprecated use `MinimumTLSVersionPrometheusRw$outboundSchema` instead. */
  export const outboundSchema = MinimumTLSVersionPrometheusRw$outboundSchema;
}

/** @internal */
export const MaximumTLSVersionPrometheusRw$inboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionPrometheusRw
> = z.nativeEnum(MaximumTLSVersionPrometheusRw);

/** @internal */
export const MaximumTLSVersionPrometheusRw$outboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionPrometheusRw
> = MaximumTLSVersionPrometheusRw$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaximumTLSVersionPrometheusRw$ {
  /** @deprecated use `MaximumTLSVersionPrometheusRw$inboundSchema` instead. */
  export const inboundSchema = MaximumTLSVersionPrometheusRw$inboundSchema;
  /** @deprecated use `MaximumTLSVersionPrometheusRw$outboundSchema` instead. */
  export const outboundSchema = MaximumTLSVersionPrometheusRw$outboundSchema;
}

/** @internal */
export const TLSSettingsServerSidePrometheusRw$inboundSchema: z.ZodType<
  TLSSettingsServerSidePrometheusRw,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionPrometheusRw$inboundSchema.optional(),
  maxVersion: MaximumTLSVersionPrometheusRw$inboundSchema.optional(),
});

/** @internal */
export type TLSSettingsServerSidePrometheusRw$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TLSSettingsServerSidePrometheusRw$outboundSchema: z.ZodType<
  TLSSettingsServerSidePrometheusRw$Outbound,
  z.ZodTypeDef,
  TLSSettingsServerSidePrometheusRw
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionPrometheusRw$outboundSchema.optional(),
  maxVersion: MaximumTLSVersionPrometheusRw$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsServerSidePrometheusRw$ {
  /** @deprecated use `TLSSettingsServerSidePrometheusRw$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsServerSidePrometheusRw$inboundSchema;
  /** @deprecated use `TLSSettingsServerSidePrometheusRw$outboundSchema` instead. */
  export const outboundSchema =
    TLSSettingsServerSidePrometheusRw$outboundSchema;
  /** @deprecated use `TLSSettingsServerSidePrometheusRw$Outbound` instead. */
  export type Outbound = TLSSettingsServerSidePrometheusRw$Outbound;
}

export function tlsSettingsServerSidePrometheusRwToJSON(
  tlsSettingsServerSidePrometheusRw: TLSSettingsServerSidePrometheusRw,
): string {
  return JSON.stringify(
    TLSSettingsServerSidePrometheusRw$outboundSchema.parse(
      tlsSettingsServerSidePrometheusRw,
    ),
  );
}

export function tlsSettingsServerSidePrometheusRwFromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsServerSidePrometheusRw, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TLSSettingsServerSidePrometheusRw$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsServerSidePrometheusRw' from JSON`,
  );
}

/** @internal */
export const AuthenticationTypePrometheusRw$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationTypePrometheusRw
> = z.nativeEnum(AuthenticationTypePrometheusRw);

/** @internal */
export const AuthenticationTypePrometheusRw$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationTypePrometheusRw
> = AuthenticationTypePrometheusRw$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationTypePrometheusRw$ {
  /** @deprecated use `AuthenticationTypePrometheusRw$inboundSchema` instead. */
  export const inboundSchema = AuthenticationTypePrometheusRw$inboundSchema;
  /** @deprecated use `AuthenticationTypePrometheusRw$outboundSchema` instead. */
  export const outboundSchema = AuthenticationTypePrometheusRw$outboundSchema;
}

/** @internal */
export const MetadatumPrometheusRw$inboundSchema: z.ZodType<
  MetadatumPrometheusRw,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumPrometheusRw$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumPrometheusRw$outboundSchema: z.ZodType<
  MetadatumPrometheusRw$Outbound,
  z.ZodTypeDef,
  MetadatumPrometheusRw
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumPrometheusRw$ {
  /** @deprecated use `MetadatumPrometheusRw$inboundSchema` instead. */
  export const inboundSchema = MetadatumPrometheusRw$inboundSchema;
  /** @deprecated use `MetadatumPrometheusRw$outboundSchema` instead. */
  export const outboundSchema = MetadatumPrometheusRw$outboundSchema;
  /** @deprecated use `MetadatumPrometheusRw$Outbound` instead. */
  export type Outbound = MetadatumPrometheusRw$Outbound;
}

export function metadatumPrometheusRwToJSON(
  metadatumPrometheusRw: MetadatumPrometheusRw,
): string {
  return JSON.stringify(
    MetadatumPrometheusRw$outboundSchema.parse(metadatumPrometheusRw),
  );
}

export function metadatumPrometheusRwFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumPrometheusRw, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumPrometheusRw$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumPrometheusRw' from JSON`,
  );
}

/** @internal */
export const OauthParamPrometheusRw$inboundSchema: z.ZodType<
  OauthParamPrometheusRw,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type OauthParamPrometheusRw$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const OauthParamPrometheusRw$outboundSchema: z.ZodType<
  OauthParamPrometheusRw$Outbound,
  z.ZodTypeDef,
  OauthParamPrometheusRw
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OauthParamPrometheusRw$ {
  /** @deprecated use `OauthParamPrometheusRw$inboundSchema` instead. */
  export const inboundSchema = OauthParamPrometheusRw$inboundSchema;
  /** @deprecated use `OauthParamPrometheusRw$outboundSchema` instead. */
  export const outboundSchema = OauthParamPrometheusRw$outboundSchema;
  /** @deprecated use `OauthParamPrometheusRw$Outbound` instead. */
  export type Outbound = OauthParamPrometheusRw$Outbound;
}

export function oauthParamPrometheusRwToJSON(
  oauthParamPrometheusRw: OauthParamPrometheusRw,
): string {
  return JSON.stringify(
    OauthParamPrometheusRw$outboundSchema.parse(oauthParamPrometheusRw),
  );
}

export function oauthParamPrometheusRwFromJSON(
  jsonString: string,
): SafeParseResult<OauthParamPrometheusRw, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OauthParamPrometheusRw$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OauthParamPrometheusRw' from JSON`,
  );
}

/** @internal */
export const OauthHeaderPrometheusRw$inboundSchema: z.ZodType<
  OauthHeaderPrometheusRw,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type OauthHeaderPrometheusRw$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const OauthHeaderPrometheusRw$outboundSchema: z.ZodType<
  OauthHeaderPrometheusRw$Outbound,
  z.ZodTypeDef,
  OauthHeaderPrometheusRw
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OauthHeaderPrometheusRw$ {
  /** @deprecated use `OauthHeaderPrometheusRw$inboundSchema` instead. */
  export const inboundSchema = OauthHeaderPrometheusRw$inboundSchema;
  /** @deprecated use `OauthHeaderPrometheusRw$outboundSchema` instead. */
  export const outboundSchema = OauthHeaderPrometheusRw$outboundSchema;
  /** @deprecated use `OauthHeaderPrometheusRw$Outbound` instead. */
  export type Outbound = OauthHeaderPrometheusRw$Outbound;
}

export function oauthHeaderPrometheusRwToJSON(
  oauthHeaderPrometheusRw: OauthHeaderPrometheusRw,
): string {
  return JSON.stringify(
    OauthHeaderPrometheusRw$outboundSchema.parse(oauthHeaderPrometheusRw),
  );
}

export function oauthHeaderPrometheusRwFromJSON(
  jsonString: string,
): SafeParseResult<OauthHeaderPrometheusRw, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OauthHeaderPrometheusRw$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OauthHeaderPrometheusRw' from JSON`,
  );
}

/** @internal */
export const InputPrometheusRw$inboundSchema: z.ZodType<
  InputPrometheusRw,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypePrometheusRw$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionPrometheusRw$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqPrometheusRw$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => TLSSettingsServerSidePrometheusRw$inboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  prometheusAPI: z.string().default("/write"),
  authType: AuthenticationTypePrometheusRw$inboundSchema.default("none"),
  metadata: z.array(z.lazy(() => MetadatumPrometheusRw$inboundSchema))
    .optional(),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => OauthParamPrometheusRw$inboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => OauthHeaderPrometheusRw$inboundSchema))
    .optional(),
});

/** @internal */
export type InputPrometheusRw$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionPrometheusRw$Outbound> | undefined;
  pq?: PqPrometheusRw$Outbound | undefined;
  host: string;
  port: number;
  tls?: TLSSettingsServerSidePrometheusRw$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  prometheusAPI: string;
  authType: string;
  metadata?: Array<MetadatumPrometheusRw$Outbound> | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<OauthParamPrometheusRw$Outbound> | undefined;
  oauthHeaders?: Array<OauthHeaderPrometheusRw$Outbound> | undefined;
};

/** @internal */
export const InputPrometheusRw$outboundSchema: z.ZodType<
  InputPrometheusRw$Outbound,
  z.ZodTypeDef,
  InputPrometheusRw
> = z.object({
  id: z.string(),
  type: TypePrometheusRw$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionPrometheusRw$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqPrometheusRw$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => TLSSettingsServerSidePrometheusRw$outboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  prometheusAPI: z.string().default("/write"),
  authType: AuthenticationTypePrometheusRw$outboundSchema.default("none"),
  metadata: z.array(z.lazy(() => MetadatumPrometheusRw$outboundSchema))
    .optional(),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => OauthParamPrometheusRw$outboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => OauthHeaderPrometheusRw$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusRw$ {
  /** @deprecated use `InputPrometheusRw$inboundSchema` instead. */
  export const inboundSchema = InputPrometheusRw$inboundSchema;
  /** @deprecated use `InputPrometheusRw$outboundSchema` instead. */
  export const outboundSchema = InputPrometheusRw$outboundSchema;
  /** @deprecated use `InputPrometheusRw$Outbound` instead. */
  export type Outbound = InputPrometheusRw$Outbound;
}

export function inputPrometheusRwToJSON(
  inputPrometheusRw: InputPrometheusRw,
): string {
  return JSON.stringify(
    InputPrometheusRw$outboundSchema.parse(inputPrometheusRw),
  );
}

export function inputPrometheusRwFromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheusRw, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheusRw$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheusRw' from JSON`,
  );
}

/** @internal */
export const CreateInputTypeLoki$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeLoki
> = z.nativeEnum(CreateInputTypeLoki);

/** @internal */
export const CreateInputTypeLoki$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeLoki
> = CreateInputTypeLoki$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputTypeLoki$ {
  /** @deprecated use `CreateInputTypeLoki$inboundSchema` instead. */
  export const inboundSchema = CreateInputTypeLoki$inboundSchema;
  /** @deprecated use `CreateInputTypeLoki$outboundSchema` instead. */
  export const outboundSchema = CreateInputTypeLoki$outboundSchema;
}

/** @internal */
export const ConnectionLoki$inboundSchema: z.ZodType<
  ConnectionLoki,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionLoki$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionLoki$outboundSchema: z.ZodType<
  ConnectionLoki$Outbound,
  z.ZodTypeDef,
  ConnectionLoki
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionLoki$ {
  /** @deprecated use `ConnectionLoki$inboundSchema` instead. */
  export const inboundSchema = ConnectionLoki$inboundSchema;
  /** @deprecated use `ConnectionLoki$outboundSchema` instead. */
  export const outboundSchema = ConnectionLoki$outboundSchema;
  /** @deprecated use `ConnectionLoki$Outbound` instead. */
  export type Outbound = ConnectionLoki$Outbound;
}

export function connectionLokiToJSON(connectionLoki: ConnectionLoki): string {
  return JSON.stringify(ConnectionLoki$outboundSchema.parse(connectionLoki));
}

export function connectionLokiFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionLoki, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionLoki$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionLoki' from JSON`,
  );
}

/** @internal */
export const CreateInputModeLoki$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputModeLoki
> = z.nativeEnum(CreateInputModeLoki);

/** @internal */
export const CreateInputModeLoki$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputModeLoki
> = CreateInputModeLoki$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputModeLoki$ {
  /** @deprecated use `CreateInputModeLoki$inboundSchema` instead. */
  export const inboundSchema = CreateInputModeLoki$inboundSchema;
  /** @deprecated use `CreateInputModeLoki$outboundSchema` instead. */
  export const outboundSchema = CreateInputModeLoki$outboundSchema;
}

/** @internal */
export const PqCompressionLoki$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressionLoki
> = z.nativeEnum(PqCompressionLoki);

/** @internal */
export const PqCompressionLoki$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressionLoki
> = PqCompressionLoki$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressionLoki$ {
  /** @deprecated use `PqCompressionLoki$inboundSchema` instead. */
  export const inboundSchema = PqCompressionLoki$inboundSchema;
  /** @deprecated use `PqCompressionLoki$outboundSchema` instead. */
  export const outboundSchema = PqCompressionLoki$outboundSchema;
}

/** @internal */
export const PqLoki$inboundSchema: z.ZodType<PqLoki, z.ZodTypeDef, unknown> = z
  .object({
    mode: CreateInputModeLoki$inboundSchema.default("always"),
    maxBufferSize: z.number().default(1000),
    commitFrequency: z.number().default(42),
    maxFileSize: z.string().default("1 MB"),
    maxSize: z.string().default("5GB"),
    path: z.string().default("$CRIBL_HOME/state/queues"),
    compress: PqCompressionLoki$inboundSchema.default("none"),
  });

/** @internal */
export type PqLoki$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqLoki$outboundSchema: z.ZodType<
  PqLoki$Outbound,
  z.ZodTypeDef,
  PqLoki
> = z.object({
  mode: CreateInputModeLoki$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: PqCompressionLoki$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqLoki$ {
  /** @deprecated use `PqLoki$inboundSchema` instead. */
  export const inboundSchema = PqLoki$inboundSchema;
  /** @deprecated use `PqLoki$outboundSchema` instead. */
  export const outboundSchema = PqLoki$outboundSchema;
  /** @deprecated use `PqLoki$Outbound` instead. */
  export type Outbound = PqLoki$Outbound;
}

export function pqLokiToJSON(pqLoki: PqLoki): string {
  return JSON.stringify(PqLoki$outboundSchema.parse(pqLoki));
}

export function pqLokiFromJSON(
  jsonString: string,
): SafeParseResult<PqLoki, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqLoki$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqLoki' from JSON`,
  );
}

/** @internal */
export const MinimumTLSVersionLoki$inboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionLoki
> = z.nativeEnum(MinimumTLSVersionLoki);

/** @internal */
export const MinimumTLSVersionLoki$outboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionLoki
> = MinimumTLSVersionLoki$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MinimumTLSVersionLoki$ {
  /** @deprecated use `MinimumTLSVersionLoki$inboundSchema` instead. */
  export const inboundSchema = MinimumTLSVersionLoki$inboundSchema;
  /** @deprecated use `MinimumTLSVersionLoki$outboundSchema` instead. */
  export const outboundSchema = MinimumTLSVersionLoki$outboundSchema;
}

/** @internal */
export const MaximumTLSVersionLoki$inboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionLoki
> = z.nativeEnum(MaximumTLSVersionLoki);

/** @internal */
export const MaximumTLSVersionLoki$outboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionLoki
> = MaximumTLSVersionLoki$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaximumTLSVersionLoki$ {
  /** @deprecated use `MaximumTLSVersionLoki$inboundSchema` instead. */
  export const inboundSchema = MaximumTLSVersionLoki$inboundSchema;
  /** @deprecated use `MaximumTLSVersionLoki$outboundSchema` instead. */
  export const outboundSchema = MaximumTLSVersionLoki$outboundSchema;
}

/** @internal */
export const TLSSettingsServerSideLoki$inboundSchema: z.ZodType<
  TLSSettingsServerSideLoki,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionLoki$inboundSchema.optional(),
  maxVersion: MaximumTLSVersionLoki$inboundSchema.optional(),
});

/** @internal */
export type TLSSettingsServerSideLoki$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TLSSettingsServerSideLoki$outboundSchema: z.ZodType<
  TLSSettingsServerSideLoki$Outbound,
  z.ZodTypeDef,
  TLSSettingsServerSideLoki
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionLoki$outboundSchema.optional(),
  maxVersion: MaximumTLSVersionLoki$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsServerSideLoki$ {
  /** @deprecated use `TLSSettingsServerSideLoki$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsServerSideLoki$inboundSchema;
  /** @deprecated use `TLSSettingsServerSideLoki$outboundSchema` instead. */
  export const outboundSchema = TLSSettingsServerSideLoki$outboundSchema;
  /** @deprecated use `TLSSettingsServerSideLoki$Outbound` instead. */
  export type Outbound = TLSSettingsServerSideLoki$Outbound;
}

export function tlsSettingsServerSideLokiToJSON(
  tlsSettingsServerSideLoki: TLSSettingsServerSideLoki,
): string {
  return JSON.stringify(
    TLSSettingsServerSideLoki$outboundSchema.parse(tlsSettingsServerSideLoki),
  );
}

export function tlsSettingsServerSideLokiFromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsServerSideLoki, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TLSSettingsServerSideLoki$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsServerSideLoki' from JSON`,
  );
}

/** @internal */
export const CreateInputAuthenticationTypeLoki$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputAuthenticationTypeLoki
> = z.nativeEnum(CreateInputAuthenticationTypeLoki);

/** @internal */
export const CreateInputAuthenticationTypeLoki$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputAuthenticationTypeLoki
> = CreateInputAuthenticationTypeLoki$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputAuthenticationTypeLoki$ {
  /** @deprecated use `CreateInputAuthenticationTypeLoki$inboundSchema` instead. */
  export const inboundSchema = CreateInputAuthenticationTypeLoki$inboundSchema;
  /** @deprecated use `CreateInputAuthenticationTypeLoki$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputAuthenticationTypeLoki$outboundSchema;
}

/** @internal */
export const MetadatumLoki$inboundSchema: z.ZodType<
  MetadatumLoki,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumLoki$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumLoki$outboundSchema: z.ZodType<
  MetadatumLoki$Outbound,
  z.ZodTypeDef,
  MetadatumLoki
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumLoki$ {
  /** @deprecated use `MetadatumLoki$inboundSchema` instead. */
  export const inboundSchema = MetadatumLoki$inboundSchema;
  /** @deprecated use `MetadatumLoki$outboundSchema` instead. */
  export const outboundSchema = MetadatumLoki$outboundSchema;
  /** @deprecated use `MetadatumLoki$Outbound` instead. */
  export type Outbound = MetadatumLoki$Outbound;
}

export function metadatumLokiToJSON(metadatumLoki: MetadatumLoki): string {
  return JSON.stringify(MetadatumLoki$outboundSchema.parse(metadatumLoki));
}

export function metadatumLokiFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumLoki, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumLoki$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumLoki' from JSON`,
  );
}

/** @internal */
export const OauthParamLoki$inboundSchema: z.ZodType<
  OauthParamLoki,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type OauthParamLoki$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const OauthParamLoki$outboundSchema: z.ZodType<
  OauthParamLoki$Outbound,
  z.ZodTypeDef,
  OauthParamLoki
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OauthParamLoki$ {
  /** @deprecated use `OauthParamLoki$inboundSchema` instead. */
  export const inboundSchema = OauthParamLoki$inboundSchema;
  /** @deprecated use `OauthParamLoki$outboundSchema` instead. */
  export const outboundSchema = OauthParamLoki$outboundSchema;
  /** @deprecated use `OauthParamLoki$Outbound` instead. */
  export type Outbound = OauthParamLoki$Outbound;
}

export function oauthParamLokiToJSON(oauthParamLoki: OauthParamLoki): string {
  return JSON.stringify(OauthParamLoki$outboundSchema.parse(oauthParamLoki));
}

export function oauthParamLokiFromJSON(
  jsonString: string,
): SafeParseResult<OauthParamLoki, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OauthParamLoki$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OauthParamLoki' from JSON`,
  );
}

/** @internal */
export const OauthHeaderLoki$inboundSchema: z.ZodType<
  OauthHeaderLoki,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type OauthHeaderLoki$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const OauthHeaderLoki$outboundSchema: z.ZodType<
  OauthHeaderLoki$Outbound,
  z.ZodTypeDef,
  OauthHeaderLoki
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OauthHeaderLoki$ {
  /** @deprecated use `OauthHeaderLoki$inboundSchema` instead. */
  export const inboundSchema = OauthHeaderLoki$inboundSchema;
  /** @deprecated use `OauthHeaderLoki$outboundSchema` instead. */
  export const outboundSchema = OauthHeaderLoki$outboundSchema;
  /** @deprecated use `OauthHeaderLoki$Outbound` instead. */
  export type Outbound = OauthHeaderLoki$Outbound;
}

export function oauthHeaderLokiToJSON(
  oauthHeaderLoki: OauthHeaderLoki,
): string {
  return JSON.stringify(OauthHeaderLoki$outboundSchema.parse(oauthHeaderLoki));
}

export function oauthHeaderLokiFromJSON(
  jsonString: string,
): SafeParseResult<OauthHeaderLoki, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OauthHeaderLoki$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OauthHeaderLoki' from JSON`,
  );
}

/** @internal */
export const InputLoki$inboundSchema: z.ZodType<
  InputLoki,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateInputTypeLoki$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionLoki$inboundSchema)).optional(),
  pq: z.lazy(() => PqLoki$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => TLSSettingsServerSideLoki$inboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  lokiAPI: z.string().default("/loki/api/v1/push"),
  authType: CreateInputAuthenticationTypeLoki$inboundSchema.default("none"),
  metadata: z.array(z.lazy(() => MetadatumLoki$inboundSchema)).optional(),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => OauthParamLoki$inboundSchema)).optional(),
  oauthHeaders: z.array(z.lazy(() => OauthHeaderLoki$inboundSchema)).optional(),
});

/** @internal */
export type InputLoki$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionLoki$Outbound> | undefined;
  pq?: PqLoki$Outbound | undefined;
  host: string;
  port: number;
  tls?: TLSSettingsServerSideLoki$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  lokiAPI: string;
  authType: string;
  metadata?: Array<MetadatumLoki$Outbound> | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<OauthParamLoki$Outbound> | undefined;
  oauthHeaders?: Array<OauthHeaderLoki$Outbound> | undefined;
};

/** @internal */
export const InputLoki$outboundSchema: z.ZodType<
  InputLoki$Outbound,
  z.ZodTypeDef,
  InputLoki
> = z.object({
  id: z.string(),
  type: CreateInputTypeLoki$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionLoki$outboundSchema)).optional(),
  pq: z.lazy(() => PqLoki$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => TLSSettingsServerSideLoki$outboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  lokiAPI: z.string().default("/loki/api/v1/push"),
  authType: CreateInputAuthenticationTypeLoki$outboundSchema.default("none"),
  metadata: z.array(z.lazy(() => MetadatumLoki$outboundSchema)).optional(),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => OauthParamLoki$outboundSchema)).optional(),
  oauthHeaders: z.array(z.lazy(() => OauthHeaderLoki$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputLoki$ {
  /** @deprecated use `InputLoki$inboundSchema` instead. */
  export const inboundSchema = InputLoki$inboundSchema;
  /** @deprecated use `InputLoki$outboundSchema` instead. */
  export const outboundSchema = InputLoki$outboundSchema;
  /** @deprecated use `InputLoki$Outbound` instead. */
  export type Outbound = InputLoki$Outbound;
}

export function inputLokiToJSON(inputLoki: InputLoki): string {
  return JSON.stringify(InputLoki$outboundSchema.parse(inputLoki));
}

export function inputLokiFromJSON(
  jsonString: string,
): SafeParseResult<InputLoki, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputLoki$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputLoki' from JSON`,
  );
}

/** @internal */
export const InputGrafanaType2$inboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaType2
> = z.nativeEnum(InputGrafanaType2);

/** @internal */
export const InputGrafanaType2$outboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaType2
> = InputGrafanaType2$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaType2$ {
  /** @deprecated use `InputGrafanaType2$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaType2$inboundSchema;
  /** @deprecated use `InputGrafanaType2$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaType2$outboundSchema;
}

/** @internal */
export const InputGrafanaConnection2$inboundSchema: z.ZodType<
  InputGrafanaConnection2,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputGrafanaConnection2$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputGrafanaConnection2$outboundSchema: z.ZodType<
  InputGrafanaConnection2$Outbound,
  z.ZodTypeDef,
  InputGrafanaConnection2
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaConnection2$ {
  /** @deprecated use `InputGrafanaConnection2$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaConnection2$inboundSchema;
  /** @deprecated use `InputGrafanaConnection2$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaConnection2$outboundSchema;
  /** @deprecated use `InputGrafanaConnection2$Outbound` instead. */
  export type Outbound = InputGrafanaConnection2$Outbound;
}

export function inputGrafanaConnection2ToJSON(
  inputGrafanaConnection2: InputGrafanaConnection2,
): string {
  return JSON.stringify(
    InputGrafanaConnection2$outboundSchema.parse(inputGrafanaConnection2),
  );
}

export function inputGrafanaConnection2FromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaConnection2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafanaConnection2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaConnection2' from JSON`,
  );
}

/** @internal */
export const InputGrafanaMode2$inboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaMode2
> = z.nativeEnum(InputGrafanaMode2);

/** @internal */
export const InputGrafanaMode2$outboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaMode2
> = InputGrafanaMode2$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaMode2$ {
  /** @deprecated use `InputGrafanaMode2$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaMode2$inboundSchema;
  /** @deprecated use `InputGrafanaMode2$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaMode2$outboundSchema;
}

/** @internal */
export const InputGrafanaCompression2$inboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaCompression2
> = z.nativeEnum(InputGrafanaCompression2);

/** @internal */
export const InputGrafanaCompression2$outboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaCompression2
> = InputGrafanaCompression2$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaCompression2$ {
  /** @deprecated use `InputGrafanaCompression2$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaCompression2$inboundSchema;
  /** @deprecated use `InputGrafanaCompression2$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaCompression2$outboundSchema;
}

/** @internal */
export const InputGrafanaPq2$inboundSchema: z.ZodType<
  InputGrafanaPq2,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputGrafanaMode2$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputGrafanaCompression2$inboundSchema.default("none"),
});

/** @internal */
export type InputGrafanaPq2$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputGrafanaPq2$outboundSchema: z.ZodType<
  InputGrafanaPq2$Outbound,
  z.ZodTypeDef,
  InputGrafanaPq2
> = z.object({
  mode: InputGrafanaMode2$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputGrafanaCompression2$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaPq2$ {
  /** @deprecated use `InputGrafanaPq2$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaPq2$inboundSchema;
  /** @deprecated use `InputGrafanaPq2$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaPq2$outboundSchema;
  /** @deprecated use `InputGrafanaPq2$Outbound` instead. */
  export type Outbound = InputGrafanaPq2$Outbound;
}

export function inputGrafanaPq2ToJSON(
  inputGrafanaPq2: InputGrafanaPq2,
): string {
  return JSON.stringify(InputGrafanaPq2$outboundSchema.parse(inputGrafanaPq2));
}

export function inputGrafanaPq2FromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaPq2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafanaPq2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaPq2' from JSON`,
  );
}

/** @internal */
export const InputGrafanaMinimumTLSVersion2$inboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaMinimumTLSVersion2
> = z.nativeEnum(InputGrafanaMinimumTLSVersion2);

/** @internal */
export const InputGrafanaMinimumTLSVersion2$outboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaMinimumTLSVersion2
> = InputGrafanaMinimumTLSVersion2$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaMinimumTLSVersion2$ {
  /** @deprecated use `InputGrafanaMinimumTLSVersion2$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaMinimumTLSVersion2$inboundSchema;
  /** @deprecated use `InputGrafanaMinimumTLSVersion2$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaMinimumTLSVersion2$outboundSchema;
}

/** @internal */
export const InputGrafanaMaximumTLSVersion2$inboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaMaximumTLSVersion2
> = z.nativeEnum(InputGrafanaMaximumTLSVersion2);

/** @internal */
export const InputGrafanaMaximumTLSVersion2$outboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaMaximumTLSVersion2
> = InputGrafanaMaximumTLSVersion2$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaMaximumTLSVersion2$ {
  /** @deprecated use `InputGrafanaMaximumTLSVersion2$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaMaximumTLSVersion2$inboundSchema;
  /** @deprecated use `InputGrafanaMaximumTLSVersion2$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaMaximumTLSVersion2$outboundSchema;
}

/** @internal */
export const InputGrafanaTLSSettingsServerSide2$inboundSchema: z.ZodType<
  InputGrafanaTLSSettingsServerSide2,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputGrafanaMinimumTLSVersion2$inboundSchema.optional(),
  maxVersion: InputGrafanaMaximumTLSVersion2$inboundSchema.optional(),
});

/** @internal */
export type InputGrafanaTLSSettingsServerSide2$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputGrafanaTLSSettingsServerSide2$outboundSchema: z.ZodType<
  InputGrafanaTLSSettingsServerSide2$Outbound,
  z.ZodTypeDef,
  InputGrafanaTLSSettingsServerSide2
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputGrafanaMinimumTLSVersion2$outboundSchema.optional(),
  maxVersion: InputGrafanaMaximumTLSVersion2$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaTLSSettingsServerSide2$ {
  /** @deprecated use `InputGrafanaTLSSettingsServerSide2$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaTLSSettingsServerSide2$inboundSchema;
  /** @deprecated use `InputGrafanaTLSSettingsServerSide2$outboundSchema` instead. */
  export const outboundSchema =
    InputGrafanaTLSSettingsServerSide2$outboundSchema;
  /** @deprecated use `InputGrafanaTLSSettingsServerSide2$Outbound` instead. */
  export type Outbound = InputGrafanaTLSSettingsServerSide2$Outbound;
}

export function inputGrafanaTLSSettingsServerSide2ToJSON(
  inputGrafanaTLSSettingsServerSide2: InputGrafanaTLSSettingsServerSide2,
): string {
  return JSON.stringify(
    InputGrafanaTLSSettingsServerSide2$outboundSchema.parse(
      inputGrafanaTLSSettingsServerSide2,
    ),
  );
}

export function inputGrafanaTLSSettingsServerSide2FromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaTLSSettingsServerSide2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      InputGrafanaTLSSettingsServerSide2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaTLSSettingsServerSide2' from JSON`,
  );
}

/** @internal */
export const PrometheusAuthAuthenticationType2$inboundSchema: z.ZodNativeEnum<
  typeof PrometheusAuthAuthenticationType2
> = z.nativeEnum(PrometheusAuthAuthenticationType2);

/** @internal */
export const PrometheusAuthAuthenticationType2$outboundSchema: z.ZodNativeEnum<
  typeof PrometheusAuthAuthenticationType2
> = PrometheusAuthAuthenticationType2$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrometheusAuthAuthenticationType2$ {
  /** @deprecated use `PrometheusAuthAuthenticationType2$inboundSchema` instead. */
  export const inboundSchema = PrometheusAuthAuthenticationType2$inboundSchema;
  /** @deprecated use `PrometheusAuthAuthenticationType2$outboundSchema` instead. */
  export const outboundSchema =
    PrometheusAuthAuthenticationType2$outboundSchema;
}

/** @internal */
export const PrometheusAuthOauthParam2$inboundSchema: z.ZodType<
  PrometheusAuthOauthParam2,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type PrometheusAuthOauthParam2$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const PrometheusAuthOauthParam2$outboundSchema: z.ZodType<
  PrometheusAuthOauthParam2$Outbound,
  z.ZodTypeDef,
  PrometheusAuthOauthParam2
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrometheusAuthOauthParam2$ {
  /** @deprecated use `PrometheusAuthOauthParam2$inboundSchema` instead. */
  export const inboundSchema = PrometheusAuthOauthParam2$inboundSchema;
  /** @deprecated use `PrometheusAuthOauthParam2$outboundSchema` instead. */
  export const outboundSchema = PrometheusAuthOauthParam2$outboundSchema;
  /** @deprecated use `PrometheusAuthOauthParam2$Outbound` instead. */
  export type Outbound = PrometheusAuthOauthParam2$Outbound;
}

export function prometheusAuthOauthParam2ToJSON(
  prometheusAuthOauthParam2: PrometheusAuthOauthParam2,
): string {
  return JSON.stringify(
    PrometheusAuthOauthParam2$outboundSchema.parse(prometheusAuthOauthParam2),
  );
}

export function prometheusAuthOauthParam2FromJSON(
  jsonString: string,
): SafeParseResult<PrometheusAuthOauthParam2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrometheusAuthOauthParam2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrometheusAuthOauthParam2' from JSON`,
  );
}

/** @internal */
export const PrometheusAuthOauthHeader2$inboundSchema: z.ZodType<
  PrometheusAuthOauthHeader2,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type PrometheusAuthOauthHeader2$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const PrometheusAuthOauthHeader2$outboundSchema: z.ZodType<
  PrometheusAuthOauthHeader2$Outbound,
  z.ZodTypeDef,
  PrometheusAuthOauthHeader2
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrometheusAuthOauthHeader2$ {
  /** @deprecated use `PrometheusAuthOauthHeader2$inboundSchema` instead. */
  export const inboundSchema = PrometheusAuthOauthHeader2$inboundSchema;
  /** @deprecated use `PrometheusAuthOauthHeader2$outboundSchema` instead. */
  export const outboundSchema = PrometheusAuthOauthHeader2$outboundSchema;
  /** @deprecated use `PrometheusAuthOauthHeader2$Outbound` instead. */
  export type Outbound = PrometheusAuthOauthHeader2$Outbound;
}

export function prometheusAuthOauthHeader2ToJSON(
  prometheusAuthOauthHeader2: PrometheusAuthOauthHeader2,
): string {
  return JSON.stringify(
    PrometheusAuthOauthHeader2$outboundSchema.parse(prometheusAuthOauthHeader2),
  );
}

export function prometheusAuthOauthHeader2FromJSON(
  jsonString: string,
): SafeParseResult<PrometheusAuthOauthHeader2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrometheusAuthOauthHeader2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrometheusAuthOauthHeader2' from JSON`,
  );
}

/** @internal */
export const PrometheusAuth2$inboundSchema: z.ZodType<
  PrometheusAuth2,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: PrometheusAuthAuthenticationType2$inboundSchema.default("none"),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => PrometheusAuthOauthParam2$inboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => PrometheusAuthOauthHeader2$inboundSchema))
    .optional(),
});

/** @internal */
export type PrometheusAuth2$Outbound = {
  authType: string;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<PrometheusAuthOauthParam2$Outbound> | undefined;
  oauthHeaders?: Array<PrometheusAuthOauthHeader2$Outbound> | undefined;
};

/** @internal */
export const PrometheusAuth2$outboundSchema: z.ZodType<
  PrometheusAuth2$Outbound,
  z.ZodTypeDef,
  PrometheusAuth2
> = z.object({
  authType: PrometheusAuthAuthenticationType2$outboundSchema.default("none"),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => PrometheusAuthOauthParam2$outboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => PrometheusAuthOauthHeader2$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrometheusAuth2$ {
  /** @deprecated use `PrometheusAuth2$inboundSchema` instead. */
  export const inboundSchema = PrometheusAuth2$inboundSchema;
  /** @deprecated use `PrometheusAuth2$outboundSchema` instead. */
  export const outboundSchema = PrometheusAuth2$outboundSchema;
  /** @deprecated use `PrometheusAuth2$Outbound` instead. */
  export type Outbound = PrometheusAuth2$Outbound;
}

export function prometheusAuth2ToJSON(
  prometheusAuth2: PrometheusAuth2,
): string {
  return JSON.stringify(PrometheusAuth2$outboundSchema.parse(prometheusAuth2));
}

export function prometheusAuth2FromJSON(
  jsonString: string,
): SafeParseResult<PrometheusAuth2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrometheusAuth2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrometheusAuth2' from JSON`,
  );
}

/** @internal */
export const LokiAuthAuthenticationType2$inboundSchema: z.ZodNativeEnum<
  typeof LokiAuthAuthenticationType2
> = z.nativeEnum(LokiAuthAuthenticationType2);

/** @internal */
export const LokiAuthAuthenticationType2$outboundSchema: z.ZodNativeEnum<
  typeof LokiAuthAuthenticationType2
> = LokiAuthAuthenticationType2$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LokiAuthAuthenticationType2$ {
  /** @deprecated use `LokiAuthAuthenticationType2$inboundSchema` instead. */
  export const inboundSchema = LokiAuthAuthenticationType2$inboundSchema;
  /** @deprecated use `LokiAuthAuthenticationType2$outboundSchema` instead. */
  export const outboundSchema = LokiAuthAuthenticationType2$outboundSchema;
}

/** @internal */
export const LokiAuthOauthParam2$inboundSchema: z.ZodType<
  LokiAuthOauthParam2,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type LokiAuthOauthParam2$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const LokiAuthOauthParam2$outboundSchema: z.ZodType<
  LokiAuthOauthParam2$Outbound,
  z.ZodTypeDef,
  LokiAuthOauthParam2
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LokiAuthOauthParam2$ {
  /** @deprecated use `LokiAuthOauthParam2$inboundSchema` instead. */
  export const inboundSchema = LokiAuthOauthParam2$inboundSchema;
  /** @deprecated use `LokiAuthOauthParam2$outboundSchema` instead. */
  export const outboundSchema = LokiAuthOauthParam2$outboundSchema;
  /** @deprecated use `LokiAuthOauthParam2$Outbound` instead. */
  export type Outbound = LokiAuthOauthParam2$Outbound;
}

export function lokiAuthOauthParam2ToJSON(
  lokiAuthOauthParam2: LokiAuthOauthParam2,
): string {
  return JSON.stringify(
    LokiAuthOauthParam2$outboundSchema.parse(lokiAuthOauthParam2),
  );
}

export function lokiAuthOauthParam2FromJSON(
  jsonString: string,
): SafeParseResult<LokiAuthOauthParam2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LokiAuthOauthParam2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LokiAuthOauthParam2' from JSON`,
  );
}

/** @internal */
export const LokiAuthOauthHeader2$inboundSchema: z.ZodType<
  LokiAuthOauthHeader2,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type LokiAuthOauthHeader2$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const LokiAuthOauthHeader2$outboundSchema: z.ZodType<
  LokiAuthOauthHeader2$Outbound,
  z.ZodTypeDef,
  LokiAuthOauthHeader2
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LokiAuthOauthHeader2$ {
  /** @deprecated use `LokiAuthOauthHeader2$inboundSchema` instead. */
  export const inboundSchema = LokiAuthOauthHeader2$inboundSchema;
  /** @deprecated use `LokiAuthOauthHeader2$outboundSchema` instead. */
  export const outboundSchema = LokiAuthOauthHeader2$outboundSchema;
  /** @deprecated use `LokiAuthOauthHeader2$Outbound` instead. */
  export type Outbound = LokiAuthOauthHeader2$Outbound;
}

export function lokiAuthOauthHeader2ToJSON(
  lokiAuthOauthHeader2: LokiAuthOauthHeader2,
): string {
  return JSON.stringify(
    LokiAuthOauthHeader2$outboundSchema.parse(lokiAuthOauthHeader2),
  );
}

export function lokiAuthOauthHeader2FromJSON(
  jsonString: string,
): SafeParseResult<LokiAuthOauthHeader2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LokiAuthOauthHeader2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LokiAuthOauthHeader2' from JSON`,
  );
}

/** @internal */
export const LokiAuth2$inboundSchema: z.ZodType<
  LokiAuth2,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: LokiAuthAuthenticationType2$inboundSchema.default("none"),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => LokiAuthOauthParam2$inboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => LokiAuthOauthHeader2$inboundSchema))
    .optional(),
});

/** @internal */
export type LokiAuth2$Outbound = {
  authType: string;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<LokiAuthOauthParam2$Outbound> | undefined;
  oauthHeaders?: Array<LokiAuthOauthHeader2$Outbound> | undefined;
};

/** @internal */
export const LokiAuth2$outboundSchema: z.ZodType<
  LokiAuth2$Outbound,
  z.ZodTypeDef,
  LokiAuth2
> = z.object({
  authType: LokiAuthAuthenticationType2$outboundSchema.default("none"),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => LokiAuthOauthParam2$outboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => LokiAuthOauthHeader2$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LokiAuth2$ {
  /** @deprecated use `LokiAuth2$inboundSchema` instead. */
  export const inboundSchema = LokiAuth2$inboundSchema;
  /** @deprecated use `LokiAuth2$outboundSchema` instead. */
  export const outboundSchema = LokiAuth2$outboundSchema;
  /** @deprecated use `LokiAuth2$Outbound` instead. */
  export type Outbound = LokiAuth2$Outbound;
}

export function lokiAuth2ToJSON(lokiAuth2: LokiAuth2): string {
  return JSON.stringify(LokiAuth2$outboundSchema.parse(lokiAuth2));
}

export function lokiAuth2FromJSON(
  jsonString: string,
): SafeParseResult<LokiAuth2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LokiAuth2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LokiAuth2' from JSON`,
  );
}

/** @internal */
export const InputGrafanaMetadatum2$inboundSchema: z.ZodType<
  InputGrafanaMetadatum2,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputGrafanaMetadatum2$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputGrafanaMetadatum2$outboundSchema: z.ZodType<
  InputGrafanaMetadatum2$Outbound,
  z.ZodTypeDef,
  InputGrafanaMetadatum2
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaMetadatum2$ {
  /** @deprecated use `InputGrafanaMetadatum2$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaMetadatum2$inboundSchema;
  /** @deprecated use `InputGrafanaMetadatum2$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaMetadatum2$outboundSchema;
  /** @deprecated use `InputGrafanaMetadatum2$Outbound` instead. */
  export type Outbound = InputGrafanaMetadatum2$Outbound;
}

export function inputGrafanaMetadatum2ToJSON(
  inputGrafanaMetadatum2: InputGrafanaMetadatum2,
): string {
  return JSON.stringify(
    InputGrafanaMetadatum2$outboundSchema.parse(inputGrafanaMetadatum2),
  );
}

export function inputGrafanaMetadatum2FromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaMetadatum2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafanaMetadatum2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaMetadatum2' from JSON`,
  );
}

/** @internal */
export const InputGrafanaGrafana2$inboundSchema: z.ZodType<
  InputGrafanaGrafana2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputGrafanaType2$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputGrafanaConnection2$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputGrafanaPq2$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputGrafanaTLSSettingsServerSide2$inboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  prometheusAPI: z.string().default("/api/prom/push"),
  lokiAPI: z.string().default("/loki/api/v1/push"),
  prometheusAuth: z.lazy(() => PrometheusAuth2$inboundSchema).optional(),
  lokiAuth: z.lazy(() => LokiAuth2$inboundSchema).optional(),
  metadata: z.array(z.lazy(() => InputGrafanaMetadatum2$inboundSchema))
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputGrafanaGrafana2$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputGrafanaConnection2$Outbound> | undefined;
  pq?: InputGrafanaPq2$Outbound | undefined;
  host: string;
  port: number;
  tls?: InputGrafanaTLSSettingsServerSide2$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  prometheusAPI: string;
  lokiAPI: string;
  prometheusAuth?: PrometheusAuth2$Outbound | undefined;
  lokiAuth?: LokiAuth2$Outbound | undefined;
  metadata?: Array<InputGrafanaMetadatum2$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputGrafanaGrafana2$outboundSchema: z.ZodType<
  InputGrafanaGrafana2$Outbound,
  z.ZodTypeDef,
  InputGrafanaGrafana2
> = z.object({
  id: z.string(),
  type: InputGrafanaType2$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputGrafanaConnection2$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputGrafanaPq2$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputGrafanaTLSSettingsServerSide2$outboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  prometheusAPI: z.string().default("/api/prom/push"),
  lokiAPI: z.string().default("/loki/api/v1/push"),
  prometheusAuth: z.lazy(() => PrometheusAuth2$outboundSchema).optional(),
  lokiAuth: z.lazy(() => LokiAuth2$outboundSchema).optional(),
  metadata: z.array(z.lazy(() => InputGrafanaMetadatum2$outboundSchema))
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaGrafana2$ {
  /** @deprecated use `InputGrafanaGrafana2$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaGrafana2$inboundSchema;
  /** @deprecated use `InputGrafanaGrafana2$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaGrafana2$outboundSchema;
  /** @deprecated use `InputGrafanaGrafana2$Outbound` instead. */
  export type Outbound = InputGrafanaGrafana2$Outbound;
}

export function inputGrafanaGrafana2ToJSON(
  inputGrafanaGrafana2: InputGrafanaGrafana2,
): string {
  return JSON.stringify(
    InputGrafanaGrafana2$outboundSchema.parse(inputGrafanaGrafana2),
  );
}

export function inputGrafanaGrafana2FromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaGrafana2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafanaGrafana2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaGrafana2' from JSON`,
  );
}

/** @internal */
export const InputGrafanaType1$inboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaType1
> = z.nativeEnum(InputGrafanaType1);

/** @internal */
export const InputGrafanaType1$outboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaType1
> = InputGrafanaType1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaType1$ {
  /** @deprecated use `InputGrafanaType1$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaType1$inboundSchema;
  /** @deprecated use `InputGrafanaType1$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaType1$outboundSchema;
}

/** @internal */
export const InputGrafanaConnection1$inboundSchema: z.ZodType<
  InputGrafanaConnection1,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputGrafanaConnection1$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputGrafanaConnection1$outboundSchema: z.ZodType<
  InputGrafanaConnection1$Outbound,
  z.ZodTypeDef,
  InputGrafanaConnection1
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaConnection1$ {
  /** @deprecated use `InputGrafanaConnection1$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaConnection1$inboundSchema;
  /** @deprecated use `InputGrafanaConnection1$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaConnection1$outboundSchema;
  /** @deprecated use `InputGrafanaConnection1$Outbound` instead. */
  export type Outbound = InputGrafanaConnection1$Outbound;
}

export function inputGrafanaConnection1ToJSON(
  inputGrafanaConnection1: InputGrafanaConnection1,
): string {
  return JSON.stringify(
    InputGrafanaConnection1$outboundSchema.parse(inputGrafanaConnection1),
  );
}

export function inputGrafanaConnection1FromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaConnection1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafanaConnection1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaConnection1' from JSON`,
  );
}

/** @internal */
export const InputGrafanaMode1$inboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaMode1
> = z.nativeEnum(InputGrafanaMode1);

/** @internal */
export const InputGrafanaMode1$outboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaMode1
> = InputGrafanaMode1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaMode1$ {
  /** @deprecated use `InputGrafanaMode1$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaMode1$inboundSchema;
  /** @deprecated use `InputGrafanaMode1$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaMode1$outboundSchema;
}

/** @internal */
export const InputGrafanaCompression1$inboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaCompression1
> = z.nativeEnum(InputGrafanaCompression1);

/** @internal */
export const InputGrafanaCompression1$outboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaCompression1
> = InputGrafanaCompression1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaCompression1$ {
  /** @deprecated use `InputGrafanaCompression1$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaCompression1$inboundSchema;
  /** @deprecated use `InputGrafanaCompression1$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaCompression1$outboundSchema;
}

/** @internal */
export const InputGrafanaPq1$inboundSchema: z.ZodType<
  InputGrafanaPq1,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputGrafanaMode1$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputGrafanaCompression1$inboundSchema.default("none"),
});

/** @internal */
export type InputGrafanaPq1$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputGrafanaPq1$outboundSchema: z.ZodType<
  InputGrafanaPq1$Outbound,
  z.ZodTypeDef,
  InputGrafanaPq1
> = z.object({
  mode: InputGrafanaMode1$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputGrafanaCompression1$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaPq1$ {
  /** @deprecated use `InputGrafanaPq1$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaPq1$inboundSchema;
  /** @deprecated use `InputGrafanaPq1$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaPq1$outboundSchema;
  /** @deprecated use `InputGrafanaPq1$Outbound` instead. */
  export type Outbound = InputGrafanaPq1$Outbound;
}

export function inputGrafanaPq1ToJSON(
  inputGrafanaPq1: InputGrafanaPq1,
): string {
  return JSON.stringify(InputGrafanaPq1$outboundSchema.parse(inputGrafanaPq1));
}

export function inputGrafanaPq1FromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaPq1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafanaPq1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaPq1' from JSON`,
  );
}

/** @internal */
export const InputGrafanaMinimumTLSVersion1$inboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaMinimumTLSVersion1
> = z.nativeEnum(InputGrafanaMinimumTLSVersion1);

/** @internal */
export const InputGrafanaMinimumTLSVersion1$outboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaMinimumTLSVersion1
> = InputGrafanaMinimumTLSVersion1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaMinimumTLSVersion1$ {
  /** @deprecated use `InputGrafanaMinimumTLSVersion1$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaMinimumTLSVersion1$inboundSchema;
  /** @deprecated use `InputGrafanaMinimumTLSVersion1$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaMinimumTLSVersion1$outboundSchema;
}

/** @internal */
export const InputGrafanaMaximumTLSVersion1$inboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaMaximumTLSVersion1
> = z.nativeEnum(InputGrafanaMaximumTLSVersion1);

/** @internal */
export const InputGrafanaMaximumTLSVersion1$outboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaMaximumTLSVersion1
> = InputGrafanaMaximumTLSVersion1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaMaximumTLSVersion1$ {
  /** @deprecated use `InputGrafanaMaximumTLSVersion1$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaMaximumTLSVersion1$inboundSchema;
  /** @deprecated use `InputGrafanaMaximumTLSVersion1$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaMaximumTLSVersion1$outboundSchema;
}

/** @internal */
export const InputGrafanaTLSSettingsServerSide1$inboundSchema: z.ZodType<
  InputGrafanaTLSSettingsServerSide1,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputGrafanaMinimumTLSVersion1$inboundSchema.optional(),
  maxVersion: InputGrafanaMaximumTLSVersion1$inboundSchema.optional(),
});

/** @internal */
export type InputGrafanaTLSSettingsServerSide1$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputGrafanaTLSSettingsServerSide1$outboundSchema: z.ZodType<
  InputGrafanaTLSSettingsServerSide1$Outbound,
  z.ZodTypeDef,
  InputGrafanaTLSSettingsServerSide1
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputGrafanaMinimumTLSVersion1$outboundSchema.optional(),
  maxVersion: InputGrafanaMaximumTLSVersion1$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaTLSSettingsServerSide1$ {
  /** @deprecated use `InputGrafanaTLSSettingsServerSide1$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaTLSSettingsServerSide1$inboundSchema;
  /** @deprecated use `InputGrafanaTLSSettingsServerSide1$outboundSchema` instead. */
  export const outboundSchema =
    InputGrafanaTLSSettingsServerSide1$outboundSchema;
  /** @deprecated use `InputGrafanaTLSSettingsServerSide1$Outbound` instead. */
  export type Outbound = InputGrafanaTLSSettingsServerSide1$Outbound;
}

export function inputGrafanaTLSSettingsServerSide1ToJSON(
  inputGrafanaTLSSettingsServerSide1: InputGrafanaTLSSettingsServerSide1,
): string {
  return JSON.stringify(
    InputGrafanaTLSSettingsServerSide1$outboundSchema.parse(
      inputGrafanaTLSSettingsServerSide1,
    ),
  );
}

export function inputGrafanaTLSSettingsServerSide1FromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaTLSSettingsServerSide1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      InputGrafanaTLSSettingsServerSide1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaTLSSettingsServerSide1' from JSON`,
  );
}

/** @internal */
export const PrometheusAuthAuthenticationType1$inboundSchema: z.ZodNativeEnum<
  typeof PrometheusAuthAuthenticationType1
> = z.nativeEnum(PrometheusAuthAuthenticationType1);

/** @internal */
export const PrometheusAuthAuthenticationType1$outboundSchema: z.ZodNativeEnum<
  typeof PrometheusAuthAuthenticationType1
> = PrometheusAuthAuthenticationType1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrometheusAuthAuthenticationType1$ {
  /** @deprecated use `PrometheusAuthAuthenticationType1$inboundSchema` instead. */
  export const inboundSchema = PrometheusAuthAuthenticationType1$inboundSchema;
  /** @deprecated use `PrometheusAuthAuthenticationType1$outboundSchema` instead. */
  export const outboundSchema =
    PrometheusAuthAuthenticationType1$outboundSchema;
}

/** @internal */
export const PrometheusAuthOauthParam1$inboundSchema: z.ZodType<
  PrometheusAuthOauthParam1,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type PrometheusAuthOauthParam1$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const PrometheusAuthOauthParam1$outboundSchema: z.ZodType<
  PrometheusAuthOauthParam1$Outbound,
  z.ZodTypeDef,
  PrometheusAuthOauthParam1
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrometheusAuthOauthParam1$ {
  /** @deprecated use `PrometheusAuthOauthParam1$inboundSchema` instead. */
  export const inboundSchema = PrometheusAuthOauthParam1$inboundSchema;
  /** @deprecated use `PrometheusAuthOauthParam1$outboundSchema` instead. */
  export const outboundSchema = PrometheusAuthOauthParam1$outboundSchema;
  /** @deprecated use `PrometheusAuthOauthParam1$Outbound` instead. */
  export type Outbound = PrometheusAuthOauthParam1$Outbound;
}

export function prometheusAuthOauthParam1ToJSON(
  prometheusAuthOauthParam1: PrometheusAuthOauthParam1,
): string {
  return JSON.stringify(
    PrometheusAuthOauthParam1$outboundSchema.parse(prometheusAuthOauthParam1),
  );
}

export function prometheusAuthOauthParam1FromJSON(
  jsonString: string,
): SafeParseResult<PrometheusAuthOauthParam1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrometheusAuthOauthParam1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrometheusAuthOauthParam1' from JSON`,
  );
}

/** @internal */
export const PrometheusAuthOauthHeader1$inboundSchema: z.ZodType<
  PrometheusAuthOauthHeader1,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type PrometheusAuthOauthHeader1$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const PrometheusAuthOauthHeader1$outboundSchema: z.ZodType<
  PrometheusAuthOauthHeader1$Outbound,
  z.ZodTypeDef,
  PrometheusAuthOauthHeader1
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrometheusAuthOauthHeader1$ {
  /** @deprecated use `PrometheusAuthOauthHeader1$inboundSchema` instead. */
  export const inboundSchema = PrometheusAuthOauthHeader1$inboundSchema;
  /** @deprecated use `PrometheusAuthOauthHeader1$outboundSchema` instead. */
  export const outboundSchema = PrometheusAuthOauthHeader1$outboundSchema;
  /** @deprecated use `PrometheusAuthOauthHeader1$Outbound` instead. */
  export type Outbound = PrometheusAuthOauthHeader1$Outbound;
}

export function prometheusAuthOauthHeader1ToJSON(
  prometheusAuthOauthHeader1: PrometheusAuthOauthHeader1,
): string {
  return JSON.stringify(
    PrometheusAuthOauthHeader1$outboundSchema.parse(prometheusAuthOauthHeader1),
  );
}

export function prometheusAuthOauthHeader1FromJSON(
  jsonString: string,
): SafeParseResult<PrometheusAuthOauthHeader1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrometheusAuthOauthHeader1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrometheusAuthOauthHeader1' from JSON`,
  );
}

/** @internal */
export const PrometheusAuth1$inboundSchema: z.ZodType<
  PrometheusAuth1,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: PrometheusAuthAuthenticationType1$inboundSchema.default("none"),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => PrometheusAuthOauthParam1$inboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => PrometheusAuthOauthHeader1$inboundSchema))
    .optional(),
});

/** @internal */
export type PrometheusAuth1$Outbound = {
  authType: string;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<PrometheusAuthOauthParam1$Outbound> | undefined;
  oauthHeaders?: Array<PrometheusAuthOauthHeader1$Outbound> | undefined;
};

/** @internal */
export const PrometheusAuth1$outboundSchema: z.ZodType<
  PrometheusAuth1$Outbound,
  z.ZodTypeDef,
  PrometheusAuth1
> = z.object({
  authType: PrometheusAuthAuthenticationType1$outboundSchema.default("none"),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => PrometheusAuthOauthParam1$outboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => PrometheusAuthOauthHeader1$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrometheusAuth1$ {
  /** @deprecated use `PrometheusAuth1$inboundSchema` instead. */
  export const inboundSchema = PrometheusAuth1$inboundSchema;
  /** @deprecated use `PrometheusAuth1$outboundSchema` instead. */
  export const outboundSchema = PrometheusAuth1$outboundSchema;
  /** @deprecated use `PrometheusAuth1$Outbound` instead. */
  export type Outbound = PrometheusAuth1$Outbound;
}

export function prometheusAuth1ToJSON(
  prometheusAuth1: PrometheusAuth1,
): string {
  return JSON.stringify(PrometheusAuth1$outboundSchema.parse(prometheusAuth1));
}

export function prometheusAuth1FromJSON(
  jsonString: string,
): SafeParseResult<PrometheusAuth1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrometheusAuth1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrometheusAuth1' from JSON`,
  );
}

/** @internal */
export const LokiAuthAuthenticationType1$inboundSchema: z.ZodNativeEnum<
  typeof LokiAuthAuthenticationType1
> = z.nativeEnum(LokiAuthAuthenticationType1);

/** @internal */
export const LokiAuthAuthenticationType1$outboundSchema: z.ZodNativeEnum<
  typeof LokiAuthAuthenticationType1
> = LokiAuthAuthenticationType1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LokiAuthAuthenticationType1$ {
  /** @deprecated use `LokiAuthAuthenticationType1$inboundSchema` instead. */
  export const inboundSchema = LokiAuthAuthenticationType1$inboundSchema;
  /** @deprecated use `LokiAuthAuthenticationType1$outboundSchema` instead. */
  export const outboundSchema = LokiAuthAuthenticationType1$outboundSchema;
}

/** @internal */
export const LokiAuthOauthParam1$inboundSchema: z.ZodType<
  LokiAuthOauthParam1,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type LokiAuthOauthParam1$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const LokiAuthOauthParam1$outboundSchema: z.ZodType<
  LokiAuthOauthParam1$Outbound,
  z.ZodTypeDef,
  LokiAuthOauthParam1
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LokiAuthOauthParam1$ {
  /** @deprecated use `LokiAuthOauthParam1$inboundSchema` instead. */
  export const inboundSchema = LokiAuthOauthParam1$inboundSchema;
  /** @deprecated use `LokiAuthOauthParam1$outboundSchema` instead. */
  export const outboundSchema = LokiAuthOauthParam1$outboundSchema;
  /** @deprecated use `LokiAuthOauthParam1$Outbound` instead. */
  export type Outbound = LokiAuthOauthParam1$Outbound;
}

export function lokiAuthOauthParam1ToJSON(
  lokiAuthOauthParam1: LokiAuthOauthParam1,
): string {
  return JSON.stringify(
    LokiAuthOauthParam1$outboundSchema.parse(lokiAuthOauthParam1),
  );
}

export function lokiAuthOauthParam1FromJSON(
  jsonString: string,
): SafeParseResult<LokiAuthOauthParam1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LokiAuthOauthParam1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LokiAuthOauthParam1' from JSON`,
  );
}

/** @internal */
export const LokiAuthOauthHeader1$inboundSchema: z.ZodType<
  LokiAuthOauthHeader1,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type LokiAuthOauthHeader1$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const LokiAuthOauthHeader1$outboundSchema: z.ZodType<
  LokiAuthOauthHeader1$Outbound,
  z.ZodTypeDef,
  LokiAuthOauthHeader1
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LokiAuthOauthHeader1$ {
  /** @deprecated use `LokiAuthOauthHeader1$inboundSchema` instead. */
  export const inboundSchema = LokiAuthOauthHeader1$inboundSchema;
  /** @deprecated use `LokiAuthOauthHeader1$outboundSchema` instead. */
  export const outboundSchema = LokiAuthOauthHeader1$outboundSchema;
  /** @deprecated use `LokiAuthOauthHeader1$Outbound` instead. */
  export type Outbound = LokiAuthOauthHeader1$Outbound;
}

export function lokiAuthOauthHeader1ToJSON(
  lokiAuthOauthHeader1: LokiAuthOauthHeader1,
): string {
  return JSON.stringify(
    LokiAuthOauthHeader1$outboundSchema.parse(lokiAuthOauthHeader1),
  );
}

export function lokiAuthOauthHeader1FromJSON(
  jsonString: string,
): SafeParseResult<LokiAuthOauthHeader1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LokiAuthOauthHeader1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LokiAuthOauthHeader1' from JSON`,
  );
}

/** @internal */
export const LokiAuth1$inboundSchema: z.ZodType<
  LokiAuth1,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: LokiAuthAuthenticationType1$inboundSchema.default("none"),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => LokiAuthOauthParam1$inboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => LokiAuthOauthHeader1$inboundSchema))
    .optional(),
});

/** @internal */
export type LokiAuth1$Outbound = {
  authType: string;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<LokiAuthOauthParam1$Outbound> | undefined;
  oauthHeaders?: Array<LokiAuthOauthHeader1$Outbound> | undefined;
};

/** @internal */
export const LokiAuth1$outboundSchema: z.ZodType<
  LokiAuth1$Outbound,
  z.ZodTypeDef,
  LokiAuth1
> = z.object({
  authType: LokiAuthAuthenticationType1$outboundSchema.default("none"),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => LokiAuthOauthParam1$outboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => LokiAuthOauthHeader1$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LokiAuth1$ {
  /** @deprecated use `LokiAuth1$inboundSchema` instead. */
  export const inboundSchema = LokiAuth1$inboundSchema;
  /** @deprecated use `LokiAuth1$outboundSchema` instead. */
  export const outboundSchema = LokiAuth1$outboundSchema;
  /** @deprecated use `LokiAuth1$Outbound` instead. */
  export type Outbound = LokiAuth1$Outbound;
}

export function lokiAuth1ToJSON(lokiAuth1: LokiAuth1): string {
  return JSON.stringify(LokiAuth1$outboundSchema.parse(lokiAuth1));
}

export function lokiAuth1FromJSON(
  jsonString: string,
): SafeParseResult<LokiAuth1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LokiAuth1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LokiAuth1' from JSON`,
  );
}

/** @internal */
export const InputGrafanaMetadatum1$inboundSchema: z.ZodType<
  InputGrafanaMetadatum1,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputGrafanaMetadatum1$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputGrafanaMetadatum1$outboundSchema: z.ZodType<
  InputGrafanaMetadatum1$Outbound,
  z.ZodTypeDef,
  InputGrafanaMetadatum1
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaMetadatum1$ {
  /** @deprecated use `InputGrafanaMetadatum1$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaMetadatum1$inboundSchema;
  /** @deprecated use `InputGrafanaMetadatum1$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaMetadatum1$outboundSchema;
  /** @deprecated use `InputGrafanaMetadatum1$Outbound` instead. */
  export type Outbound = InputGrafanaMetadatum1$Outbound;
}

export function inputGrafanaMetadatum1ToJSON(
  inputGrafanaMetadatum1: InputGrafanaMetadatum1,
): string {
  return JSON.stringify(
    InputGrafanaMetadatum1$outboundSchema.parse(inputGrafanaMetadatum1),
  );
}

export function inputGrafanaMetadatum1FromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaMetadatum1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafanaMetadatum1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaMetadatum1' from JSON`,
  );
}

/** @internal */
export const InputGrafanaGrafana1$inboundSchema: z.ZodType<
  InputGrafanaGrafana1,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputGrafanaType1$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputGrafanaConnection1$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputGrafanaPq1$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputGrafanaTLSSettingsServerSide1$inboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  prometheusAPI: z.string().default("/api/prom/push"),
  lokiAPI: z.string().default("/loki/api/v1/push"),
  prometheusAuth: z.lazy(() => PrometheusAuth1$inboundSchema).optional(),
  lokiAuth: z.lazy(() => LokiAuth1$inboundSchema).optional(),
  metadata: z.array(z.lazy(() => InputGrafanaMetadatum1$inboundSchema))
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputGrafanaGrafana1$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputGrafanaConnection1$Outbound> | undefined;
  pq?: InputGrafanaPq1$Outbound | undefined;
  host: string;
  port: number;
  tls?: InputGrafanaTLSSettingsServerSide1$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  prometheusAPI: string;
  lokiAPI: string;
  prometheusAuth?: PrometheusAuth1$Outbound | undefined;
  lokiAuth?: LokiAuth1$Outbound | undefined;
  metadata?: Array<InputGrafanaMetadatum1$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputGrafanaGrafana1$outboundSchema: z.ZodType<
  InputGrafanaGrafana1$Outbound,
  z.ZodTypeDef,
  InputGrafanaGrafana1
> = z.object({
  id: z.string(),
  type: InputGrafanaType1$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputGrafanaConnection1$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputGrafanaPq1$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputGrafanaTLSSettingsServerSide1$outboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  prometheusAPI: z.string().default("/api/prom/push"),
  lokiAPI: z.string().default("/loki/api/v1/push"),
  prometheusAuth: z.lazy(() => PrometheusAuth1$outboundSchema).optional(),
  lokiAuth: z.lazy(() => LokiAuth1$outboundSchema).optional(),
  metadata: z.array(z.lazy(() => InputGrafanaMetadatum1$outboundSchema))
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaGrafana1$ {
  /** @deprecated use `InputGrafanaGrafana1$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaGrafana1$inboundSchema;
  /** @deprecated use `InputGrafanaGrafana1$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaGrafana1$outboundSchema;
  /** @deprecated use `InputGrafanaGrafana1$Outbound` instead. */
  export type Outbound = InputGrafanaGrafana1$Outbound;
}

export function inputGrafanaGrafana1ToJSON(
  inputGrafanaGrafana1: InputGrafanaGrafana1,
): string {
  return JSON.stringify(
    InputGrafanaGrafana1$outboundSchema.parse(inputGrafanaGrafana1),
  );
}

export function inputGrafanaGrafana1FromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaGrafana1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafanaGrafana1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaGrafana1' from JSON`,
  );
}

/** @internal */
export const InputGrafana$inboundSchema: z.ZodType<
  InputGrafana,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => InputGrafanaGrafana1$inboundSchema),
  z.lazy(() => InputGrafanaGrafana2$inboundSchema),
]);

/** @internal */
export type InputGrafana$Outbound =
  | InputGrafanaGrafana1$Outbound
  | InputGrafanaGrafana2$Outbound;

/** @internal */
export const InputGrafana$outboundSchema: z.ZodType<
  InputGrafana$Outbound,
  z.ZodTypeDef,
  InputGrafana
> = z.union([
  z.lazy(() => InputGrafanaGrafana1$outboundSchema),
  z.lazy(() => InputGrafanaGrafana2$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafana$ {
  /** @deprecated use `InputGrafana$inboundSchema` instead. */
  export const inboundSchema = InputGrafana$inboundSchema;
  /** @deprecated use `InputGrafana$outboundSchema` instead. */
  export const outboundSchema = InputGrafana$outboundSchema;
  /** @deprecated use `InputGrafana$Outbound` instead. */
  export type Outbound = InputGrafana$Outbound;
}

export function inputGrafanaToJSON(inputGrafana: InputGrafana): string {
  return JSON.stringify(InputGrafana$outboundSchema.parse(inputGrafana));
}

export function inputGrafanaFromJSON(
  jsonString: string,
): SafeParseResult<InputGrafana, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafana$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafana' from JSON`,
  );
}

/** @internal */
export const CreateInputTypeConfluentCloud$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeConfluentCloud
> = z.nativeEnum(CreateInputTypeConfluentCloud);

/** @internal */
export const CreateInputTypeConfluentCloud$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeConfluentCloud
> = CreateInputTypeConfluentCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputTypeConfluentCloud$ {
  /** @deprecated use `CreateInputTypeConfluentCloud$inboundSchema` instead. */
  export const inboundSchema = CreateInputTypeConfluentCloud$inboundSchema;
  /** @deprecated use `CreateInputTypeConfluentCloud$outboundSchema` instead. */
  export const outboundSchema = CreateInputTypeConfluentCloud$outboundSchema;
}

/** @internal */
export const ConnectionConfluentCloud$inboundSchema: z.ZodType<
  ConnectionConfluentCloud,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionConfluentCloud$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionConfluentCloud$outboundSchema: z.ZodType<
  ConnectionConfluentCloud$Outbound,
  z.ZodTypeDef,
  ConnectionConfluentCloud
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionConfluentCloud$ {
  /** @deprecated use `ConnectionConfluentCloud$inboundSchema` instead. */
  export const inboundSchema = ConnectionConfluentCloud$inboundSchema;
  /** @deprecated use `ConnectionConfluentCloud$outboundSchema` instead. */
  export const outboundSchema = ConnectionConfluentCloud$outboundSchema;
  /** @deprecated use `ConnectionConfluentCloud$Outbound` instead. */
  export type Outbound = ConnectionConfluentCloud$Outbound;
}

export function connectionConfluentCloudToJSON(
  connectionConfluentCloud: ConnectionConfluentCloud,
): string {
  return JSON.stringify(
    ConnectionConfluentCloud$outboundSchema.parse(connectionConfluentCloud),
  );
}

export function connectionConfluentCloudFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionConfluentCloud, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionConfluentCloud$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionConfluentCloud' from JSON`,
  );
}

/** @internal */
export const CreateInputModeConfluentCloud$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputModeConfluentCloud
> = z.nativeEnum(CreateInputModeConfluentCloud);

/** @internal */
export const CreateInputModeConfluentCloud$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputModeConfluentCloud
> = CreateInputModeConfluentCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputModeConfluentCloud$ {
  /** @deprecated use `CreateInputModeConfluentCloud$inboundSchema` instead. */
  export const inboundSchema = CreateInputModeConfluentCloud$inboundSchema;
  /** @deprecated use `CreateInputModeConfluentCloud$outboundSchema` instead. */
  export const outboundSchema = CreateInputModeConfluentCloud$outboundSchema;
}

/** @internal */
export const PqCompressionConfluentCloud$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressionConfluentCloud
> = z.nativeEnum(PqCompressionConfluentCloud);

/** @internal */
export const PqCompressionConfluentCloud$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressionConfluentCloud
> = PqCompressionConfluentCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressionConfluentCloud$ {
  /** @deprecated use `PqCompressionConfluentCloud$inboundSchema` instead. */
  export const inboundSchema = PqCompressionConfluentCloud$inboundSchema;
  /** @deprecated use `PqCompressionConfluentCloud$outboundSchema` instead. */
  export const outboundSchema = PqCompressionConfluentCloud$outboundSchema;
}

/** @internal */
export const PqConfluentCloud$inboundSchema: z.ZodType<
  PqConfluentCloud,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: CreateInputModeConfluentCloud$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: PqCompressionConfluentCloud$inboundSchema.default("none"),
});

/** @internal */
export type PqConfluentCloud$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqConfluentCloud$outboundSchema: z.ZodType<
  PqConfluentCloud$Outbound,
  z.ZodTypeDef,
  PqConfluentCloud
> = z.object({
  mode: CreateInputModeConfluentCloud$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: PqCompressionConfluentCloud$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqConfluentCloud$ {
  /** @deprecated use `PqConfluentCloud$inboundSchema` instead. */
  export const inboundSchema = PqConfluentCloud$inboundSchema;
  /** @deprecated use `PqConfluentCloud$outboundSchema` instead. */
  export const outboundSchema = PqConfluentCloud$outboundSchema;
  /** @deprecated use `PqConfluentCloud$Outbound` instead. */
  export type Outbound = PqConfluentCloud$Outbound;
}

export function pqConfluentCloudToJSON(
  pqConfluentCloud: PqConfluentCloud,
): string {
  return JSON.stringify(
    PqConfluentCloud$outboundSchema.parse(pqConfluentCloud),
  );
}

export function pqConfluentCloudFromJSON(
  jsonString: string,
): SafeParseResult<PqConfluentCloud, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqConfluentCloud$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqConfluentCloud' from JSON`,
  );
}

/** @internal */
export const CreateInputMinimumTLSVersionConfluentCloud$inboundSchema:
  z.ZodNativeEnum<typeof CreateInputMinimumTLSVersionConfluentCloud> = z
    .nativeEnum(CreateInputMinimumTLSVersionConfluentCloud);

/** @internal */
export const CreateInputMinimumTLSVersionConfluentCloud$outboundSchema:
  z.ZodNativeEnum<typeof CreateInputMinimumTLSVersionConfluentCloud> =
    CreateInputMinimumTLSVersionConfluentCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputMinimumTLSVersionConfluentCloud$ {
  /** @deprecated use `CreateInputMinimumTLSVersionConfluentCloud$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputMinimumTLSVersionConfluentCloud$inboundSchema;
  /** @deprecated use `CreateInputMinimumTLSVersionConfluentCloud$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputMinimumTLSVersionConfluentCloud$outboundSchema;
}

/** @internal */
export const CreateInputMaximumTLSVersionConfluentCloud$inboundSchema:
  z.ZodNativeEnum<typeof CreateInputMaximumTLSVersionConfluentCloud> = z
    .nativeEnum(CreateInputMaximumTLSVersionConfluentCloud);

/** @internal */
export const CreateInputMaximumTLSVersionConfluentCloud$outboundSchema:
  z.ZodNativeEnum<typeof CreateInputMaximumTLSVersionConfluentCloud> =
    CreateInputMaximumTLSVersionConfluentCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputMaximumTLSVersionConfluentCloud$ {
  /** @deprecated use `CreateInputMaximumTLSVersionConfluentCloud$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputMaximumTLSVersionConfluentCloud$inboundSchema;
  /** @deprecated use `CreateInputMaximumTLSVersionConfluentCloud$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputMaximumTLSVersionConfluentCloud$outboundSchema;
}

/** @internal */
export const CreateInputTLSSettingsClientSideConfluentCloud$inboundSchema:
  z.ZodType<
    CreateInputTLSSettingsClientSideConfluentCloud,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(false),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion: CreateInputMinimumTLSVersionConfluentCloud$inboundSchema
      .optional(),
    maxVersion: CreateInputMaximumTLSVersionConfluentCloud$inboundSchema
      .optional(),
  });

/** @internal */
export type CreateInputTLSSettingsClientSideConfluentCloud$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const CreateInputTLSSettingsClientSideConfluentCloud$outboundSchema:
  z.ZodType<
    CreateInputTLSSettingsClientSideConfluentCloud$Outbound,
    z.ZodTypeDef,
    CreateInputTLSSettingsClientSideConfluentCloud
  > = z.object({
    disabled: z.boolean().default(false),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion: CreateInputMinimumTLSVersionConfluentCloud$outboundSchema
      .optional(),
    maxVersion: CreateInputMaximumTLSVersionConfluentCloud$outboundSchema
      .optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputTLSSettingsClientSideConfluentCloud$ {
  /** @deprecated use `CreateInputTLSSettingsClientSideConfluentCloud$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputTLSSettingsClientSideConfluentCloud$inboundSchema;
  /** @deprecated use `CreateInputTLSSettingsClientSideConfluentCloud$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputTLSSettingsClientSideConfluentCloud$outboundSchema;
  /** @deprecated use `CreateInputTLSSettingsClientSideConfluentCloud$Outbound` instead. */
  export type Outbound =
    CreateInputTLSSettingsClientSideConfluentCloud$Outbound;
}

export function createInputTLSSettingsClientSideConfluentCloudToJSON(
  createInputTLSSettingsClientSideConfluentCloud:
    CreateInputTLSSettingsClientSideConfluentCloud,
): string {
  return JSON.stringify(
    CreateInputTLSSettingsClientSideConfluentCloud$outboundSchema.parse(
      createInputTLSSettingsClientSideConfluentCloud,
    ),
  );
}

export function createInputTLSSettingsClientSideConfluentCloudFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateInputTLSSettingsClientSideConfluentCloud,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateInputTLSSettingsClientSideConfluentCloud$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateInputTLSSettingsClientSideConfluentCloud' from JSON`,
  );
}

/** @internal */
export const CreateInputAuthConfluentCloud$inboundSchema: z.ZodType<
  CreateInputAuthConfluentCloud,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/** @internal */
export type CreateInputAuthConfluentCloud$Outbound = {
  disabled: boolean;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const CreateInputAuthConfluentCloud$outboundSchema: z.ZodType<
  CreateInputAuthConfluentCloud$Outbound,
  z.ZodTypeDef,
  CreateInputAuthConfluentCloud
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputAuthConfluentCloud$ {
  /** @deprecated use `CreateInputAuthConfluentCloud$inboundSchema` instead. */
  export const inboundSchema = CreateInputAuthConfluentCloud$inboundSchema;
  /** @deprecated use `CreateInputAuthConfluentCloud$outboundSchema` instead. */
  export const outboundSchema = CreateInputAuthConfluentCloud$outboundSchema;
  /** @deprecated use `CreateInputAuthConfluentCloud$Outbound` instead. */
  export type Outbound = CreateInputAuthConfluentCloud$Outbound;
}

export function createInputAuthConfluentCloudToJSON(
  createInputAuthConfluentCloud: CreateInputAuthConfluentCloud,
): string {
  return JSON.stringify(
    CreateInputAuthConfluentCloud$outboundSchema.parse(
      createInputAuthConfluentCloud,
    ),
  );
}

export function createInputAuthConfluentCloudFromJSON(
  jsonString: string,
): SafeParseResult<CreateInputAuthConfluentCloud, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateInputAuthConfluentCloud$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateInputAuthConfluentCloud' from JSON`,
  );
}

/** @internal */
export const CreateInputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateInputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud
  > = z.nativeEnum(
    CreateInputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud,
  );

/** @internal */
export const CreateInputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateInputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud
  > =
    CreateInputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud$ {
  /** @deprecated use `CreateInputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud$inboundSchema;
  /** @deprecated use `CreateInputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud$outboundSchema;
}

/** @internal */
export const CreateInputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateInputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud
  > = z.nativeEnum(
    CreateInputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud,
  );

/** @internal */
export const CreateInputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateInputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud
  > =
    CreateInputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud$ {
  /** @deprecated use `CreateInputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud$inboundSchema;
  /** @deprecated use `CreateInputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud$outboundSchema;
}

/** @internal */
export const CreateInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$inboundSchema:
  z.ZodType<
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion:
      CreateInputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud$inboundSchema
        .optional(),
    maxVersion:
      CreateInputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud$inboundSchema
        .optional(),
  });

/** @internal */
export type CreateInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$Outbound =
  {
    disabled: boolean;
    rejectUnauthorized: boolean;
    servername?: string | undefined;
    certificateName?: string | undefined;
    caPath?: string | undefined;
    privKeyPath?: string | undefined;
    certPath?: string | undefined;
    passphrase?: string | undefined;
    minVersion?: string | undefined;
    maxVersion?: string | undefined;
  };

/** @internal */
export const CreateInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$outboundSchema:
  z.ZodType<
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$Outbound,
    z.ZodTypeDef,
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion:
      CreateInputKafkaSchemaRegistryMinimumTLSVersionConfluentCloud$outboundSchema
        .optional(),
    maxVersion:
      CreateInputKafkaSchemaRegistryMaximumTLSVersionConfluentCloud$outboundSchema
        .optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$ {
  /** @deprecated use `CreateInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$inboundSchema;
  /** @deprecated use `CreateInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$outboundSchema;
  /** @deprecated use `CreateInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$Outbound` instead. */
  export type Outbound =
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$Outbound;
}

export function createInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloudToJSON(
  createInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud:
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud,
): string {
  return JSON.stringify(
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$outboundSchema
      .parse(createInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud),
  );
}

export function createInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloudFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud' from JSON`,
  );
}

/** @internal */
export const CreateInputKafkaSchemaRegistryAuthenticationConfluentCloud$inboundSchema:
  z.ZodType<
    CreateInputKafkaSchemaRegistryAuthenticationConfluentCloud,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    schemaRegistryURL: z.string().default("http://localhost:8081"),
    connectionTimeout: z.number().default(30000),
    requestTimeout: z.number().default(30000),
    maxRetries: z.number().default(1),
    auth: z.lazy(() => CreateInputAuthConfluentCloud$inboundSchema).optional(),
    tls: z.lazy(() =>
      CreateInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$inboundSchema
    ).optional(),
  });

/** @internal */
export type CreateInputKafkaSchemaRegistryAuthenticationConfluentCloud$Outbound =
  {
    disabled: boolean;
    schemaRegistryURL: string;
    connectionTimeout: number;
    requestTimeout: number;
    maxRetries: number;
    auth?: CreateInputAuthConfluentCloud$Outbound | undefined;
    tls?:
      | CreateInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$Outbound
      | undefined;
  };

/** @internal */
export const CreateInputKafkaSchemaRegistryAuthenticationConfluentCloud$outboundSchema:
  z.ZodType<
    CreateInputKafkaSchemaRegistryAuthenticationConfluentCloud$Outbound,
    z.ZodTypeDef,
    CreateInputKafkaSchemaRegistryAuthenticationConfluentCloud
  > = z.object({
    disabled: z.boolean().default(true),
    schemaRegistryURL: z.string().default("http://localhost:8081"),
    connectionTimeout: z.number().default(30000),
    requestTimeout: z.number().default(30000),
    maxRetries: z.number().default(1),
    auth: z.lazy(() => CreateInputAuthConfluentCloud$outboundSchema).optional(),
    tls: z.lazy(() =>
      CreateInputKafkaSchemaRegistryTLSSettingsClientSideConfluentCloud$outboundSchema
    ).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputKafkaSchemaRegistryAuthenticationConfluentCloud$ {
  /** @deprecated use `CreateInputKafkaSchemaRegistryAuthenticationConfluentCloud$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputKafkaSchemaRegistryAuthenticationConfluentCloud$inboundSchema;
  /** @deprecated use `CreateInputKafkaSchemaRegistryAuthenticationConfluentCloud$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputKafkaSchemaRegistryAuthenticationConfluentCloud$outboundSchema;
  /** @deprecated use `CreateInputKafkaSchemaRegistryAuthenticationConfluentCloud$Outbound` instead. */
  export type Outbound =
    CreateInputKafkaSchemaRegistryAuthenticationConfluentCloud$Outbound;
}

export function createInputKafkaSchemaRegistryAuthenticationConfluentCloudToJSON(
  createInputKafkaSchemaRegistryAuthenticationConfluentCloud:
    CreateInputKafkaSchemaRegistryAuthenticationConfluentCloud,
): string {
  return JSON.stringify(
    CreateInputKafkaSchemaRegistryAuthenticationConfluentCloud$outboundSchema
      .parse(createInputKafkaSchemaRegistryAuthenticationConfluentCloud),
  );
}

export function createInputKafkaSchemaRegistryAuthenticationConfluentCloudFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateInputKafkaSchemaRegistryAuthenticationConfluentCloud,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateInputKafkaSchemaRegistryAuthenticationConfluentCloud$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateInputKafkaSchemaRegistryAuthenticationConfluentCloud' from JSON`,
  );
}

/** @internal */
export const CreateInputSASLMechanismConfluentCloud$inboundSchema:
  z.ZodNativeEnum<typeof CreateInputSASLMechanismConfluentCloud> = z.nativeEnum(
    CreateInputSASLMechanismConfluentCloud,
  );

/** @internal */
export const CreateInputSASLMechanismConfluentCloud$outboundSchema:
  z.ZodNativeEnum<typeof CreateInputSASLMechanismConfluentCloud> =
    CreateInputSASLMechanismConfluentCloud$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputSASLMechanismConfluentCloud$ {
  /** @deprecated use `CreateInputSASLMechanismConfluentCloud$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputSASLMechanismConfluentCloud$inboundSchema;
  /** @deprecated use `CreateInputSASLMechanismConfluentCloud$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputSASLMechanismConfluentCloud$outboundSchema;
}

/** @internal */
export const CreateInputAuthenticationConfluentCloud$inboundSchema: z.ZodType<
  CreateInputAuthenticationConfluentCloud,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  mechanism: CreateInputSASLMechanismConfluentCloud$inboundSchema.default(
    "plain",
  ),
});

/** @internal */
export type CreateInputAuthenticationConfluentCloud$Outbound = {
  disabled: boolean;
  mechanism: string;
};

/** @internal */
export const CreateInputAuthenticationConfluentCloud$outboundSchema: z.ZodType<
  CreateInputAuthenticationConfluentCloud$Outbound,
  z.ZodTypeDef,
  CreateInputAuthenticationConfluentCloud
> = z.object({
  disabled: z.boolean().default(true),
  mechanism: CreateInputSASLMechanismConfluentCloud$outboundSchema.default(
    "plain",
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputAuthenticationConfluentCloud$ {
  /** @deprecated use `CreateInputAuthenticationConfluentCloud$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputAuthenticationConfluentCloud$inboundSchema;
  /** @deprecated use `CreateInputAuthenticationConfluentCloud$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputAuthenticationConfluentCloud$outboundSchema;
  /** @deprecated use `CreateInputAuthenticationConfluentCloud$Outbound` instead. */
  export type Outbound = CreateInputAuthenticationConfluentCloud$Outbound;
}

export function createInputAuthenticationConfluentCloudToJSON(
  createInputAuthenticationConfluentCloud:
    CreateInputAuthenticationConfluentCloud,
): string {
  return JSON.stringify(
    CreateInputAuthenticationConfluentCloud$outboundSchema.parse(
      createInputAuthenticationConfluentCloud,
    ),
  );
}

export function createInputAuthenticationConfluentCloudFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateInputAuthenticationConfluentCloud,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateInputAuthenticationConfluentCloud$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateInputAuthenticationConfluentCloud' from JSON`,
  );
}

/** @internal */
export const MetadatumConfluentCloud$inboundSchema: z.ZodType<
  MetadatumConfluentCloud,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumConfluentCloud$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumConfluentCloud$outboundSchema: z.ZodType<
  MetadatumConfluentCloud$Outbound,
  z.ZodTypeDef,
  MetadatumConfluentCloud
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumConfluentCloud$ {
  /** @deprecated use `MetadatumConfluentCloud$inboundSchema` instead. */
  export const inboundSchema = MetadatumConfluentCloud$inboundSchema;
  /** @deprecated use `MetadatumConfluentCloud$outboundSchema` instead. */
  export const outboundSchema = MetadatumConfluentCloud$outboundSchema;
  /** @deprecated use `MetadatumConfluentCloud$Outbound` instead. */
  export type Outbound = MetadatumConfluentCloud$Outbound;
}

export function metadatumConfluentCloudToJSON(
  metadatumConfluentCloud: MetadatumConfluentCloud,
): string {
  return JSON.stringify(
    MetadatumConfluentCloud$outboundSchema.parse(metadatumConfluentCloud),
  );
}

export function metadatumConfluentCloudFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumConfluentCloud, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumConfluentCloud$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumConfluentCloud' from JSON`,
  );
}

/** @internal */
export const InputConfluentCloud$inboundSchema: z.ZodType<
  InputConfluentCloud,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateInputTypeConfluentCloud$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionConfluentCloud$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqConfluentCloud$inboundSchema).optional(),
  brokers: z.array(z.string()),
  tls: z.lazy(() =>
    CreateInputTLSSettingsClientSideConfluentCloud$inboundSchema
  ).optional(),
  topics: z.array(z.string()),
  groupId: z.string().default("Cribl"),
  fromBeginning: z.boolean().default(true),
  kafkaSchemaRegistry: z.lazy(() =>
    CreateInputKafkaSchemaRegistryAuthenticationConfluentCloud$inboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => CreateInputAuthenticationConfluentCloud$inboundSchema)
    .optional(),
  sessionTimeout: z.number().default(30000),
  rebalanceTimeout: z.number().default(60000),
  heartbeatInterval: z.number().default(3000),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().default(1048576),
  maxBytes: z.number().default(10485760),
  maxSocketErrors: z.number().default(0),
  metadata: z.array(z.lazy(() => MetadatumConfluentCloud$inboundSchema))
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputConfluentCloud$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionConfluentCloud$Outbound> | undefined;
  pq?: PqConfluentCloud$Outbound | undefined;
  brokers: Array<string>;
  tls?: CreateInputTLSSettingsClientSideConfluentCloud$Outbound | undefined;
  topics: Array<string>;
  groupId: string;
  fromBeginning: boolean;
  kafkaSchemaRegistry?:
    | CreateInputKafkaSchemaRegistryAuthenticationConfluentCloud$Outbound
    | undefined;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  maxBackOff: number;
  initialBackoff: number;
  backoffRate: number;
  authenticationTimeout: number;
  reauthenticationThreshold: number;
  sasl?: CreateInputAuthenticationConfluentCloud$Outbound | undefined;
  sessionTimeout: number;
  rebalanceTimeout: number;
  heartbeatInterval: number;
  autoCommitInterval?: number | undefined;
  autoCommitThreshold?: number | undefined;
  maxBytesPerPartition: number;
  maxBytes: number;
  maxSocketErrors: number;
  metadata?: Array<MetadatumConfluentCloud$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputConfluentCloud$outboundSchema: z.ZodType<
  InputConfluentCloud$Outbound,
  z.ZodTypeDef,
  InputConfluentCloud
> = z.object({
  id: z.string(),
  type: CreateInputTypeConfluentCloud$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionConfluentCloud$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqConfluentCloud$outboundSchema).optional(),
  brokers: z.array(z.string()),
  tls: z.lazy(() =>
    CreateInputTLSSettingsClientSideConfluentCloud$outboundSchema
  ).optional(),
  topics: z.array(z.string()),
  groupId: z.string().default("Cribl"),
  fromBeginning: z.boolean().default(true),
  kafkaSchemaRegistry: z.lazy(() =>
    CreateInputKafkaSchemaRegistryAuthenticationConfluentCloud$outboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => CreateInputAuthenticationConfluentCloud$outboundSchema)
    .optional(),
  sessionTimeout: z.number().default(30000),
  rebalanceTimeout: z.number().default(60000),
  heartbeatInterval: z.number().default(3000),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().default(1048576),
  maxBytes: z.number().default(10485760),
  maxSocketErrors: z.number().default(0),
  metadata: z.array(z.lazy(() => MetadatumConfluentCloud$outboundSchema))
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputConfluentCloud$ {
  /** @deprecated use `InputConfluentCloud$inboundSchema` instead. */
  export const inboundSchema = InputConfluentCloud$inboundSchema;
  /** @deprecated use `InputConfluentCloud$outboundSchema` instead. */
  export const outboundSchema = InputConfluentCloud$outboundSchema;
  /** @deprecated use `InputConfluentCloud$Outbound` instead. */
  export type Outbound = InputConfluentCloud$Outbound;
}

export function inputConfluentCloudToJSON(
  inputConfluentCloud: InputConfluentCloud,
): string {
  return JSON.stringify(
    InputConfluentCloud$outboundSchema.parse(inputConfluentCloud),
  );
}

export function inputConfluentCloudFromJSON(
  jsonString: string,
): SafeParseResult<InputConfluentCloud, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputConfluentCloud$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputConfluentCloud' from JSON`,
  );
}

/** @internal */
export const CreateInputTypeElastic$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeElastic
> = z.nativeEnum(CreateInputTypeElastic);

/** @internal */
export const CreateInputTypeElastic$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeElastic
> = CreateInputTypeElastic$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputTypeElastic$ {
  /** @deprecated use `CreateInputTypeElastic$inboundSchema` instead. */
  export const inboundSchema = CreateInputTypeElastic$inboundSchema;
  /** @deprecated use `CreateInputTypeElastic$outboundSchema` instead. */
  export const outboundSchema = CreateInputTypeElastic$outboundSchema;
}

/** @internal */
export const ConnectionElastic$inboundSchema: z.ZodType<
  ConnectionElastic,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionElastic$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionElastic$outboundSchema: z.ZodType<
  ConnectionElastic$Outbound,
  z.ZodTypeDef,
  ConnectionElastic
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionElastic$ {
  /** @deprecated use `ConnectionElastic$inboundSchema` instead. */
  export const inboundSchema = ConnectionElastic$inboundSchema;
  /** @deprecated use `ConnectionElastic$outboundSchema` instead. */
  export const outboundSchema = ConnectionElastic$outboundSchema;
  /** @deprecated use `ConnectionElastic$Outbound` instead. */
  export type Outbound = ConnectionElastic$Outbound;
}

export function connectionElasticToJSON(
  connectionElastic: ConnectionElastic,
): string {
  return JSON.stringify(
    ConnectionElastic$outboundSchema.parse(connectionElastic),
  );
}

export function connectionElasticFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionElastic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionElastic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionElastic' from JSON`,
  );
}

/** @internal */
export const CreateInputModeElastic$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputModeElastic
> = z.nativeEnum(CreateInputModeElastic);

/** @internal */
export const CreateInputModeElastic$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputModeElastic
> = CreateInputModeElastic$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputModeElastic$ {
  /** @deprecated use `CreateInputModeElastic$inboundSchema` instead. */
  export const inboundSchema = CreateInputModeElastic$inboundSchema;
  /** @deprecated use `CreateInputModeElastic$outboundSchema` instead. */
  export const outboundSchema = CreateInputModeElastic$outboundSchema;
}

/** @internal */
export const PqCompressionElastic$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressionElastic
> = z.nativeEnum(PqCompressionElastic);

/** @internal */
export const PqCompressionElastic$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressionElastic
> = PqCompressionElastic$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressionElastic$ {
  /** @deprecated use `PqCompressionElastic$inboundSchema` instead. */
  export const inboundSchema = PqCompressionElastic$inboundSchema;
  /** @deprecated use `PqCompressionElastic$outboundSchema` instead. */
  export const outboundSchema = PqCompressionElastic$outboundSchema;
}

/** @internal */
export const PqElastic$inboundSchema: z.ZodType<
  PqElastic,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: CreateInputModeElastic$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: PqCompressionElastic$inboundSchema.default("none"),
});

/** @internal */
export type PqElastic$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqElastic$outboundSchema: z.ZodType<
  PqElastic$Outbound,
  z.ZodTypeDef,
  PqElastic
> = z.object({
  mode: CreateInputModeElastic$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: PqCompressionElastic$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqElastic$ {
  /** @deprecated use `PqElastic$inboundSchema` instead. */
  export const inboundSchema = PqElastic$inboundSchema;
  /** @deprecated use `PqElastic$outboundSchema` instead. */
  export const outboundSchema = PqElastic$outboundSchema;
  /** @deprecated use `PqElastic$Outbound` instead. */
  export type Outbound = PqElastic$Outbound;
}

export function pqElasticToJSON(pqElastic: PqElastic): string {
  return JSON.stringify(PqElastic$outboundSchema.parse(pqElastic));
}

export function pqElasticFromJSON(
  jsonString: string,
): SafeParseResult<PqElastic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqElastic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqElastic' from JSON`,
  );
}

/** @internal */
export const MinimumTLSVersionElastic$inboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionElastic
> = z.nativeEnum(MinimumTLSVersionElastic);

/** @internal */
export const MinimumTLSVersionElastic$outboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionElastic
> = MinimumTLSVersionElastic$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MinimumTLSVersionElastic$ {
  /** @deprecated use `MinimumTLSVersionElastic$inboundSchema` instead. */
  export const inboundSchema = MinimumTLSVersionElastic$inboundSchema;
  /** @deprecated use `MinimumTLSVersionElastic$outboundSchema` instead. */
  export const outboundSchema = MinimumTLSVersionElastic$outboundSchema;
}

/** @internal */
export const MaximumTLSVersionElastic$inboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionElastic
> = z.nativeEnum(MaximumTLSVersionElastic);

/** @internal */
export const MaximumTLSVersionElastic$outboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionElastic
> = MaximumTLSVersionElastic$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaximumTLSVersionElastic$ {
  /** @deprecated use `MaximumTLSVersionElastic$inboundSchema` instead. */
  export const inboundSchema = MaximumTLSVersionElastic$inboundSchema;
  /** @deprecated use `MaximumTLSVersionElastic$outboundSchema` instead. */
  export const outboundSchema = MaximumTLSVersionElastic$outboundSchema;
}

/** @internal */
export const TLSSettingsServerSideElastic$inboundSchema: z.ZodType<
  TLSSettingsServerSideElastic,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionElastic$inboundSchema.optional(),
  maxVersion: MaximumTLSVersionElastic$inboundSchema.optional(),
});

/** @internal */
export type TLSSettingsServerSideElastic$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TLSSettingsServerSideElastic$outboundSchema: z.ZodType<
  TLSSettingsServerSideElastic$Outbound,
  z.ZodTypeDef,
  TLSSettingsServerSideElastic
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionElastic$outboundSchema.optional(),
  maxVersion: MaximumTLSVersionElastic$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsServerSideElastic$ {
  /** @deprecated use `TLSSettingsServerSideElastic$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsServerSideElastic$inboundSchema;
  /** @deprecated use `TLSSettingsServerSideElastic$outboundSchema` instead. */
  export const outboundSchema = TLSSettingsServerSideElastic$outboundSchema;
  /** @deprecated use `TLSSettingsServerSideElastic$Outbound` instead. */
  export type Outbound = TLSSettingsServerSideElastic$Outbound;
}

export function tlsSettingsServerSideElasticToJSON(
  tlsSettingsServerSideElastic: TLSSettingsServerSideElastic,
): string {
  return JSON.stringify(
    TLSSettingsServerSideElastic$outboundSchema.parse(
      tlsSettingsServerSideElastic,
    ),
  );
}

export function tlsSettingsServerSideElasticFromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsServerSideElastic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TLSSettingsServerSideElastic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsServerSideElastic' from JSON`,
  );
}

/** @internal */
export const AuthenticationTypeElastic$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationTypeElastic
> = z.nativeEnum(AuthenticationTypeElastic);

/** @internal */
export const AuthenticationTypeElastic$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationTypeElastic
> = AuthenticationTypeElastic$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationTypeElastic$ {
  /** @deprecated use `AuthenticationTypeElastic$inboundSchema` instead. */
  export const inboundSchema = AuthenticationTypeElastic$inboundSchema;
  /** @deprecated use `AuthenticationTypeElastic$outboundSchema` instead. */
  export const outboundSchema = AuthenticationTypeElastic$outboundSchema;
}

/** @internal */
export const CreateInputAPIVersion$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputAPIVersion
> = z.nativeEnum(CreateInputAPIVersion);

/** @internal */
export const CreateInputAPIVersion$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputAPIVersion
> = CreateInputAPIVersion$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputAPIVersion$ {
  /** @deprecated use `CreateInputAPIVersion$inboundSchema` instead. */
  export const inboundSchema = CreateInputAPIVersion$inboundSchema;
  /** @deprecated use `CreateInputAPIVersion$outboundSchema` instead. */
  export const outboundSchema = CreateInputAPIVersion$outboundSchema;
}

/** @internal */
export const CreateInputExtraHttpHeader$inboundSchema: z.ZodType<
  CreateInputExtraHttpHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type CreateInputExtraHttpHeader$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const CreateInputExtraHttpHeader$outboundSchema: z.ZodType<
  CreateInputExtraHttpHeader$Outbound,
  z.ZodTypeDef,
  CreateInputExtraHttpHeader
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputExtraHttpHeader$ {
  /** @deprecated use `CreateInputExtraHttpHeader$inboundSchema` instead. */
  export const inboundSchema = CreateInputExtraHttpHeader$inboundSchema;
  /** @deprecated use `CreateInputExtraHttpHeader$outboundSchema` instead. */
  export const outboundSchema = CreateInputExtraHttpHeader$outboundSchema;
  /** @deprecated use `CreateInputExtraHttpHeader$Outbound` instead. */
  export type Outbound = CreateInputExtraHttpHeader$Outbound;
}

export function createInputExtraHttpHeaderToJSON(
  createInputExtraHttpHeader: CreateInputExtraHttpHeader,
): string {
  return JSON.stringify(
    CreateInputExtraHttpHeader$outboundSchema.parse(createInputExtraHttpHeader),
  );
}

export function createInputExtraHttpHeaderFromJSON(
  jsonString: string,
): SafeParseResult<CreateInputExtraHttpHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateInputExtraHttpHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateInputExtraHttpHeader' from JSON`,
  );
}

/** @internal */
export const MetadatumElastic$inboundSchema: z.ZodType<
  MetadatumElastic,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumElastic$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumElastic$outboundSchema: z.ZodType<
  MetadatumElastic$Outbound,
  z.ZodTypeDef,
  MetadatumElastic
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumElastic$ {
  /** @deprecated use `MetadatumElastic$inboundSchema` instead. */
  export const inboundSchema = MetadatumElastic$inboundSchema;
  /** @deprecated use `MetadatumElastic$outboundSchema` instead. */
  export const outboundSchema = MetadatumElastic$outboundSchema;
  /** @deprecated use `MetadatumElastic$Outbound` instead. */
  export type Outbound = MetadatumElastic$Outbound;
}

export function metadatumElasticToJSON(
  metadatumElastic: MetadatumElastic,
): string {
  return JSON.stringify(
    MetadatumElastic$outboundSchema.parse(metadatumElastic),
  );
}

export function metadatumElasticFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumElastic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumElastic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumElastic' from JSON`,
  );
}

/** @internal */
export const ProxyModeAuthenticationMethod$inboundSchema: z.ZodNativeEnum<
  typeof ProxyModeAuthenticationMethod
> = z.nativeEnum(ProxyModeAuthenticationMethod);

/** @internal */
export const ProxyModeAuthenticationMethod$outboundSchema: z.ZodNativeEnum<
  typeof ProxyModeAuthenticationMethod
> = ProxyModeAuthenticationMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ProxyModeAuthenticationMethod$ {
  /** @deprecated use `ProxyModeAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = ProxyModeAuthenticationMethod$inboundSchema;
  /** @deprecated use `ProxyModeAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema = ProxyModeAuthenticationMethod$outboundSchema;
}

/** @internal */
export const ProxyModeElastic$inboundSchema: z.ZodType<
  ProxyModeElastic,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().default(false),
  url: z.string().optional(),
  rejectUnauthorized: z.boolean().default(false),
  removeHeaders: z.array(z.string()).optional(),
  timeoutSec: z.number().default(60),
  authType: ProxyModeAuthenticationMethod$inboundSchema.default("none"),
});

/** @internal */
export type ProxyModeElastic$Outbound = {
  enabled: boolean;
  url?: string | undefined;
  rejectUnauthorized: boolean;
  removeHeaders?: Array<string> | undefined;
  timeoutSec: number;
  authType: string;
};

/** @internal */
export const ProxyModeElastic$outboundSchema: z.ZodType<
  ProxyModeElastic$Outbound,
  z.ZodTypeDef,
  ProxyModeElastic
> = z.object({
  enabled: z.boolean().default(false),
  url: z.string().optional(),
  rejectUnauthorized: z.boolean().default(false),
  removeHeaders: z.array(z.string()).optional(),
  timeoutSec: z.number().default(60),
  authType: ProxyModeAuthenticationMethod$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ProxyModeElastic$ {
  /** @deprecated use `ProxyModeElastic$inboundSchema` instead. */
  export const inboundSchema = ProxyModeElastic$inboundSchema;
  /** @deprecated use `ProxyModeElastic$outboundSchema` instead. */
  export const outboundSchema = ProxyModeElastic$outboundSchema;
  /** @deprecated use `ProxyModeElastic$Outbound` instead. */
  export type Outbound = ProxyModeElastic$Outbound;
}

export function proxyModeElasticToJSON(
  proxyModeElastic: ProxyModeElastic,
): string {
  return JSON.stringify(
    ProxyModeElastic$outboundSchema.parse(proxyModeElastic),
  );
}

export function proxyModeElasticFromJSON(
  jsonString: string,
): SafeParseResult<ProxyModeElastic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ProxyModeElastic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProxyModeElastic' from JSON`,
  );
}

/** @internal */
export const InputElastic$inboundSchema: z.ZodType<
  InputElastic,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateInputTypeElastic$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionElastic$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqElastic$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => TLSSettingsServerSideElastic$inboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  elasticAPI: z.string().default("/"),
  authType: AuthenticationTypeElastic$inboundSchema.default("none"),
  apiVersion: CreateInputAPIVersion$inboundSchema.default("8.3.2"),
  extraHttpHeaders: z.array(
    z.lazy(() => CreateInputExtraHttpHeader$inboundSchema),
  ).optional(),
  metadata: z.array(z.lazy(() => MetadatumElastic$inboundSchema)).optional(),
  proxyMode: z.lazy(() => ProxyModeElastic$inboundSchema).optional(),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  authTokens: z.array(z.string()).optional(),
  customAPIVersion: z.string().default(
    "{\n    \"name\": \"AzU84iL\",\n    \"cluster_name\": \"cribl\",\n    \"cluster_uuid\": \"Js6_Z2VKS3KbfRSxPmPbaw\",\n    \"version\": {\n        \"number\": \"8.3.2\",\n        \"build_type\": \"tar\",\n        \"build_hash\": \"bca0c8d\",\n        \"build_date\": \"2019-10-16T06:19:49.319352Z\",\n        \"build_snapshot\": false,\n        \"lucene_version\": \"9.7.2\",\n        \"minimum_wire_compatibility_version\": \"7.17.0\",\n        \"minimum_index_compatibility_version\": \"7.0.0\"\n    },\n    \"tagline\": \"You Know, for Search\"\n}",
  ),
});

/** @internal */
export type InputElastic$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionElastic$Outbound> | undefined;
  pq?: PqElastic$Outbound | undefined;
  host: string;
  port: number;
  tls?: TLSSettingsServerSideElastic$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  elasticAPI: string;
  authType: string;
  apiVersion: string;
  extraHttpHeaders?: Array<CreateInputExtraHttpHeader$Outbound> | undefined;
  metadata?: Array<MetadatumElastic$Outbound> | undefined;
  proxyMode?: ProxyModeElastic$Outbound | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  authTokens?: Array<string> | undefined;
  customAPIVersion: string;
};

/** @internal */
export const InputElastic$outboundSchema: z.ZodType<
  InputElastic$Outbound,
  z.ZodTypeDef,
  InputElastic
> = z.object({
  id: z.string(),
  type: CreateInputTypeElastic$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionElastic$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqElastic$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => TLSSettingsServerSideElastic$outboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  elasticAPI: z.string().default("/"),
  authType: AuthenticationTypeElastic$outboundSchema.default("none"),
  apiVersion: CreateInputAPIVersion$outboundSchema.default("8.3.2"),
  extraHttpHeaders: z.array(
    z.lazy(() => CreateInputExtraHttpHeader$outboundSchema),
  ).optional(),
  metadata: z.array(z.lazy(() => MetadatumElastic$outboundSchema)).optional(),
  proxyMode: z.lazy(() => ProxyModeElastic$outboundSchema).optional(),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  authTokens: z.array(z.string()).optional(),
  customAPIVersion: z.string().default(
    "{\n    \"name\": \"AzU84iL\",\n    \"cluster_name\": \"cribl\",\n    \"cluster_uuid\": \"Js6_Z2VKS3KbfRSxPmPbaw\",\n    \"version\": {\n        \"number\": \"8.3.2\",\n        \"build_type\": \"tar\",\n        \"build_hash\": \"bca0c8d\",\n        \"build_date\": \"2019-10-16T06:19:49.319352Z\",\n        \"build_snapshot\": false,\n        \"lucene_version\": \"9.7.2\",\n        \"minimum_wire_compatibility_version\": \"7.17.0\",\n        \"minimum_index_compatibility_version\": \"7.0.0\"\n    },\n    \"tagline\": \"You Know, for Search\"\n}",
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputElastic$ {
  /** @deprecated use `InputElastic$inboundSchema` instead. */
  export const inboundSchema = InputElastic$inboundSchema;
  /** @deprecated use `InputElastic$outboundSchema` instead. */
  export const outboundSchema = InputElastic$outboundSchema;
  /** @deprecated use `InputElastic$Outbound` instead. */
  export type Outbound = InputElastic$Outbound;
}

export function inputElasticToJSON(inputElastic: InputElastic): string {
  return JSON.stringify(InputElastic$outboundSchema.parse(inputElastic));
}

export function inputElasticFromJSON(
  jsonString: string,
): SafeParseResult<InputElastic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputElastic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputElastic' from JSON`,
  );
}

/** @internal */
export const CreateInputTypeAzureBlob$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeAzureBlob
> = z.nativeEnum(CreateInputTypeAzureBlob);

/** @internal */
export const CreateInputTypeAzureBlob$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeAzureBlob
> = CreateInputTypeAzureBlob$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputTypeAzureBlob$ {
  /** @deprecated use `CreateInputTypeAzureBlob$inboundSchema` instead. */
  export const inboundSchema = CreateInputTypeAzureBlob$inboundSchema;
  /** @deprecated use `CreateInputTypeAzureBlob$outboundSchema` instead. */
  export const outboundSchema = CreateInputTypeAzureBlob$outboundSchema;
}

/** @internal */
export const ConnectionAzureBlob$inboundSchema: z.ZodType<
  ConnectionAzureBlob,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionAzureBlob$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionAzureBlob$outboundSchema: z.ZodType<
  ConnectionAzureBlob$Outbound,
  z.ZodTypeDef,
  ConnectionAzureBlob
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionAzureBlob$ {
  /** @deprecated use `ConnectionAzureBlob$inboundSchema` instead. */
  export const inboundSchema = ConnectionAzureBlob$inboundSchema;
  /** @deprecated use `ConnectionAzureBlob$outboundSchema` instead. */
  export const outboundSchema = ConnectionAzureBlob$outboundSchema;
  /** @deprecated use `ConnectionAzureBlob$Outbound` instead. */
  export type Outbound = ConnectionAzureBlob$Outbound;
}

export function connectionAzureBlobToJSON(
  connectionAzureBlob: ConnectionAzureBlob,
): string {
  return JSON.stringify(
    ConnectionAzureBlob$outboundSchema.parse(connectionAzureBlob),
  );
}

export function connectionAzureBlobFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionAzureBlob, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionAzureBlob$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionAzureBlob' from JSON`,
  );
}

/** @internal */
export const ModeAzureBlob$inboundSchema: z.ZodNativeEnum<
  typeof ModeAzureBlob
> = z.nativeEnum(ModeAzureBlob);

/** @internal */
export const ModeAzureBlob$outboundSchema: z.ZodNativeEnum<
  typeof ModeAzureBlob
> = ModeAzureBlob$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeAzureBlob$ {
  /** @deprecated use `ModeAzureBlob$inboundSchema` instead. */
  export const inboundSchema = ModeAzureBlob$inboundSchema;
  /** @deprecated use `ModeAzureBlob$outboundSchema` instead. */
  export const outboundSchema = ModeAzureBlob$outboundSchema;
}

/** @internal */
export const PqCompressionAzureBlob$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressionAzureBlob
> = z.nativeEnum(PqCompressionAzureBlob);

/** @internal */
export const PqCompressionAzureBlob$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressionAzureBlob
> = PqCompressionAzureBlob$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressionAzureBlob$ {
  /** @deprecated use `PqCompressionAzureBlob$inboundSchema` instead. */
  export const inboundSchema = PqCompressionAzureBlob$inboundSchema;
  /** @deprecated use `PqCompressionAzureBlob$outboundSchema` instead. */
  export const outboundSchema = PqCompressionAzureBlob$outboundSchema;
}

/** @internal */
export const PqAzureBlob$inboundSchema: z.ZodType<
  PqAzureBlob,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeAzureBlob$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: PqCompressionAzureBlob$inboundSchema.default("none"),
});

/** @internal */
export type PqAzureBlob$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqAzureBlob$outboundSchema: z.ZodType<
  PqAzureBlob$Outbound,
  z.ZodTypeDef,
  PqAzureBlob
> = z.object({
  mode: ModeAzureBlob$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: PqCompressionAzureBlob$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqAzureBlob$ {
  /** @deprecated use `PqAzureBlob$inboundSchema` instead. */
  export const inboundSchema = PqAzureBlob$inboundSchema;
  /** @deprecated use `PqAzureBlob$outboundSchema` instead. */
  export const outboundSchema = PqAzureBlob$outboundSchema;
  /** @deprecated use `PqAzureBlob$Outbound` instead. */
  export type Outbound = PqAzureBlob$Outbound;
}

export function pqAzureBlobToJSON(pqAzureBlob: PqAzureBlob): string {
  return JSON.stringify(PqAzureBlob$outboundSchema.parse(pqAzureBlob));
}

export function pqAzureBlobFromJSON(
  jsonString: string,
): SafeParseResult<PqAzureBlob, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqAzureBlob$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqAzureBlob' from JSON`,
  );
}

/** @internal */
export const MetadatumAzureBlob$inboundSchema: z.ZodType<
  MetadatumAzureBlob,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumAzureBlob$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumAzureBlob$outboundSchema: z.ZodType<
  MetadatumAzureBlob$Outbound,
  z.ZodTypeDef,
  MetadatumAzureBlob
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumAzureBlob$ {
  /** @deprecated use `MetadatumAzureBlob$inboundSchema` instead. */
  export const inboundSchema = MetadatumAzureBlob$inboundSchema;
  /** @deprecated use `MetadatumAzureBlob$outboundSchema` instead. */
  export const outboundSchema = MetadatumAzureBlob$outboundSchema;
  /** @deprecated use `MetadatumAzureBlob$Outbound` instead. */
  export type Outbound = MetadatumAzureBlob$Outbound;
}

export function metadatumAzureBlobToJSON(
  metadatumAzureBlob: MetadatumAzureBlob,
): string {
  return JSON.stringify(
    MetadatumAzureBlob$outboundSchema.parse(metadatumAzureBlob),
  );
}

export function metadatumAzureBlobFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumAzureBlob, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumAzureBlob$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumAzureBlob' from JSON`,
  );
}

/** @internal */
export const CreateInputAuthenticationMethodAzureBlob$inboundSchema:
  z.ZodNativeEnum<typeof CreateInputAuthenticationMethodAzureBlob> = z
    .nativeEnum(CreateInputAuthenticationMethodAzureBlob);

/** @internal */
export const CreateInputAuthenticationMethodAzureBlob$outboundSchema:
  z.ZodNativeEnum<typeof CreateInputAuthenticationMethodAzureBlob> =
    CreateInputAuthenticationMethodAzureBlob$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputAuthenticationMethodAzureBlob$ {
  /** @deprecated use `CreateInputAuthenticationMethodAzureBlob$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputAuthenticationMethodAzureBlob$inboundSchema;
  /** @deprecated use `CreateInputAuthenticationMethodAzureBlob$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputAuthenticationMethodAzureBlob$outboundSchema;
}

/** @internal */
export const CreateInputCertificate$inboundSchema: z.ZodType<
  CreateInputCertificate,
  z.ZodTypeDef,
  unknown
> = z.object({
  certificateName: z.string(),
});

/** @internal */
export type CreateInputCertificate$Outbound = {
  certificateName: string;
};

/** @internal */
export const CreateInputCertificate$outboundSchema: z.ZodType<
  CreateInputCertificate$Outbound,
  z.ZodTypeDef,
  CreateInputCertificate
> = z.object({
  certificateName: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputCertificate$ {
  /** @deprecated use `CreateInputCertificate$inboundSchema` instead. */
  export const inboundSchema = CreateInputCertificate$inboundSchema;
  /** @deprecated use `CreateInputCertificate$outboundSchema` instead. */
  export const outboundSchema = CreateInputCertificate$outboundSchema;
  /** @deprecated use `CreateInputCertificate$Outbound` instead. */
  export type Outbound = CreateInputCertificate$Outbound;
}

export function createInputCertificateToJSON(
  createInputCertificate: CreateInputCertificate,
): string {
  return JSON.stringify(
    CreateInputCertificate$outboundSchema.parse(createInputCertificate),
  );
}

export function createInputCertificateFromJSON(
  jsonString: string,
): SafeParseResult<CreateInputCertificate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateInputCertificate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateInputCertificate' from JSON`,
  );
}

/** @internal */
export const InputAzureBlob$inboundSchema: z.ZodType<
  InputAzureBlob,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateInputTypeAzureBlob$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionAzureBlob$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqAzureBlob$inboundSchema).optional(),
  queueName: z.string(),
  fileFilter: z.string().default("/.*/"),
  visibilityTimeout: z.number().default(600),
  numReceivers: z.number().default(1),
  maxMessages: z.number().default(1),
  servicePeriodSecs: z.number().default(5),
  skipOnError: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumAzureBlob$inboundSchema)).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  parquetChunkSizeMB: z.number().default(5),
  parquetChunkDownloadTimeout: z.number().default(600),
  authType: CreateInputAuthenticationMethodAzureBlob$inboundSchema.default(
    "manual",
  ),
  description: z.string().optional(),
  connectionString: z.string().optional(),
  textSecret: z.string().optional(),
  storageAccountName: z.string().optional(),
  tenantId: z.string().optional(),
  clientId: z.string().optional(),
  azureCloud: z.string().optional(),
  endpointSuffix: z.string().optional(),
  clientTextSecret: z.string().optional(),
  certificate: z.lazy(() => CreateInputCertificate$inboundSchema).optional(),
});

/** @internal */
export type InputAzureBlob$Outbound = {
  id: string;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionAzureBlob$Outbound> | undefined;
  pq?: PqAzureBlob$Outbound | undefined;
  queueName: string;
  fileFilter: string;
  visibilityTimeout: number;
  numReceivers: number;
  maxMessages: number;
  servicePeriodSecs: number;
  skipOnError: boolean;
  metadata?: Array<MetadatumAzureBlob$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  parquetChunkSizeMB: number;
  parquetChunkDownloadTimeout: number;
  authType: string;
  description?: string | undefined;
  connectionString?: string | undefined;
  textSecret?: string | undefined;
  storageAccountName?: string | undefined;
  tenantId?: string | undefined;
  clientId?: string | undefined;
  azureCloud?: string | undefined;
  endpointSuffix?: string | undefined;
  clientTextSecret?: string | undefined;
  certificate?: CreateInputCertificate$Outbound | undefined;
};

/** @internal */
export const InputAzureBlob$outboundSchema: z.ZodType<
  InputAzureBlob$Outbound,
  z.ZodTypeDef,
  InputAzureBlob
> = z.object({
  id: z.string(),
  type: CreateInputTypeAzureBlob$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionAzureBlob$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqAzureBlob$outboundSchema).optional(),
  queueName: z.string(),
  fileFilter: z.string().default("/.*/"),
  visibilityTimeout: z.number().default(600),
  numReceivers: z.number().default(1),
  maxMessages: z.number().default(1),
  servicePeriodSecs: z.number().default(5),
  skipOnError: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumAzureBlob$outboundSchema)).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  parquetChunkSizeMB: z.number().default(5),
  parquetChunkDownloadTimeout: z.number().default(600),
  authType: CreateInputAuthenticationMethodAzureBlob$outboundSchema.default(
    "manual",
  ),
  description: z.string().optional(),
  connectionString: z.string().optional(),
  textSecret: z.string().optional(),
  storageAccountName: z.string().optional(),
  tenantId: z.string().optional(),
  clientId: z.string().optional(),
  azureCloud: z.string().optional(),
  endpointSuffix: z.string().optional(),
  clientTextSecret: z.string().optional(),
  certificate: z.lazy(() => CreateInputCertificate$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputAzureBlob$ {
  /** @deprecated use `InputAzureBlob$inboundSchema` instead. */
  export const inboundSchema = InputAzureBlob$inboundSchema;
  /** @deprecated use `InputAzureBlob$outboundSchema` instead. */
  export const outboundSchema = InputAzureBlob$outboundSchema;
  /** @deprecated use `InputAzureBlob$Outbound` instead. */
  export type Outbound = InputAzureBlob$Outbound;
}

export function inputAzureBlobToJSON(inputAzureBlob: InputAzureBlob): string {
  return JSON.stringify(InputAzureBlob$outboundSchema.parse(inputAzureBlob));
}

export function inputAzureBlobFromJSON(
  jsonString: string,
): SafeParseResult<InputAzureBlob, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAzureBlob$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAzureBlob' from JSON`,
  );
}

/** @internal */
export const TypeSplunkHec$inboundSchema: z.ZodNativeEnum<
  typeof TypeSplunkHec
> = z.nativeEnum(TypeSplunkHec);

/** @internal */
export const TypeSplunkHec$outboundSchema: z.ZodNativeEnum<
  typeof TypeSplunkHec
> = TypeSplunkHec$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeSplunkHec$ {
  /** @deprecated use `TypeSplunkHec$inboundSchema` instead. */
  export const inboundSchema = TypeSplunkHec$inboundSchema;
  /** @deprecated use `TypeSplunkHec$outboundSchema` instead. */
  export const outboundSchema = TypeSplunkHec$outboundSchema;
}

/** @internal */
export const ConnectionSplunkHec$inboundSchema: z.ZodType<
  ConnectionSplunkHec,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionSplunkHec$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionSplunkHec$outboundSchema: z.ZodType<
  ConnectionSplunkHec$Outbound,
  z.ZodTypeDef,
  ConnectionSplunkHec
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionSplunkHec$ {
  /** @deprecated use `ConnectionSplunkHec$inboundSchema` instead. */
  export const inboundSchema = ConnectionSplunkHec$inboundSchema;
  /** @deprecated use `ConnectionSplunkHec$outboundSchema` instead. */
  export const outboundSchema = ConnectionSplunkHec$outboundSchema;
  /** @deprecated use `ConnectionSplunkHec$Outbound` instead. */
  export type Outbound = ConnectionSplunkHec$Outbound;
}

export function connectionSplunkHecToJSON(
  connectionSplunkHec: ConnectionSplunkHec,
): string {
  return JSON.stringify(
    ConnectionSplunkHec$outboundSchema.parse(connectionSplunkHec),
  );
}

export function connectionSplunkHecFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionSplunkHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionSplunkHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionSplunkHec' from JSON`,
  );
}

/** @internal */
export const ModeSplunkHec$inboundSchema: z.ZodNativeEnum<
  typeof ModeSplunkHec
> = z.nativeEnum(ModeSplunkHec);

/** @internal */
export const ModeSplunkHec$outboundSchema: z.ZodNativeEnum<
  typeof ModeSplunkHec
> = ModeSplunkHec$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeSplunkHec$ {
  /** @deprecated use `ModeSplunkHec$inboundSchema` instead. */
  export const inboundSchema = ModeSplunkHec$inboundSchema;
  /** @deprecated use `ModeSplunkHec$outboundSchema` instead. */
  export const outboundSchema = ModeSplunkHec$outboundSchema;
}

/** @internal */
export const CompressionSplunkHec$inboundSchema: z.ZodNativeEnum<
  typeof CompressionSplunkHec
> = z.nativeEnum(CompressionSplunkHec);

/** @internal */
export const CompressionSplunkHec$outboundSchema: z.ZodNativeEnum<
  typeof CompressionSplunkHec
> = CompressionSplunkHec$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionSplunkHec$ {
  /** @deprecated use `CompressionSplunkHec$inboundSchema` instead. */
  export const inboundSchema = CompressionSplunkHec$inboundSchema;
  /** @deprecated use `CompressionSplunkHec$outboundSchema` instead. */
  export const outboundSchema = CompressionSplunkHec$outboundSchema;
}

/** @internal */
export const PqSplunkHec$inboundSchema: z.ZodType<
  PqSplunkHec,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeSplunkHec$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionSplunkHec$inboundSchema.default("none"),
});

/** @internal */
export type PqSplunkHec$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqSplunkHec$outboundSchema: z.ZodType<
  PqSplunkHec$Outbound,
  z.ZodTypeDef,
  PqSplunkHec
> = z.object({
  mode: ModeSplunkHec$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionSplunkHec$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqSplunkHec$ {
  /** @deprecated use `PqSplunkHec$inboundSchema` instead. */
  export const inboundSchema = PqSplunkHec$inboundSchema;
  /** @deprecated use `PqSplunkHec$outboundSchema` instead. */
  export const outboundSchema = PqSplunkHec$outboundSchema;
  /** @deprecated use `PqSplunkHec$Outbound` instead. */
  export type Outbound = PqSplunkHec$Outbound;
}

export function pqSplunkHecToJSON(pqSplunkHec: PqSplunkHec): string {
  return JSON.stringify(PqSplunkHec$outboundSchema.parse(pqSplunkHec));
}

export function pqSplunkHecFromJSON(
  jsonString: string,
): SafeParseResult<PqSplunkHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqSplunkHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqSplunkHec' from JSON`,
  );
}

/** @internal */
export const AuthenticationMethodSplunkHec$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodSplunkHec
> = z.nativeEnum(AuthenticationMethodSplunkHec);

/** @internal */
export const AuthenticationMethodSplunkHec$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationMethodSplunkHec
> = AuthenticationMethodSplunkHec$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationMethodSplunkHec$ {
  /** @deprecated use `AuthenticationMethodSplunkHec$inboundSchema` instead. */
  export const inboundSchema = AuthenticationMethodSplunkHec$inboundSchema;
  /** @deprecated use `AuthenticationMethodSplunkHec$outboundSchema` instead. */
  export const outboundSchema = AuthenticationMethodSplunkHec$outboundSchema;
}

/** @internal */
export const AuthTokenMetadatumSplunkHec$inboundSchema: z.ZodType<
  AuthTokenMetadatumSplunkHec,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type AuthTokenMetadatumSplunkHec$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const AuthTokenMetadatumSplunkHec$outboundSchema: z.ZodType<
  AuthTokenMetadatumSplunkHec$Outbound,
  z.ZodTypeDef,
  AuthTokenMetadatumSplunkHec
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenMetadatumSplunkHec$ {
  /** @deprecated use `AuthTokenMetadatumSplunkHec$inboundSchema` instead. */
  export const inboundSchema = AuthTokenMetadatumSplunkHec$inboundSchema;
  /** @deprecated use `AuthTokenMetadatumSplunkHec$outboundSchema` instead. */
  export const outboundSchema = AuthTokenMetadatumSplunkHec$outboundSchema;
  /** @deprecated use `AuthTokenMetadatumSplunkHec$Outbound` instead. */
  export type Outbound = AuthTokenMetadatumSplunkHec$Outbound;
}

export function authTokenMetadatumSplunkHecToJSON(
  authTokenMetadatumSplunkHec: AuthTokenMetadatumSplunkHec,
): string {
  return JSON.stringify(
    AuthTokenMetadatumSplunkHec$outboundSchema.parse(
      authTokenMetadatumSplunkHec,
    ),
  );
}

export function authTokenMetadatumSplunkHecFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokenMetadatumSplunkHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthTokenMetadatumSplunkHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokenMetadatumSplunkHec' from JSON`,
  );
}

/** @internal */
export const AuthTokenSplunkHec$inboundSchema: z.ZodType<
  AuthTokenSplunkHec,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthenticationMethodSplunkHec$inboundSchema.default("manual"),
  tokenSecret: z.any().optional(),
  token: z.any().optional(),
  enabled: z.boolean().default(true),
  description: z.string().optional(),
  allowedIndexesAtToken: z.array(z.string()).optional(),
  metadata: z.array(z.lazy(() => AuthTokenMetadatumSplunkHec$inboundSchema))
    .optional(),
});

/** @internal */
export type AuthTokenSplunkHec$Outbound = {
  authType: string;
  tokenSecret?: any | undefined;
  token?: any | undefined;
  enabled: boolean;
  description?: string | undefined;
  allowedIndexesAtToken?: Array<string> | undefined;
  metadata?: Array<AuthTokenMetadatumSplunkHec$Outbound> | undefined;
};

/** @internal */
export const AuthTokenSplunkHec$outboundSchema: z.ZodType<
  AuthTokenSplunkHec$Outbound,
  z.ZodTypeDef,
  AuthTokenSplunkHec
> = z.object({
  authType: AuthenticationMethodSplunkHec$outboundSchema.default("manual"),
  tokenSecret: z.any().optional(),
  token: z.any().optional(),
  enabled: z.boolean().default(true),
  description: z.string().optional(),
  allowedIndexesAtToken: z.array(z.string()).optional(),
  metadata: z.array(z.lazy(() => AuthTokenMetadatumSplunkHec$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenSplunkHec$ {
  /** @deprecated use `AuthTokenSplunkHec$inboundSchema` instead. */
  export const inboundSchema = AuthTokenSplunkHec$inboundSchema;
  /** @deprecated use `AuthTokenSplunkHec$outboundSchema` instead. */
  export const outboundSchema = AuthTokenSplunkHec$outboundSchema;
  /** @deprecated use `AuthTokenSplunkHec$Outbound` instead. */
  export type Outbound = AuthTokenSplunkHec$Outbound;
}

export function authTokenSplunkHecToJSON(
  authTokenSplunkHec: AuthTokenSplunkHec,
): string {
  return JSON.stringify(
    AuthTokenSplunkHec$outboundSchema.parse(authTokenSplunkHec),
  );
}

export function authTokenSplunkHecFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokenSplunkHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthTokenSplunkHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokenSplunkHec' from JSON`,
  );
}

/** @internal */
export const MinimumTLSVersionSplunkHec$inboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionSplunkHec
> = z.nativeEnum(MinimumTLSVersionSplunkHec);

/** @internal */
export const MinimumTLSVersionSplunkHec$outboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionSplunkHec
> = MinimumTLSVersionSplunkHec$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MinimumTLSVersionSplunkHec$ {
  /** @deprecated use `MinimumTLSVersionSplunkHec$inboundSchema` instead. */
  export const inboundSchema = MinimumTLSVersionSplunkHec$inboundSchema;
  /** @deprecated use `MinimumTLSVersionSplunkHec$outboundSchema` instead. */
  export const outboundSchema = MinimumTLSVersionSplunkHec$outboundSchema;
}

/** @internal */
export const MaximumTLSVersionSplunkHec$inboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionSplunkHec
> = z.nativeEnum(MaximumTLSVersionSplunkHec);

/** @internal */
export const MaximumTLSVersionSplunkHec$outboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionSplunkHec
> = MaximumTLSVersionSplunkHec$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaximumTLSVersionSplunkHec$ {
  /** @deprecated use `MaximumTLSVersionSplunkHec$inboundSchema` instead. */
  export const inboundSchema = MaximumTLSVersionSplunkHec$inboundSchema;
  /** @deprecated use `MaximumTLSVersionSplunkHec$outboundSchema` instead. */
  export const outboundSchema = MaximumTLSVersionSplunkHec$outboundSchema;
}

/** @internal */
export const TLSSettingsServerSideSplunkHec$inboundSchema: z.ZodType<
  TLSSettingsServerSideSplunkHec,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionSplunkHec$inboundSchema.optional(),
  maxVersion: MaximumTLSVersionSplunkHec$inboundSchema.optional(),
});

/** @internal */
export type TLSSettingsServerSideSplunkHec$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TLSSettingsServerSideSplunkHec$outboundSchema: z.ZodType<
  TLSSettingsServerSideSplunkHec$Outbound,
  z.ZodTypeDef,
  TLSSettingsServerSideSplunkHec
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionSplunkHec$outboundSchema.optional(),
  maxVersion: MaximumTLSVersionSplunkHec$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsServerSideSplunkHec$ {
  /** @deprecated use `TLSSettingsServerSideSplunkHec$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsServerSideSplunkHec$inboundSchema;
  /** @deprecated use `TLSSettingsServerSideSplunkHec$outboundSchema` instead. */
  export const outboundSchema = TLSSettingsServerSideSplunkHec$outboundSchema;
  /** @deprecated use `TLSSettingsServerSideSplunkHec$Outbound` instead. */
  export type Outbound = TLSSettingsServerSideSplunkHec$Outbound;
}

export function tlsSettingsServerSideSplunkHecToJSON(
  tlsSettingsServerSideSplunkHec: TLSSettingsServerSideSplunkHec,
): string {
  return JSON.stringify(
    TLSSettingsServerSideSplunkHec$outboundSchema.parse(
      tlsSettingsServerSideSplunkHec,
    ),
  );
}

export function tlsSettingsServerSideSplunkHecFromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsServerSideSplunkHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TLSSettingsServerSideSplunkHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsServerSideSplunkHec' from JSON`,
  );
}

/** @internal */
export const MetadatumSplunkHec$inboundSchema: z.ZodType<
  MetadatumSplunkHec,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumSplunkHec$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumSplunkHec$outboundSchema: z.ZodType<
  MetadatumSplunkHec$Outbound,
  z.ZodTypeDef,
  MetadatumSplunkHec
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumSplunkHec$ {
  /** @deprecated use `MetadatumSplunkHec$inboundSchema` instead. */
  export const inboundSchema = MetadatumSplunkHec$inboundSchema;
  /** @deprecated use `MetadatumSplunkHec$outboundSchema` instead. */
  export const outboundSchema = MetadatumSplunkHec$outboundSchema;
  /** @deprecated use `MetadatumSplunkHec$Outbound` instead. */
  export type Outbound = MetadatumSplunkHec$Outbound;
}

export function metadatumSplunkHecToJSON(
  metadatumSplunkHec: MetadatumSplunkHec,
): string {
  return JSON.stringify(
    MetadatumSplunkHec$outboundSchema.parse(metadatumSplunkHec),
  );
}

export function metadatumSplunkHecFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumSplunkHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumSplunkHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumSplunkHec' from JSON`,
  );
}

/** @internal */
export const InputSplunkHec$inboundSchema: z.ZodType<
  InputSplunkHec,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeSplunkHec$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionSplunkHec$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqSplunkHec$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.lazy(() => AuthTokenSplunkHec$inboundSchema))
    .optional(),
  tls: z.lazy(() => TLSSettingsServerSideSplunkHec$inboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.any().optional(),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  splunkHecAPI: z.string().default("/services/collector"),
  metadata: z.array(z.lazy(() => MetadatumSplunkHec$inboundSchema)).optional(),
  allowedIndexes: z.array(z.string()).optional(),
  splunkHecAcks: z.boolean().default(false),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  useFwdTimezone: z.boolean().default(true),
  dropControlFields: z.boolean().default(true),
  extractMetrics: z.boolean().default(false),
  accessControlAllowOrigin: z.array(z.string()).optional(),
  accessControlAllowHeaders: z.array(z.string()).optional(),
  emitTokenMetrics: z.boolean().default(false),
  description: z.string().optional(),
});

/** @internal */
export type InputSplunkHec$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionSplunkHec$Outbound> | undefined;
  pq?: PqSplunkHec$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<AuthTokenSplunkHec$Outbound> | undefined;
  tls?: TLSSettingsServerSideSplunkHec$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck?: any | undefined;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  splunkHecAPI: string;
  metadata?: Array<MetadatumSplunkHec$Outbound> | undefined;
  allowedIndexes?: Array<string> | undefined;
  splunkHecAcks: boolean;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  useFwdTimezone: boolean;
  dropControlFields: boolean;
  extractMetrics: boolean;
  accessControlAllowOrigin?: Array<string> | undefined;
  accessControlAllowHeaders?: Array<string> | undefined;
  emitTokenMetrics: boolean;
  description?: string | undefined;
};

/** @internal */
export const InputSplunkHec$outboundSchema: z.ZodType<
  InputSplunkHec$Outbound,
  z.ZodTypeDef,
  InputSplunkHec
> = z.object({
  id: z.string(),
  type: TypeSplunkHec$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionSplunkHec$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqSplunkHec$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.lazy(() => AuthTokenSplunkHec$outboundSchema))
    .optional(),
  tls: z.lazy(() => TLSSettingsServerSideSplunkHec$outboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.any().optional(),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  splunkHecAPI: z.string().default("/services/collector"),
  metadata: z.array(z.lazy(() => MetadatumSplunkHec$outboundSchema)).optional(),
  allowedIndexes: z.array(z.string()).optional(),
  splunkHecAcks: z.boolean().default(false),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  useFwdTimezone: z.boolean().default(true),
  dropControlFields: z.boolean().default(true),
  extractMetrics: z.boolean().default(false),
  accessControlAllowOrigin: z.array(z.string()).optional(),
  accessControlAllowHeaders: z.array(z.string()).optional(),
  emitTokenMetrics: z.boolean().default(false),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkHec$ {
  /** @deprecated use `InputSplunkHec$inboundSchema` instead. */
  export const inboundSchema = InputSplunkHec$inboundSchema;
  /** @deprecated use `InputSplunkHec$outboundSchema` instead. */
  export const outboundSchema = InputSplunkHec$outboundSchema;
  /** @deprecated use `InputSplunkHec$Outbound` instead. */
  export type Outbound = InputSplunkHec$Outbound;
}

export function inputSplunkHecToJSON(inputSplunkHec: InputSplunkHec): string {
  return JSON.stringify(InputSplunkHec$outboundSchema.parse(inputSplunkHec));
}

export function inputSplunkHecFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkHec' from JSON`,
  );
}

/** @internal */
export const TypeSplunkSearch$inboundSchema: z.ZodNativeEnum<
  typeof TypeSplunkSearch
> = z.nativeEnum(TypeSplunkSearch);

/** @internal */
export const TypeSplunkSearch$outboundSchema: z.ZodNativeEnum<
  typeof TypeSplunkSearch
> = TypeSplunkSearch$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TypeSplunkSearch$ {
  /** @deprecated use `TypeSplunkSearch$inboundSchema` instead. */
  export const inboundSchema = TypeSplunkSearch$inboundSchema;
  /** @deprecated use `TypeSplunkSearch$outboundSchema` instead. */
  export const outboundSchema = TypeSplunkSearch$outboundSchema;
}

/** @internal */
export const ConnectionSplunkSearch$inboundSchema: z.ZodType<
  ConnectionSplunkSearch,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionSplunkSearch$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionSplunkSearch$outboundSchema: z.ZodType<
  ConnectionSplunkSearch$Outbound,
  z.ZodTypeDef,
  ConnectionSplunkSearch
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionSplunkSearch$ {
  /** @deprecated use `ConnectionSplunkSearch$inboundSchema` instead. */
  export const inboundSchema = ConnectionSplunkSearch$inboundSchema;
  /** @deprecated use `ConnectionSplunkSearch$outboundSchema` instead. */
  export const outboundSchema = ConnectionSplunkSearch$outboundSchema;
  /** @deprecated use `ConnectionSplunkSearch$Outbound` instead. */
  export type Outbound = ConnectionSplunkSearch$Outbound;
}

export function connectionSplunkSearchToJSON(
  connectionSplunkSearch: ConnectionSplunkSearch,
): string {
  return JSON.stringify(
    ConnectionSplunkSearch$outboundSchema.parse(connectionSplunkSearch),
  );
}

export function connectionSplunkSearchFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionSplunkSearch, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionSplunkSearch$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionSplunkSearch' from JSON`,
  );
}

/** @internal */
export const ModeSplunkSearch$inboundSchema: z.ZodNativeEnum<
  typeof ModeSplunkSearch
> = z.nativeEnum(ModeSplunkSearch);

/** @internal */
export const ModeSplunkSearch$outboundSchema: z.ZodNativeEnum<
  typeof ModeSplunkSearch
> = ModeSplunkSearch$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModeSplunkSearch$ {
  /** @deprecated use `ModeSplunkSearch$inboundSchema` instead. */
  export const inboundSchema = ModeSplunkSearch$inboundSchema;
  /** @deprecated use `ModeSplunkSearch$outboundSchema` instead. */
  export const outboundSchema = ModeSplunkSearch$outboundSchema;
}

/** @internal */
export const CompressionSplunkSearch$inboundSchema: z.ZodNativeEnum<
  typeof CompressionSplunkSearch
> = z.nativeEnum(CompressionSplunkSearch);

/** @internal */
export const CompressionSplunkSearch$outboundSchema: z.ZodNativeEnum<
  typeof CompressionSplunkSearch
> = CompressionSplunkSearch$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressionSplunkSearch$ {
  /** @deprecated use `CompressionSplunkSearch$inboundSchema` instead. */
  export const inboundSchema = CompressionSplunkSearch$inboundSchema;
  /** @deprecated use `CompressionSplunkSearch$outboundSchema` instead. */
  export const outboundSchema = CompressionSplunkSearch$outboundSchema;
}

/** @internal */
export const PqSplunkSearch$inboundSchema: z.ZodType<
  PqSplunkSearch,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeSplunkSearch$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionSplunkSearch$inboundSchema.default("none"),
});

/** @internal */
export type PqSplunkSearch$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqSplunkSearch$outboundSchema: z.ZodType<
  PqSplunkSearch$Outbound,
  z.ZodTypeDef,
  PqSplunkSearch
> = z.object({
  mode: ModeSplunkSearch$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: CompressionSplunkSearch$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqSplunkSearch$ {
  /** @deprecated use `PqSplunkSearch$inboundSchema` instead. */
  export const inboundSchema = PqSplunkSearch$inboundSchema;
  /** @deprecated use `PqSplunkSearch$outboundSchema` instead. */
  export const outboundSchema = PqSplunkSearch$outboundSchema;
  /** @deprecated use `PqSplunkSearch$Outbound` instead. */
  export type Outbound = PqSplunkSearch$Outbound;
}

export function pqSplunkSearchToJSON(pqSplunkSearch: PqSplunkSearch): string {
  return JSON.stringify(PqSplunkSearch$outboundSchema.parse(pqSplunkSearch));
}

export function pqSplunkSearchFromJSON(
  jsonString: string,
): SafeParseResult<PqSplunkSearch, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqSplunkSearch$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqSplunkSearch' from JSON`,
  );
}

/** @internal */
export const OutputMode$inboundSchema: z.ZodNativeEnum<typeof OutputMode> = z
  .nativeEnum(OutputMode);

/** @internal */
export const OutputMode$outboundSchema: z.ZodNativeEnum<typeof OutputMode> =
  OutputMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMode$ {
  /** @deprecated use `OutputMode$inboundSchema` instead. */
  export const inboundSchema = OutputMode$inboundSchema;
  /** @deprecated use `OutputMode$outboundSchema` instead. */
  export const outboundSchema = OutputMode$outboundSchema;
}

/** @internal */
export const EndpointParam$inboundSchema: z.ZodType<
  EndpointParam,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type EndpointParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const EndpointParam$outboundSchema: z.ZodType<
  EndpointParam$Outbound,
  z.ZodTypeDef,
  EndpointParam
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EndpointParam$ {
  /** @deprecated use `EndpointParam$inboundSchema` instead. */
  export const inboundSchema = EndpointParam$inboundSchema;
  /** @deprecated use `EndpointParam$outboundSchema` instead. */
  export const outboundSchema = EndpointParam$outboundSchema;
  /** @deprecated use `EndpointParam$Outbound` instead. */
  export type Outbound = EndpointParam$Outbound;
}

export function endpointParamToJSON(endpointParam: EndpointParam): string {
  return JSON.stringify(EndpointParam$outboundSchema.parse(endpointParam));
}

export function endpointParamFromJSON(
  jsonString: string,
): SafeParseResult<EndpointParam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EndpointParam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EndpointParam' from JSON`,
  );
}

/** @internal */
export const EndpointHeader$inboundSchema: z.ZodType<
  EndpointHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type EndpointHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const EndpointHeader$outboundSchema: z.ZodType<
  EndpointHeader$Outbound,
  z.ZodTypeDef,
  EndpointHeader
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EndpointHeader$ {
  /** @deprecated use `EndpointHeader$inboundSchema` instead. */
  export const inboundSchema = EndpointHeader$inboundSchema;
  /** @deprecated use `EndpointHeader$outboundSchema` instead. */
  export const outboundSchema = EndpointHeader$outboundSchema;
  /** @deprecated use `EndpointHeader$Outbound` instead. */
  export type Outbound = EndpointHeader$Outbound;
}

export function endpointHeaderToJSON(endpointHeader: EndpointHeader): string {
  return JSON.stringify(EndpointHeader$outboundSchema.parse(endpointHeader));
}

export function endpointHeaderFromJSON(
  jsonString: string,
): SafeParseResult<EndpointHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EndpointHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EndpointHeader' from JSON`,
  );
}

/** @internal */
export const LogLevelSplunkSearch$inboundSchema: z.ZodNativeEnum<
  typeof LogLevelSplunkSearch
> = z.nativeEnum(LogLevelSplunkSearch);

/** @internal */
export const LogLevelSplunkSearch$outboundSchema: z.ZodNativeEnum<
  typeof LogLevelSplunkSearch
> = LogLevelSplunkSearch$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LogLevelSplunkSearch$ {
  /** @deprecated use `LogLevelSplunkSearch$inboundSchema` instead. */
  export const inboundSchema = LogLevelSplunkSearch$inboundSchema;
  /** @deprecated use `LogLevelSplunkSearch$outboundSchema` instead. */
  export const outboundSchema = LogLevelSplunkSearch$outboundSchema;
}

/** @internal */
export const MetadatumSplunkSearch$inboundSchema: z.ZodType<
  MetadatumSplunkSearch,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumSplunkSearch$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumSplunkSearch$outboundSchema: z.ZodType<
  MetadatumSplunkSearch$Outbound,
  z.ZodTypeDef,
  MetadatumSplunkSearch
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumSplunkSearch$ {
  /** @deprecated use `MetadatumSplunkSearch$inboundSchema` instead. */
  export const inboundSchema = MetadatumSplunkSearch$inboundSchema;
  /** @deprecated use `MetadatumSplunkSearch$outboundSchema` instead. */
  export const outboundSchema = MetadatumSplunkSearch$outboundSchema;
  /** @deprecated use `MetadatumSplunkSearch$Outbound` instead. */
  export type Outbound = MetadatumSplunkSearch$Outbound;
}

export function metadatumSplunkSearchToJSON(
  metadatumSplunkSearch: MetadatumSplunkSearch,
): string {
  return JSON.stringify(
    MetadatumSplunkSearch$outboundSchema.parse(metadatumSplunkSearch),
  );
}

export function metadatumSplunkSearchFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumSplunkSearch, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumSplunkSearch$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumSplunkSearch' from JSON`,
  );
}

/** @internal */
export const RetryTypeSplunkSearch$inboundSchema: z.ZodNativeEnum<
  typeof RetryTypeSplunkSearch
> = z.nativeEnum(RetryTypeSplunkSearch);

/** @internal */
export const RetryTypeSplunkSearch$outboundSchema: z.ZodNativeEnum<
  typeof RetryTypeSplunkSearch
> = RetryTypeSplunkSearch$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RetryTypeSplunkSearch$ {
  /** @deprecated use `RetryTypeSplunkSearch$inboundSchema` instead. */
  export const inboundSchema = RetryTypeSplunkSearch$inboundSchema;
  /** @deprecated use `RetryTypeSplunkSearch$outboundSchema` instead. */
  export const outboundSchema = RetryTypeSplunkSearch$outboundSchema;
}

/** @internal */
export const RetryRulesSplunkSearch$inboundSchema: z.ZodType<
  RetryRulesSplunkSearch,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeSplunkSearch$inboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/** @internal */
export type RetryRulesSplunkSearch$Outbound = {
  type: string;
  interval: number;
  limit: number;
  multiplier: number;
  codes?: Array<number> | undefined;
  enableHeader: boolean;
  retryConnectTimeout: boolean;
  retryConnectReset: boolean;
};

/** @internal */
export const RetryRulesSplunkSearch$outboundSchema: z.ZodType<
  RetryRulesSplunkSearch$Outbound,
  z.ZodTypeDef,
  RetryRulesSplunkSearch
> = z.object({
  type: RetryTypeSplunkSearch$outboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RetryRulesSplunkSearch$ {
  /** @deprecated use `RetryRulesSplunkSearch$inboundSchema` instead. */
  export const inboundSchema = RetryRulesSplunkSearch$inboundSchema;
  /** @deprecated use `RetryRulesSplunkSearch$outboundSchema` instead. */
  export const outboundSchema = RetryRulesSplunkSearch$outboundSchema;
  /** @deprecated use `RetryRulesSplunkSearch$Outbound` instead. */
  export type Outbound = RetryRulesSplunkSearch$Outbound;
}

export function retryRulesSplunkSearchToJSON(
  retryRulesSplunkSearch: RetryRulesSplunkSearch,
): string {
  return JSON.stringify(
    RetryRulesSplunkSearch$outboundSchema.parse(retryRulesSplunkSearch),
  );
}

export function retryRulesSplunkSearchFromJSON(
  jsonString: string,
): SafeParseResult<RetryRulesSplunkSearch, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetryRulesSplunkSearch$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetryRulesSplunkSearch' from JSON`,
  );
}

/** @internal */
export const AuthenticationTypeSplunkSearch$inboundSchema: z.ZodNativeEnum<
  typeof AuthenticationTypeSplunkSearch
> = z.nativeEnum(AuthenticationTypeSplunkSearch);

/** @internal */
export const AuthenticationTypeSplunkSearch$outboundSchema: z.ZodNativeEnum<
  typeof AuthenticationTypeSplunkSearch
> = AuthenticationTypeSplunkSearch$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationTypeSplunkSearch$ {
  /** @deprecated use `AuthenticationTypeSplunkSearch$inboundSchema` instead. */
  export const inboundSchema = AuthenticationTypeSplunkSearch$inboundSchema;
  /** @deprecated use `AuthenticationTypeSplunkSearch$outboundSchema` instead. */
  export const outboundSchema = AuthenticationTypeSplunkSearch$outboundSchema;
}

/** @internal */
export const OauthParamSplunkSearch$inboundSchema: z.ZodType<
  OauthParamSplunkSearch,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type OauthParamSplunkSearch$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const OauthParamSplunkSearch$outboundSchema: z.ZodType<
  OauthParamSplunkSearch$Outbound,
  z.ZodTypeDef,
  OauthParamSplunkSearch
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OauthParamSplunkSearch$ {
  /** @deprecated use `OauthParamSplunkSearch$inboundSchema` instead. */
  export const inboundSchema = OauthParamSplunkSearch$inboundSchema;
  /** @deprecated use `OauthParamSplunkSearch$outboundSchema` instead. */
  export const outboundSchema = OauthParamSplunkSearch$outboundSchema;
  /** @deprecated use `OauthParamSplunkSearch$Outbound` instead. */
  export type Outbound = OauthParamSplunkSearch$Outbound;
}

export function oauthParamSplunkSearchToJSON(
  oauthParamSplunkSearch: OauthParamSplunkSearch,
): string {
  return JSON.stringify(
    OauthParamSplunkSearch$outboundSchema.parse(oauthParamSplunkSearch),
  );
}

export function oauthParamSplunkSearchFromJSON(
  jsonString: string,
): SafeParseResult<OauthParamSplunkSearch, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OauthParamSplunkSearch$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OauthParamSplunkSearch' from JSON`,
  );
}

/** @internal */
export const OauthHeaderSplunkSearch$inboundSchema: z.ZodType<
  OauthHeaderSplunkSearch,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type OauthHeaderSplunkSearch$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const OauthHeaderSplunkSearch$outboundSchema: z.ZodType<
  OauthHeaderSplunkSearch$Outbound,
  z.ZodTypeDef,
  OauthHeaderSplunkSearch
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OauthHeaderSplunkSearch$ {
  /** @deprecated use `OauthHeaderSplunkSearch$inboundSchema` instead. */
  export const inboundSchema = OauthHeaderSplunkSearch$inboundSchema;
  /** @deprecated use `OauthHeaderSplunkSearch$outboundSchema` instead. */
  export const outboundSchema = OauthHeaderSplunkSearch$outboundSchema;
  /** @deprecated use `OauthHeaderSplunkSearch$Outbound` instead. */
  export type Outbound = OauthHeaderSplunkSearch$Outbound;
}

export function oauthHeaderSplunkSearchToJSON(
  oauthHeaderSplunkSearch: OauthHeaderSplunkSearch,
): string {
  return JSON.stringify(
    OauthHeaderSplunkSearch$outboundSchema.parse(oauthHeaderSplunkSearch),
  );
}

export function oauthHeaderSplunkSearchFromJSON(
  jsonString: string,
): SafeParseResult<OauthHeaderSplunkSearch, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OauthHeaderSplunkSearch$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OauthHeaderSplunkSearch' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearch$inboundSchema: z.ZodType<
  InputSplunkSearch,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: TypeSplunkSearch$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionSplunkSearch$inboundSchema))
    .optional(),
  pq: z.lazy(() => PqSplunkSearch$inboundSchema).optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode$inboundSchema.default("json"),
  endpointParams: z.array(z.lazy(() => EndpointParam$inboundSchema)).optional(),
  endpointHeaders: z.array(z.lazy(() => EndpointHeader$inboundSchema))
    .optional(),
  logLevel: LogLevelSplunkSearch$inboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumSplunkSearch$inboundSchema))
    .optional(),
  retryRules: z.lazy(() => RetryRulesSplunkSearch$inboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  authType: AuthenticationTypeSplunkSearch$inboundSchema.default("basic"),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => OauthParamSplunkSearch$inboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => OauthHeaderSplunkSearch$inboundSchema))
    .optional(),
});

/** @internal */
export type InputSplunkSearch$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionSplunkSearch$Outbound> | undefined;
  pq?: PqSplunkSearch$Outbound | undefined;
  searchHead: string;
  search: string;
  earliest: string;
  latest: string;
  cronSchedule: string;
  endpoint: string;
  outputMode: string;
  endpointParams?: Array<EndpointParam$Outbound> | undefined;
  endpointHeaders?: Array<EndpointHeader$Outbound> | undefined;
  logLevel?: string | undefined;
  requestTimeout: number;
  useRoundRobinDns: boolean;
  rejectUnauthorized: boolean;
  encoding?: string | undefined;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<MetadatumSplunkSearch$Outbound> | undefined;
  retryRules?: RetryRulesSplunkSearch$Outbound | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  authType: string;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<OauthParamSplunkSearch$Outbound> | undefined;
  oauthHeaders?: Array<OauthHeaderSplunkSearch$Outbound> | undefined;
};

/** @internal */
export const InputSplunkSearch$outboundSchema: z.ZodType<
  InputSplunkSearch$Outbound,
  z.ZodTypeDef,
  InputSplunkSearch
> = z.object({
  id: z.string(),
  type: TypeSplunkSearch$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionSplunkSearch$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqSplunkSearch$outboundSchema).optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode$outboundSchema.default("json"),
  endpointParams: z.array(z.lazy(() => EndpointParam$outboundSchema))
    .optional(),
  endpointHeaders: z.array(z.lazy(() => EndpointHeader$outboundSchema))
    .optional(),
  logLevel: LogLevelSplunkSearch$outboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumSplunkSearch$outboundSchema))
    .optional(),
  retryRules: z.lazy(() => RetryRulesSplunkSearch$outboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  authType: AuthenticationTypeSplunkSearch$outboundSchema.default("basic"),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => OauthParamSplunkSearch$outboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => OauthHeaderSplunkSearch$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearch$ {
  /** @deprecated use `InputSplunkSearch$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearch$inboundSchema;
  /** @deprecated use `InputSplunkSearch$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearch$outboundSchema;
  /** @deprecated use `InputSplunkSearch$Outbound` instead. */
  export type Outbound = InputSplunkSearch$Outbound;
}

export function inputSplunkSearchToJSON(
  inputSplunkSearch: InputSplunkSearch,
): string {
  return JSON.stringify(
    InputSplunkSearch$outboundSchema.parse(inputSplunkSearch),
  );
}

export function inputSplunkSearchFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearch, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearch$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearch' from JSON`,
  );
}

/** @internal */
export const CreateInputTypeSplunk$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeSplunk
> = z.nativeEnum(CreateInputTypeSplunk);

/** @internal */
export const CreateInputTypeSplunk$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeSplunk
> = CreateInputTypeSplunk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputTypeSplunk$ {
  /** @deprecated use `CreateInputTypeSplunk$inboundSchema` instead. */
  export const inboundSchema = CreateInputTypeSplunk$inboundSchema;
  /** @deprecated use `CreateInputTypeSplunk$outboundSchema` instead. */
  export const outboundSchema = CreateInputTypeSplunk$outboundSchema;
}

/** @internal */
export const ConnectionSplunk$inboundSchema: z.ZodType<
  ConnectionSplunk,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionSplunk$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionSplunk$outboundSchema: z.ZodType<
  ConnectionSplunk$Outbound,
  z.ZodTypeDef,
  ConnectionSplunk
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionSplunk$ {
  /** @deprecated use `ConnectionSplunk$inboundSchema` instead. */
  export const inboundSchema = ConnectionSplunk$inboundSchema;
  /** @deprecated use `ConnectionSplunk$outboundSchema` instead. */
  export const outboundSchema = ConnectionSplunk$outboundSchema;
  /** @deprecated use `ConnectionSplunk$Outbound` instead. */
  export type Outbound = ConnectionSplunk$Outbound;
}

export function connectionSplunkToJSON(
  connectionSplunk: ConnectionSplunk,
): string {
  return JSON.stringify(
    ConnectionSplunk$outboundSchema.parse(connectionSplunk),
  );
}

export function connectionSplunkFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionSplunk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionSplunk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionSplunk' from JSON`,
  );
}

/** @internal */
export const CreateInputModeSplunk$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputModeSplunk
> = z.nativeEnum(CreateInputModeSplunk);

/** @internal */
export const CreateInputModeSplunk$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputModeSplunk
> = CreateInputModeSplunk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputModeSplunk$ {
  /** @deprecated use `CreateInputModeSplunk$inboundSchema` instead. */
  export const inboundSchema = CreateInputModeSplunk$inboundSchema;
  /** @deprecated use `CreateInputModeSplunk$outboundSchema` instead. */
  export const outboundSchema = CreateInputModeSplunk$outboundSchema;
}

/** @internal */
export const PqCompressionSplunk$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressionSplunk
> = z.nativeEnum(PqCompressionSplunk);

/** @internal */
export const PqCompressionSplunk$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressionSplunk
> = PqCompressionSplunk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressionSplunk$ {
  /** @deprecated use `PqCompressionSplunk$inboundSchema` instead. */
  export const inboundSchema = PqCompressionSplunk$inboundSchema;
  /** @deprecated use `PqCompressionSplunk$outboundSchema` instead. */
  export const outboundSchema = PqCompressionSplunk$outboundSchema;
}

/** @internal */
export const PqSplunk$inboundSchema: z.ZodType<
  PqSplunk,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: CreateInputModeSplunk$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: PqCompressionSplunk$inboundSchema.default("none"),
});

/** @internal */
export type PqSplunk$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqSplunk$outboundSchema: z.ZodType<
  PqSplunk$Outbound,
  z.ZodTypeDef,
  PqSplunk
> = z.object({
  mode: CreateInputModeSplunk$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: PqCompressionSplunk$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqSplunk$ {
  /** @deprecated use `PqSplunk$inboundSchema` instead. */
  export const inboundSchema = PqSplunk$inboundSchema;
  /** @deprecated use `PqSplunk$outboundSchema` instead. */
  export const outboundSchema = PqSplunk$outboundSchema;
  /** @deprecated use `PqSplunk$Outbound` instead. */
  export type Outbound = PqSplunk$Outbound;
}

export function pqSplunkToJSON(pqSplunk: PqSplunk): string {
  return JSON.stringify(PqSplunk$outboundSchema.parse(pqSplunk));
}

export function pqSplunkFromJSON(
  jsonString: string,
): SafeParseResult<PqSplunk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqSplunk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqSplunk' from JSON`,
  );
}

/** @internal */
export const CreateInputMinimumTLSVersionSplunk$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputMinimumTLSVersionSplunk
> = z.nativeEnum(CreateInputMinimumTLSVersionSplunk);

/** @internal */
export const CreateInputMinimumTLSVersionSplunk$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputMinimumTLSVersionSplunk
> = CreateInputMinimumTLSVersionSplunk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputMinimumTLSVersionSplunk$ {
  /** @deprecated use `CreateInputMinimumTLSVersionSplunk$inboundSchema` instead. */
  export const inboundSchema = CreateInputMinimumTLSVersionSplunk$inboundSchema;
  /** @deprecated use `CreateInputMinimumTLSVersionSplunk$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputMinimumTLSVersionSplunk$outboundSchema;
}

/** @internal */
export const CreateInputMaximumTLSVersionSplunk$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputMaximumTLSVersionSplunk
> = z.nativeEnum(CreateInputMaximumTLSVersionSplunk);

/** @internal */
export const CreateInputMaximumTLSVersionSplunk$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputMaximumTLSVersionSplunk
> = CreateInputMaximumTLSVersionSplunk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputMaximumTLSVersionSplunk$ {
  /** @deprecated use `CreateInputMaximumTLSVersionSplunk$inboundSchema` instead. */
  export const inboundSchema = CreateInputMaximumTLSVersionSplunk$inboundSchema;
  /** @deprecated use `CreateInputMaximumTLSVersionSplunk$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputMaximumTLSVersionSplunk$outboundSchema;
}

/** @internal */
export const TLSSettingsServerSideSplunk$inboundSchema: z.ZodType<
  TLSSettingsServerSideSplunk,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: CreateInputMinimumTLSVersionSplunk$inboundSchema.optional(),
  maxVersion: CreateInputMaximumTLSVersionSplunk$inboundSchema.optional(),
});

/** @internal */
export type TLSSettingsServerSideSplunk$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TLSSettingsServerSideSplunk$outboundSchema: z.ZodType<
  TLSSettingsServerSideSplunk$Outbound,
  z.ZodTypeDef,
  TLSSettingsServerSideSplunk
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: CreateInputMinimumTLSVersionSplunk$outboundSchema.optional(),
  maxVersion: CreateInputMaximumTLSVersionSplunk$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsServerSideSplunk$ {
  /** @deprecated use `TLSSettingsServerSideSplunk$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsServerSideSplunk$inboundSchema;
  /** @deprecated use `TLSSettingsServerSideSplunk$outboundSchema` instead. */
  export const outboundSchema = TLSSettingsServerSideSplunk$outboundSchema;
  /** @deprecated use `TLSSettingsServerSideSplunk$Outbound` instead. */
  export type Outbound = TLSSettingsServerSideSplunk$Outbound;
}

export function tlsSettingsServerSideSplunkToJSON(
  tlsSettingsServerSideSplunk: TLSSettingsServerSideSplunk,
): string {
  return JSON.stringify(
    TLSSettingsServerSideSplunk$outboundSchema.parse(
      tlsSettingsServerSideSplunk,
    ),
  );
}

export function tlsSettingsServerSideSplunkFromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsServerSideSplunk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TLSSettingsServerSideSplunk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsServerSideSplunk' from JSON`,
  );
}

/** @internal */
export const MetadatumSplunk$inboundSchema: z.ZodType<
  MetadatumSplunk,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumSplunk$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumSplunk$outboundSchema: z.ZodType<
  MetadatumSplunk$Outbound,
  z.ZodTypeDef,
  MetadatumSplunk
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumSplunk$ {
  /** @deprecated use `MetadatumSplunk$inboundSchema` instead. */
  export const inboundSchema = MetadatumSplunk$inboundSchema;
  /** @deprecated use `MetadatumSplunk$outboundSchema` instead. */
  export const outboundSchema = MetadatumSplunk$outboundSchema;
  /** @deprecated use `MetadatumSplunk$Outbound` instead. */
  export type Outbound = MetadatumSplunk$Outbound;
}

export function metadatumSplunkToJSON(
  metadatumSplunk: MetadatumSplunk,
): string {
  return JSON.stringify(MetadatumSplunk$outboundSchema.parse(metadatumSplunk));
}

export function metadatumSplunkFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumSplunk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumSplunk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumSplunk' from JSON`,
  );
}

/** @internal */
export const AuthTokenSplunk$inboundSchema: z.ZodType<
  AuthTokenSplunk,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  description: z.string().optional(),
});

/** @internal */
export type AuthTokenSplunk$Outbound = {
  token: string;
  description?: string | undefined;
};

/** @internal */
export const AuthTokenSplunk$outboundSchema: z.ZodType<
  AuthTokenSplunk$Outbound,
  z.ZodTypeDef,
  AuthTokenSplunk
> = z.object({
  token: z.string(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenSplunk$ {
  /** @deprecated use `AuthTokenSplunk$inboundSchema` instead. */
  export const inboundSchema = AuthTokenSplunk$inboundSchema;
  /** @deprecated use `AuthTokenSplunk$outboundSchema` instead. */
  export const outboundSchema = AuthTokenSplunk$outboundSchema;
  /** @deprecated use `AuthTokenSplunk$Outbound` instead. */
  export type Outbound = AuthTokenSplunk$Outbound;
}

export function authTokenSplunkToJSON(
  authTokenSplunk: AuthTokenSplunk,
): string {
  return JSON.stringify(AuthTokenSplunk$outboundSchema.parse(authTokenSplunk));
}

export function authTokenSplunkFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokenSplunk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthTokenSplunk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokenSplunk' from JSON`,
  );
}

/** @internal */
export const CreateInputMaxS2SVersion$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputMaxS2SVersion
> = z.nativeEnum(CreateInputMaxS2SVersion);

/** @internal */
export const CreateInputMaxS2SVersion$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputMaxS2SVersion
> = CreateInputMaxS2SVersion$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputMaxS2SVersion$ {
  /** @deprecated use `CreateInputMaxS2SVersion$inboundSchema` instead. */
  export const inboundSchema = CreateInputMaxS2SVersion$inboundSchema;
  /** @deprecated use `CreateInputMaxS2SVersion$outboundSchema` instead. */
  export const outboundSchema = CreateInputMaxS2SVersion$outboundSchema;
}

/** @internal */
export const CreateInputCompressionSplunk$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputCompressionSplunk
> = z.nativeEnum(CreateInputCompressionSplunk);

/** @internal */
export const CreateInputCompressionSplunk$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputCompressionSplunk
> = CreateInputCompressionSplunk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputCompressionSplunk$ {
  /** @deprecated use `CreateInputCompressionSplunk$inboundSchema` instead. */
  export const inboundSchema = CreateInputCompressionSplunk$inboundSchema;
  /** @deprecated use `CreateInputCompressionSplunk$outboundSchema` instead. */
  export const outboundSchema = CreateInputCompressionSplunk$outboundSchema;
}

/** @internal */
export const InputSplunk$inboundSchema: z.ZodType<
  InputSplunk,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateInputTypeSplunk$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionSplunk$inboundSchema)).optional(),
  pq: z.lazy(() => PqSplunk$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => TLSSettingsServerSideSplunk$inboundSchema).optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumSplunk$inboundSchema)).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  authTokens: z.array(z.lazy(() => AuthTokenSplunk$inboundSchema)).optional(),
  maxS2Sversion: CreateInputMaxS2SVersion$inboundSchema.default("v3"),
  description: z.string().optional(),
  useFwdTimezone: z.boolean().default(true),
  dropControlFields: z.boolean().default(true),
  extractMetrics: z.boolean().default(false),
  compress: CreateInputCompressionSplunk$inboundSchema.default("disabled"),
});

/** @internal */
export type InputSplunk$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionSplunk$Outbound> | undefined;
  pq?: PqSplunk$Outbound | undefined;
  host: string;
  port: number;
  tls?: TLSSettingsServerSideSplunk$Outbound | undefined;
  ipWhitelistRegex: string;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  enableProxyHeader: boolean;
  metadata?: Array<MetadatumSplunk$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  authTokens?: Array<AuthTokenSplunk$Outbound> | undefined;
  maxS2Sversion: string;
  description?: string | undefined;
  useFwdTimezone: boolean;
  dropControlFields: boolean;
  extractMetrics: boolean;
  compress: string;
};

/** @internal */
export const InputSplunk$outboundSchema: z.ZodType<
  InputSplunk$Outbound,
  z.ZodTypeDef,
  InputSplunk
> = z.object({
  id: z.string(),
  type: CreateInputTypeSplunk$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionSplunk$outboundSchema))
    .optional(),
  pq: z.lazy(() => PqSplunk$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => TLSSettingsServerSideSplunk$outboundSchema).optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(z.lazy(() => MetadatumSplunk$outboundSchema)).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  authTokens: z.array(z.lazy(() => AuthTokenSplunk$outboundSchema)).optional(),
  maxS2Sversion: CreateInputMaxS2SVersion$outboundSchema.default("v3"),
  description: z.string().optional(),
  useFwdTimezone: z.boolean().default(true),
  dropControlFields: z.boolean().default(true),
  extractMetrics: z.boolean().default(false),
  compress: CreateInputCompressionSplunk$outboundSchema.default("disabled"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunk$ {
  /** @deprecated use `InputSplunk$inboundSchema` instead. */
  export const inboundSchema = InputSplunk$inboundSchema;
  /** @deprecated use `InputSplunk$outboundSchema` instead. */
  export const outboundSchema = InputSplunk$outboundSchema;
  /** @deprecated use `InputSplunk$Outbound` instead. */
  export type Outbound = InputSplunk$Outbound;
}

export function inputSplunkToJSON(inputSplunk: InputSplunk): string {
  return JSON.stringify(InputSplunk$outboundSchema.parse(inputSplunk));
}

export function inputSplunkFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunk' from JSON`,
  );
}

/** @internal */
export const CreateInputTypeHTTP$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeHTTP
> = z.nativeEnum(CreateInputTypeHTTP);

/** @internal */
export const CreateInputTypeHTTP$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeHTTP
> = CreateInputTypeHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputTypeHTTP$ {
  /** @deprecated use `CreateInputTypeHTTP$inboundSchema` instead. */
  export const inboundSchema = CreateInputTypeHTTP$inboundSchema;
  /** @deprecated use `CreateInputTypeHTTP$outboundSchema` instead. */
  export const outboundSchema = CreateInputTypeHTTP$outboundSchema;
}

/** @internal */
export const ConnectionHTTP$inboundSchema: z.ZodType<
  ConnectionHTTP,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionHTTP$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionHTTP$outboundSchema: z.ZodType<
  ConnectionHTTP$Outbound,
  z.ZodTypeDef,
  ConnectionHTTP
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionHTTP$ {
  /** @deprecated use `ConnectionHTTP$inboundSchema` instead. */
  export const inboundSchema = ConnectionHTTP$inboundSchema;
  /** @deprecated use `ConnectionHTTP$outboundSchema` instead. */
  export const outboundSchema = ConnectionHTTP$outboundSchema;
  /** @deprecated use `ConnectionHTTP$Outbound` instead. */
  export type Outbound = ConnectionHTTP$Outbound;
}

export function connectionHTTPToJSON(connectionHTTP: ConnectionHTTP): string {
  return JSON.stringify(ConnectionHTTP$outboundSchema.parse(connectionHTTP));
}

export function connectionHTTPFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionHTTP' from JSON`,
  );
}

/** @internal */
export const CreateInputModeHTTP$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputModeHTTP
> = z.nativeEnum(CreateInputModeHTTP);

/** @internal */
export const CreateInputModeHTTP$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputModeHTTP
> = CreateInputModeHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputModeHTTP$ {
  /** @deprecated use `CreateInputModeHTTP$inboundSchema` instead. */
  export const inboundSchema = CreateInputModeHTTP$inboundSchema;
  /** @deprecated use `CreateInputModeHTTP$outboundSchema` instead. */
  export const outboundSchema = CreateInputModeHTTP$outboundSchema;
}

/** @internal */
export const PqCompressionHTTP$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressionHTTP
> = z.nativeEnum(PqCompressionHTTP);

/** @internal */
export const PqCompressionHTTP$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressionHTTP
> = PqCompressionHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressionHTTP$ {
  /** @deprecated use `PqCompressionHTTP$inboundSchema` instead. */
  export const inboundSchema = PqCompressionHTTP$inboundSchema;
  /** @deprecated use `PqCompressionHTTP$outboundSchema` instead. */
  export const outboundSchema = PqCompressionHTTP$outboundSchema;
}

/** @internal */
export const PqHTTP$inboundSchema: z.ZodType<PqHTTP, z.ZodTypeDef, unknown> = z
  .object({
    mode: CreateInputModeHTTP$inboundSchema.default("always"),
    maxBufferSize: z.number().default(1000),
    commitFrequency: z.number().default(42),
    maxFileSize: z.string().default("1 MB"),
    maxSize: z.string().default("5GB"),
    path: z.string().default("$CRIBL_HOME/state/queues"),
    compress: PqCompressionHTTP$inboundSchema.default("none"),
  });

/** @internal */
export type PqHTTP$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqHTTP$outboundSchema: z.ZodType<
  PqHTTP$Outbound,
  z.ZodTypeDef,
  PqHTTP
> = z.object({
  mode: CreateInputModeHTTP$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: PqCompressionHTTP$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqHTTP$ {
  /** @deprecated use `PqHTTP$inboundSchema` instead. */
  export const inboundSchema = PqHTTP$inboundSchema;
  /** @deprecated use `PqHTTP$outboundSchema` instead. */
  export const outboundSchema = PqHTTP$outboundSchema;
  /** @deprecated use `PqHTTP$Outbound` instead. */
  export type Outbound = PqHTTP$Outbound;
}

export function pqHTTPToJSON(pqHTTP: PqHTTP): string {
  return JSON.stringify(PqHTTP$outboundSchema.parse(pqHTTP));
}

export function pqHTTPFromJSON(
  jsonString: string,
): SafeParseResult<PqHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqHTTP' from JSON`,
  );
}

/** @internal */
export const MinimumTLSVersionHTTP$inboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionHTTP
> = z.nativeEnum(MinimumTLSVersionHTTP);

/** @internal */
export const MinimumTLSVersionHTTP$outboundSchema: z.ZodNativeEnum<
  typeof MinimumTLSVersionHTTP
> = MinimumTLSVersionHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MinimumTLSVersionHTTP$ {
  /** @deprecated use `MinimumTLSVersionHTTP$inboundSchema` instead. */
  export const inboundSchema = MinimumTLSVersionHTTP$inboundSchema;
  /** @deprecated use `MinimumTLSVersionHTTP$outboundSchema` instead. */
  export const outboundSchema = MinimumTLSVersionHTTP$outboundSchema;
}

/** @internal */
export const MaximumTLSVersionHTTP$inboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionHTTP
> = z.nativeEnum(MaximumTLSVersionHTTP);

/** @internal */
export const MaximumTLSVersionHTTP$outboundSchema: z.ZodNativeEnum<
  typeof MaximumTLSVersionHTTP
> = MaximumTLSVersionHTTP$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MaximumTLSVersionHTTP$ {
  /** @deprecated use `MaximumTLSVersionHTTP$inboundSchema` instead. */
  export const inboundSchema = MaximumTLSVersionHTTP$inboundSchema;
  /** @deprecated use `MaximumTLSVersionHTTP$outboundSchema` instead. */
  export const outboundSchema = MaximumTLSVersionHTTP$outboundSchema;
}

/** @internal */
export const TLSSettingsServerSideHTTP$inboundSchema: z.ZodType<
  TLSSettingsServerSideHTTP,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionHTTP$inboundSchema.optional(),
  maxVersion: MaximumTLSVersionHTTP$inboundSchema.optional(),
});

/** @internal */
export type TLSSettingsServerSideHTTP$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const TLSSettingsServerSideHTTP$outboundSchema: z.ZodType<
  TLSSettingsServerSideHTTP$Outbound,
  z.ZodTypeDef,
  TLSSettingsServerSideHTTP
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: MinimumTLSVersionHTTP$outboundSchema.optional(),
  maxVersion: MaximumTLSVersionHTTP$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TLSSettingsServerSideHTTP$ {
  /** @deprecated use `TLSSettingsServerSideHTTP$inboundSchema` instead. */
  export const inboundSchema = TLSSettingsServerSideHTTP$inboundSchema;
  /** @deprecated use `TLSSettingsServerSideHTTP$outboundSchema` instead. */
  export const outboundSchema = TLSSettingsServerSideHTTP$outboundSchema;
  /** @deprecated use `TLSSettingsServerSideHTTP$Outbound` instead. */
  export type Outbound = TLSSettingsServerSideHTTP$Outbound;
}

export function tlsSettingsServerSideHTTPToJSON(
  tlsSettingsServerSideHTTP: TLSSettingsServerSideHTTP,
): string {
  return JSON.stringify(
    TLSSettingsServerSideHTTP$outboundSchema.parse(tlsSettingsServerSideHTTP),
  );
}

export function tlsSettingsServerSideHTTPFromJSON(
  jsonString: string,
): SafeParseResult<TLSSettingsServerSideHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TLSSettingsServerSideHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TLSSettingsServerSideHTTP' from JSON`,
  );
}

/** @internal */
export const CreateInputMetadatumHTTP$inboundSchema: z.ZodType<
  CreateInputMetadatumHTTP,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type CreateInputMetadatumHTTP$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CreateInputMetadatumHTTP$outboundSchema: z.ZodType<
  CreateInputMetadatumHTTP$Outbound,
  z.ZodTypeDef,
  CreateInputMetadatumHTTP
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputMetadatumHTTP$ {
  /** @deprecated use `CreateInputMetadatumHTTP$inboundSchema` instead. */
  export const inboundSchema = CreateInputMetadatumHTTP$inboundSchema;
  /** @deprecated use `CreateInputMetadatumHTTP$outboundSchema` instead. */
  export const outboundSchema = CreateInputMetadatumHTTP$outboundSchema;
  /** @deprecated use `CreateInputMetadatumHTTP$Outbound` instead. */
  export type Outbound = CreateInputMetadatumHTTP$Outbound;
}

export function createInputMetadatumHTTPToJSON(
  createInputMetadatumHTTP: CreateInputMetadatumHTTP,
): string {
  return JSON.stringify(
    CreateInputMetadatumHTTP$outboundSchema.parse(createInputMetadatumHTTP),
  );
}

export function createInputMetadatumHTTPFromJSON(
  jsonString: string,
): SafeParseResult<CreateInputMetadatumHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateInputMetadatumHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateInputMetadatumHTTP' from JSON`,
  );
}

/** @internal */
export const AuthTokensExtMetadatumHTTP$inboundSchema: z.ZodType<
  AuthTokensExtMetadatumHTTP,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type AuthTokensExtMetadatumHTTP$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const AuthTokensExtMetadatumHTTP$outboundSchema: z.ZodType<
  AuthTokensExtMetadatumHTTP$Outbound,
  z.ZodTypeDef,
  AuthTokensExtMetadatumHTTP
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokensExtMetadatumHTTP$ {
  /** @deprecated use `AuthTokensExtMetadatumHTTP$inboundSchema` instead. */
  export const inboundSchema = AuthTokensExtMetadatumHTTP$inboundSchema;
  /** @deprecated use `AuthTokensExtMetadatumHTTP$outboundSchema` instead. */
  export const outboundSchema = AuthTokensExtMetadatumHTTP$outboundSchema;
  /** @deprecated use `AuthTokensExtMetadatumHTTP$Outbound` instead. */
  export type Outbound = AuthTokensExtMetadatumHTTP$Outbound;
}

export function authTokensExtMetadatumHTTPToJSON(
  authTokensExtMetadatumHTTP: AuthTokensExtMetadatumHTTP,
): string {
  return JSON.stringify(
    AuthTokensExtMetadatumHTTP$outboundSchema.parse(authTokensExtMetadatumHTTP),
  );
}

export function authTokensExtMetadatumHTTPFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokensExtMetadatumHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthTokensExtMetadatumHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokensExtMetadatumHTTP' from JSON`,
  );
}

/** @internal */
export const AuthTokensExtHTTP$inboundSchema: z.ZodType<
  AuthTokensExtHTTP,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  description: z.string().optional(),
  metadata: z.array(z.lazy(() => AuthTokensExtMetadatumHTTP$inboundSchema))
    .optional(),
});

/** @internal */
export type AuthTokensExtHTTP$Outbound = {
  token: string;
  description?: string | undefined;
  metadata?: Array<AuthTokensExtMetadatumHTTP$Outbound> | undefined;
};

/** @internal */
export const AuthTokensExtHTTP$outboundSchema: z.ZodType<
  AuthTokensExtHTTP$Outbound,
  z.ZodTypeDef,
  AuthTokensExtHTTP
> = z.object({
  token: z.string(),
  description: z.string().optional(),
  metadata: z.array(z.lazy(() => AuthTokensExtMetadatumHTTP$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokensExtHTTP$ {
  /** @deprecated use `AuthTokensExtHTTP$inboundSchema` instead. */
  export const inboundSchema = AuthTokensExtHTTP$inboundSchema;
  /** @deprecated use `AuthTokensExtHTTP$outboundSchema` instead. */
  export const outboundSchema = AuthTokensExtHTTP$outboundSchema;
  /** @deprecated use `AuthTokensExtHTTP$Outbound` instead. */
  export type Outbound = AuthTokensExtHTTP$Outbound;
}

export function authTokensExtHTTPToJSON(
  authTokensExtHTTP: AuthTokensExtHTTP,
): string {
  return JSON.stringify(
    AuthTokensExtHTTP$outboundSchema.parse(authTokensExtHTTP),
  );
}

export function authTokensExtHTTPFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokensExtHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthTokensExtHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokensExtHTTP' from JSON`,
  );
}

/** @internal */
export const InputHttp$inboundSchema: z.ZodType<
  InputHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateInputTypeHTTP$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionHTTP$inboundSchema)).optional(),
  pq: z.lazy(() => PqHTTP$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: z.lazy(() => TLSSettingsServerSideHTTP$inboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  criblAPI: z.string().default("/cribl"),
  elasticAPI: z.string().default("/elastic"),
  splunkHecAPI: z.string().default("/services/collector"),
  splunkHecAcks: z.boolean().default(false),
  metadata: z.array(z.lazy(() => CreateInputMetadatumHTTP$inboundSchema))
    .optional(),
  authTokensExt: z.array(z.lazy(() => AuthTokensExtHTTP$inboundSchema))
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputHttp$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionHTTP$Outbound> | undefined;
  pq?: PqHTTP$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: TLSSettingsServerSideHTTP$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  criblAPI: string;
  elasticAPI: string;
  splunkHecAPI: string;
  splunkHecAcks: boolean;
  metadata?: Array<CreateInputMetadatumHTTP$Outbound> | undefined;
  authTokensExt?: Array<AuthTokensExtHTTP$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputHttp$outboundSchema: z.ZodType<
  InputHttp$Outbound,
  z.ZodTypeDef,
  InputHttp
> = z.object({
  id: z.string(),
  type: CreateInputTypeHTTP$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionHTTP$outboundSchema)).optional(),
  pq: z.lazy(() => PqHTTP$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: z.lazy(() => TLSSettingsServerSideHTTP$outboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  criblAPI: z.string().default("/cribl"),
  elasticAPI: z.string().default("/elastic"),
  splunkHecAPI: z.string().default("/services/collector"),
  splunkHecAcks: z.boolean().default(false),
  metadata: z.array(z.lazy(() => CreateInputMetadatumHTTP$outboundSchema))
    .optional(),
  authTokensExt: z.array(z.lazy(() => AuthTokensExtHTTP$outboundSchema))
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttp$ {
  /** @deprecated use `InputHttp$inboundSchema` instead. */
  export const inboundSchema = InputHttp$inboundSchema;
  /** @deprecated use `InputHttp$outboundSchema` instead. */
  export const outboundSchema = InputHttp$outboundSchema;
  /** @deprecated use `InputHttp$Outbound` instead. */
  export type Outbound = InputHttp$Outbound;
}

export function inputHttpToJSON(inputHttp: InputHttp): string {
  return JSON.stringify(InputHttp$outboundSchema.parse(inputHttp));
}

export function inputHttpFromJSON(
  jsonString: string,
): SafeParseResult<InputHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputHttp' from JSON`,
  );
}

/** @internal */
export const CreateInputTypeMsk$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeMsk
> = z.nativeEnum(CreateInputTypeMsk);

/** @internal */
export const CreateInputTypeMsk$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeMsk
> = CreateInputTypeMsk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputTypeMsk$ {
  /** @deprecated use `CreateInputTypeMsk$inboundSchema` instead. */
  export const inboundSchema = CreateInputTypeMsk$inboundSchema;
  /** @deprecated use `CreateInputTypeMsk$outboundSchema` instead. */
  export const outboundSchema = CreateInputTypeMsk$outboundSchema;
}

/** @internal */
export const ConnectionMsk$inboundSchema: z.ZodType<
  ConnectionMsk,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionMsk$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionMsk$outboundSchema: z.ZodType<
  ConnectionMsk$Outbound,
  z.ZodTypeDef,
  ConnectionMsk
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionMsk$ {
  /** @deprecated use `ConnectionMsk$inboundSchema` instead. */
  export const inboundSchema = ConnectionMsk$inboundSchema;
  /** @deprecated use `ConnectionMsk$outboundSchema` instead. */
  export const outboundSchema = ConnectionMsk$outboundSchema;
  /** @deprecated use `ConnectionMsk$Outbound` instead. */
  export type Outbound = ConnectionMsk$Outbound;
}

export function connectionMskToJSON(connectionMsk: ConnectionMsk): string {
  return JSON.stringify(ConnectionMsk$outboundSchema.parse(connectionMsk));
}

export function connectionMskFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionMsk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionMsk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionMsk' from JSON`,
  );
}

/** @internal */
export const CreateInputModeMsk$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputModeMsk
> = z.nativeEnum(CreateInputModeMsk);

/** @internal */
export const CreateInputModeMsk$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputModeMsk
> = CreateInputModeMsk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputModeMsk$ {
  /** @deprecated use `CreateInputModeMsk$inboundSchema` instead. */
  export const inboundSchema = CreateInputModeMsk$inboundSchema;
  /** @deprecated use `CreateInputModeMsk$outboundSchema` instead. */
  export const outboundSchema = CreateInputModeMsk$outboundSchema;
}

/** @internal */
export const PqCompressionMsk$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressionMsk
> = z.nativeEnum(PqCompressionMsk);

/** @internal */
export const PqCompressionMsk$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressionMsk
> = PqCompressionMsk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressionMsk$ {
  /** @deprecated use `PqCompressionMsk$inboundSchema` instead. */
  export const inboundSchema = PqCompressionMsk$inboundSchema;
  /** @deprecated use `PqCompressionMsk$outboundSchema` instead. */
  export const outboundSchema = PqCompressionMsk$outboundSchema;
}

/** @internal */
export const PqMsk$inboundSchema: z.ZodType<PqMsk, z.ZodTypeDef, unknown> = z
  .object({
    mode: CreateInputModeMsk$inboundSchema.default("always"),
    maxBufferSize: z.number().default(1000),
    commitFrequency: z.number().default(42),
    maxFileSize: z.string().default("1 MB"),
    maxSize: z.string().default("5GB"),
    path: z.string().default("$CRIBL_HOME/state/queues"),
    compress: PqCompressionMsk$inboundSchema.default("none"),
  });

/** @internal */
export type PqMsk$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqMsk$outboundSchema: z.ZodType<
  PqMsk$Outbound,
  z.ZodTypeDef,
  PqMsk
> = z.object({
  mode: CreateInputModeMsk$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: PqCompressionMsk$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqMsk$ {
  /** @deprecated use `PqMsk$inboundSchema` instead. */
  export const inboundSchema = PqMsk$inboundSchema;
  /** @deprecated use `PqMsk$outboundSchema` instead. */
  export const outboundSchema = PqMsk$outboundSchema;
  /** @deprecated use `PqMsk$Outbound` instead. */
  export type Outbound = PqMsk$Outbound;
}

export function pqMskToJSON(pqMsk: PqMsk): string {
  return JSON.stringify(PqMsk$outboundSchema.parse(pqMsk));
}

export function pqMskFromJSON(
  jsonString: string,
): SafeParseResult<PqMsk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqMsk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqMsk' from JSON`,
  );
}

/** @internal */
export const MetadatumMsk$inboundSchema: z.ZodType<
  MetadatumMsk,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumMsk$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumMsk$outboundSchema: z.ZodType<
  MetadatumMsk$Outbound,
  z.ZodTypeDef,
  MetadatumMsk
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumMsk$ {
  /** @deprecated use `MetadatumMsk$inboundSchema` instead. */
  export const inboundSchema = MetadatumMsk$inboundSchema;
  /** @deprecated use `MetadatumMsk$outboundSchema` instead. */
  export const outboundSchema = MetadatumMsk$outboundSchema;
  /** @deprecated use `MetadatumMsk$Outbound` instead. */
  export type Outbound = MetadatumMsk$Outbound;
}

export function metadatumMskToJSON(metadatumMsk: MetadatumMsk): string {
  return JSON.stringify(MetadatumMsk$outboundSchema.parse(metadatumMsk));
}

export function metadatumMskFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumMsk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumMsk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumMsk' from JSON`,
  );
}

/** @internal */
export const CreateInputAuthMsk$inboundSchema: z.ZodType<
  CreateInputAuthMsk,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/** @internal */
export type CreateInputAuthMsk$Outbound = {
  disabled: boolean;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const CreateInputAuthMsk$outboundSchema: z.ZodType<
  CreateInputAuthMsk$Outbound,
  z.ZodTypeDef,
  CreateInputAuthMsk
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputAuthMsk$ {
  /** @deprecated use `CreateInputAuthMsk$inboundSchema` instead. */
  export const inboundSchema = CreateInputAuthMsk$inboundSchema;
  /** @deprecated use `CreateInputAuthMsk$outboundSchema` instead. */
  export const outboundSchema = CreateInputAuthMsk$outboundSchema;
  /** @deprecated use `CreateInputAuthMsk$Outbound` instead. */
  export type Outbound = CreateInputAuthMsk$Outbound;
}

export function createInputAuthMskToJSON(
  createInputAuthMsk: CreateInputAuthMsk,
): string {
  return JSON.stringify(
    CreateInputAuthMsk$outboundSchema.parse(createInputAuthMsk),
  );
}

export function createInputAuthMskFromJSON(
  jsonString: string,
): SafeParseResult<CreateInputAuthMsk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateInputAuthMsk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateInputAuthMsk' from JSON`,
  );
}

/** @internal */
export const CreateInputKafkaSchemaRegistryMinimumTLSVersionMsk$inboundSchema:
  z.ZodNativeEnum<typeof CreateInputKafkaSchemaRegistryMinimumTLSVersionMsk> = z
    .nativeEnum(CreateInputKafkaSchemaRegistryMinimumTLSVersionMsk);

/** @internal */
export const CreateInputKafkaSchemaRegistryMinimumTLSVersionMsk$outboundSchema:
  z.ZodNativeEnum<typeof CreateInputKafkaSchemaRegistryMinimumTLSVersionMsk> =
    CreateInputKafkaSchemaRegistryMinimumTLSVersionMsk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputKafkaSchemaRegistryMinimumTLSVersionMsk$ {
  /** @deprecated use `CreateInputKafkaSchemaRegistryMinimumTLSVersionMsk$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputKafkaSchemaRegistryMinimumTLSVersionMsk$inboundSchema;
  /** @deprecated use `CreateInputKafkaSchemaRegistryMinimumTLSVersionMsk$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputKafkaSchemaRegistryMinimumTLSVersionMsk$outboundSchema;
}

/** @internal */
export const CreateInputKafkaSchemaRegistryMaximumTLSVersionMsk$inboundSchema:
  z.ZodNativeEnum<typeof CreateInputKafkaSchemaRegistryMaximumTLSVersionMsk> = z
    .nativeEnum(CreateInputKafkaSchemaRegistryMaximumTLSVersionMsk);

/** @internal */
export const CreateInputKafkaSchemaRegistryMaximumTLSVersionMsk$outboundSchema:
  z.ZodNativeEnum<typeof CreateInputKafkaSchemaRegistryMaximumTLSVersionMsk> =
    CreateInputKafkaSchemaRegistryMaximumTLSVersionMsk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputKafkaSchemaRegistryMaximumTLSVersionMsk$ {
  /** @deprecated use `CreateInputKafkaSchemaRegistryMaximumTLSVersionMsk$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputKafkaSchemaRegistryMaximumTLSVersionMsk$inboundSchema;
  /** @deprecated use `CreateInputKafkaSchemaRegistryMaximumTLSVersionMsk$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputKafkaSchemaRegistryMaximumTLSVersionMsk$outboundSchema;
}

/** @internal */
export const CreateInputKafkaSchemaRegistryTLSSettingsClientSideMsk$inboundSchema:
  z.ZodType<
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideMsk,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion: CreateInputKafkaSchemaRegistryMinimumTLSVersionMsk$inboundSchema
      .optional(),
    maxVersion: CreateInputKafkaSchemaRegistryMaximumTLSVersionMsk$inboundSchema
      .optional(),
  });

/** @internal */
export type CreateInputKafkaSchemaRegistryTLSSettingsClientSideMsk$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const CreateInputKafkaSchemaRegistryTLSSettingsClientSideMsk$outboundSchema:
  z.ZodType<
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideMsk$Outbound,
    z.ZodTypeDef,
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideMsk
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion:
      CreateInputKafkaSchemaRegistryMinimumTLSVersionMsk$outboundSchema
        .optional(),
    maxVersion:
      CreateInputKafkaSchemaRegistryMaximumTLSVersionMsk$outboundSchema
        .optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputKafkaSchemaRegistryTLSSettingsClientSideMsk$ {
  /** @deprecated use `CreateInputKafkaSchemaRegistryTLSSettingsClientSideMsk$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideMsk$inboundSchema;
  /** @deprecated use `CreateInputKafkaSchemaRegistryTLSSettingsClientSideMsk$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideMsk$outboundSchema;
  /** @deprecated use `CreateInputKafkaSchemaRegistryTLSSettingsClientSideMsk$Outbound` instead. */
  export type Outbound =
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideMsk$Outbound;
}

export function createInputKafkaSchemaRegistryTLSSettingsClientSideMskToJSON(
  createInputKafkaSchemaRegistryTLSSettingsClientSideMsk:
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideMsk,
): string {
  return JSON.stringify(
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideMsk$outboundSchema.parse(
      createInputKafkaSchemaRegistryTLSSettingsClientSideMsk,
    ),
  );
}

export function createInputKafkaSchemaRegistryTLSSettingsClientSideMskFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateInputKafkaSchemaRegistryTLSSettingsClientSideMsk,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateInputKafkaSchemaRegistryTLSSettingsClientSideMsk$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateInputKafkaSchemaRegistryTLSSettingsClientSideMsk' from JSON`,
  );
}

/** @internal */
export const CreateInputKafkaSchemaRegistryAuthenticationMsk$inboundSchema:
  z.ZodType<
    CreateInputKafkaSchemaRegistryAuthenticationMsk,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    schemaRegistryURL: z.string().default("http://localhost:8081"),
    connectionTimeout: z.number().default(30000),
    requestTimeout: z.number().default(30000),
    maxRetries: z.number().default(1),
    auth: z.lazy(() => CreateInputAuthMsk$inboundSchema).optional(),
    tls: z.lazy(() =>
      CreateInputKafkaSchemaRegistryTLSSettingsClientSideMsk$inboundSchema
    ).optional(),
  });

/** @internal */
export type CreateInputKafkaSchemaRegistryAuthenticationMsk$Outbound = {
  disabled: boolean;
  schemaRegistryURL: string;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  auth?: CreateInputAuthMsk$Outbound | undefined;
  tls?:
    | CreateInputKafkaSchemaRegistryTLSSettingsClientSideMsk$Outbound
    | undefined;
};

/** @internal */
export const CreateInputKafkaSchemaRegistryAuthenticationMsk$outboundSchema:
  z.ZodType<
    CreateInputKafkaSchemaRegistryAuthenticationMsk$Outbound,
    z.ZodTypeDef,
    CreateInputKafkaSchemaRegistryAuthenticationMsk
  > = z.object({
    disabled: z.boolean().default(true),
    schemaRegistryURL: z.string().default("http://localhost:8081"),
    connectionTimeout: z.number().default(30000),
    requestTimeout: z.number().default(30000),
    maxRetries: z.number().default(1),
    auth: z.lazy(() => CreateInputAuthMsk$outboundSchema).optional(),
    tls: z.lazy(() =>
      CreateInputKafkaSchemaRegistryTLSSettingsClientSideMsk$outboundSchema
    ).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputKafkaSchemaRegistryAuthenticationMsk$ {
  /** @deprecated use `CreateInputKafkaSchemaRegistryAuthenticationMsk$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputKafkaSchemaRegistryAuthenticationMsk$inboundSchema;
  /** @deprecated use `CreateInputKafkaSchemaRegistryAuthenticationMsk$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputKafkaSchemaRegistryAuthenticationMsk$outboundSchema;
  /** @deprecated use `CreateInputKafkaSchemaRegistryAuthenticationMsk$Outbound` instead. */
  export type Outbound =
    CreateInputKafkaSchemaRegistryAuthenticationMsk$Outbound;
}

export function createInputKafkaSchemaRegistryAuthenticationMskToJSON(
  createInputKafkaSchemaRegistryAuthenticationMsk:
    CreateInputKafkaSchemaRegistryAuthenticationMsk,
): string {
  return JSON.stringify(
    CreateInputKafkaSchemaRegistryAuthenticationMsk$outboundSchema.parse(
      createInputKafkaSchemaRegistryAuthenticationMsk,
    ),
  );
}

export function createInputKafkaSchemaRegistryAuthenticationMskFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateInputKafkaSchemaRegistryAuthenticationMsk,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateInputKafkaSchemaRegistryAuthenticationMsk$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateInputKafkaSchemaRegistryAuthenticationMsk' from JSON`,
  );
}

/** @internal */
export const CreateInputAuthenticationMethodMsk$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputAuthenticationMethodMsk
> = z.nativeEnum(CreateInputAuthenticationMethodMsk);

/** @internal */
export const CreateInputAuthenticationMethodMsk$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputAuthenticationMethodMsk
> = CreateInputAuthenticationMethodMsk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputAuthenticationMethodMsk$ {
  /** @deprecated use `CreateInputAuthenticationMethodMsk$inboundSchema` instead. */
  export const inboundSchema = CreateInputAuthenticationMethodMsk$inboundSchema;
  /** @deprecated use `CreateInputAuthenticationMethodMsk$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputAuthenticationMethodMsk$outboundSchema;
}

/** @internal */
export const CreateInputSignatureVersionMsk$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputSignatureVersionMsk
> = z.nativeEnum(CreateInputSignatureVersionMsk);

/** @internal */
export const CreateInputSignatureVersionMsk$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputSignatureVersionMsk
> = CreateInputSignatureVersionMsk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputSignatureVersionMsk$ {
  /** @deprecated use `CreateInputSignatureVersionMsk$inboundSchema` instead. */
  export const inboundSchema = CreateInputSignatureVersionMsk$inboundSchema;
  /** @deprecated use `CreateInputSignatureVersionMsk$outboundSchema` instead. */
  export const outboundSchema = CreateInputSignatureVersionMsk$outboundSchema;
}

/** @internal */
export const CreateInputMinimumTLSVersionMsk$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputMinimumTLSVersionMsk
> = z.nativeEnum(CreateInputMinimumTLSVersionMsk);

/** @internal */
export const CreateInputMinimumTLSVersionMsk$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputMinimumTLSVersionMsk
> = CreateInputMinimumTLSVersionMsk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputMinimumTLSVersionMsk$ {
  /** @deprecated use `CreateInputMinimumTLSVersionMsk$inboundSchema` instead. */
  export const inboundSchema = CreateInputMinimumTLSVersionMsk$inboundSchema;
  /** @deprecated use `CreateInputMinimumTLSVersionMsk$outboundSchema` instead. */
  export const outboundSchema = CreateInputMinimumTLSVersionMsk$outboundSchema;
}

/** @internal */
export const CreateInputMaximumTLSVersionMsk$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputMaximumTLSVersionMsk
> = z.nativeEnum(CreateInputMaximumTLSVersionMsk);

/** @internal */
export const CreateInputMaximumTLSVersionMsk$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputMaximumTLSVersionMsk
> = CreateInputMaximumTLSVersionMsk$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputMaximumTLSVersionMsk$ {
  /** @deprecated use `CreateInputMaximumTLSVersionMsk$inboundSchema` instead. */
  export const inboundSchema = CreateInputMaximumTLSVersionMsk$inboundSchema;
  /** @deprecated use `CreateInputMaximumTLSVersionMsk$outboundSchema` instead. */
  export const outboundSchema = CreateInputMaximumTLSVersionMsk$outboundSchema;
}

/** @internal */
export const CreateInputTLSSettingsClientSideMsk$inboundSchema: z.ZodType<
  CreateInputTLSSettingsClientSideMsk,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: CreateInputMinimumTLSVersionMsk$inboundSchema.optional(),
  maxVersion: CreateInputMaximumTLSVersionMsk$inboundSchema.optional(),
});

/** @internal */
export type CreateInputTLSSettingsClientSideMsk$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const CreateInputTLSSettingsClientSideMsk$outboundSchema: z.ZodType<
  CreateInputTLSSettingsClientSideMsk$Outbound,
  z.ZodTypeDef,
  CreateInputTLSSettingsClientSideMsk
> = z.object({
  disabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: CreateInputMinimumTLSVersionMsk$outboundSchema.optional(),
  maxVersion: CreateInputMaximumTLSVersionMsk$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputTLSSettingsClientSideMsk$ {
  /** @deprecated use `CreateInputTLSSettingsClientSideMsk$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputTLSSettingsClientSideMsk$inboundSchema;
  /** @deprecated use `CreateInputTLSSettingsClientSideMsk$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputTLSSettingsClientSideMsk$outboundSchema;
  /** @deprecated use `CreateInputTLSSettingsClientSideMsk$Outbound` instead. */
  export type Outbound = CreateInputTLSSettingsClientSideMsk$Outbound;
}

export function createInputTLSSettingsClientSideMskToJSON(
  createInputTLSSettingsClientSideMsk: CreateInputTLSSettingsClientSideMsk,
): string {
  return JSON.stringify(
    CreateInputTLSSettingsClientSideMsk$outboundSchema.parse(
      createInputTLSSettingsClientSideMsk,
    ),
  );
}

export function createInputTLSSettingsClientSideMskFromJSON(
  jsonString: string,
): SafeParseResult<CreateInputTLSSettingsClientSideMsk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateInputTLSSettingsClientSideMsk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateInputTLSSettingsClientSideMsk' from JSON`,
  );
}

/** @internal */
export const InputMsk$inboundSchema: z.ZodType<
  InputMsk,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateInputTypeMsk$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionMsk$inboundSchema)).optional(),
  pq: z.lazy(() => PqMsk$inboundSchema).optional(),
  brokers: z.array(z.string()),
  topics: z.array(z.string()),
  groupId: z.string().default("Cribl"),
  fromBeginning: z.boolean().default(true),
  sessionTimeout: z.number().default(30000),
  rebalanceTimeout: z.number().default(60000),
  heartbeatInterval: z.number().default(3000),
  metadata: z.array(z.lazy(() => MetadatumMsk$inboundSchema)).optional(),
  kafkaSchemaRegistry: z.lazy(() =>
    CreateInputKafkaSchemaRegistryAuthenticationMsk$inboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  awsAuthenticationMethod: CreateInputAuthenticationMethodMsk$inboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: CreateInputSignatureVersionMsk$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  tls: z.lazy(() => CreateInputTLSSettingsClientSideMsk$inboundSchema)
    .optional(),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().default(1048576),
  maxBytes: z.number().default(10485760),
  maxSocketErrors: z.number().default(0),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});

/** @internal */
export type InputMsk$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionMsk$Outbound> | undefined;
  pq?: PqMsk$Outbound | undefined;
  brokers: Array<string>;
  topics: Array<string>;
  groupId: string;
  fromBeginning: boolean;
  sessionTimeout: number;
  rebalanceTimeout: number;
  heartbeatInterval: number;
  metadata?: Array<MetadatumMsk$Outbound> | undefined;
  kafkaSchemaRegistry?:
    | CreateInputKafkaSchemaRegistryAuthenticationMsk$Outbound
    | undefined;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  maxBackOff: number;
  initialBackoff: number;
  backoffRate: number;
  authenticationTimeout: number;
  reauthenticationThreshold: number;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  tls?: CreateInputTLSSettingsClientSideMsk$Outbound | undefined;
  autoCommitInterval?: number | undefined;
  autoCommitThreshold?: number | undefined;
  maxBytesPerPartition: number;
  maxBytes: number;
  maxSocketErrors: number;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
};

/** @internal */
export const InputMsk$outboundSchema: z.ZodType<
  InputMsk$Outbound,
  z.ZodTypeDef,
  InputMsk
> = z.object({
  id: z.string(),
  type: CreateInputTypeMsk$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionMsk$outboundSchema)).optional(),
  pq: z.lazy(() => PqMsk$outboundSchema).optional(),
  brokers: z.array(z.string()),
  topics: z.array(z.string()),
  groupId: z.string().default("Cribl"),
  fromBeginning: z.boolean().default(true),
  sessionTimeout: z.number().default(30000),
  rebalanceTimeout: z.number().default(60000),
  heartbeatInterval: z.number().default(3000),
  metadata: z.array(z.lazy(() => MetadatumMsk$outboundSchema)).optional(),
  kafkaSchemaRegistry: z.lazy(() =>
    CreateInputKafkaSchemaRegistryAuthenticationMsk$outboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  awsAuthenticationMethod: CreateInputAuthenticationMethodMsk$outboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: CreateInputSignatureVersionMsk$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  tls: z.lazy(() => CreateInputTLSSettingsClientSideMsk$outboundSchema)
    .optional(),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().default(1048576),
  maxBytes: z.number().default(10485760),
  maxSocketErrors: z.number().default(0),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMsk$ {
  /** @deprecated use `InputMsk$inboundSchema` instead. */
  export const inboundSchema = InputMsk$inboundSchema;
  /** @deprecated use `InputMsk$outboundSchema` instead. */
  export const outboundSchema = InputMsk$outboundSchema;
  /** @deprecated use `InputMsk$Outbound` instead. */
  export type Outbound = InputMsk$Outbound;
}

export function inputMskToJSON(inputMsk: InputMsk): string {
  return JSON.stringify(InputMsk$outboundSchema.parse(inputMsk));
}

export function inputMskFromJSON(
  jsonString: string,
): SafeParseResult<InputMsk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMsk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMsk' from JSON`,
  );
}

/** @internal */
export const CreateInputTypeKafka$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeKafka
> = z.nativeEnum(CreateInputTypeKafka);

/** @internal */
export const CreateInputTypeKafka$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputTypeKafka
> = CreateInputTypeKafka$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputTypeKafka$ {
  /** @deprecated use `CreateInputTypeKafka$inboundSchema` instead. */
  export const inboundSchema = CreateInputTypeKafka$inboundSchema;
  /** @deprecated use `CreateInputTypeKafka$outboundSchema` instead. */
  export const outboundSchema = CreateInputTypeKafka$outboundSchema;
}

/** @internal */
export const ConnectionKafka$inboundSchema: z.ZodType<
  ConnectionKafka,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type ConnectionKafka$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const ConnectionKafka$outboundSchema: z.ZodType<
  ConnectionKafka$Outbound,
  z.ZodTypeDef,
  ConnectionKafka
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionKafka$ {
  /** @deprecated use `ConnectionKafka$inboundSchema` instead. */
  export const inboundSchema = ConnectionKafka$inboundSchema;
  /** @deprecated use `ConnectionKafka$outboundSchema` instead. */
  export const outboundSchema = ConnectionKafka$outboundSchema;
  /** @deprecated use `ConnectionKafka$Outbound` instead. */
  export type Outbound = ConnectionKafka$Outbound;
}

export function connectionKafkaToJSON(
  connectionKafka: ConnectionKafka,
): string {
  return JSON.stringify(ConnectionKafka$outboundSchema.parse(connectionKafka));
}

export function connectionKafkaFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionKafka, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionKafka$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionKafka' from JSON`,
  );
}

/** @internal */
export const CreateInputModeKafka$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputModeKafka
> = z.nativeEnum(CreateInputModeKafka);

/** @internal */
export const CreateInputModeKafka$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputModeKafka
> = CreateInputModeKafka$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputModeKafka$ {
  /** @deprecated use `CreateInputModeKafka$inboundSchema` instead. */
  export const inboundSchema = CreateInputModeKafka$inboundSchema;
  /** @deprecated use `CreateInputModeKafka$outboundSchema` instead. */
  export const outboundSchema = CreateInputModeKafka$outboundSchema;
}

/** @internal */
export const PqCompressionKafka$inboundSchema: z.ZodNativeEnum<
  typeof PqCompressionKafka
> = z.nativeEnum(PqCompressionKafka);

/** @internal */
export const PqCompressionKafka$outboundSchema: z.ZodNativeEnum<
  typeof PqCompressionKafka
> = PqCompressionKafka$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqCompressionKafka$ {
  /** @deprecated use `PqCompressionKafka$inboundSchema` instead. */
  export const inboundSchema = PqCompressionKafka$inboundSchema;
  /** @deprecated use `PqCompressionKafka$outboundSchema` instead. */
  export const outboundSchema = PqCompressionKafka$outboundSchema;
}

/** @internal */
export const PqKafka$inboundSchema: z.ZodType<PqKafka, z.ZodTypeDef, unknown> =
  z.object({
    mode: CreateInputModeKafka$inboundSchema.default("always"),
    maxBufferSize: z.number().default(1000),
    commitFrequency: z.number().default(42),
    maxFileSize: z.string().default("1 MB"),
    maxSize: z.string().default("5GB"),
    path: z.string().default("$CRIBL_HOME/state/queues"),
    compress: PqCompressionKafka$inboundSchema.default("none"),
  });

/** @internal */
export type PqKafka$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const PqKafka$outboundSchema: z.ZodType<
  PqKafka$Outbound,
  z.ZodTypeDef,
  PqKafka
> = z.object({
  mode: CreateInputModeKafka$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: PqCompressionKafka$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PqKafka$ {
  /** @deprecated use `PqKafka$inboundSchema` instead. */
  export const inboundSchema = PqKafka$inboundSchema;
  /** @deprecated use `PqKafka$outboundSchema` instead. */
  export const outboundSchema = PqKafka$outboundSchema;
  /** @deprecated use `PqKafka$Outbound` instead. */
  export type Outbound = PqKafka$Outbound;
}

export function pqKafkaToJSON(pqKafka: PqKafka): string {
  return JSON.stringify(PqKafka$outboundSchema.parse(pqKafka));
}

export function pqKafkaFromJSON(
  jsonString: string,
): SafeParseResult<PqKafka, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PqKafka$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PqKafka' from JSON`,
  );
}

/** @internal */
export const CreateInputAuthKafka$inboundSchema: z.ZodType<
  CreateInputAuthKafka,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/** @internal */
export type CreateInputAuthKafka$Outbound = {
  disabled: boolean;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const CreateInputAuthKafka$outboundSchema: z.ZodType<
  CreateInputAuthKafka$Outbound,
  z.ZodTypeDef,
  CreateInputAuthKafka
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputAuthKafka$ {
  /** @deprecated use `CreateInputAuthKafka$inboundSchema` instead. */
  export const inboundSchema = CreateInputAuthKafka$inboundSchema;
  /** @deprecated use `CreateInputAuthKafka$outboundSchema` instead. */
  export const outboundSchema = CreateInputAuthKafka$outboundSchema;
  /** @deprecated use `CreateInputAuthKafka$Outbound` instead. */
  export type Outbound = CreateInputAuthKafka$Outbound;
}

export function createInputAuthKafkaToJSON(
  createInputAuthKafka: CreateInputAuthKafka,
): string {
  return JSON.stringify(
    CreateInputAuthKafka$outboundSchema.parse(createInputAuthKafka),
  );
}

export function createInputAuthKafkaFromJSON(
  jsonString: string,
): SafeParseResult<CreateInputAuthKafka, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateInputAuthKafka$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateInputAuthKafka' from JSON`,
  );
}

/** @internal */
export const CreateInputKafkaSchemaRegistryMinimumTLSVersionKafka$inboundSchema:
  z.ZodNativeEnum<typeof CreateInputKafkaSchemaRegistryMinimumTLSVersionKafka> =
    z.nativeEnum(CreateInputKafkaSchemaRegistryMinimumTLSVersionKafka);

/** @internal */
export const CreateInputKafkaSchemaRegistryMinimumTLSVersionKafka$outboundSchema:
  z.ZodNativeEnum<typeof CreateInputKafkaSchemaRegistryMinimumTLSVersionKafka> =
    CreateInputKafkaSchemaRegistryMinimumTLSVersionKafka$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputKafkaSchemaRegistryMinimumTLSVersionKafka$ {
  /** @deprecated use `CreateInputKafkaSchemaRegistryMinimumTLSVersionKafka$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputKafkaSchemaRegistryMinimumTLSVersionKafka$inboundSchema;
  /** @deprecated use `CreateInputKafkaSchemaRegistryMinimumTLSVersionKafka$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputKafkaSchemaRegistryMinimumTLSVersionKafka$outboundSchema;
}

/** @internal */
export const CreateInputKafkaSchemaRegistryMaximumTLSVersionKafka$inboundSchema:
  z.ZodNativeEnum<typeof CreateInputKafkaSchemaRegistryMaximumTLSVersionKafka> =
    z.nativeEnum(CreateInputKafkaSchemaRegistryMaximumTLSVersionKafka);

/** @internal */
export const CreateInputKafkaSchemaRegistryMaximumTLSVersionKafka$outboundSchema:
  z.ZodNativeEnum<typeof CreateInputKafkaSchemaRegistryMaximumTLSVersionKafka> =
    CreateInputKafkaSchemaRegistryMaximumTLSVersionKafka$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputKafkaSchemaRegistryMaximumTLSVersionKafka$ {
  /** @deprecated use `CreateInputKafkaSchemaRegistryMaximumTLSVersionKafka$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputKafkaSchemaRegistryMaximumTLSVersionKafka$inboundSchema;
  /** @deprecated use `CreateInputKafkaSchemaRegistryMaximumTLSVersionKafka$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputKafkaSchemaRegistryMaximumTLSVersionKafka$outboundSchema;
}

/** @internal */
export const CreateInputKafkaSchemaRegistryTLSSettingsClientSideKafka$inboundSchema:
  z.ZodType<
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideKafka,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion:
      CreateInputKafkaSchemaRegistryMinimumTLSVersionKafka$inboundSchema
        .optional(),
    maxVersion:
      CreateInputKafkaSchemaRegistryMaximumTLSVersionKafka$inboundSchema
        .optional(),
  });

/** @internal */
export type CreateInputKafkaSchemaRegistryTLSSettingsClientSideKafka$Outbound =
  {
    disabled: boolean;
    rejectUnauthorized: boolean;
    servername?: string | undefined;
    certificateName?: string | undefined;
    caPath?: string | undefined;
    privKeyPath?: string | undefined;
    certPath?: string | undefined;
    passphrase?: string | undefined;
    minVersion?: string | undefined;
    maxVersion?: string | undefined;
  };

/** @internal */
export const CreateInputKafkaSchemaRegistryTLSSettingsClientSideKafka$outboundSchema:
  z.ZodType<
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideKafka$Outbound,
    z.ZodTypeDef,
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideKafka
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion:
      CreateInputKafkaSchemaRegistryMinimumTLSVersionKafka$outboundSchema
        .optional(),
    maxVersion:
      CreateInputKafkaSchemaRegistryMaximumTLSVersionKafka$outboundSchema
        .optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputKafkaSchemaRegistryTLSSettingsClientSideKafka$ {
  /** @deprecated use `CreateInputKafkaSchemaRegistryTLSSettingsClientSideKafka$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideKafka$inboundSchema;
  /** @deprecated use `CreateInputKafkaSchemaRegistryTLSSettingsClientSideKafka$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideKafka$outboundSchema;
  /** @deprecated use `CreateInputKafkaSchemaRegistryTLSSettingsClientSideKafka$Outbound` instead. */
  export type Outbound =
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideKafka$Outbound;
}

export function createInputKafkaSchemaRegistryTLSSettingsClientSideKafkaToJSON(
  createInputKafkaSchemaRegistryTLSSettingsClientSideKafka:
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideKafka,
): string {
  return JSON.stringify(
    CreateInputKafkaSchemaRegistryTLSSettingsClientSideKafka$outboundSchema
      .parse(createInputKafkaSchemaRegistryTLSSettingsClientSideKafka),
  );
}

export function createInputKafkaSchemaRegistryTLSSettingsClientSideKafkaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateInputKafkaSchemaRegistryTLSSettingsClientSideKafka,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateInputKafkaSchemaRegistryTLSSettingsClientSideKafka$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateInputKafkaSchemaRegistryTLSSettingsClientSideKafka' from JSON`,
  );
}

/** @internal */
export const CreateInputKafkaSchemaRegistryAuthenticationKafka$inboundSchema:
  z.ZodType<
    CreateInputKafkaSchemaRegistryAuthenticationKafka,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    schemaRegistryURL: z.string().default("http://localhost:8081"),
    connectionTimeout: z.number().default(30000),
    requestTimeout: z.number().default(30000),
    maxRetries: z.number().default(1),
    auth: z.lazy(() => CreateInputAuthKafka$inboundSchema).optional(),
    tls: z.lazy(() =>
      CreateInputKafkaSchemaRegistryTLSSettingsClientSideKafka$inboundSchema
    ).optional(),
  });

/** @internal */
export type CreateInputKafkaSchemaRegistryAuthenticationKafka$Outbound = {
  disabled: boolean;
  schemaRegistryURL: string;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  auth?: CreateInputAuthKafka$Outbound | undefined;
  tls?:
    | CreateInputKafkaSchemaRegistryTLSSettingsClientSideKafka$Outbound
    | undefined;
};

/** @internal */
export const CreateInputKafkaSchemaRegistryAuthenticationKafka$outboundSchema:
  z.ZodType<
    CreateInputKafkaSchemaRegistryAuthenticationKafka$Outbound,
    z.ZodTypeDef,
    CreateInputKafkaSchemaRegistryAuthenticationKafka
  > = z.object({
    disabled: z.boolean().default(true),
    schemaRegistryURL: z.string().default("http://localhost:8081"),
    connectionTimeout: z.number().default(30000),
    requestTimeout: z.number().default(30000),
    maxRetries: z.number().default(1),
    auth: z.lazy(() => CreateInputAuthKafka$outboundSchema).optional(),
    tls: z.lazy(() =>
      CreateInputKafkaSchemaRegistryTLSSettingsClientSideKafka$outboundSchema
    ).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputKafkaSchemaRegistryAuthenticationKafka$ {
  /** @deprecated use `CreateInputKafkaSchemaRegistryAuthenticationKafka$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputKafkaSchemaRegistryAuthenticationKafka$inboundSchema;
  /** @deprecated use `CreateInputKafkaSchemaRegistryAuthenticationKafka$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputKafkaSchemaRegistryAuthenticationKafka$outboundSchema;
  /** @deprecated use `CreateInputKafkaSchemaRegistryAuthenticationKafka$Outbound` instead. */
  export type Outbound =
    CreateInputKafkaSchemaRegistryAuthenticationKafka$Outbound;
}

export function createInputKafkaSchemaRegistryAuthenticationKafkaToJSON(
  createInputKafkaSchemaRegistryAuthenticationKafka:
    CreateInputKafkaSchemaRegistryAuthenticationKafka,
): string {
  return JSON.stringify(
    CreateInputKafkaSchemaRegistryAuthenticationKafka$outboundSchema.parse(
      createInputKafkaSchemaRegistryAuthenticationKafka,
    ),
  );
}

export function createInputKafkaSchemaRegistryAuthenticationKafkaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateInputKafkaSchemaRegistryAuthenticationKafka,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateInputKafkaSchemaRegistryAuthenticationKafka$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateInputKafkaSchemaRegistryAuthenticationKafka' from JSON`,
  );
}

/** @internal */
export const CreateInputSASLMechanismKafka$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputSASLMechanismKafka
> = z.nativeEnum(CreateInputSASLMechanismKafka);

/** @internal */
export const CreateInputSASLMechanismKafka$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputSASLMechanismKafka
> = CreateInputSASLMechanismKafka$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputSASLMechanismKafka$ {
  /** @deprecated use `CreateInputSASLMechanismKafka$inboundSchema` instead. */
  export const inboundSchema = CreateInputSASLMechanismKafka$inboundSchema;
  /** @deprecated use `CreateInputSASLMechanismKafka$outboundSchema` instead. */
  export const outboundSchema = CreateInputSASLMechanismKafka$outboundSchema;
}

/** @internal */
export const CreateInputAuthenticationKafka$inboundSchema: z.ZodType<
  CreateInputAuthenticationKafka,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  mechanism: CreateInputSASLMechanismKafka$inboundSchema.default("plain"),
});

/** @internal */
export type CreateInputAuthenticationKafka$Outbound = {
  disabled: boolean;
  mechanism: string;
};

/** @internal */
export const CreateInputAuthenticationKafka$outboundSchema: z.ZodType<
  CreateInputAuthenticationKafka$Outbound,
  z.ZodTypeDef,
  CreateInputAuthenticationKafka
> = z.object({
  disabled: z.boolean().default(true),
  mechanism: CreateInputSASLMechanismKafka$outboundSchema.default("plain"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputAuthenticationKafka$ {
  /** @deprecated use `CreateInputAuthenticationKafka$inboundSchema` instead. */
  export const inboundSchema = CreateInputAuthenticationKafka$inboundSchema;
  /** @deprecated use `CreateInputAuthenticationKafka$outboundSchema` instead. */
  export const outboundSchema = CreateInputAuthenticationKafka$outboundSchema;
  /** @deprecated use `CreateInputAuthenticationKafka$Outbound` instead. */
  export type Outbound = CreateInputAuthenticationKafka$Outbound;
}

export function createInputAuthenticationKafkaToJSON(
  createInputAuthenticationKafka: CreateInputAuthenticationKafka,
): string {
  return JSON.stringify(
    CreateInputAuthenticationKafka$outboundSchema.parse(
      createInputAuthenticationKafka,
    ),
  );
}

export function createInputAuthenticationKafkaFromJSON(
  jsonString: string,
): SafeParseResult<CreateInputAuthenticationKafka, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateInputAuthenticationKafka$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateInputAuthenticationKafka' from JSON`,
  );
}

/** @internal */
export const CreateInputMinimumTLSVersionKafka$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputMinimumTLSVersionKafka
> = z.nativeEnum(CreateInputMinimumTLSVersionKafka);

/** @internal */
export const CreateInputMinimumTLSVersionKafka$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputMinimumTLSVersionKafka
> = CreateInputMinimumTLSVersionKafka$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputMinimumTLSVersionKafka$ {
  /** @deprecated use `CreateInputMinimumTLSVersionKafka$inboundSchema` instead. */
  export const inboundSchema = CreateInputMinimumTLSVersionKafka$inboundSchema;
  /** @deprecated use `CreateInputMinimumTLSVersionKafka$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputMinimumTLSVersionKafka$outboundSchema;
}

/** @internal */
export const CreateInputMaximumTLSVersionKafka$inboundSchema: z.ZodNativeEnum<
  typeof CreateInputMaximumTLSVersionKafka
> = z.nativeEnum(CreateInputMaximumTLSVersionKafka);

/** @internal */
export const CreateInputMaximumTLSVersionKafka$outboundSchema: z.ZodNativeEnum<
  typeof CreateInputMaximumTLSVersionKafka
> = CreateInputMaximumTLSVersionKafka$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputMaximumTLSVersionKafka$ {
  /** @deprecated use `CreateInputMaximumTLSVersionKafka$inboundSchema` instead. */
  export const inboundSchema = CreateInputMaximumTLSVersionKafka$inboundSchema;
  /** @deprecated use `CreateInputMaximumTLSVersionKafka$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputMaximumTLSVersionKafka$outboundSchema;
}

/** @internal */
export const CreateInputTLSSettingsClientSideKafka$inboundSchema: z.ZodType<
  CreateInputTLSSettingsClientSideKafka,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: CreateInputMinimumTLSVersionKafka$inboundSchema.optional(),
  maxVersion: CreateInputMaximumTLSVersionKafka$inboundSchema.optional(),
});

/** @internal */
export type CreateInputTLSSettingsClientSideKafka$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const CreateInputTLSSettingsClientSideKafka$outboundSchema: z.ZodType<
  CreateInputTLSSettingsClientSideKafka$Outbound,
  z.ZodTypeDef,
  CreateInputTLSSettingsClientSideKafka
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: CreateInputMinimumTLSVersionKafka$outboundSchema.optional(),
  maxVersion: CreateInputMaximumTLSVersionKafka$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputTLSSettingsClientSideKafka$ {
  /** @deprecated use `CreateInputTLSSettingsClientSideKafka$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputTLSSettingsClientSideKafka$inboundSchema;
  /** @deprecated use `CreateInputTLSSettingsClientSideKafka$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputTLSSettingsClientSideKafka$outboundSchema;
  /** @deprecated use `CreateInputTLSSettingsClientSideKafka$Outbound` instead. */
  export type Outbound = CreateInputTLSSettingsClientSideKafka$Outbound;
}

export function createInputTLSSettingsClientSideKafkaToJSON(
  createInputTLSSettingsClientSideKafka: CreateInputTLSSettingsClientSideKafka,
): string {
  return JSON.stringify(
    CreateInputTLSSettingsClientSideKafka$outboundSchema.parse(
      createInputTLSSettingsClientSideKafka,
    ),
  );
}

export function createInputTLSSettingsClientSideKafkaFromJSON(
  jsonString: string,
): SafeParseResult<CreateInputTLSSettingsClientSideKafka, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateInputTLSSettingsClientSideKafka$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateInputTLSSettingsClientSideKafka' from JSON`,
  );
}

/** @internal */
export const MetadatumKafka$inboundSchema: z.ZodType<
  MetadatumKafka,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type MetadatumKafka$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const MetadatumKafka$outboundSchema: z.ZodType<
  MetadatumKafka$Outbound,
  z.ZodTypeDef,
  MetadatumKafka
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadatumKafka$ {
  /** @deprecated use `MetadatumKafka$inboundSchema` instead. */
  export const inboundSchema = MetadatumKafka$inboundSchema;
  /** @deprecated use `MetadatumKafka$outboundSchema` instead. */
  export const outboundSchema = MetadatumKafka$outboundSchema;
  /** @deprecated use `MetadatumKafka$Outbound` instead. */
  export type Outbound = MetadatumKafka$Outbound;
}

export function metadatumKafkaToJSON(metadatumKafka: MetadatumKafka): string {
  return JSON.stringify(MetadatumKafka$outboundSchema.parse(metadatumKafka));
}

export function metadatumKafkaFromJSON(
  jsonString: string,
): SafeParseResult<MetadatumKafka, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadatumKafka$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadatumKafka' from JSON`,
  );
}

/** @internal */
export const InputKafka$inboundSchema: z.ZodType<
  InputKafka,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateInputTypeKafka$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionKafka$inboundSchema)).optional(),
  pq: z.lazy(() => PqKafka$inboundSchema).optional(),
  brokers: z.array(z.string()),
  topics: z.array(z.string()),
  groupId: z.string().default("Cribl"),
  fromBeginning: z.boolean().default(true),
  kafkaSchemaRegistry: z.lazy(() =>
    CreateInputKafkaSchemaRegistryAuthenticationKafka$inboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => CreateInputAuthenticationKafka$inboundSchema).optional(),
  tls: z.lazy(() => CreateInputTLSSettingsClientSideKafka$inboundSchema)
    .optional(),
  sessionTimeout: z.number().default(30000),
  rebalanceTimeout: z.number().default(60000),
  heartbeatInterval: z.number().default(3000),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().default(1048576),
  maxBytes: z.number().default(10485760),
  maxSocketErrors: z.number().default(0),
  metadata: z.array(z.lazy(() => MetadatumKafka$inboundSchema)).optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputKafka$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionKafka$Outbound> | undefined;
  pq?: PqKafka$Outbound | undefined;
  brokers: Array<string>;
  topics: Array<string>;
  groupId: string;
  fromBeginning: boolean;
  kafkaSchemaRegistry?:
    | CreateInputKafkaSchemaRegistryAuthenticationKafka$Outbound
    | undefined;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  maxBackOff: number;
  initialBackoff: number;
  backoffRate: number;
  authenticationTimeout: number;
  reauthenticationThreshold: number;
  sasl?: CreateInputAuthenticationKafka$Outbound | undefined;
  tls?: CreateInputTLSSettingsClientSideKafka$Outbound | undefined;
  sessionTimeout: number;
  rebalanceTimeout: number;
  heartbeatInterval: number;
  autoCommitInterval?: number | undefined;
  autoCommitThreshold?: number | undefined;
  maxBytesPerPartition: number;
  maxBytes: number;
  maxSocketErrors: number;
  metadata?: Array<MetadatumKafka$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputKafka$outboundSchema: z.ZodType<
  InputKafka$Outbound,
  z.ZodTypeDef,
  InputKafka
> = z.object({
  id: z.string(),
  type: CreateInputTypeKafka$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => ConnectionKafka$outboundSchema)).optional(),
  pq: z.lazy(() => PqKafka$outboundSchema).optional(),
  brokers: z.array(z.string()),
  topics: z.array(z.string()),
  groupId: z.string().default("Cribl"),
  fromBeginning: z.boolean().default(true),
  kafkaSchemaRegistry: z.lazy(() =>
    CreateInputKafkaSchemaRegistryAuthenticationKafka$outboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => CreateInputAuthenticationKafka$outboundSchema).optional(),
  tls: z.lazy(() => CreateInputTLSSettingsClientSideKafka$outboundSchema)
    .optional(),
  sessionTimeout: z.number().default(30000),
  rebalanceTimeout: z.number().default(60000),
  heartbeatInterval: z.number().default(3000),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().default(1048576),
  maxBytes: z.number().default(10485760),
  maxSocketErrors: z.number().default(0),
  metadata: z.array(z.lazy(() => MetadatumKafka$outboundSchema)).optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKafka$ {
  /** @deprecated use `InputKafka$inboundSchema` instead. */
  export const inboundSchema = InputKafka$inboundSchema;
  /** @deprecated use `InputKafka$outboundSchema` instead. */
  export const outboundSchema = InputKafka$outboundSchema;
  /** @deprecated use `InputKafka$Outbound` instead. */
  export type Outbound = InputKafka$Outbound;
}

export function inputKafkaToJSON(inputKafka: InputKafka): string {
  return JSON.stringify(InputKafka$outboundSchema.parse(inputKafka));
}

export function inputKafkaFromJSON(
  jsonString: string,
): SafeParseResult<InputKafka, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputKafka$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputKafka' from JSON`,
  );
}

/** @internal */
export const CreateInputRequest$inboundSchema: z.ZodType<
  CreateInputRequest,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => InputMsk$inboundSchema),
  z.lazy(() => InputWiz$inboundSchema),
  z.lazy(() => InputKafka$inboundSchema),
  z.lazy(() => InputAzureBlob$inboundSchema),
  z.lazy(() => InputConfluentCloud$inboundSchema),
  z.lazy(() => InputOffice365Mgmt$inboundSchema),
  z.lazy(() => InputOffice365Service$inboundSchema),
  z.lazy(() => InputEventhub$inboundSchema),
  z.lazy(() => InputExec$inboundSchema),
  z.lazy(() => InputGooglePubsub$inboundSchema),
  z.lazy(() => InputCrowdstrike$inboundSchema),
  z.lazy(() => InputDatagen$inboundSchema),
  z.lazy(() => InputKinesis$inboundSchema),
  z.lazy(() => InputS3$inboundSchema),
  z.lazy(() => InputS3Inventory$inboundSchema),
  z.lazy(() => InputWinEventLogs$inboundSchema),
  z.lazy(() => InputJournalFiles$inboundSchema),
  z.lazy(() => InputSecurityLake$inboundSchema),
  z.lazy(() => InputHttp$inboundSchema),
  z.lazy(() => InputSplunk$inboundSchema),
  z.lazy(() => InputSplunkSearch$inboundSchema),
  z.lazy(() => InputSplunkHec$inboundSchema),
  z.lazy(() => InputElastic$inboundSchema),
  z.lazy(() => InputLoki$inboundSchema),
  z.lazy(() => InputPrometheusRw$inboundSchema),
  z.lazy(() => InputFirehose$inboundSchema),
  models.InputCribl$inboundSchema,
  z.lazy(() => InputCriblTcp$inboundSchema),
  z.lazy(() => InputCriblHttp$inboundSchema),
  z.lazy(() => InputCriblLakeHttp$inboundSchema),
  z.lazy(() => InputTcpjson$inboundSchema),
  models.InputSystemMetrics$inboundSchema,
  models.InputSystemState$inboundSchema,
  models.InputKubeMetrics$inboundSchema,
  models.InputKubeLogs$inboundSchema,
  models.InputKubeEvents$inboundSchema,
  models.InputWindowsMetrics$inboundSchema,
  z.lazy(() => InputDatadogAgent$inboundSchema),
  z.lazy(() => InputHttpRaw$inboundSchema),
  models.InputCriblmetrics$inboundSchema,
  z.lazy(() => InputMetrics$inboundSchema),
  z.lazy(() => InputSqs$inboundSchema),
  models.InputFile$inboundSchema,
  z.lazy(() => InputTcp$inboundSchema),
  models.InputAppscope$inboundSchema,
  z.lazy(() => InputWef$inboundSchema),
  z.lazy(() => InputRawUdp$inboundSchema),
  z.lazy(() => InputZscalerHec$inboundSchema),
  models.InputCollection$inboundSchema,
  z.lazy(() => InputPrometheus$inboundSchema),
  z.lazy(() => InputEdgePrometheus$inboundSchema),
  z.lazy(() => InputOffice365MsgTrace$inboundSchema),
  z.lazy(() => InputSnmp$inboundSchema),
  z.lazy(() => InputOpenTelemetry$inboundSchema),
  z.lazy(() => InputModelDrivenTelemetry$inboundSchema),
  z.lazy(() => InputNetflow$inboundSchema),
  z.union([
    z.lazy(() => InputGrafanaGrafana1$inboundSchema),
    z.lazy(() => InputGrafanaGrafana2$inboundSchema),
  ]),
  z.union([
    z.lazy(() => InputSyslogSyslog1$inboundSchema),
    z.lazy(() => InputSyslogSyslog2$inboundSchema),
  ]),
]);

/** @internal */
export type CreateInputRequest$Outbound =
  | InputMsk$Outbound
  | InputWiz$Outbound
  | InputKafka$Outbound
  | InputAzureBlob$Outbound
  | InputConfluentCloud$Outbound
  | InputOffice365Mgmt$Outbound
  | InputOffice365Service$Outbound
  | InputEventhub$Outbound
  | InputExec$Outbound
  | InputGooglePubsub$Outbound
  | InputCrowdstrike$Outbound
  | InputDatagen$Outbound
  | InputKinesis$Outbound
  | InputS3$Outbound
  | InputS3Inventory$Outbound
  | InputWinEventLogs$Outbound
  | InputJournalFiles$Outbound
  | InputSecurityLake$Outbound
  | InputHttp$Outbound
  | InputSplunk$Outbound
  | InputSplunkSearch$Outbound
  | InputSplunkHec$Outbound
  | InputElastic$Outbound
  | InputLoki$Outbound
  | InputPrometheusRw$Outbound
  | InputFirehose$Outbound
  | models.InputCribl$Outbound
  | InputCriblTcp$Outbound
  | InputCriblHttp$Outbound
  | InputCriblLakeHttp$Outbound
  | InputTcpjson$Outbound
  | models.InputSystemMetrics$Outbound
  | models.InputSystemState$Outbound
  | models.InputKubeMetrics$Outbound
  | models.InputKubeLogs$Outbound
  | models.InputKubeEvents$Outbound
  | models.InputWindowsMetrics$Outbound
  | InputDatadogAgent$Outbound
  | InputHttpRaw$Outbound
  | models.InputCriblmetrics$Outbound
  | InputMetrics$Outbound
  | InputSqs$Outbound
  | models.InputFile$Outbound
  | InputTcp$Outbound
  | models.InputAppscope$Outbound
  | InputWef$Outbound
  | InputRawUdp$Outbound
  | InputZscalerHec$Outbound
  | models.InputCollection$Outbound
  | InputPrometheus$Outbound
  | InputEdgePrometheus$Outbound
  | InputOffice365MsgTrace$Outbound
  | InputSnmp$Outbound
  | InputOpenTelemetry$Outbound
  | InputModelDrivenTelemetry$Outbound
  | InputNetflow$Outbound
  | InputGrafanaGrafana1$Outbound
  | InputGrafanaGrafana2$Outbound
  | InputSyslogSyslog1$Outbound
  | InputSyslogSyslog2$Outbound;

/** @internal */
export const CreateInputRequest$outboundSchema: z.ZodType<
  CreateInputRequest$Outbound,
  z.ZodTypeDef,
  CreateInputRequest
> = z.union([
  z.lazy(() => InputMsk$outboundSchema),
  z.lazy(() => InputWiz$outboundSchema),
  z.lazy(() => InputKafka$outboundSchema),
  z.lazy(() => InputAzureBlob$outboundSchema),
  z.lazy(() => InputConfluentCloud$outboundSchema),
  z.lazy(() => InputOffice365Mgmt$outboundSchema),
  z.lazy(() => InputOffice365Service$outboundSchema),
  z.lazy(() => InputEventhub$outboundSchema),
  z.lazy(() => InputExec$outboundSchema),
  z.lazy(() => InputGooglePubsub$outboundSchema),
  z.lazy(() => InputCrowdstrike$outboundSchema),
  z.lazy(() => InputDatagen$outboundSchema),
  z.lazy(() => InputKinesis$outboundSchema),
  z.lazy(() => InputS3$outboundSchema),
  z.lazy(() => InputS3Inventory$outboundSchema),
  z.lazy(() => InputWinEventLogs$outboundSchema),
  z.lazy(() => InputJournalFiles$outboundSchema),
  z.lazy(() => InputSecurityLake$outboundSchema),
  z.lazy(() => InputHttp$outboundSchema),
  z.lazy(() => InputSplunk$outboundSchema),
  z.lazy(() => InputSplunkSearch$outboundSchema),
  z.lazy(() => InputSplunkHec$outboundSchema),
  z.lazy(() => InputElastic$outboundSchema),
  z.lazy(() => InputLoki$outboundSchema),
  z.lazy(() => InputPrometheusRw$outboundSchema),
  z.lazy(() => InputFirehose$outboundSchema),
  models.InputCribl$outboundSchema,
  z.lazy(() => InputCriblTcp$outboundSchema),
  z.lazy(() => InputCriblHttp$outboundSchema),
  z.lazy(() => InputCriblLakeHttp$outboundSchema),
  z.lazy(() => InputTcpjson$outboundSchema),
  models.InputSystemMetrics$outboundSchema,
  models.InputSystemState$outboundSchema,
  models.InputKubeMetrics$outboundSchema,
  models.InputKubeLogs$outboundSchema,
  models.InputKubeEvents$outboundSchema,
  models.InputWindowsMetrics$outboundSchema,
  z.lazy(() => InputDatadogAgent$outboundSchema),
  z.lazy(() => InputHttpRaw$outboundSchema),
  models.InputCriblmetrics$outboundSchema,
  z.lazy(() => InputMetrics$outboundSchema),
  z.lazy(() => InputSqs$outboundSchema),
  models.InputFile$outboundSchema,
  z.lazy(() => InputTcp$outboundSchema),
  models.InputAppscope$outboundSchema,
  z.lazy(() => InputWef$outboundSchema),
  z.lazy(() => InputRawUdp$outboundSchema),
  z.lazy(() => InputZscalerHec$outboundSchema),
  models.InputCollection$outboundSchema,
  z.lazy(() => InputPrometheus$outboundSchema),
  z.lazy(() => InputEdgePrometheus$outboundSchema),
  z.lazy(() => InputOffice365MsgTrace$outboundSchema),
  z.lazy(() => InputSnmp$outboundSchema),
  z.lazy(() => InputOpenTelemetry$outboundSchema),
  z.lazy(() => InputModelDrivenTelemetry$outboundSchema),
  z.lazy(() => InputNetflow$outboundSchema),
  z.union([
    z.lazy(() => InputGrafanaGrafana1$outboundSchema),
    z.lazy(() => InputGrafanaGrafana2$outboundSchema),
  ]),
  z.union([
    z.lazy(() => InputSyslogSyslog1$outboundSchema),
    z.lazy(() => InputSyslogSyslog2$outboundSchema),
  ]),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputRequest$ {
  /** @deprecated use `CreateInputRequest$inboundSchema` instead. */
  export const inboundSchema = CreateInputRequest$inboundSchema;
  /** @deprecated use `CreateInputRequest$outboundSchema` instead. */
  export const outboundSchema = CreateInputRequest$outboundSchema;
  /** @deprecated use `CreateInputRequest$Outbound` instead. */
  export type Outbound = CreateInputRequest$Outbound;
}

export function createInputRequestToJSON(
  createInputRequest: CreateInputRequest,
): string {
  return JSON.stringify(
    CreateInputRequest$outboundSchema.parse(createInputRequest),
  );
}

export function createInputRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateInputRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateInputRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateInputRequest' from JSON`,
  );
}

/** @internal */
export const CreateInputResponse$inboundSchema: z.ZodType<
  CreateInputResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  items: z.array(models.Input$inboundSchema).optional(),
});

/** @internal */
export type CreateInputResponse$Outbound = {
  count?: number | undefined;
  items?: Array<models.Input$Outbound> | undefined;
};

/** @internal */
export const CreateInputResponse$outboundSchema: z.ZodType<
  CreateInputResponse$Outbound,
  z.ZodTypeDef,
  CreateInputResponse
> = z.object({
  count: z.number().int().optional(),
  items: z.array(models.Input$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputResponse$ {
  /** @deprecated use `CreateInputResponse$inboundSchema` instead. */
  export const inboundSchema = CreateInputResponse$inboundSchema;
  /** @deprecated use `CreateInputResponse$outboundSchema` instead. */
  export const outboundSchema = CreateInputResponse$outboundSchema;
  /** @deprecated use `CreateInputResponse$Outbound` instead. */
  export type Outbound = CreateInputResponse$Outbound;
}

export function createInputResponseToJSON(
  createInputResponse: CreateInputResponse,
): string {
  return JSON.stringify(
    CreateInputResponse$outboundSchema.parse(createInputResponse),
  );
}

export function createInputResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateInputResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateInputResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateInputResponse' from JSON`,
  );
}
